<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="en,zh-CN,default">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/feather.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="众里寻她千百度">
<meta property="og:type" content="article">
<meta property="og:title" content="查找">
<meta property="og:url" content="http://sqduan.github.io/2024/10/13/计算机/算法/搜索/index.html">
<meta property="og:site_name" content="一隅">
<meta property="og:description" content="众里寻她千百度">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://raw.githubusercontent.com/sqduan/hexoimg/master/1_GT9oSo0agIeIj6nTg3jFEA.gif">
<meta property="og:updated_time" content="2024-10-13T01:59:46.511Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="查找">
<meta name="twitter:description" content="众里寻她千百度">
<meta name="twitter:image" content="https://raw.githubusercontent.com/sqduan/hexoimg/master/1_GT9oSo0agIeIj6nTg3jFEA.gif">



  <link rel="alternate" href="/atom.xml" title="一隅" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://sqduan.github.io/2024/10/13/计算机/算法/搜索/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>查找 | 一隅</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一隅</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">记录生活</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sqduan.github.io/2024/10/13/计算机/算法/搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shiqi Duan">
      <meta itemprop="description" content="Do Not Go Gentle Into That Good Night">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一隅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">查找

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2024-10-13 09:59:46" itemprop="dateCreated datePublished" datetime="2024-10-13T09:59:46+08:00">2024-10-13</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机/算法和数据结构/" itemprop="url" rel="index"><span itemprop="name">算法和数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>众里寻她千百度</p>
</blockquote>
<a id="more"></a>
<h2 id="常见查找算法"><a href="#常见查找算法" class="headerlink" title="常见查找算法"></a>常见查找算法</h2><h3 id="深度优先查找DFS（不撞南墙不回头）"><a href="#深度优先查找DFS（不撞南墙不回头）" class="headerlink" title="深度优先查找DFS（不撞南墙不回头）"></a>深度优先查找DFS（不撞南墙不回头）</h3><h4 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int step)&#123;</span><br><span class="line">    //判断边界并返回，阶段二</span><br><span class="line">    //如果有备忘录，那么此时可以返回备忘录中的值</span><br><span class="line">    //尝试每一种可能 for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        继续下一步 dfs(step+1)      //自上而下搜索</span><br><span class="line">    &#125;</span><br><span class="line">    //返回  自下而上计算结果并返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre class="mermaid">graph TB
    node("开始")
    judge1{"已遍历所有节点？"}
    node2("结束")
    dfs["进行深度优先搜索"]

    node-->judge1
    judge1-->|N|dfs
    dfs-->judge1
    judge1-->|Y|node2</pre>

<h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>深度优先搜索通常使用递归形式实现，如果要改为迭代形式，那么需要利用栈。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; search_set&#123;&#125;; <span class="comment">// 在迭代实现中，我们采用栈保存当前待搜索对象</span></span><br><span class="line">    search_set.push(first);  <span class="comment">// 放入初始搜索点，例如树的根节点或数组的第一个节点或者图的初始任意节点</span></span><br><span class="line">    <span class="keyword">while</span>(!search_set.empty()) &#123;  <span class="comment">//搜索区间未空，就不能停止搜索</span></span><br><span class="line">        <span class="keyword">int</span> cur = search_set.top(); <span class="comment">//获取当前搜索点</span></span><br><span class="line">        search_set.pop();   </span><br><span class="line">        </span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加和cur相关的新的搜索点，例如树的左子树、右子树，图的与当前节点相连的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="难点总结"><a href="#难点总结" class="headerlink" title="难点总结"></a>难点总结</h4><h5 id="理解dfs"><a href="#理解dfs" class="headerlink" title="理解dfs"></a>理解dfs</h5><p>在dfs中，每进行一次递归，就相当于深入一层。有些情况下可能会有不同路径，例如在迷宫类问题中，有上下左右四个方向，此时需要进行四次递归，相当于走了四条路径，构成了一个四叉树。</p>
<h5 id="dfs思路"><a href="#dfs思路" class="headerlink" title="dfs思路"></a>dfs思路</h5><p>dfs分为两个阶段，在写dfs时要考虑清楚每个阶段的过程：</p>
<ul>
<li>自上而下搜索</li>
<li>自下而上计算结果并返回<ul>
<li>在搜索的叶节点处直接返回叶节点值</li>
<li>在非叶节点处根据下层计算结果与当前节点值进行计算</li>
</ul>
</li>
</ul>
<p>这里以<a href="https://leetcode-cn.com/problems/triangle/">leetcode120. 三角形最小路径和</a>为例，对dfs思路进行整理。给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (triangle.size() - <span class="number">1</span> == row) &#123;  <span class="comment">//到达最后一行, 在搜索的叶节点处直接返回叶节点值</span></span><br><span class="line">        <span class="keyword">return</span> triangle[row][col];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> down = helper(triangle, row + <span class="number">1</span>, col);   <span class="comment">//自上而下搜索</span></span><br><span class="line">    <span class="keyword">int</span> right = helper(triangle, row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min(down, right) + triangle[row][col];    <span class="comment">//在非叶节点处根据下层计算结果与当前节点值进行计算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(triangle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="搜索入口"><a href="#搜索入口" class="headerlink" title="搜索入口"></a>搜索入口</h5><p>为了保证搜索覆盖的全面性，我们需要对所有的待搜索的点进行搜索，例如我们对一个有$n$个节点的图进行搜索，代码框架如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">        dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使图中有不相连的部分，因为我们经过了遍历，所以深度优先搜索能保证所有的节点都访问到。</p>
<h5 id="边界判断"><a href="#边界判断" class="headerlink" title="边界判断"></a>边界判断</h5><p>边界判断是DFS的重要部分，保证了DFS能够顺利退出递归，以下总结一些常见的DFS退出条件。首先，由于DFS是递归算法，所以很可能会搜索到重复的位置，因此往往需要一个visited向量，用于保存已经访问的位置，如果已经visited，那么直接返回。</p>
<ol>
<li>指针类DFS</li>
</ol>
<p>多见于处理链表或二叉树问题的DFS中，常见退出条件如下：</p>
<ul>
<li>head == nullptr：return head;</li>
<li>visited(head) == true：return head;</li>
</ul>
<ol>
<li>数组类DFS</li>
</ol>
<p>常见退出条件如下：</p>
<ul>
<li>范围超过数组边界：<code>if(cur_m &lt; 0 || cur_n &lt; 0 ||cur_m &gt;= m || cur_n &gt;= n)</code></li>
<li>已经访问过指定位置：<code>if(visited[cur_m][cur_n] == 1)</code></li>
<li>所在位置不满足搜索要求：<code>if(int_to_sum(cur_m) + int_to_sum(cur_n) != k)</code></li>
<li>给定数组搜索范围<code>[left,right)</code>（左开右闭区间），那么搜索结束的标志为left == right，见leetcode<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></li>
</ul>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>递归由于涉及到多次函数调用，因此返回值的计算可能会比较麻烦，这里针对dfs给出一个比较套路化的返回规则，首先，如果不满足条件，那么就在进入递归函数后立刻返回；其次，最终的返回值应当放在递归函数结尾给出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> )    <span class="comment">//第一返回位置，不满足条件，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=traverse(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right=traverse(root-&gt;right);</span><br><span class="line">    tilt+=Math.<span class="built_in">abs</span>(left-right);</span><br><span class="line">    <span class="keyword">return</span> left+right+root-&gt;val;  <span class="comment">//第二返回位置，在递归体结束后返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="何时增加深度"><a href="#何时增加深度" class="headerlink" title="何时增加深度"></a>何时增加深度</h5><p>当明确有一条搜索路径时，我们再去增加递归深度，例如在二叉树搜索中，如果我们明确了某个子节点不为空，再向这条子节点进行搜索，这样可以减少递归深度，提高效率：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123; <span class="comment">//左节点存在时，再进行深度搜索哦</span></span><br><span class="line">    dfs(root-&gt;left, temp, ans); </span><br><span class="line">    <span class="keyword">if</span>(temp.back() == <span class="string">'&gt;'</span>)temp.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp.back() != <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">        temp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="被搜索节点的状态"><a href="#被搜索节点的状态" class="headerlink" title="被搜索节点的状态"></a>被搜索节点的状态</h5><p>在深度优先搜索中，一个被搜索节点一般有三个状态：</p>
<ul>
<li>未搜索：该节点尚未被搜索</li>
<li>搜索中：我们正在搜索该节点和相邻的节点，但是该节点相邻的节点还未搜索完成</li>
<li>已完成：我们搜索过所有的相邻节点，回溯了该节点，搜索已完成</li>
</ul>
<h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><p>在某些情况下，我们需要剪枝操作，例如当前位置和前一个位置相同，那么我们直接跳过该步骤即可，剪枝的操作代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != start &amp;&amp; s[i] == s[i<span class="number">-1</span>]) <span class="keyword">continue</span>;  <span class="comment">//去除重复</span></span><br></pre></td></tr></table></figure>
<p>将上述语句放入dfs的for循环中，即可实现剪枝操作。</p>
<h4 id="常见DFS类型总结及模板"><a href="#常见DFS类型总结及模板" class="headerlink" title="常见DFS类型总结及模板"></a>常见DFS类型总结及模板</h4><h5 id="判断搜索路径是否存在"><a href="#判断搜索路径是否存在" class="headerlink" title="判断搜索路径是否存在"></a>判断搜索路径是否存在</h5><p>此类问题要求我们判断搜索树中是否存在一条符合条件的搜索路径，因此搜索过程中，一旦找到了路径，我们应当立刻返回，以免不必要的递归造成效率的降低。这里以<a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/">面试题 04.01. 节点间通路</a>为例，对此类问题模板进行总结。</p>
<p>思路</p>
<p>我们希望找到答案后直接返回，而找到答案的可能性有两种，一种是在本层中直接找到答案；另一种是在深层递归中找到答案。因此我们需要进行两次判断，当在本层中找到答案后直接返回；当在下层搜索后，判断是否找到答案，然后根据情况中断搜索，模板如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;                    </span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_pos = adList[start][i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (viewed[cur_pos]==<span class="number">0</span>)&#123;         <span class="comment">//对没有搜索的点处理</span></span><br><span class="line">            <span class="keyword">if</span>(cur_pos==target)&#123;         <span class="comment">//找到后直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = search(cur_pos,target);   <span class="comment">//递归搜索</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">true</span>)                 <span class="comment">//找到后中断搜索</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    viewed[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;                    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;adList[start].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_pos = adList[start][i];     <span class="comment">//循环遍历所有分支</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (viewed[cur_pos]==<span class="number">0</span>)&#123;         <span class="comment">//对没有搜索的点处理</span></span><br><span class="line">            <span class="keyword">if</span>(cur_pos==target)&#123;         <span class="comment">//找到后直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = search(cur_pos,target);   <span class="comment">//递归搜索</span></span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">true</span>)                 <span class="comment">//找到后中断搜索</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们可以看到，此时判断是否退出的条件放在了循环体中，意味着我们找到答案后会立刻退出，另外递归后也加了一条判断语句，确保找到答案立刻退出。</p>
<h5 id="获取累加值"><a href="#获取累加值" class="headerlink" title="获取累加值"></a>获取累加值</h5><p>有些dfs问题需要我们记录累加值，这种情况下，我们需要在dfs开始时设置一个临时变量，然后结尾处返回该临时变量，每个递归函数都会定义自己的局部变量，而第一次递归时定义的局部变量即为最终的计算结果。一个框架如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(...)&#123; <span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> ...; <span class="comment">//返回边界值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123; <span class="comment">//遍历当前搜索集合</span></span><br><span class="line">        ans += dfs(depth+<span class="number">1</span>);   <span class="comment">//遍历搜索树的每一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算递归深度"><a href="#计算递归深度" class="headerlink" title="计算递归深度"></a>计算递归深度</h5><p>在有些情况下，我们需要计算递归树的深度，例如计算二叉树的深度，其代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 关键语句，我们遍历了所有可行分支，对于二叉树来说，一共有两个分支，然后获得其中的最大深度</span></span><br><span class="line">    depth = max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">    <span class="comment">// 返回值需要+1，因为计算深度时要包含当前节点</span></span><br><span class="line">    <span class="keyword">return</span> depth+<span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以此类推，我们可以延伸到计算任意递归函数的深度，只需要循环遍历所有分支，找到分支最大深度即可。例如leetcode<a href="https://leetcode-cn.com/problems/nested-list-weight-sum-ii/">364. 加权嵌套序列和 II</a>，计算递归深度的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ni : nestedList)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ni.isInteger())&#123;</span><br><span class="line">            sum += depth * ni.getInteger();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum += getSum(ni.getList(), depth - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获得所有可能解的DFS"><a href="#获得所有可能解的DFS" class="headerlink" title="获得所有可能解的DFS"></a>获得所有可能解的DFS</h5><p>例题</p>
<p><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></p>
<p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。说明: 输入可能包含了除 <code>(</code> 和 <code>)</code> 以外的字符。</p>
<p>思路</p>
<p>这个问题可以划分为三个子问题：</p>
<ul>
<li>判断括号是否合法</li>
<li>计算有多少个左右括号需要删除</li>
<li>递归删除括号，得到结果后进行保存</li>
</ul>
<p>前两个子问题我们可以通过栈实现，后一个可以通过DFS实现 ，重点是第三个问题，第三个问题中，我们又可以列举出如下几个问题：</p>
<ul>
<li>先删除哪种括号？先删除右括号，如果先删除左括号，可能导致前缀非法，例如对于<code>())(</code>，如果我们先删除了第一个左括号，那么会变成<code>))(</code>，原来合法的前缀反而不合法了。这样会构成额外的枝。</li>
<li>如何避免重复解 ，例如对于<code>(()</code>，删掉第一个和第二个左括号，得到的结果都为<code>()</code>，所以我们需要剪枝操作</li>
</ul>
<p>例子</p>
<p>我们以<code>s = &quot;)())(&quot;</code>为例，需要删除两个右括号，一个左括号，那么我们的递归函数为<code>dfs(s, l=1, r=2)</code>，删除过程的递归树如下：</p>
<pre class="mermaid">graph TB
    node["dfs( s = )())( , l=1, r=2)"]
    node1["dfs(s = *())( , l=1, r=1)"]
    node2["dfs(s = )(*)( , l=1, r=1)"]
    node3["dfs(s = )()*( , l=1, r=2)"]
    node4["dfs(s = *(*)( , l=1, r=0)"]
    node5["dfs(s = *(*)* , l=0, r=0): 合法"]
    node6["dfs(s = )(**( , l=1, r=0)"]
    node7["dfs(s = )(*** , l=0, r=0): 非法"]

    node---node1
    node---node2
    node--冗余枝条---node3
    node1---node4
    node4---node5
    node2---node6
    node6---node7</pre>

<p>可以看出递归深度为$l+r$，所以时间复杂度为$2^{l+r}$</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span> ch : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'('</span>) ++count;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">')'</span>) --count;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//小于0说明右括号落单，一定是非法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    **    计算最少需要的左括号和右括号的值，这里没有用栈的方法，而是</span></span><br><span class="line"><span class="comment">    **    使用了投票法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span> ch : s)&#123;</span><br><span class="line">        l += (ch == <span class="string">'('</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span>)                 <span class="comment">//表示右括号会落单，因此如果l==0，如果出现右括号，一定删除</span></span><br><span class="line">            r += (ch == <span class="string">')'</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l -= (ch == <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    dfs(s, <span class="number">0</span>, l, r, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">*    dfs -- 递归进行括号删除                                  </span></span><br><span class="line"><span class="comment">*                                                           </span></span><br><span class="line"><span class="comment">*    INPUT: s     -- 待处理字符串                   </span></span><br><span class="line"><span class="comment">*           start -- 上一次删除的括号的位置，每次删除从该位置之后开始</span></span><br><span class="line"><span class="comment">*           l     -- 剩余待删除左括号数目</span></span><br><span class="line"><span class="comment">*           r     -- 剩余待删除右括号数目</span></span><br><span class="line"><span class="comment">*           ans   -- 答案</span></span><br><span class="line"><span class="comment">*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isValid(s)) ans.push_back(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != start &amp;&amp; s[i] == s[i<span class="number">-1</span>]) <span class="keyword">continue</span>;  <span class="comment">//去除重复</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'('</span> || s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr = s;</span><br><span class="line">            curr.erase(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(r &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">')'</span>) dfs(curr, i, l, r<span class="number">-1</span>, ans);    <span class="comment">//优先删除右括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">'('</span>) dfs(curr, i, l<span class="number">-1</span>, r, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DFS优化"><a href="#DFS优化" class="headerlink" title="DFS优化"></a>DFS优化</h4><h5 id="动态规划与DFS结合"><a href="#动态规划与DFS结合" class="headerlink" title="动态规划与DFS结合"></a>动态规划与DFS结合</h5><p>在深度优先搜索中，可能会产生大量重复计算，如果我们能像动态规划那样，牺牲一些空间来保存中间结果，能够有效减少计算时间，DFS与DP结合的代码框架如下，其中有两个关键步骤，记录与提取：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mem, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> row, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.size() - <span class="number">1</span> == row) &#123;</span><br><span class="line">        <span class="keyword">return</span> board[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem[row][col]) <span class="keyword">return</span> mem[row][col];            <span class="comment">//返回备忘录中的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> down = helper(board, mem, row + <span class="number">1</span>, col);        <span class="comment">//向下向右搜索</span></span><br><span class="line">    <span class="keyword">int</span> right = helper(board, mem, row, col + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = min(down, right) + board[row][col];</span><br><span class="line">    mem[row][col] = ans;                                <span class="comment">//记录备忘录中的值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></p>
<p>给定一个整数矩阵，找出最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;        <span class="comment">// Row num of matrix</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;        <span class="comment">// Column num of matrix</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    **    Moving directions</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy = &#123;<span class="number">0</span>, <span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **    Init work</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        r = matrix.size();</span><br><span class="line">        c = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **    This dp vector stores the mid results to avoid duplicate calculation</span></span><br><span class="line"><span class="comment">        **    dp[i][j] means the longest pathes length which is end at (i,j)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c,<span class="number">0</span>))</span></span>;   </span><br><span class="line">                                                   </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **    Search at each element of the matrix</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                ans = max(ans,dfs(matrix, i, j, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*----------------------------------------------------------</span></span><br><span class="line"><span class="comment">    *  dfs -- Find all the possible pathes of the matrix</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  INPUT:  matrix -- The matrix which needs to be searched</span></span><br><span class="line"><span class="comment">    *          cur_r  -- Current row in the matrix</span></span><br><span class="line"><span class="comment">    *          cur_c  -- Current col in the matrix</span></span><br><span class="line"><span class="comment">    *          dp     -- The matrix which store mid results</span></span><br><span class="line"><span class="comment">    *  OUTPUT: The longest pathes of current search position</span></span><br><span class="line"><span class="comment">    *          ended at (cur_r, cur_c)</span></span><br><span class="line"><span class="comment">    *----------------------------------------------------------*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> cur_r, <span class="keyword">int</span> cur_c, </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **    Return if dp[cur_r][cur_c] != 0 which means the result </span></span><br><span class="line"><span class="comment">        **    at position (cur_r, cur_c) has already been calculated</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(dp[cur_r][cur_c] != <span class="number">0</span>) <span class="keyword">return</span> dp[cur_r][cur_c];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nr = cur_r + dx[i], nc = cur_c + dy[i];    <span class="comment">// New row and col</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            **    Only if the adjcent is valid then apply dfs</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(nr &gt;= <span class="number">0</span> &amp;&amp; nr &lt; r &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nc &lt; c &amp;&amp; matrix[nr][nc] &lt; matrix[cur_r][cur_c])   </span><br><span class="line">                dp[cur_r][cur_c] = max(dp[cur_r][cur_c],dfs(matrix, nr, nc, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++dp[cur_r][cur_c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>广度优先搜索能够保证在搜索到<code>d+1</code>距离的位置时，距离为<code>d</code>的位置都已经搜索过，所以可以使用广度优先搜索处理例如迷宫中最短路径等问题。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>创建队列保存搜索点</li>
<li>保存初始搜索点</li>
<li>弹出搜索点，并以搜索点为基准，遍历所有搜索分支，例如在迷宫当中，有上下左右四个方向，即四个搜索分支</li>
<li>每个搜索分支下，添加新的搜索点，扩大搜索范围</li>
</ul>
<h4 id="基本模型-1"><a href="#基本模型-1" class="headerlink" title="基本模型"></a>基本模型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先通常采用迭代形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断是否返回</span></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; res&#123;&#125;;</span><br><span class="line">    res.push(root-&gt;val);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bfs 循环</span></span><br><span class="line">    <span class="keyword">while</span>(!res.empty())&#123;</span><br><span class="line">        <span class="comment">//新建vector&lt;int&gt; temp 用于保存每一层的结果</span></span><br><span class="line">        <span class="keyword">int</span> width = res.size();  <span class="comment">//保存当前层长度</span></span><br><span class="line">        <span class="comment">//当前层循环打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">            <span class="comment">//1. 出队列</span></span><br><span class="line">            <span class="comment">//2. 访问</span></span><br><span class="line">            <span class="comment">//3. 入队列  将待搜索的位置放入队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将temp添加至res</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广度优先搜索一般要利用队列，来实现对于一层的存储。</p>
<h4 id="难点及要点总结"><a href="#难点及要点总结" class="headerlink" title="难点及要点总结"></a>难点及要点总结</h4><p>广度优先过程中会出现<strong>重复搜索</strong>的问题，即相邻两个待搜索对象，第一个时刻由对象1搜索到了对象2，第二个时刻又由对象2搜索到了对象1，解决方法是使用visited矩阵或集合进行标记，已经搜索过的就直接跳过。</p>
<h3 id="DFS与BFS的比较"><a href="#DFS与BFS的比较" class="headerlink" title="DFS与BFS的比较"></a>DFS与BFS的比较</h3><p>这张图直观地对DFS与BFS进行了比较：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/1_GT9oSo0agIeIj6nTg3jFEA.gif" width="450" alt="图片名称" align="center"></p>
<h3 id="专题：图的DFS和BFS搜索"><a href="#专题：图的DFS和BFS搜索" class="headerlink" title="专题：图的DFS和BFS搜索"></a>专题：图的DFS和BFS搜索</h3><h4 id="DFS搜索"><a href="#DFS搜索" class="headerlink" title="DFS搜索"></a>DFS搜索</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在图中搜索所有为'O'的格子，然后将格子置为'#'</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'#'</span>) <span class="keyword">return</span>; <span class="comment">//不满足搜索结果</span></span><br><span class="line">    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    dfs(board, i+<span class="number">1</span>, j, m,n);</span><br><span class="line">    dfs(board, i<span class="number">-1</span>, j, m,n);</span><br><span class="line">    dfs(board, i, j+<span class="number">1</span>, m,n);</span><br><span class="line">    dfs(board, i, j<span class="number">-1</span>, m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS搜索"><a href="#BFS搜索" class="headerlink" title="BFS搜索"></a>BFS搜索</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rooms[row][col] == GATE) &#123;</span><br><span class="line">            q.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; row, col &#125;);   <span class="comment">//将所有搜索点放入队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] point = q.poll();</span><br><span class="line">    <span class="keyword">int</span> row = point[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> col = point[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : DIRECTIONS) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = row + direction[<span class="number">0</span>];     <span class="comment">//下一个搜索位置</span></span><br><span class="line">        <span class="keyword">int</span> c = col + direction[<span class="number">1</span>];   </span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= m || c &gt;= n || rooms[r][c] != EMPTY) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        rooms[r][c] = rooms[row][col] + <span class="number">1</span>;   </span><br><span class="line">        q.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; r, c &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用画图的形式解释BFS在图中的搜索，那么其形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//以传染病模型为例，其中1是被感染的人，一开始他会将上下左右四个方向上的人全部感染，产生四个新感染的人，即四个新的搜索点</span><br><span class="line">0 0 0 0 0       0 1 0 0 0       0 1 0 0 0        0 1 0 0 0         0 1 0 0 0</span><br><span class="line">0 1 0 0 0       0 1 0 0 0       0 1 1 0 0        0 1 1 0 0         1 1 1 0 0</span><br><span class="line">0 0 0 0 0       0 0 0 0 0       0 0 0 0 0        0 1 0 0 0         0 1 0 0 0</span><br><span class="line">0 0 0 0 0       0 0 0 0 0       0 0 0 0 0        0 0 0 0 0         0 0 0 0 0</span><br><span class="line"></span><br><span class="line">这四个新的搜索点会继续扩散，直到所有的人都感染为止。所以BFS类似于一种传染病模型，会将临近的单位全部感染</span><br><span class="line"></span><br><span class="line">那么问题来了，当BFS有不只一个搜索点，例如在传染病模型中，有多个初始病人，那么我们如何知道新病人是由哪个病人感染的呢？这个问题不必担心，由于BFS是一种临近搜索，因此新病人必然是由离得最近的病人感染的，BFS的特性能够保证传播符合实际情况，不会出现病人被离得远的病人所感染。</span><br></pre></td></tr></table></figure>
<h3 id="专题：岛屿问题"><a href="#专题：岛屿问题" class="headerlink" title="专题：岛屿问题"></a>专题：岛屿问题</h3><p>岛屿问题是经典的二维搜索问题，本节将对常见的岛屿问题进行总结。</p>
<h4 id="求连通域数目"><a href="#求连通域数目" class="headerlink" title="求连通域数目"></a>求连通域数目</h4><ol>
<li>leetcode 695</li>
</ol>
<p>求4-连通域最大面积，这个问题很经典，需要记住代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"> </span><br><span class="line"> 返回6</span><br></pre></td></tr></table></figure>
<p>答案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.size() || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].size() </span><br><span class="line">          || grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//查找到某一块边界点，停止</span></span><br><span class="line">        grid[r][c] = <span class="number">0</span>;   <span class="comment">//防止重复查找，也可以通过设置一个flag矩阵，保存已经查找过的区域</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> + area(r+<span class="number">1</span>,c,grid)+area(r<span class="number">-1</span>,c,grid)+area(r,c+<span class="number">1</span>,grid)+area(r,c<span class="number">-1</span>,grid));  <span class="comment">//一直查找直到达到边界点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.size() == <span class="number">0</span> || grid[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>;r&lt;grid.size();r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;grid[<span class="number">0</span>].size();c++)&#123;    <span class="comment">//遍历岛屿的每一个格子</span></span><br><span class="line">                <span class="keyword">int</span> temp = area(r,c,grid);    <span class="comment">//一次执行过程中，area函数就会将相邻的连通区域全部置零，如果需要统计连通域个数，那么设置一个标记位进行统计即可。</span></span><br><span class="line">                ans = max(ans,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> <a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域搜索</a><br> 给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>运行函数后，矩阵变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>如果我们认为O所在位置为海岛，那么该问题的本质就是求所有与边界不联通的海岛的位置，然后进行替换。所以我们应当从边界位置处的海岛O开始搜索，找到所有的和边界相连的海岛，那么剩下的海岛就一定是被X包围的。</p>
<p><strong>任务</strong></p>
<ul>
<li>找到边界岛屿</li>
<li>从找到的边界岛屿处开始搜索（每一个边界岛屿都要作为搜索的起始点）</li>
<li>搜索过程中，将与边界相连的海岛替换为#（方便后续恢复）</li>
<li>遍历棋盘，将不与边界相连的海岛淹没，将与边界相连的海岛恢复</li>
</ul>
<p><strong>代码</strong></p>
<p>解法1：深度优先搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == <span class="number">0</span> || board[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">bool</span> isEdge = (i == <span class="number">0</span> || j == <span class="number">0</span> || i == m<span class="number">-1</span> || j == n<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    dfs(board, i, j,m,n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>) board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'#'</span>) board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'#'</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        dfs(board, i+<span class="number">1</span>, j, m,n);</span><br><span class="line">        dfs(board, i<span class="number">-1</span>, j, m,n);</span><br><span class="line">        dfs(board, i, j+<span class="number">1</span>, m,n);</span><br><span class="line">        dfs(board, i, j<span class="number">-1</span>, m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p>
<h3 id="专题：迷宫问题"><a href="#专题：迷宫问题" class="headerlink" title="专题：迷宫问题"></a>专题：迷宫问题</h3><p>迷宫问题中，我们可能遇到有效路径、遍历迷宫以及最短路径等问题，本节将针对常见的迷宫问题进行总结</p>
<h4 id="寻找迷宫中的门"><a href="#寻找迷宫中的门" class="headerlink" title="寻找迷宫中的门"></a>寻找迷宫中的门</h4><blockquote>
<p>你被给定一个 <em>m × n</em> 的二维网格，网格中有以下三种可能的初始化值：</p>
<ol>
<li><code>-1</code> 表示墙或是障碍物</li>
<li><code>0</code> 表示一扇门</li>
<li><code>INF</code> 无限表示一个空的房间。然后，我们用 <code>231 - 1 = 2147483647</code> 代表 <code>INF</code>。你可以认为通往门的距离总是小于 <code>2147483647</code> 的。</li>
</ol>
<p>你要给每个空房间位上填上该房间到 <em>最近</em> 门的距离，如果无法到达门，则填 <code>INF</code> 即可。</p>
<p>例如，给定迷宫</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;INF  -1  0  INF</span><br><span class="line">&gt;INF INF INF  -1</span><br><span class="line">&gt;INF  -1 INF  -1</span><br><span class="line">&gt;  0  -1 INF INF</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  3  -1   0   1</span><br><span class="line">&gt;  2   2   1  -1</span><br><span class="line">&gt;  1  -1   2  -1</span><br><span class="line">&gt;  0  -1   3   4</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>从门使用BFS进行搜索，能够以扩散传播的方式，对周边区域进行搜索，从而确保周围的房间能够到达最近的门</p>
<p><strong>任务</strong></p>
<ul>
<li>找到门坐标</li>
<li>从门坐标开始，进行深度优先搜索</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rooms.size() == <span class="number">0</span> || rooms[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = rooms.size();</span><br><span class="line">    <span class="keyword">int</span> n = rooms[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; direction&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; point_queue&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rooms[i][j] == <span class="number">0</span>) point_queue.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!point_queue.empty())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = point_queue.front();</span><br><span class="line">        point_queue.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;direction.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = p[<span class="number">0</span>] + direction[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = p[<span class="number">1</span>] + direction[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= m || c &gt;= n || rooms[r][c] != <span class="number">2147483647</span>) <span class="keyword">continue</span>;</span><br><span class="line">            rooms[r][c] = rooms[p[<span class="number">0</span>]][p[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">            point_queue.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;r,c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断是否能走到终点"><a href="#判断是否能走到终点" class="headerlink" title="判断是否能走到终点"></a>判断是否能走到终点</h4><p>迷宫三问</p>
<p><a href="https://leetcode-cn.com/problems/the-maze/">490. 迷宫</a></p>
<p><a href="https://leetcode-cn.com/problems/the-maze-ii/">505. 迷宫 II</a></p>
<p>迷宫II是对迷宫I的问题的延伸，我们不仅要判断能否到达终点，还要记录从起点到终点的最短路径。这里我们定义了一个distance矩阵，把每一个可以到达的方块距离起点的最短距离记录下来，然后返回目标点所在的值即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] dest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[maze.length][maze[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: distance)</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE);</span><br><span class="line">        distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        dfs(maze, start, distance);</span><br><span class="line">        <span class="keyword">return</span> distance[dest[<span class="number">0</span>]][dest[<span class="number">1</span>]] == Integer.MAX_VALUE ? -<span class="number">1</span> : distance[dest[<span class="number">0</span>]][dest[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[][] distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir: dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = start[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = start[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; maze.length &amp;&amp; y &lt; maze[<span class="number">0</span>].length &amp;&amp; maze[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                x += dir[<span class="number">0</span>];</span><br><span class="line">                y += dir[<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x-dir[<span class="number">0</span>]; y = y-dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 注意！上面的循环结束时，实际上走到了非法区域，需要后退一步，才能走到正确的位置，所以需要x = x-dir[0]; y = y-dir[1];</span></span><br><span class="line">            <span class="keyword">if</span> (distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] + count &lt; distance[x][y]) &#123;    </span><br><span class="line">                distance[x][y] = distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] + count;</span><br><span class="line">                dfs(maze, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;, distance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迷宫遍历"><a href="#迷宫遍历" class="headerlink" title="迷宫遍历"></a>迷宫遍历</h4><p>有些问题需要我们遍历迷宫中所有可以行走的路径，例如<a href="https://leetcode-cn.com/problems/robot-room-cleaner/">489. 扫地机器人</a></p>
<blockquote>
<p>房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。扫地机器人提供4个API，可以向前进，向左转或者向右转。每次转弯90度。当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。请利用提供的4个API编写让机器人清理整个房间的算法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Robot &#123;</span><br><span class="line">  // 若下一个方格为空，则返回true，并移动至该方格</span><br><span class="line">  // 若下一个方格为障碍物，则返回false，并停留在原地</span><br><span class="line">  boolean move();</span><br><span class="line"></span><br><span class="line">  // 在调用turnLeft/turnRight后机器人会停留在原位置</span><br><span class="line">  // 每次转弯90度</span><br><span class="line">  void turnLeft();</span><br><span class="line">  void turnRight();</span><br><span class="line"></span><br><span class="line">  // 清理所在方格</span><br><span class="line">  void clean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路</p>
<p>由于我们不清楚起始位置在哪里，因此只能使用相对信息对位置坐标进行记录，令起始点坐标为(0,0)，然后实施dfs</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;F, S&gt; &#123;</span></span><br><span class="line">    <span class="keyword">public</span> F first;</span><br><span class="line">    <span class="keyword">public</span> S second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(F first, S second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Pair&lt;F, S&gt; p = (Pair&lt;F, S&gt;) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(p.first, first) &amp;&amp; Objects.equals(p.second, second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.hashCode() ^ second.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// going clockwise : 0: 'up', 1: 'right', 2: 'down', 3: 'left'</span></span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    Set&lt;Pair&lt;Integer, Integer&gt;&gt; visited = <span class="keyword">new</span> HashSet();</span><br><span class="line">    Robot robot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        robot.turnRight();</span><br><span class="line">        robot.turnRight();</span><br><span class="line">        robot.move();</span><br><span class="line">        robot.turnRight();</span><br><span class="line">        robot.turnRight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        visited.add(<span class="keyword">new</span> Pair(row, col));</span><br><span class="line">        robot.clean();</span><br><span class="line">        <span class="comment">// going clockwise : 0: 'up', 1: 'right', 2: 'down', 3: 'left'</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newD = (d + i) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + directions[newD][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newCol = col + directions[newD][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 当下一个点未访问过并且可以到达时，再进行dfs</span></span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(<span class="keyword">new</span> Pair(newRow, newCol)) &amp;&amp; robot.move()) &#123;</span><br><span class="line">                backtrack(newRow, newCol, newD);</span><br><span class="line">                goBack();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// turn the robot following chosen direction : clockwise</span></span><br><span class="line">            robot.turnRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanRoom</span><span class="params">(Robot robot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.robot = robot;</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找（常常和二叉树一起出现）"><a href="#二分查找（常常和二叉树一起出现）" class="headerlink" title="二分查找（常常和二叉树一起出现）"></a>二分查找（常常和二叉树一起出现）</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>每一次循环都能排除掉一半以上的元素，最后把区间限定在一个元素，<strong>二分查找要求被查找的对象必须经过排序</strong>。循环条件为left &lt; right，如果被查找元素未经排序，那么循环条件可能发生改变，例如<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">LeetCode154旋转数组</a>。</p>
<h4 id="算法要求"><a href="#算法要求" class="headerlink" title="算法要求"></a>算法要求</h4><ol>
<li>必须采用顺序存储结构</li>
<li>必须按照关键字大小有序排列</li>
</ol>
<h4 id="算法适用场景及每个场景对应框架-重要！"><a href="#算法适用场景及每个场景对应框架-重要！" class="headerlink" title="算法适用场景及每个场景对应框架(重要！)"></a>算法适用场景及每个场景对应框架(重要！)</h4><p>二分查找最适用的场景包括三个：寻找一个数、寻找左侧边界、寻找右侧边界。大部分涉及寻找特定值$x$的问题，都可以使用二分查找进行解决，例如寻找一个数的整数开方问题等。</p>
<h5 id="二分查找基本框架2"><a href="#二分查找基本框架2" class="headerlink" title="二分查找基本框架2"></a>二分查找基本框架<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;           <span class="comment">//right的值为查找的右边界（搜索结果包括右边界）</span></span><br><span class="line">                                         <span class="comment">//对于本题，就是nums.size()-1</span></span><br><span class="line">    <span class="comment">//搜索区间为][left,right]，左闭右闭</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;  <span class="comment">//结束时 left == right 留下的搜索区间为[left,right];</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;    <span class="comment">//使用else if显示所有情况</span></span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;    <span class="comment">//这里需要对nums[left]进行单独判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;       </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="寻找左侧边界的二分查找"><a href="#寻找左侧边界的二分查找" class="headerlink" title="寻找左侧边界的二分查找"></a>寻找左侧边界的二分查找</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt;= target) &#123; <span class="comment">//即使找到也不能停止，要不断压缩右边界，确保找到的一定是左边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况，这个程序也可以用来搜索第一个大于target的位置（如果nums[left]!=target）</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">//收缩左侧边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法要点及难点"><a href="#算法要点及难点" class="headerlink" title="算法要点及难点"></a>算法要点及难点</h4><p>本节将对二分查找的一些难点及要点进行总结。</p>
<h5 id="二维矩阵中的二分查找"><a href="#二维矩阵中的二分查找" class="headerlink" title="二维矩阵中的二分查找"></a>二维矩阵中的二分查找</h5><p>有些情况下，我们需要对二维矩阵进行二分查找的操作，如果我们按照先分行再分列的方法，搜索效率很低，因此我们采用整体搜索法，假设矩阵大小为$m×n$，那么待搜索的元素的个数为$m×n$，所以<code>left = 0, right = m*n-1</code>，在矩阵中进行二分查找的框架如下所示，时间复杂度为$O(log(mn))$：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">    pivotElement = matrix[pivotIdx / n][pivotIdx % n];   <span class="comment">// 关键，行为当前索引p/n，列为p%n</span></span><br><span class="line">    <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h4><blockquote>
<p>注：以下内容在难以判断循环结束后left是否为搜索位置时较为好用</p>
</blockquote>
<ol>
<li>取中位数索引</li>
</ol>
<p>二分法第一个麻烦的问题就是对中位数索引的判断，如果按照如下方式写，可能发生越界情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>所以可以写为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>一个更好的写法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = <span class="keyword">unsigned</span>(left+right)&gt;&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><strong>中位数的处理方法</strong></p>
<p>根据元素个数为奇数还是偶数，中位数的选取也会比较麻烦，当元素个数为偶数时，有左右中位数的区分</p>
<ul>
<li>当数组的元素个数是偶数的时候：</li>
</ul>
<p>使用 <code>int mid = unsigned(left + right) &gt;&gt; 1</code> 得到左中位数的索引；</p>
<p>使用<code>int mid = unsigned(left + right + 1) &gt;&gt; 1</code>得到右中位数的索引。</p>
<ol>
<li>边界选取</li>
</ol>
<p>左右边界选取时要注意，如果左右边界不包括目标数值，会导致错误，例如LeetCode 第 35 题：“搜索插入位置” ，当 target 比数组中的最后一个数字还要大（不能等于）的时候，插入元素的位置就是数组的最后一个位置 + 1，即 (len - 1 + 1 ) =  len，如果忽略掉这一点，把右边界定为 len - 1 ，代码就不能通过在线测评<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。所以<code>left = 0</code>，<code>right = len</code>而不是len-1。</p>
<ol>
<li>循环条件</li>
</ol>
<p>循环条件一般可以写为：<code>left &lt; right</code>，当循环结束时，一定有<code>left == right</code>，返回left或者right都可以，但是，退出循环的时候遗漏了一个元素没有看，那就是left或right索引上的值。</p>
<ol>
<li>分支逻辑编写</li>
</ol>
<p>二分法的分支逻辑很简单，这里有一个关键是，在分支逻辑中，<strong>一个分支是包括中位数的，另一个是排除中位数的</strong>。根据上面的分支逻辑的分析，那么会有两种情况出现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******1******/</span></span><br><span class="line"><span class="keyword">if</span>(排除中位数的逻辑分支)&#123;</span><br><span class="line">    left = mid+<span class="number">1</span>;  <span class="comment">//目标元素至少是中位数，但不包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    right = mid;  <span class="comment">//目标元素至多是中位数，且包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******2******/</span></span><br><span class="line"><span class="keyword">if</span>(排除中位数的逻辑分支)&#123;</span><br><span class="line">    right = mid<span class="number">-1</span>;  <span class="comment">//目标元素至多是中位数，但不包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    left = mid;  <span class="comment">//目标元素至少是中位数，且包括中位数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据分支逻辑选择左右中位数，选择标准是避免死循环</li>
</ol>
<p>死循环容易发生在区间只有两个元素的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面的代码中，如果只有两个元素，一旦进入左边界，那么左边界不收缩，如此下去会进入死循环，因此需要换成右中位数*/</span></span><br><span class="line"><span class="keyword">int</span> mid = <span class="keyword">unsigned</span>(left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(排除中位数的逻辑分支)&#123;</span><br><span class="line">    right = mid<span class="number">-1</span>;  <span class="comment">//目标元素至多是中位数，但不包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    left = mid;  <span class="comment">//目标元素至少是中位数，且包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一样的道理，下面的也需要换成左中位数*/</span> </span><br><span class="line"><span class="keyword">int</span> mid = <span class="keyword">unsigned</span>(left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(排除中位数的逻辑分支)&#123;</span><br><span class="line">    left = mid+<span class="number">1</span>;  <span class="comment">//目标元素至多是中位数，但不包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    right = mid;  <span class="comment">//目标元素至少是中位数，且包括中位数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>后处理</li>
</ol>
<p>当退出循环后，我们可能需要对两边夹逼剩下的那个数做一个单独的处理，何时要进行后处理呢：</p>
<ul>
<li><p>如果你的业务逻辑保证了你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 left 或者 right，无需再做判断；</p>
</li>
<li><p>如果你的业务逻辑不能保证你要找的数一定在左边界和右边界所表示的区间里出现，那么只要在退出循环以后，再针对 nums[left] 或者 nums[right] （此时 nums[left] == nums[right]）单独作一次判断，看它是不是你要找的数即可，这一步操作常常叫做“后处理”。</p>
</li>
</ul>
<p>例如</p>
<p>LeetCode 第 704 题：二分查找</p>
<blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
</blockquote>
<p>分析：因为目标数有可能不在数组中，当候选区间夹逼成一个数的时候，要单独判断一下这个数是不是目标数，如果不是，返回 -1。</p>
<h5 id="模板-来自例题1"><a href="#模板-来自例题1" class="headerlink" title="模板(来自例题1)"></a>模板(来自例题1)</h5><p>二分查找的一个难点主要是边界条件的控制，如果控制不好，可能会陷入死循环当中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();     </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="keyword">unsigned</span> <span class="keyword">int</span>(left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; mid) &#123; </span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (counter &gt;= mid) &#123;   <span class="comment">//小数较多</span></span><br><span class="line">            right = mid - <span class="number">1</span>;        <span class="comment">//收缩右边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;             <span class="comment">//大数较多</span></span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说了这么多，总结一下常用模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = left + ((right-left)&gt;&gt;<span class="number">1</span>);   <span class="comment">//左中位数</span></span><br><span class="line">    <span class="keyword">if</span>(target &gt; mid) left = mid + <span class="number">1</span>;            <span class="comment">//排除中位数的逻辑分支，left++</span></span><br><span class="line">    <span class="keyword">else</span> right = mid;                           <span class="comment">//包含中位数的逻辑分支，right保持不变</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>思路：使用二分查找的方式，把1～n个数字从中间数m分为两部分，统计每个区间中数字的个数，如果某个区间数字个数大于m，那么一定存在重复数字。下面是一个二分法的模板，可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();     </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;    <span class="comment">//n/2</span></span><br><span class="line">            <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt; mid) &#123;  </span><br><span class="line">                    counter++;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (counter &gt;= mid) &#123;   </span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二、LeetCode 35</p>
<p>三、最大值最小化问题</p>
<blockquote>
<p>考虑下列问题，把一个包含$n$个正整数的序列划分为$m$个连续子序列，设第$i$个序列各数之和为$S(i)$，你的任务是让所有$S(i)$的最大值尽量小，例如序列1 2 3 2 5 4，划分为3个序列的最优方案为1 2 3| 2 5 | 4，其中$S(1)$、$S(2)$和$S(3)$分别为6、7、4，最大值为7，如果划分为1 2|3 2|5 4，最大值为9，不如刚才的好。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>最大值尽量小是一种常见的优化问题，我们考虑一个新问题，能否把输入序列划分为$m$个连续子序列，使所有$S(i)$均不超过$x$？那么让答案为真的最小的$x$就是原题的答案，接下来随便猜一个数字$x_0$，如果不满足，那么说明答案比$x_0$大，否则答案小于等于$x_0$。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> arr[MAXN], sum, min, ans;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> M)</span></span>&#123;   <span class="comment">//对数组进行划分，返回的是当最大值为M时，所需的划分组数的最小值，即最少需要分为多少组，才能满足最大值最小化的要求</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos=m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&gt;=<span class="number">0</span> &amp;&amp; sum+arr[pos]&lt;=M)&#123;    <span class="comment">//如果该组目前还小于最大值，说明还可以继续往里添加数</span></span><br><span class="line">            ok=<span class="literal">false</span>;</span><br><span class="line">            sum += arr[pos];</span><br><span class="line">            --pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">            <span class="keyword">return</span> k+<span class="number">1</span>; <span class="comment">// 返回一个大于k的数，说明划分的组数超过了k，M不满足要求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=<span class="number">0</span>) vis[pos] = <span class="literal">true</span>;  </span><br><span class="line">        ++cnt;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;  <span class="comment">//返回划分的组数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">binary</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left=min, right=sum, mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(divide(mid)&lt;=k)     <span class="comment">//说明所需的组数小于k，则还可以添加新组，最大值可以继续缩小</span></span><br><span class="line">            right=mid;</span><br><span class="line">        <span class="keyword">else</span>              <span class="comment">//所需组数大于k，说明不能再添加新组，最大值应当适当扩大</span></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=divide(ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>&amp;&amp;cnt&lt;k; ++i)<span class="keyword">if</span>(!vis[i])&#123;  <span class="comment">//返回的组数有可能小于k，那么说明还有几组空闲，那么我在任意多划分几组，满足要求即可</span></span><br><span class="line">        vis[i]=<span class="literal">true</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i) <span class="built_in">printf</span>(<span class="string">" %lld"</span>,arr[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" /"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;k);</span><br><span class="line">        sum=<span class="number">0</span>;  min=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;arr[i]);</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;min) min=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=binary();</span><br><span class="line">        output();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「shuangde800」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/shuangde800/java/article/details/7828695</span></span><br></pre></td></tr></table></figure>
<h2 id="常见搜索算法应用场景"><a href="#常见搜索算法应用场景" class="headerlink" title="常见搜索算法应用场景"></a>常见搜索算法应用场景</h2><h3 id="BFS及DFS应用"><a href="#BFS及DFS应用" class="headerlink" title="BFS及DFS应用"></a>BFS及DFS应用</h3><h4 id="迷宫类题目"><a href="#迷宫类题目" class="headerlink" title="迷宫类题目"></a>迷宫类题目</h4><p>深度及广度优先搜索有一个重要的应用就是在迷宫中寻找路径。本节将针对该类问题进行一个总结。</p>
<ol>
<li>处理迷宫方向</li>
</ol>
<p>我们可以使用方向向量，处理迷宫中任务的移动方向，方向数组如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int dx[2] = &#123;0, 1, -1,  0&#125;;   //下、右、左、上</span><br><span class="line">int dy[2] = &#123;1, 0,  0, -1&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li>
</ol>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">二分法讲解</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/">二分查找相关细节</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/10/13/计算机/算法/查并集/" rel="next" title="查并集">
                <i class="fa fa-chevron-left"></i> 查并集
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/10/13/计算机/算法/数组/" rel="prev" title="数组">
                数组 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Shiqi Duan">
            
              <p class="site-author-name" itemprop="name">Shiqi Duan</p>
              <div class="site-description motion-element" itemprop="description">Do Not Go Gentle Into That Good Night</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">287</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">61</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:sqduan@mail.ustc.edu.cn" title="E-Mail &rarr; mailto:sqduan@mail.ustc.edu.cn" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://gitlab.com/sqduan" title="GitLab &rarr; https://gitlab.com/sqduan" rel="noopener" target="_blank"><i class="fa fa-fw fa-gitlab"></i>GitLab</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.zhihu.com/people/duan-shi-qi-72/activities" title="知乎 &rarr; https://www.zhihu.com/people/duan-shi-qi-72/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>知乎</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                我的朋友们
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mayi1996.top/" title="https://mayi1996.top/" rel="noopener" target="_blank">马亿</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zhangchenyu.me/" title="https://zhangchenyu.me/" rel="noopener" target="_blank">张琛昱</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#常见查找算法"><span class="nav-number">1.</span> <span class="nav-text">常见查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先查找DFS（不撞南墙不回头）"><span class="nav-number">1.1.</span> <span class="nav-text">深度优先查找DFS（不撞南墙不回头）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本模型"><span class="nav-number">1.1.1.</span> <span class="nav-text">基本模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#递归"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">迭代</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#难点总结"><span class="nav-number">1.1.2.</span> <span class="nav-text">难点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#理解dfs"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">理解dfs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dfs思路"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">dfs思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#搜索入口"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">搜索入口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#边界判断"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">边界判断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#何时增加深度"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">何时增加深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#被搜索节点的状态"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">被搜索节点的状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#剪枝"><span class="nav-number">1.1.2.8.</span> <span class="nav-text">剪枝</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见DFS类型总结及模板"><span class="nav-number">1.1.3.</span> <span class="nav-text">常见DFS类型总结及模板</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#判断搜索路径是否存在"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">判断搜索路径是否存在</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取累加值"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">获取累加值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#计算递归深度"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">计算递归深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获得所有可能解的DFS"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">获得所有可能解的DFS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS优化"><span class="nav-number">1.1.4.</span> <span class="nav-text">DFS优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#动态规划与DFS结合"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">动态规划与DFS结合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#广度优先搜索BFS"><span class="nav-number">1.2.</span> <span class="nav-text">广度优先搜索BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">1.2.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">1.2.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本模型-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">基本模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#难点及要点总结"><span class="nav-number">1.2.4.</span> <span class="nav-text">难点及要点总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS与BFS的比较"><span class="nav-number">1.3.</span> <span class="nav-text">DFS与BFS的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#专题：图的DFS和BFS搜索"><span class="nav-number">1.4.</span> <span class="nav-text">专题：图的DFS和BFS搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS搜索"><span class="nav-number">1.4.1.</span> <span class="nav-text">DFS搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BFS搜索"><span class="nav-number">1.4.2.</span> <span class="nav-text">BFS搜索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#专题：岛屿问题"><span class="nav-number">1.5.</span> <span class="nav-text">专题：岛屿问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#求连通域数目"><span class="nav-number">1.5.1.</span> <span class="nav-text">求连通域数目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#专题：迷宫问题"><span class="nav-number">1.6.</span> <span class="nav-text">专题：迷宫问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#寻找迷宫中的门"><span class="nav-number">1.6.1.</span> <span class="nav-text">寻找迷宫中的门</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断是否能走到终点"><span class="nav-number">1.6.2.</span> <span class="nav-text">判断是否能走到终点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迷宫遍历"><span class="nav-number">1.6.3.</span> <span class="nav-text">迷宫遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找（常常和二叉树一起出现）"><span class="nav-number">1.7.</span> <span class="nav-text">二分查找（常常和二叉树一起出现）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本原理"><span class="nav-number">1.7.1.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法要求"><span class="nav-number">1.7.2.</span> <span class="nav-text">算法要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法适用场景及每个场景对应框架-重要！"><span class="nav-number">1.7.3.</span> <span class="nav-text">算法适用场景及每个场景对应框架(重要！)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#二分查找基本框架2"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">二分查找基本框架2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#寻找一个数"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">寻找一个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#寻找左侧边界的二分查找"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">寻找左侧边界的二分查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#寻找右侧边界的二分查找"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">寻找右侧边界的二分查找</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法要点及难点"><span class="nav-number">1.7.4.</span> <span class="nav-text">算法要点及难点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#二维矩阵中的二分查找"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">二维矩阵中的二分查找</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法讲解"><span class="nav-number">1.7.5.</span> <span class="nav-text">算法讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#模板-来自例题1"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">模板(来自例题1)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例题"><span class="nav-number">1.7.6.</span> <span class="nav-text">例题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见搜索算法应用场景"><span class="nav-number">2.</span> <span class="nav-text">常见搜索算法应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS及DFS应用"><span class="nav-number">2.1.</span> <span class="nav-text">BFS及DFS应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迷宫类题目"><span class="nav-number">2.1.1.</span> <span class="nav-text">迷宫类题目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">3.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shiqi Duan</span>

  

  
</div>






  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.2</div>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">|总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>






  <script src="https://cdn.jsdelivr.net/npm/mermaid@7.1.2/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

        






<div>
<!-- 填写你的友盟代码 -->
<script type="text/javascript">
	var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
	document.write(unescape("%3Cspan id='cnzz_stat_icon_1278217259'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s9.cnzz.com/z_stat.php%3Fid%3D1278217259' type='text/javascript'%3E%3C/script%3E"));
</script>
<!-- 你的友盟代码 end -->
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="66,73,73" opacity="0.7" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
       TeX: {equationNumbers: {autoNumber: ["AMS"], useLabelIds: true}},
       "HTML-CSS": {linebreaks: {automatic: true}},
       SVG: {linebreaks: {automatic: true}}
   });
</script>
    
  


  
<script>
if ($('body').find('div.pdf').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      $('body').find('div.pdf').each(function(i, o) {
        PDFObject.embed($(o).attr('target'), $(o), {
          pdfOpenParams: {
            navpanes: 0,
            toolbar: 0,
            statusbar: 0,
            pagemode: 'thumbs',
            view: 'FitH'
          },
          PDFJS_URL: '/lib/pdf/web/viewer.html',
          height: $(o).attr('height') || '600px'
        });
      });
    },
  });
}
</script>


  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/mermaid@7.1.2/dist/mermaid.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: 'forest',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

  

  

  

  

  

  

  

  

</body>
</html>
