<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>井井有条地管理自己的分支</title>
    <url>/2024/10/13/%E5%B7%A5%E4%BD%9C/%E5%B7%A5%E4%BD%9C%E5%8F%8D%E6%80%9D/%E4%BA%95%E4%BA%95%E6%9C%89%E6%9D%A1%E5%9C%B0%E7%AE%A1%E7%90%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
</blockquote>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在我的工作中，经常性会出现需要多个分支并发管理的场景：同一份代码直接或经过适当修改及适配后，再合入不同的分支。如果我们不能有效地对分支进行管理，那么多份代码的提交极其容易造成混乱和冲突，且分支延迟合入会导致合入成本直线上升。所以我们需要一套行之有效的分支管理方法，使得我们的合入更加顺滑。</p>
<h1 id="分支管理方法"><a href="#分支管理方法" class="headerlink" title="分支管理方法"></a>分支管理方法</h1><h2 id="规范地创建分支"><a href="#规范地创建分支" class="headerlink" title="规范地创建分支"></a>规范地创建分支</h2><p>一般来说，当我们修复一个bug，或者进行一个新的需求时，可能会拉取一个新的分支。随着bug进行修复，或者需求提交，这些分支可能越来越多，如何有效地管理自己的分支，就成为了一个很重要的话题</p>
<h2 id="MR的表管理"><a href="#MR的表管理" class="headerlink" title="MR的表管理"></a>MR的表管理</h2><p>应当有一个在线的表格文档能够承接相关的MR提交，这个表格中包括提交链接，详细提交内容，应当合入的所有分支及合入情况。表格需要以周为单位进行定期更新，上个周未经合入的代码应当顺延到下个周，周一对上周提交的MR进行回顾。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>MR链接</th>
<th>提交内容（提取关键信息）</th>
<th>分支1</th>
<th>分支2</th>
<th>分支3</th>
</tr>
</thead>
<tbody>
<tr>
<td>链接1</td>
<td>内存隔离适配代码</td>
<td>已经合入</td>
<td>未合入</td>
<td>等待合入</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>以下列举了进行表管理时的一些原则：</p>
<ul>
<li>每天抽出10分钟时间回顾当日提交的MR并在表格中记录（5:00 - 5:10）</li>
<li>周一早晨抽出20分钟时间回顾上周MR，创建本周的MR管理表，并同步上周未合入的MR（9:30 - 9:50）</li>
</ul>
]]></content>
      <categories>
        <category>工作</category>
        <category>工作经验</category>
      </categories>
  </entry>
  <entry>
    <title>C++静态审查</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/C++%E9%9D%99%E6%80%81%E5%AE%A1%E6%9F%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>代码静态审查指在不对代码进行运行的情况下，对源代码进行分析，找到一些可能存在的问题，本文将针对CPP中代码静态审查工具cppcheck及其使用进行一些总结。</p>
<a id="more"></a>
<h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><h3 id="以目录为基准进行代码审查"><a href="#以目录为基准进行代码审查" class="headerlink" title="以目录为基准进行代码审查"></a>以目录为基准进行代码审查</h3><p>cppcheck使用过程非常简单，其界面如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/cppcheck.JPG" width = "500" alt="图片名称" align=center /></p>
<p>cppcheck可以对vs项目和cmake项目进行分析，工程类型比较少，实用性不高，因此建议还是以实际源代码的目录为基础，对代码进行分析。点击Analysis——目录或者Ctrl+D即可打开，然后自动对目录下所有代码进行审查。</p>
<h2 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://cppcheck.net/manual.pdf">cppcheck使用文档</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>X86-64汇编基本语法</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Assembly/X86-64%E6%B1%87%E7%BC%96%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>.LC0:<br>  .string “Helloworld”</p>
</blockquote>
<a id="more"></a>
<p>这里的汇编是GNU汇编，即使用AT&amp;T语法的汇编，请不要和别的汇编器混淆。</p>
<h2 id="指令助记符号与伪操作"><a href="#指令助记符号与伪操作" class="headerlink" title="指令助记符号与伪操作"></a>指令助记符号与伪操作</h2><h3 id="伪操作"><a href="#伪操作" class="headerlink" title="伪操作"></a>伪操作</h3><p>在汇编程序中，以’.’开头的名称并不是指令助记符，不会被翻译为机器码，而是给汇编器的特殊指令，叫做伪操作（实际上是汇编会执行的操作，同时也辅助人们阅读），常见伪操作及其含义如下：</p>
<h4 id="section及常用段"><a href="#section及常用段" class="headerlink" title=".section及常用段"></a>.section及常用段</h4><p>.section 用于把代码划分为若干段，每个段会被加载至不同地址，同时不同的页面会有相应的操作权限，常见段包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">读写/可执行性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.text</td>
<td style="text-align:center">保存代码</td>
<td style="text-align:center">只读可执行</td>
</tr>
<tr>
<td style="text-align:center">.data</td>
<td style="text-align:center">全局数据段</td>
<td style="text-align:center">可读可写</td>
</tr>
<tr>
<td style="text-align:center">.rodata</td>
<td style="text-align:center">常量数据段</td>
<td style="text-align:center">只读</td>
</tr>
</tbody>
</table>
</div>
<h4 id="globl"><a href="#globl" class="headerlink" title=".globl"></a>.globl</h4><p>该伪操作的作用是声明全局变量/标号，可供其他源文件在链接时访问，当汇编器编译汇编代码时，会将改变量进行记录，知道其是一个全局变量，当其他文件使用该全局变量时即可提供访问，类似于C语言中的extern语句作用。</p>
<h4 id="code"><a href="#code" class="headerlink" title=".code*"></a>.code*</h4><p>这个操作表示程序要在<em>位模式下运行，\</em>可以是16、32或64，当使用GDB进行调试时，遇到.code会发生架构的切换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) si</span><br><span class="line">The target arghitecture is set to &quot;i386&quot;  # .code32</span><br><span class="line">=&gt; 0x7c32: mov &amp;0x10, %ax</span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title=".set"></a>.set</h3><p>设置变量，例如下面的语句将PROT_MODE_CSEG的值设置为0x8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8</span><br></pre></td></tr></table></figure>
<h3 id="com"><a href="#com" class="headerlink" title=".com"></a>.com</h3><p>分配空间，在数据段中分配指定空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.comm stack, KSTACKSIZE</span><br></pre></td></tr></table></figure>
<p>在数据段中分配KSTACKSIZE长度的空间，这段空间用符号stack来表示。</p>
<h3 id="align"><a href="#align" class="headerlink" title=".align"></a>.align</h3><p>内存对齐操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.align 2;       /* align function definition 令函数对齐，即其起始地址为2的倍数*/     \ </span><br><span class="line">name:           /* function starts here */      \</span><br></pre></td></tr></table></figure>
<p>函数的起始地址就变成了2的倍数，中间部分会用null补齐。操作数必须是2的整数倍。</p>
<h2 id="常用寄存器及功能"><a href="#常用寄存器及功能" class="headerlink" title="常用寄存器及功能"></a>常用寄存器及功能</h2><p>此部分请参考<a href="/2024/10/13/计算机/组成原理/寄存器/" title="关于寄存器的讲解">关于寄存器的讲解</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="数据移动类"><a href="#数据移动类" class="headerlink" title="数据移动类"></a>数据移动类</h3><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>一下列举了一些mov的使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    0x10(%ebp),%edi  # ebp+10 --&gt; edi</span><br></pre></td></tr></table></figure>
<h5 id="mov的变种"><a href="#mov的变种" class="headerlink" title="mov的变种"></a>mov的变种</h5><p>根据mov数据长度的不同，mov还有如下变种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令名</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>movw</td>
<td>移动2字节(一个word)</td>
<td>mov word</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>只要有PUSH的动作，ESP寄存器自动减小，push命令使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push %eax</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subl $4, %esp </span><br><span class="line">movl %eax, (%esp)</span><br></pre></td></tr></table></figure>
<p>先减小esp，再移动数据。</p>
<h5 id="push的变种"><a href="#push的变种" class="headerlink" title="push的变种"></a>push的变种</h5><p>根据push数据长度的不同，push还有如下的变种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令名</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>pushl</td>
<td>压入2字节(一个word)</td>
<td>push long</td>
</tr>
<tr>
<td>pushal</td>
<td>push EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI，一次性压入上述寄存器</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>下面给出针对push的一个测试代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_pushl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"movl %esp, %eax\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="string">"pushl %ds\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="string">"subl %esp, %eax\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="string">"popl %ds\n"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"It used %d bytes\n"</span>, test_pushl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><h3 id="计算类"><a href="#计算类" class="headerlink" title="计算类"></a>计算类</h3><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><h4 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub $0x1c, %esp  #  %esp = %esp - 0x1c</span><br></pre></td></tr></table></figure>
<p>这个语句用于为栈分配空间</p>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><h4 id="shl"><a href="#shl" class="headerlink" title="shl"></a>shl</h4><h3 id="控制类"><a href="#控制类" class="headerlink" title="控制类"></a>控制类</h3><h4 id="转移命令"><a href="#转移命令" class="headerlink" title="转移命令"></a>转移命令</h4><h5 id="ljmp"><a href="#ljmp" class="headerlink" title="ljmp"></a>ljmp</h5><p>长转移命令，使用格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ljmp addr16</span><br></pre></td></tr></table></figure>
<h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><p>函数调用命令，使用方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call addr</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushl %eip          # 先将当前eip保存</span><br><span class="line">movl $addr, %eip    # 然后将新地址移至eip</span><br></pre></td></tr></table></figure>
<p>所以每次调用call，会导致esp减小，因为要将返回地址进行保存。x86架构规定栈向下生长，一个使用call指令的例子如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Example instruction</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td>pushl %eax</td>
<td>subl $4, %esp <br />movl %eax, (%esp)</td>
</tr>
<tr>
<td>popl %eax</td>
<td>movl (%esp), %eax <br />addl $4, %esp</td>
</tr>
<tr>
<td>call 0x12345</td>
<td>pushl %eip <br />movl $0x12345, %eip</td>
</tr>
<tr>
<td>ret</td>
<td>popl %eip</td>
</tr>
</tbody>
</table>
</div>
<h5 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h5><p>函数返回命令，使用方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>该指令等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">popl %eip</span><br></pre></td></tr></table></figure>
<h3 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h3><h4 id="iret"><a href="#iret" class="headerlink" title="iret"></a>iret</h4><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><h3 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h3><h4 id="inb"><a href="#inb" class="headerlink" title="inb"></a>inb</h4><p>从一个端口读数，读至寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inb $0x64, %al</span><br></pre></td></tr></table></figure>
<p>从0x64 port读取一个数，然后读至al寄存器中。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="符号及功能"><a href="#符号及功能" class="headerlink" title="符号及功能"></a>符号及功能</h3><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>功能</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>常量符号，所有常量都必须以$开头</td>
<td><code>mov $100, %bx</code>，将100移植bx</td>
</tr>
<tr>
<td></td>
<td>取地址符号</td>
<td><code>movl $values, %edi</code>，将value所在地址移至edi</td>
</tr>
<tr>
<td>%</td>
<td>寄存器标志，所有寄存器必须以%开头</td>
<td><code>mov %ax, %bx</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://docs.oracle.com/cd/E26502_01/html/E28388/eoiyg.html">伪指令索引</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Assembly</category>
      </categories>
  </entry>
  <entry>
    <title>call和ret命令</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Assembly/call%20and%20ret/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>call main</p>
</blockquote>
<a id="more"></a>
<p>call和ret是重要的控制转移类指令，本文将详细分析这两个指令的执行过程，从而理清C语言在调用函数过程中堆栈和寄存器的变化。</p>
<h2 id="call和ret的原理"><a href="#call和ret的原理" class="headerlink" title="call和ret的原理"></a>call和ret的原理</h2><p>函数调用命令，使用方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call addr</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushl %eip          # 先将当前eip保存</span><br><span class="line">movl $addr, %eip    # 然后将新地址移至eip</span><br></pre></td></tr></table></figure>
<p>所以每次调用call，会导致esp减小，因为要将返回地址进行保存。x86架构规定栈向下生长，一个使用call指令的例子如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Example instruction</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td>call 0x12345</td>
<td>pushl %eip <br />movl $0x12345, %eip</td>
</tr>
<tr>
<td>ret</td>
<td>popl %eip</td>
</tr>
</tbody>
</table>
</div>
<h5 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h5><p>函数返回命令，使用方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>该指令等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">popl %eip</span><br></pre></td></tr></table></figure>
<h2 id="调用函数的过程"><a href="#调用函数的过程" class="headerlink" title="调用函数的过程"></a>调用函数的过程</h2><p>下面我们以实际的调用函数的过程为例，对call和ret调用过程中堆栈和寄存器的变化进行研究。我们首先考虑无参函数，进一步扩展至有参函数。</p>
<h3 id="调用无参函数的过程"><a href="#调用无参函数的过程" class="headerlink" title="调用无参函数的过程"></a>调用无参函数的过程</h3><p>考虑一个最简单的函数调用过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in main.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    function1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用下述命令对<code>main.c</code>进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o build main.c -g</span><br></pre></td></tr></table></figure>
<p>输入<code>gdb</code>进入调试界面，然后输入下面的命令载入符号表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) file build</span><br><span class="line">Reading symbols from build...done.</span><br></pre></td></tr></table></figure>
<p>载入后，启动<code>tui</code>调试界面，然后开启汇编和寄存器窗口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) tui enable</span><br><span class="line">(gdb) layout asm</span><br><span class="line">(gdb) layout reg</span><br></pre></td></tr></table></figure>
<p>根据汇编代码，我们可以在程序的第一条指令处设置断点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) starti</span><br></pre></td></tr></table></figure>
<p>下面我们将根据调试过程，将函数调用过程分为五个阶段，对每个阶段中栈及关键寄存器的变化进行介绍。</p>
<h4 id="函数调用之前：原始栈"><a href="#函数调用之前：原始栈" class="headerlink" title="函数调用之前：原始栈"></a>函数调用之前：原始栈</h4><p>在调用函数之前，我们先观察调用函数的堆栈情况，根据调试结果，堆栈的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/beforecall.svg" width = "500" alt="uProf界面" align=center /></p>
<p>此时，<code>eip</code>恰好位于<code>call function1</code>之前。</p>
<h4 id="使用call命令：保存eip"><a href="#使用call命令：保存eip" class="headerlink" title="使用call命令：保存eip"></a>使用call命令：保存eip</h4><p>调用<code>call</code>命令后，该命令会首先对<code>eip</code>进行保存，将其<code>push</code>到栈内，然后将新命令的地址保存至<code>eip</code>中。经过该操作后，栈的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/callfuncion1modify.svg" width = "500" alt="uProf界面" align=center /></p>
<h4 id="执行函数：建立新栈"><a href="#执行函数：建立新栈" class="headerlink" title="执行函数：建立新栈"></a>执行函数：建立新栈</h4><p>在调用<code>call</code>命令后，我们进入被调用函数中，开始执行被调用函数。在被调用函数中，第一个工作就是创建新栈，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov %esp, %ebp</span><br></pre></td></tr></table></figure>
<p>将旧的栈基址保存，然后将新栈基址设置为当前<code>esp</code>，经过该操作后，新的栈生成：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/createnewstack.svg" width = "600" alt="uProf界面" align=center /></p>
<h4 id="即将从函数返回：销毁新栈"><a href="#即将从函数返回：销毁新栈" class="headerlink" title="即将从函数返回：销毁新栈"></a>即将从函数返回：销毁新栈</h4><p>在函数调用过程中，栈也会随着局部变量的添加而增长，这里我们不关心栈中局部变量的创建和销毁过程，只关注被调用函数返回的前一时刻，我们需要对被调用函数的栈进行销毁，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop %ebp</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/destorystack.svg" width = "600" alt="uProf界面" align=center /></p>
<p>现在，<code>esp</code>寄存器指向了保存旧的<code>eip</code>的位置，被调用函数的堆栈已经销毁，程序只需要将<code>eip</code>弹出，即可恢复调用程序的堆栈，同时从调用函数中中断的位置继续执行。</p>
<h4 id="使用ret命令：恢复eip"><a href="#使用ret命令：恢复eip" class="headerlink" title="使用ret命令：恢复eip"></a>使用ret命令：恢复eip</h4><p>最后，被调用函数执行<code>ret</code>指令，将<code>eip</code>从堆栈中恢复，实际就是<code>pop %eip</code>，在该操作之后，堆栈的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/popeip.svg" width = "600" alt="uProf界面" align=center /></p>
<p>在执行完成上面的命令之后，两个堆栈之间用于保存<code>eip</code>的这一小段空间也被销毁，现在程序状态已经回到了调用函数之前，将会从被中断的地方继续执行。</p>
<h3 id="调用有参函数的过程"><a href="#调用有参函数的过程" class="headerlink" title="调用有参函数的过程"></a>调用有参函数的过程</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Assembly</category>
      </categories>
  </entry>
  <entry>
    <title>Lambda</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/Lambda/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>一种临时性的轻量化的匿名函数</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是Lambda"><a href="#什么是Lambda" class="headerlink" title="什么是Lambda"></a>什么是Lambda</h2><p>Lambda是C++ 11 中的新标准， 用于定义并创建匿名的函数对象，以简化编程工作。</p>
<h2 id="Lambda-语法"><a href="#Lambda-语法" class="headerlink" title="Lambda 语法"></a>Lambda 语法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[函数对象参数] (操作符重载函数参数) <span class="keyword">mutable</span> 或 exception 声明 -&gt; 返回值类型 &#123;函数体&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">int</span> z = x + y; <span class="keyword">return</span> z; &#125;  返回类型为<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 隐式返回类型</span></span><br></pre></td></tr></table></figure>
<h2 id="Lambda-常用场景"><a href="#Lambda-常用场景" class="headerlink" title="Lambda 常用场景"></a>Lambda 常用场景</h2><h3 id="在算法中用于定义排序规则"><a href="#在算法中用于定义排序规则" class="headerlink" title="在算法中用于定义排序规则"></a>在算法中用于定义排序规则</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(people.begin(), people.end(),</span><br><span class="line">                [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rhs)</span><br><span class="line">                 &#123;<span class="keyword">return</span> lhs[<span class="number">0</span>] == rhs[<span class="number">0</span>] ? lhs[<span class="number">1</span>] &lt;= rhs[<span class="number">1</span>] : lhs[<span class="number">0</span>] &gt; rhs[<span class="number">0</span>];&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的lambda表达式定义了排序规则，其解释如下：</p>
<blockquote>
<ol>
<li><p>按照h递减 (lhs[0] &gt; rhs[0])</p>
</li>
<li><p>h相同时，按照k递增 (lhs[1] &lt;= rhs[1])</p>
</li>
</ol>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>内联汇编</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Assembly/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>asm asm-qualifiers ( AssemblerTemplate<br>                 : OutputOperands<br>                 [ : InputOperands<br>                 [ : Clobbers ] ])</p>
</blockquote>
<a id="more"></a>
<p>内联汇编允许我们在C或C++代码中插入汇编语句，本文将对内联汇编的相关使用方法进行总结。</p>
<h2 id="基本汇编——不带有运算数"><a href="#基本汇编——不带有运算数" class="headerlink" title="基本汇编——不带有运算数"></a>基本汇编——不带有运算数</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>一个基本内联汇编语句语法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> [qualifiers] ( instructions )</span><br></pre></td></tr></table></figure>
<h3 id="修饰定语-Qualifiers"><a href="#修饰定语-Qualifiers" class="headerlink" title="修饰定语(Qualifiers)"></a>修饰定语(Qualifiers)</h3><p>修饰定语可添加inline，那么asm的语句将被优化，尽可能占用少的空间</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>asm的参数为汇编语句，需要采用””括起来，并使用<code>\n\t</code>换行</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asm (&quot;.globl func\n\t&quot;</span><br><span class="line">        &quot;.type func, @function\n\t&quot;</span><br><span class="line">        &quot;func:\n\t&quot;</span><br><span class="line">        &quot;.cfi_startproc\n\t&quot;</span><br><span class="line">        &quot;movl $7, %eax\n\t&quot;</span><br><span class="line">        &quot;ret\n\t&quot;</span><br><span class="line">        &quot;.cfi_endproc&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="扩展汇编"><a href="#扩展汇编" class="headerlink" title="扩展汇编"></a>扩展汇编</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>相比基本汇编，扩展汇编更加灵活高效，但是必须放在函数中。扩展汇编的基本语法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( assembler <span class="keyword">template</span> </span><br><span class="line">    : output operands                  <span class="comment">/* optional 输出操作数*/</span>  </span><br><span class="line">    : input operands                   <span class="comment">/* optional 输入操作数*/</span></span><br><span class="line">    : <span class="built_in">list</span> of clobbered registers      <span class="comment">/* optional 破坏的寄存器*/</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h3 id="assembler-template"><a href="#assembler-template" class="headerlink" title="assembler template"></a>assembler template</h3><p>assembler template由汇编指令组成</p>
<h3 id="输入-输出操作数"><a href="#输入-输出操作数" class="headerlink" title="输入/输出操作数"></a>输入/输出操作数</h3><h4 id="操作数顺序"><a href="#操作数顺序" class="headerlink" title="操作数顺序"></a>操作数顺序</h4><p>我们在内联汇编中能看到<code>%0, %1, %2...</code>，这些数表示输入的第1个、第2个、…、第<code>n</code>个操作数，顺序即输入操作数在内联汇编中的排列顺序。</p>
<h4 id="操作数限制"><a href="#操作数限制" class="headerlink" title="操作数限制"></a>操作数限制</h4><p>我们可以用限制词限制输入输出操作数的位置，限制词的语法为：</p>
<ul>
<li><code>: &quot;=c&quot; (output)</code></li>
<li><code>: &quot;c&quot; (input)</code></li>
</ul>
<p>常用的限制词如下：</p>
<ul>
<li><code>r</code>：表示使用任意寄存器保存操作数</li>
</ul>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">"movl %1, %%eax; </span></span><br><span class="line"><span class="string">     movl %%eax, %0;"</span></span><br><span class="line">     :<span class="string">"=r"</span>(b)        <span class="comment">/* output */</span></span><br><span class="line">     :<span class="string">"r"</span>(a)         <span class="comment">/* input */</span></span><br><span class="line">     :<span class="string">"%eax"</span>         <span class="comment">/* clobbered register */</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>这段代码解释如下：</p>
<ul>
<li><code>b</code>是输出操作数，由<code>%0</code>表示第一个传入的表示输入或输出操作数的变量</li>
<li><code>a</code>是输入操作数，由<code>%1</code>表示第二个传入的表示输入或输出操作数的变量</li>
<li><code>r</code>为操作数限制，表示使用任意寄存器保存操作数</li>
<li>寄存器前有两个%%，这是为了区分操作数和寄存器，操作数只有一个%</li>
<li>被破坏的寄存器是<code>%eax</code>，告知GCC<code>eax</code>的值发生了改变，GCC将不会用这些寄存器保存值</li>
</ul>
<p>当上面的代码运行完成后，<code>b</code>将保存更新后的输出值。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://gcc.gnu.org/onlinedocs/gcc/Basic-Asm.html#Basic-Asm">Basic Asm (Using the GNU Compiler Collection (GCC))</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s1">GCC-Inline-Assembly-HOWTO (ibiblio.org)</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Assembly</category>
      </categories>
  </entry>
  <entry>
    <title>C++多线程</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>算了，我们走吧！</p>
<p>我们不能。<br>为什么不能？<br>我们在等待戈多。</p>
</blockquote>
<a id="more"></a>
<p>本文主要针对C++多线程编程的过程及常见问题进行总结，如果需要了解线程相关知识，请参考</p>
<h2 id="C-多线程使用流程"><a href="#C-多线程使用流程" class="headerlink" title="C++ 多线程使用流程"></a>C++ 多线程使用流程</h2><h3 id="线程的创建及运行"><a href="#线程的创建及运行" class="headerlink" title="线程的创建及运行"></a>线程的创建及运行</h3><h4 id="创建与等待"><a href="#创建与等待" class="headerlink" title="创建与等待"></a>创建与等待</h4><p>在多线程程序中，我们需要在主线程中创建子线程，然后等待子线程执行完毕，C++11引入了线程类，使得我们能够按照面向对象的方式使用线程，一个简单的线程创建代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am inside a thread function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(threadFun)</span></span>;  <span class="comment">//创建一个线程对象，参数是线程函数</span></span><br><span class="line">    t1.join();             <span class="comment">//阻塞主线程，直至t1结束执行，即等待线程执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，我们可以创建带有参数的线程函数，方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am inside a thread function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"value is "</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    thread t1&#123;threadFun, <span class="number">100</span>&#125;;  <span class="comment">//通过初始化列表方式创建一个线程对象，参数是线程函数及传入参数</span></span><br><span class="line">    t1.join();                 <span class="comment">//阻塞主线程，直至t1结束执行，即等待线程执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程函数同样可以为lambda表达式或实例化的模板函数。</p>
<h4 id="从底层了解线程的创建"><a href="#从底层了解线程的创建" class="headerlink" title="从底层了解线程的创建"></a>从底层了解线程的创建</h4><p>我们将第一段进行编译，生成汇编代码，首先是线程函数和主函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 线程函数</span><br><span class="line">.LC0:</span><br><span class="line">  .string &quot;I am the thread function&quot;</span><br><span class="line">threadFun():</span><br><span class="line">  push rbp</span><br><span class="line">  mov rbp, rsp</span><br><span class="line">  mov esi, OFFSET FLAT:.LC0</span><br><span class="line">  mov edi, OFFSET FLAT:_ZSt4cout</span><br><span class="line">  call std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)</span><br><span class="line">  mov esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_</span><br><span class="line">  mov rdi, rax</span><br><span class="line">  call std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; (*)(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;))</span><br><span class="line">  nop</span><br><span class="line">  pop rbp</span><br><span class="line">  ret</span><br><span class="line">  </span><br><span class="line">## 主函数，重点关注下面的注释内容</span><br><span class="line">main:</span><br><span class="line">  push rbp</span><br><span class="line">  mov rbp, rsp</span><br><span class="line">  push rbx</span><br><span class="line">  sub rsp, 24</span><br><span class="line">  lea rax, [rbp-24]</span><br><span class="line">  mov esi, OFFSET FLAT:threadFun()    #保存线程函数地址</span><br><span class="line">  mov rdi, rax</span><br><span class="line">  call std::thread::thread&lt;void (&amp;)(), , void&gt;(void (&amp;)())  #创建线程</span><br><span class="line">  lea rax, [rbp-24]</span><br><span class="line">  mov rdi, rax</span><br><span class="line">  call std::thread::join()            #</span><br><span class="line">  mov ebx, 0</span><br><span class="line">  lea rax, [rbp-24]</span><br><span class="line">  mov rdi, rax</span><br><span class="line">  call std::thread::~thread() [complete object destructor]  #销毁子线程即t1线程</span><br><span class="line">  mov eax, ebx</span><br><span class="line">  jmp .L14</span><br><span class="line">  mov rbx, rax</span><br><span class="line">  lea rax, [rbp-24]</span><br><span class="line">  mov rdi, rax</span><br><span class="line">  call std::thread::~thread() [complete object destructor]  #销毁主线程</span><br><span class="line">  mov rax, rbx</span><br><span class="line">  mov rdi, rax</span><br><span class="line">  call _Unwind_Resume</span><br><span class="line">.L14:</span><br><span class="line">  mov rbx, QWORD PTR [rbp-8]</span><br><span class="line">  leave</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<h4 id="获得线程ID"><a href="#获得线程ID" class="headerlink" title="获得线程ID"></a>获得线程ID</h4><p>和进程一样，每个线程都包含自己的ID，我们可以在线程函数中使用<code>this_thread::get_id()</code>来获得当前线程的ID号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am inside a thread function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(threadFun)</span></span>;  <span class="comment">//创建一个线程对象，参数是线程函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    t1.join();             <span class="comment">//阻塞主线程，直至t1结束执行，即等待线程执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程常见问题及解决方案"><a href="#线程常见问题及解决方案" class="headerlink" title="线程常见问题及解决方案"></a>线程常见问题及解决方案</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://refactoring.guru/design-patterns/what-is-pattern">C++设计模式</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++动态性能验证</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/C++%E5%8A%A8%E6%80%81%E6%80%A7%E8%83%BD%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在对代码性能验证过程中，我们需要知道哪些部分是代码性能的瓶颈，这个过程需要对C++程序进行相应的动态性能验证，本文将针对动态验证的过程进行一些介绍，并针对AMD uProf性能验证工具的一些使用方法进行总结。</p>
<a id="more"></a>
<h2 id="Profile原理"><a href="#Profile原理" class="headerlink" title="Profile原理"></a>Profile原理</h2><p>常见的性能分析程序原理一般分为三个阶段“</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据收集</td>
<td>运行程序并收集分析数据</td>
</tr>
<tr>
<td>翻译</td>
<td>将分析数据集成并保存至一个DB中</td>
</tr>
<tr>
<td>分析</td>
<td>针对数据进行分析，获得性能瓶颈</td>
</tr>
</tbody>
</table>
</div>
<p>下面将针对数据收集阶段具体工作内容进行总结：</p>
<h3 id="数据收集阶段"><a href="#数据收集阶段" class="headerlink" title="数据收集阶段"></a>数据收集阶段</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>待分析的目标可以是应用、整个系统或某个特定进程，分析的类型可以包括CPU性能、系统级别的功率分析以及功率应用分析等。数据收集可以分为事件触发或时间片，可收集的数据包括用户层和内核层部分。</p>
<h4 id="重要数据"><a href="#重要数据" class="headerlink" title="重要数据"></a>重要数据</h4><p>以CPU Profiling为例，其中比较重要的数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Profile类型</th>
<th>数据类型</th>
<th>采样事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU Profiling</td>
<td>进程及线程ID，IP，函数调用栈</td>
<td>Timer、基于指令的采样以及核心的性能监测器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>在进行profile过程中，我们应当尽可能避免阻塞式IO，因为将会影响验证的结果，合理的做法是提供一组验证数据，对于模块进行验证，避免人机交互带来的对于运行过程的影响。</li>
<li>profile软件可能需要在管理员模式下使用，这样才能访问exe的源码。</li>
</ol>
<h2 id="uProf-使用方法1"><a href="#uProf-使用方法1" class="headerlink" title="uProf 使用方法1"></a>uProf 使用方法<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><h3 id="基本界面及功能"><a href="#基本界面及功能" class="headerlink" title="基本界面及功能"></a>基本界面及功能</h3><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/uprof.JPG" width = "1000" alt="uProf界面" align=center /></p>
<h4 id="uProf基本功能"><a href="#uProf基本功能" class="headerlink" title="uProf基本功能"></a>uProf基本功能</h4><ul>
<li>性能分析</li>
<li>系统分析（IPC、内存带宽等）</li>
<li>热及功率分析以及能量分析</li>
</ul>
<p>支持的语言包括C/C++、Java、Assembly等，支持的调试文件格式包括PDB、COFF等。</p>
<h3 id="用例分析"><a href="#用例分析" class="headerlink" title="用例分析"></a>用例分析</h3><h4 id="1-待分析源码"><a href="#1-待分析源码" class="headerlink" title="1 待分析源码"></a>1 待分析源码</h4><p>这里提供了一个单词、字符以及句子统计的程序以供分析，其源代码如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wordCount</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; file)</span></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.open(file);</span><br><span class="line">    <span class="built_in">string</span> sentence, word;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ifs.is_open())&#123;</span><br><span class="line">        <span class="keyword">while</span> ( getline (ifs,sentence) )&#123;</span><br><span class="line">            <span class="function"><span class="built_in">istringstream</span> <span class="title">sentence_stream</span><span class="params">(sentence)</span></span>;</span><br><span class="line">            <span class="keyword">while</span>(sentence_stream &gt;&gt; word)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        ifs.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unable to open the file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">characterCount</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; file)</span></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.open(file);</span><br><span class="line">    <span class="keyword">char</span> character;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ifs.is_open())&#123;</span><br><span class="line">        <span class="keyword">while</span> (ifs &gt;&gt; character)&#123;    <span class="comment">//以段落对文本进行读取</span></span><br><span class="line">            <span class="keyword">if</span>(character != <span class="string">'\r'</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ifs.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unable to open the file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数写的比较丑，没什么参考价值，不断依靠重复的对标点符号进行判断从而断句。只是做一个示例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sentenceCount</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; file)</span></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.open(file);</span><br><span class="line">    <span class="built_in">string</span> sentence, word;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ifs.is_open())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( getline (ifs, sentence, <span class="string">'.'</span>) )&#123;    <span class="comment">//以段落对文本进行读取</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ifs.clear();</span><br><span class="line">        ifs.seekg(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( getline (ifs, sentence, <span class="string">'?'</span>) )&#123;    <span class="comment">//以段落对文本进行读取</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ifs.clear();</span><br><span class="line">        ifs.seekg(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> ( getline (ifs, sentence, <span class="string">';'</span>) )&#123;    <span class="comment">//以段落对文本进行读取</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ifs.clear();</span><br><span class="line">        ifs.seekg(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> ( getline (ifs, sentence, <span class="string">'!'</span>) )&#123;    <span class="comment">//以段落对文本进行读取</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        ifs.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unable to open the file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> file&#123;<span class="string">"test.txt"</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Character Number:"</span> &lt;&lt; characterCount(file) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计单词个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Word Number: "</span> &lt;&lt; wordCount(file)     &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计句子个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sentence Number: "</span> &lt;&lt;sentenceCount(file) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="2-配置分析类型以及待分析应用程序所在目录"><a href="#2-配置分析类型以及待分析应用程序所在目录" class="headerlink" title="2 配置分析类型以及待分析应用程序所在目录"></a>2 配置分析类型以及待分析应用程序所在目录</h4><p>1 以管理员模式启动uProf程序，在Select Profile Target处选择Application</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/uprofimage.JPG" width = "1000" alt="uProf界面" align=center /></p>
<p>2 设置好待分析的可执行程序路径及工作目录。</p>
<p>3 点击Next，选择profile类型以及对应的分析手段和分析过程的一些参数等，这里详见使用文档，然后点击Start Profile。这个过程可能会提示获得数据错误，多试几次即可。</p>
<p>4 观察profile结果，获得性能分析结果<img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/analyseresult.JPG" width = "1000" alt="uProf界面" align=center /></p>
<p>下图为运行后得到的分析结果，展示了热点函数、进程、模块以及线程。点击上面的Analyze，可以进一步查看更加详细的分析结果，例如某一个具体函数所占据的运行时间为多少。从而可以发现性能瓶颈。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/analyseresult2.JPG" width = "1000" alt="uProf界面" align=center /></p>
<p>在上面的详细结果中，我们可以看出每个函数所占用的时间，可以发现我们的characterCount以及wordCount占用时间都是比较短的。不算是性能上的瓶颈。</p>
<h2 id="Very-Sleepy-CS使用方法"><a href="#Very-Sleepy-CS使用方法" class="headerlink" title="Very Sleepy CS使用方法"></a>Very Sleepy CS使用方法</h2><p>由于uProf只能用于AMD的CPU，这里介绍另一个profile软件Very Sleepy CS，这个软件十分轻量化，使用也非常简单，但是也能够给我们提供比较好的分析结果。同样的，该软件应当在管理员模式下使用。</p>
<h3 id="基本界面及功能-1"><a href="#基本界面及功能-1" class="headerlink" title="基本界面及功能"></a>基本界面及功能</h3><p>Sleepy的界面如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/sleepy.JPG" width = "600" alt="uProf界面" align=center /></p>
<p>界面左上部分为当前进程，右上为待分析进程。点击File——Launch并填写待分析程序路径和执行路径后，即可开始分析，下图为分析结果。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/sleepyresult.JPG" width = "1000" alt="uProf界面" align=center /></p>
<p>在filter中我们可以查看想看的函数运行情况，从图中我们可以看出characterCount的运行情况为：</p>
<ul>
<li>Inclusive（考虑函数内部调用其他函数）：占比19.33%</li>
<li>Exclusive（不考虑函数内部调用其他函数）：占比0.00%</li>
</ul>
<p>当然一般我们是要考虑内部函数调用情况的。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://developer.amd.com/wordpress/media/files/AMDuprof_Resources/User_Guide_AMD_uProf_v3.3_GA.pdf">uProf使用介绍</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>volatile关键字总结</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/volatile/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>优化并不总是更优，可能会更差</p>
</blockquote>
<a id="more"></a>
<p>volatile，翻译过来叫做易挥发的，是C/C++当中的一个关键字，其作用是阻止编译器对代码进行的一些优化。具体来说，volatile关键字可以用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>IO与流</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/IO%E4%B8%8E%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span></span><br><span class="line">__libc_read (<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> SYSCALL_CANCEL (read, fd, buf, nbytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>文件属于IO中的重要环节，本文将针对使用C++对文件处理的过程进行总结。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在介绍文件相关的类库前，我们先来看一下C++中关于IO的类库之间的相关关系</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/iostream.gif" width = "700" alt="uProf界面" align=center /></p>
<p>从这张图中可以看出，基于最基础的IOS类，C++标准库中又延伸出了一系列的关于IO的库，包括iostream（标准输入输出流）、fstream（文件流）、sstream（string流），这些库一同构成了C++的输入输出系统。</p>
<h2 id="标准IO流"><a href="#标准IO流" class="headerlink" title="标准IO流"></a>标准IO流</h2><h3 id="基本类库介绍"><a href="#基本类库介绍" class="headerlink" title="基本类库介绍"></a>基本类库介绍</h3><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h4><p>getline是istream中非常常用的一个API，其功能是从istream中向string读取一行，该函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim)</span></span>;   <span class="comment">//以delim流作为分隔符，仅支持单个分隔符</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, <span class="built_in">string</span>&amp; str)</span></span>;               <span class="comment">//以'\n'作为流分隔符</span></span><br></pre></td></tr></table></figure>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><h3 id="基本类型介绍"><a href="#基本类型介绍" class="headerlink" title="基本类型介绍"></a>基本类型介绍</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>istringstream</td>
<td>输入string流，从string中读取数据</td>
</tr>
<tr>
<td>ostringstream</td>
<td>输出string流，向string中输出数据</td>
</tr>
<tr>
<td>sstringstream</td>
<td>同时具有ofstream和ifstream的功能，可以创建文件，并从文件中读写信息</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h3><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><h3 id="基本类型介绍-1"><a href="#基本类型介绍-1" class="headerlink" title="基本类型介绍"></a>基本类型介绍</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ofstream</td>
<td>输出文件流，创建文件并向文件写入信息，流向为$文本 \rightarrow 文件$</td>
</tr>
<tr>
<td>ifstream</td>
<td>输入文件流，从文件中读取信息</td>
</tr>
<tr>
<td>fstream</td>
<td>同时具有ofstream和ifstream的功能，可以创建文件，并从文件中读写信息</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="文本单词数统计"><a href="#文本单词数统计" class="headerlink" title="文本单词数统计"></a>文本单词数统计</h4><p>这里的单词是广义的单词，即凡是以空格或回车进行分割的都称之为单词，这个统计结果与word的结果是一致的，如果需要仅统计26个英文单词，那么可以进行单独的判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wordCount</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; file)</span></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.open(file);</span><br><span class="line">    <span class="built_in">string</span> sentence, word;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ifs.is_open())&#123;</span><br><span class="line">        <span class="keyword">while</span> ( getline (ifs,sentence) )&#123;  <span class="comment">//从 ifstream --&gt; string</span></span><br><span class="line">            <span class="function"><span class="built_in">istringstream</span> <span class="title">sentence_stream</span><span class="params">(sentence)</span></span>; <span class="comment">// 从string --&gt; istringstream</span></span><br><span class="line">            <span class="keyword">while</span>(sentence_stream &gt;&gt; word) <span class="comment">//从 istringstream --&gt; string</span></span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        ifs.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unable to open the file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用实例：词频分析器"><a href="#应用实例：词频分析器" class="headerlink" title="应用实例：词频分析器"></a>应用实例：词频分析器</h2><h3 id="条件与限制"><a href="#条件与限制" class="headerlink" title="条件与限制"></a>条件与限制</h3><ul>
<li>应当仅以<code>. ? ! ;</code>四个标点符号作为对句子进行划分</li>
<li>单词是指仅包含26个大小写英文字母的以空格进行区分的字符串</li>
</ul>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>文件处理模块</p>
<p>单句划分模块</p>
<p>词频统计模块</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文件</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>static关键字总结</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/static%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>hide, share and long live</p>
</blockquote>
<a id="more"></a>
<h2 id="静态变量及函数"><a href="#静态变量及函数" class="headerlink" title="静态变量及函数"></a>静态变量及函数</h2><h3 id="全局静态变量"><a href="#全局静态变量" class="headerlink" title="全局静态变量"></a>全局静态变量</h3><p>在cpp文件中声明并初始化的全局变量，生命周期为整个对象的周期，在定义的cpp文件中可见</p>
<h3 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h3><p>在某个程序块中声明并初始化的全局变量，只初始化一次，在定义的程序块中可见，生命周期为整个对象周期。</p>
<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><p>静态函数只能在本文件中使用。</p>
<h3 id="类的静态成员变量（一处变处处变）"><a href="#类的静态成员变量（一处变处处变）" class="headerlink" title="类的静态成员变量（一处变处处变）"></a>类的静态成员变量（一处变处处变）</h3><p>类的静态成员为类的所有对象共有，因此具有对象间通信、统计对象个数的作用。可以通过<code>classname.variable</code>直接引用，不需创造对象实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value;      <span class="comment">// 一个私有的静态成员变量，这个是声明而非定义</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Something::s_value&#123; <span class="number">1</span> &#125;; <span class="comment">// 初始化，只能进行一次，实际上是对变量的定义，所以可以访问，但是不能再次定义，否则出现重定义错误</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// how do we access Something::s_value since it is private?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们应当如何访问静态成员变量呢？可以声明一个普通成员函数进行访问，但是这样需要构造具体对象，因此更好的方法是提供一个静态成员函数接口，专门用于访问静态成员变量。</p>
<h3 id="类的静态成员函数（没有this指针）"><a href="#类的静态成员函数（没有this指针）" class="headerlink" title="类的静态成员函数（没有this指针）"></a>类的静态成员函数（没有this指针）</h3><p>有一些函数为类层面的方法，不属于任何一个对象，此时定义为静态成员函数，可以通过<code>类名::方法名</code>直接使用，而不需要创建类实例。</p>
<ul>
<li>非静态成员函数可以调用静态成员函数，反之不行。</li>
<li>静态成员函数能访问静态成员变量，不能访问非静态的成员变量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_value; &#125; <span class="comment">// static member function  专门用于访问静态成员变量，但是不能访问非静态的</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Something::s_value&#123; <span class="number">1</span> &#125;; <span class="comment">// initializer</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Something::getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="声明为静态的作用"><a href="#声明为静态的作用" class="headerlink" title="声明为静态的作用"></a>声明为静态的作用</h2><h3 id="隐藏对象或函数"><a href="#隐藏对象或函数" class="headerlink" title="隐藏对象或函数"></a>隐藏对象或函数</h3><p>一个对象如果被声明为静态，那么只对本文件中的对象可见，因此如果另一个文件中声明了同样的对象和函数，那么不会造成命名冲突。<strong>不要在header中定义静态全局对象，因为每一个包含该header的文件都会创建一个对象实例，会导致奇怪的现象发生。</strong>我们一般在cpp文件中定义全局变量。同时，定义为全局变量时，优先考虑static。</p>
<h3 id="延长对象的生命周期"><a href="#延长对象的生命周期" class="headerlink" title="延长对象的生命周期"></a>延长对象的生命周期</h3>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对C++中内存管理及变量存储位置进行总结。</p>
<a id="more"></a>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>在现代计算机系统中，我们需要考虑代码编译后在内存中的布局与使用方式，由此引出了内存对齐的概念。</p>
<h3 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h3><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><p>CPU不是按照字节对内存进行存取的，而是按照字（双字节、四字节或八字节），这个单位就叫存取粒度，经过对齐，CPU能够确保读取的是干净的数据而不需要做额外的移位处理，因此可以提高读取速度。这算是以空间换取时间的一种措施。</p>
<h4 id="支持原子操作"><a href="#支持原子操作" class="headerlink" title="支持原子操作"></a>支持原子操作</h4><p>经过对齐的内存存取可以保证读取或写入是一次完成的，这可以使CPU支持原子操作。</p>
<h2 id="C-代码及变量存储位置"><a href="#C-代码及变量存储位置" class="headerlink" title="C++代码及变量存储位置"></a>C++代码及变量存储位置</h2><ul>
<li>栈：程序自动分配，编译器在需要时分配，不需要使自动清除，用于保存局部变量</li>
<li>堆：手动内存分配时的区域，需要手动释放</li>
<li>常量存储区：存放常量，不允许修改，编译时分配，程序退出时销毁</li>
<li>全局/静态存储区：保存全局变量和局部静态变量，编译时分配内存，退出时销毁，默认设置存储变量为0</li>
<li>代码存储区：函数体等代码存储位置</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>$f(x) = x$</p>
</blockquote>
<a id="more"></a>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>本节将对函数指针的使用进行讲解，在C++中我们应当尽量使用虚函数或多态，回避函数指针。当然，虚函数的底层实现依然是通过函数指针实现的。</p>
<h3 id="函数指针常用场景"><a href="#函数指针常用场景" class="headerlink" title="函数指针常用场景"></a>函数指针常用场景</h3><h4 id="作为其他函数的参数"><a href="#作为其他函数的参数" class="headerlink" title="作为其他函数的参数"></a>作为其他函数的参数</h4><h4 id="作为回调函数"><a href="#作为回调函数" class="headerlink" title="作为回调函数"></a>作为回调函数</h4><p>回调机制在GUI中大量使用，当特定事件发生时，回调函数会被调用，格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_button</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> <span class="keyword">char</span> *text, function callback_func )</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="常见回调函数"><a href="#常见回调函数" class="headerlink" title="常见回调函数"></a>常见回调函数</h5><p>定时器回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(void (*func)(), delay);  //在时间到后执行func</span><br></pre></td></tr></table></figure>
<h5 id="回调机制的实现"><a href="#回调机制的实现" class="headerlink" title="回调机制的实现"></a>回调机制的实现</h5><p>以Javascript为例，其回调机制实现如下：函数栈和WEB API分别运行于独立环境中，当调用回调API，例如setTimeout时，该API会进入WEB API中。当定时器到达时间后，会将回调函数放置入回调队列，如果函数栈为空或者允许抢占当前正在执行的函数，那么将回调函数再放入函数栈中进行执行。</p>
<pre class="mermaid">graph LR
    node[函数栈]
    node1[WEB API]
    node2[回调队列]

    node1-->node2
    node2-->node</pre>

<h5 id="回调机制的缺陷"><a href="#回调机制的缺陷" class="headerlink" title="回调机制的缺陷"></a>回调机制的缺陷</h5><p>回调机制由于有中断作用，因此增加了程序的复杂度，同时也会导致我们无法使用程序提供的异常处理机制</p>
<h3 id="函数指针基本语法"><a href="#函数指针基本语法" class="headerlink" title="函数指针基本语法"></a>函数指针基本语法</h3><h4 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>  (*foo)  (<span class="keyword">int</span>);   <span class="comment">//返回值，指针，参数列表</span></span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化有两种方式，如下，从下面的代码我们可以看出，函数名实际就是函数指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">func_pointer = foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">func_pointer = &amp;foo;</span><br></pre></td></tr></table></figure>
<h2 id="从汇编层面了解函数调用过程1"><a href="#从汇编层面了解函数调用过程1" class="headerlink" title="从汇编层面了解函数调用过程1"></a>从汇编层面了解函数调用过程<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><h3 id="call命令及其原理"><a href="#call命令及其原理" class="headerlink" title="call命令及其原理"></a>call命令及其原理</h3><p>在汇编语言中，函数调用是通过call命令实现的，这其中涉及到了栈的生长和收缩，在x86中，栈向下生长，一个函数调用例子如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Example instruction</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pushl %eax</code></td>
<td><code>subl $4, %esp</code> <br /><code>movl %eax, (%esp)</code></td>
</tr>
<tr>
<td><code>popl %eax</code></td>
<td>movl (%esp), %eax <br />addl $4, %esp</td>
</tr>
<tr>
<td><code>call 0x12345</code></td>
<td>pushl %eip <br />movl $0x12345, %eip</td>
</tr>
<tr>
<td><code>ret</code></td>
<td>popl %eip</td>
</tr>
</tbody>
</table>
</div>
<h3 id="栈使用规则"><a href="#栈使用规则" class="headerlink" title="栈使用规则"></a>栈使用规则</h3><p>而编译器GCC决定了栈是如何被使用的：</p>
<ul>
<li>在一个函数的入口（在<code>call</code>语句后的一条语句）<ul>
<li>%eip指向函数的第一条语句</li>
<li>%esp+4指向第一个参数</li>
<li>%esp指向返回地址</li>
</ul>
</li>
<li>在ret指令后<ul>
<li>%eip包含返回地址</li>
<li>%esp指向调用者压入栈中保存的参数</li>
<li>被调用的函数可能会有垃圾参数</li>
<li>%eax（以及%edx，如果是64位）保存返回值（如果函数为void，保存垃圾值）</li>
<li>%ebp, %ebx, %esi, %edi 在 <code>call</code>命令后必须有内容</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>%eax, %ecx, %edx 是保存调用者参数的寄存器</li>
<li>%ebp, %ebx, %esi, %edi 是保存被调用者参数的寄存器</li>
</ul>
<h3 id="栈分配规则"><a href="#栈分配规则" class="headerlink" title="栈分配规则"></a>栈分配规则</h3><p>每一个函数都有一段由%ebp, %esp标识的独立的栈空间，一般这些空间是连续的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          +------------+   |</span><br><span class="line">       | arg 2      |   \</span><br><span class="line">       +------------+    &gt;- previous function&apos;s stack frame</span><br><span class="line">       | arg 1      |   /</span><br><span class="line">       +------------+   |</span><br><span class="line">       | ret %eip   |   /</span><br><span class="line">       +============+   </span><br><span class="line">       | saved %ebp |   \</span><br><span class="line">%ebp-&gt; +------------+   |</span><br><span class="line">       |            |   |</span><br><span class="line">       |   local    |   \</span><br><span class="line">       | variables, |    &gt;- current function&apos;s stack frame</span><br><span class="line">       |    etc.    |   /</span><br><span class="line">       |            |   |</span><br><span class="line">       |            |   |</span><br><span class="line">%esp-&gt; +------------+   /</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>通过移动esp，可以控制栈的生长与收缩</li>
<li>ebp指向前一个函数保存的ebp</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>函数调用时会保存ebp，然后将当前的esp保存在ebp中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushl %ebp</span><br><span class="line">movl %esp, %ebp</span><br></pre></td></tr></table></figure>
<h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><p>函数返回时会复原esp和ebp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl %ebp, %esp</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure>
<h3 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h3><ul>
<li><p>C code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> f(<span class="number">8</span>)+<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> g(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x+<span class="number">3</span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>assembler</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_main:</span><br><span class="line">                prologue</span><br><span class="line">        pushl %ebp</span><br><span class="line">        movl %esp, %ebp</span><br><span class="line">                body</span><br><span class="line">        pushl $8</span><br><span class="line">        call _f</span><br><span class="line">        addl $1, %eax</span><br><span class="line">                epilogue</span><br><span class="line">        movl %ebp, %esp</span><br><span class="line">        popl %ebp</span><br><span class="line">        ret</span><br><span class="line">_f:</span><br><span class="line">                prologue</span><br><span class="line">        pushl %ebp</span><br><span class="line">        movl %esp, %ebp</span><br><span class="line">                body</span><br><span class="line">        pushl 8(%esp)</span><br><span class="line">        call _g</span><br><span class="line">                epilogue</span><br><span class="line">        movl %ebp, %esp</span><br><span class="line">        popl %ebp</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">_g:</span><br><span class="line">                prologue</span><br><span class="line">        pushl %ebp</span><br><span class="line">        movl %esp, %ebp</span><br><span class="line">                save %ebx</span><br><span class="line">        pushl %ebx</span><br><span class="line">                body</span><br><span class="line">        movl 8(%ebp), %ebx</span><br><span class="line">        addl $3, %ebx</span><br><span class="line">        movl %ebx, %eax</span><br><span class="line">                restore %ebx</span><br><span class="line">        popl %ebx</span><br><span class="line">                epilogue</span><br><span class="line">        movl %ebp, %esp</span><br><span class="line">        popl %ebp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>根据<code>_g</code>的运算过程，其可以被压缩为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_g:</span><br><span class="line">    movl 4(%esp), %eax</span><br><span class="line">    addl $3, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>实际上，<code>_f</code>也可以被压缩，压缩为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># TODO</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.jianshu.com/p/0299f56edab5">函数调用过程</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>动态内存管理</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对C++中动态内存管理的方式进行总结</p>
<a id="more"></a>
<p>首先说明一点，动态内存管理在堆上进行，其生存周期为分配内存至手动释放内存的时间段，我们应当尽量避免手动进行内存管理。</p>
<h2 id="C-动态内存管理的方式"><a href="#C-动态内存管理的方式" class="headerlink" title="C++动态内存管理的方式"></a>C++动态内存管理的方式</h2><h4 id="new-and-delete"><a href="#new-and-delete" class="headerlink" title="new and delete"></a>new and delete</h4><h5 id="new-delete的基本用法"><a href="#new-delete的基本用法" class="headerlink" title="new/delete的基本用法"></a>new/delete的基本用法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">delete</span> []a;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>...&#125;   <span class="comment">//声明一个类 A</span></span><br><span class="line">A *obj = <span class="keyword">new</span> A();  <span class="comment">//使用 new 创建对象</span></span><br><span class="line"><span class="keyword">delete</span> obj;</span><br></pre></td></tr></table></figure>
<h5 id="new-delete底层实现"><a href="#new-delete底层实现" class="headerlink" title="new /delete底层实现"></a>new /delete底层实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局 operator new</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span>* p;</span><br><span class="line">    <span class="keyword">while</span> ((p = ::<span class="built_in">malloc</span>(size)) == <span class="number">0</span>) &#123; <span class="comment">//采用 malloc 分配空间</span></span><br><span class="line">        <span class="built_in">std</span>::new_handler nh = <span class="built_in">std</span>::get_new_handler();   <span class="comment">//std::new_handler 是函数指针类型（指向不接收参数并返回 void 的指针）</span></span><br><span class="line">        <span class="keyword">if</span> (nh)</span><br><span class="line">            nh();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();  <span class="comment">//分配失败，抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应的全局 operator delete 采用 free 释放空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">        ::<span class="built_in">free</span>(ptr); <span class="comment">//采用 free 释放空间。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="malloc-and-free"><a href="#malloc-and-free" class="headerlink" title="malloc and free"></a>malloc and free</h4><p>传统的C语言式内存管理，不建议在C++中使用，使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *str;</span><br><span class="line">str = (char *) malloc(15);</span><br><span class="line">strcpy(str, &quot;tutorialspoint&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h4><p>在C++中，如果不是必须，那么尽可能使用new和delete，因为new、delete可以确保对象的构造函数和析构函数被调用，是类型安全的。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>内存陷阱</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%86%85%E5%AD%98%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>str = (char *) malloc(15);</p>
<p>free(str)</p>
<p>free(str)</p>
</blockquote>
<a id="more"></a>
<h2 id="常见内存问题"><a href="#常见内存问题" class="headerlink" title="常见内存问题"></a>常见内存问题</h2><h3 id="内存泄漏（浪费可耻）"><a href="#内存泄漏（浪费可耻）" class="headerlink" title="内存泄漏（浪费可耻）"></a>内存泄漏（浪费可耻）</h3><h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><p>内存泄漏指应用程序用了一段内存，但是忘了释放，导致了内存的浪费。</p>
<h4 id="内存泄漏的后果"><a href="#内存泄漏的后果" class="headerlink" title="内存泄漏的后果"></a>内存泄漏的后果</h4><p>内存泄漏的的后果从轻到重可能体现为性能不良到内存彻底用尽从而导致程序崩溃，在以下情况，内存泄漏后果很严重</p>
<ol>
<li>一个生命周期较长的程序运行后导致内存逐渐流失</li>
<li>新的内存被频繁分配导致内存快速流失</li>
<li>泄漏发生在关键位置，例如操作系统或驱动程序中</li>
<li>在内存极其有限的系统中发生泄漏</li>
<li>在程序运行结束后不会自动释放内存的操作系统上发生泄漏</li>
</ol>
<h4 id="常见内存泄漏原因"><a href="#常见内存泄漏原因" class="headerlink" title="常见内存泄漏原因"></a>常见内存泄漏原因</h4><h5 id="申请-释放未配对"><a href="#申请-释放未配对" class="headerlink" title="申请/释放未配对"></a>申请/释放未配对</h5><ol>
<li>最单纯的malloc忘记free</li>
<li>内存分配和释放在不同的函数体内，可能忘记了释放</li>
<li>在malloc和free之间发生了错误导致free未能执行</li>
<li>不匹配使用new[]/delete[]</li>
</ol>
<h5 id="基类析构函数未定义为虚函数"><a href="#基类析构函数未定义为虚函数" class="headerlink" title="基类析构函数未定义为虚函数"></a>基类析构函数未定义为虚函数</h5><p>这种情况下如果基类指针指向子类，delete该对象，子类部分不会被释放</p>
<h5 id="delete-void指针导致析构函数未调用"><a href="#delete-void指针导致析构函数未调用" class="headerlink" title="delete void指针导致析构函数未调用"></a>delete void指针导致析构函数未调用</h5><p>在C++中，delete实际是做了两件事</p>
<ul>
<li>调用析构函数</li>
<li>释放空间</li>
</ul>
<p>在下面的代码中，如果我们去delete一个void指针，会导致析构函数没有被调用，而析构函数中可能会做一些内存释放工作，导致析构失败</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span>* data;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Object(<span class="keyword">int</span> sz, <span class="keyword">char</span> c):size(sz), id(c)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object() "</span> &lt;&lt; id &lt;&lt; <span class="string">" size = "</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Object()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Object() "</span> &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>  </span><br><span class="line">        <span class="keyword">delete</span> []data;        <span class="comment">// ！！！data不会被释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object* a = <span class="keyword">new</span> Object(<span class="number">10</span>, <span class="string">'A'</span>);<span class="comment">//Object*指针指向一个Object对象；</span></span><br><span class="line">    <span class="keyword">void</span>* b = <span class="keyword">new</span> Object(<span class="number">20</span>, <span class="string">'B'</span>);<span class="comment">//void*指针指向一个Object对象；</span></span><br><span class="line">    <span class="keyword">delete</span> a;<span class="comment">//执行delete，编译器自动调用析构函数；</span></span><br><span class="line">    <span class="keyword">delete</span> b;<span class="comment">//执行delete，编译器不会调用析构函数，导致data占用内存没有得到回收；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见内存问题检测"><a href="#常见内存问题检测" class="headerlink" title="常见内存问题检测"></a>常见内存问题检测</h2><h3 id="内存泄漏检测"><a href="#内存泄漏检测" class="headerlink" title="内存泄漏检测"></a>内存泄漏检测</h3><h4 id="mtrace"><a href="#mtrace" class="headerlink" title="mtrace"></a>mtrace</h4><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>The only me is me, but are you sure the only you is you?</p>
</blockquote>
<a id="more"></a>
<p>多态指在不同条件下表现出不同的状态，C++中有多种多态的实现方式，本文将对这些方式进行总结。</p>
<h2 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h2><p>多态指为不同数据类型的实体提供统一的接口。</p>
<pre class="mermaid">graph TD;
    A[Polymorphism]-->B["Compile Time"]; 
    A-->C[Run Time];
    B-->D["Function Overloading"]
    B-->E["Operator Overloading"]
    C-->F["Function Overloading"]</pre>

<h3 id="一个不使用多态的例子-静态绑定"><a href="#一个不使用多态的例子-静态绑定" class="headerlink" title="一个不使用多态的例子(静态绑定)"></a>一个不使用多态的例子(静态绑定)</h3><img  src=http://www.plantuml.com/plantuml/svg/Kr1GKE3YSYWkIImgAStDuKhEIImkLd1CJiulpIkfvWBAAfJbPwOeb6UMPAGK9PPhQ7BLSa5L1IUMPUQb4r3ad96Qd4rOMKXHQJ5k-w3kKR2fqTM5Mgk0AWYpXWig2nO46yhba9gN0l8Q0000>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account a;</span><br><span class="line">a.withdraw();        <span class="comment">// Account::withdraw();</span></span><br><span class="line"></span><br><span class="line">Saving b;</span><br><span class="line">b.withdraw();        <span class="comment">// Saving::withdraw();</span></span><br><span class="line"></span><br><span class="line">Checking c;</span><br><span class="line">c.withdraw();        <span class="comment">// Checking::withdraw();</span></span><br><span class="line"></span><br><span class="line">Trust d;</span><br><span class="line">d.withdraw();        <span class="comment">// Trust::withdraw();</span></span><br><span class="line"></span><br><span class="line">Account *p = <span class="keyword">new</span> Trust();    <span class="comment">// legal</span></span><br><span class="line">p-&gt;withdraw();           <span class="comment">// We plan to call Trust::withdraw(), but here the Account::withdraw() will be called</span></span><br></pre></td></tr></table></figure>
<p>上面的代码在编译器的认知里，p就是一个Account指针，因此他会调用Account的方法（对于传递引用也是如此）。在这种情况下，如果我们需要调用Trust的函数，那么可能需要用if-else语句进行判断，会降低代码的抽象性.因此我们需要一些改进措施。改进如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account a;</span><br><span class="line">a.withdraw();        <span class="comment">// Account::withdraw();  withdraw is virtual in Account</span></span><br><span class="line"></span><br><span class="line">Saving b;</span><br><span class="line">b.withdraw();        <span class="comment">// Saving::withdraw();</span></span><br><span class="line"></span><br><span class="line">Checking c;</span><br><span class="line">c.withdraw();        <span class="comment">// Checking::withdraw();</span></span><br><span class="line"></span><br><span class="line">Trust d;</span><br><span class="line">d.withdraw();        <span class="comment">// Trust::withdraw();</span></span><br><span class="line"></span><br><span class="line">Account *p = <span class="keyword">new</span> Trust();    <span class="comment">// legal</span></span><br><span class="line">p-&gt;withdraw();               <span class="comment">//Trust::withdraw();</span></span><br></pre></td></tr></table></figure>
<p>上面的代码几乎和之前的没有区别，唯一的区别是Account中的withdraw被定义为了虚函数，编译器被告知不要在编译时解析函数，而是在运行时进行动态绑定。<strong>在运行时会检查p到底指向那个具体的类</strong>。</p>
<h2 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h2><ul>
<li>更抽象化思考</li>
<li>让C++指定运行时调用的函数</li>
</ul>
<h2 id="不同的多态类型"><a href="#不同的多态类型" class="headerlink" title="不同的多态类型"></a>不同的多态类型</h2><h3 id="编译期多态（静态多态）"><a href="#编译期多态（静态多态）" class="headerlink" title="编译期多态（静态多态）"></a>编译期多态（静态多态）</h3><p>C++通过函数重载的方式实现编译期多态，编译时编译器会根据参数列表自动匹配最合适的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">double</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><h5 id="重载赋值运算符函数"><a href="#重载赋值运算符函数" class="headerlink" title="重载赋值运算符函数"></a>重载赋值运算符函数</h5><p>在定义赋值运算符时，我们需要注意以下几点：</p>
<ul>
<li>返回引用类型确保连续赋值，否则如果函数返回值为void，那么无法通过编译（Effective C++条款10）</li>
<li>传入参数为const 引用（节省空间，防止修改）</li>
<li>在<code>operator=</code>中处理自我赋值</li>
<li>异常安全性</li>
</ul>
<p>前两条好解释，第三条看下例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[i] = a[j]; <span class="comment">//如果i == j 潜在的自我赋值，如果i=j</span></span><br><span class="line">*px  = *py   <span class="comment">//如果px和py只想同一个东西</span></span><br></pre></td></tr></table></figure>
<p>自我赋值不安全的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;                       <span class="comment">//停止使用当前bitmap，释放空间</span></span><br><span class="line">   	<span class="comment">// 问题！！ 如果是自我赋值，那么发生了自我销毁 </span></span><br><span class="line">   </span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);        <span class="comment">//分配空间</span></span><br><span class="line">    <span class="comment">//指针指向一个已经被删除的对象！！</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自我赋值安全但异常不安全的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pb;   </span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);   <span class="comment">//如果new 发生异常（内存不足或拷贝异常），那么pb将指向一块被删除的Bitmap</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个安全的但是包含分支会导致效率降低的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">Widget::operator</span><span class="params">(<span class="keyword">const</span> Widget&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)&#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(rhs)</span></span>;            <span class="comment">//复制一个对象然后将空间交换</span></span><br><span class="line">        Bitmap* pTemp = temp.pb;</span><br><span class="line">        temp.pb = pb;</span><br><span class="line">        pb = pTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重载-运算符"><a href="#重载-运算符" class="headerlink" title="重载++运算符"></a>重载++运算符</h5><p>在重载++运算符前，我们先看下标准的前置和后置递增如何实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//前置递增</span><br><span class="line">int&amp;  int::operator++（）</span><br><span class="line">&#123;</span><br><span class="line">    *this +=1；</span><br><span class="line">    return *this；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">后置递增</span><br><span class="line">const int int::operator（int）</span><br><span class="line">&#123;</span><br><span class="line">    int oldValue = *this；</span><br><span class="line">    ++（*this）；</span><br><span class="line">    return oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时多态（基类指针或引用指向派生类对象）"><a href="#运行时多态（基类指针或引用指向派生类对象）" class="headerlink" title="运行时多态（基类指针或引用指向派生类对象）"></a>运行时多态（基类指针或引用指向派生类对象）</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul>
<li>继承</li>
<li>基类指针或引用</li>
<li>虚函数</li>
</ul>
<h4 id="基类指针"><a href="#基类指针" class="headerlink" title="基类指针"></a>基类指针</h4><p>基类指针可以指向子类，因为子类是由基类派生出来的，本质上也是基类的一种，我们可以利用这个特性进行动态绑定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account *p1 = <span class="keyword">new</span> Account();</span><br><span class="line">Account *p2 = <span class="keyword">new</span> Saving();</span><br><span class="line"></span><br><span class="line">p1-&gt;withdraw();    <span class="comment">//Account::withdraw();</span></span><br><span class="line">p2-&gt;withdraw();    <span class="comment">//Saving::withdraw();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当待处理的对象非常多时，我们可以这样写：</span></span><br><span class="line">Account *p1 = <span class="keyword">new</span> Account();</span><br><span class="line">Account *p2 = <span class="keyword">new</span> Saving();</span><br><span class="line">...</span><br><span class="line">Account *pn = <span class="keyword">new</span> Trust();</span><br><span class="line">Account *<span class="built_in">array</span>[] = &#123;p1,p2,...,pn&#125;;   <span class="comment">//或者vector&lt;Account *&gt;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)&#123;</span><br><span class="line">    <span class="built_in">array</span>[i]-&gt;withdraw();           <span class="comment">//动态绑定的精髓就是用父类指针指向子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚函数（运行时动态绑定）"><a href="#虚函数（运行时动态绑定）" class="headerlink" title="虚函数（运行时动态绑定）"></a>虚函数（运行时动态绑定）</h4><p>虚函数允许我们像处理基类一样处理子类，从而实现运行时多态。在了解虚函数之前，我们需要明确以下几点：</p>
<ul>
<li>重载的函数是静态绑定的（overload）</li>
<li>重写的函数是动态绑定的（override）</li>
<li>虚函数是一种overridden函数</li>
</ul>
<h5 id="普通虚函数和纯虚函数"><a href="#普通虚函数和纯虚函数" class="headerlink" title="普通虚函数和纯虚函数"></a>普通虚函数和纯虚函数</h5><p>虚函数可以分为普通虚函数和纯虚函数，普通虚函数父类可以实现，子类需要重新实现，而纯虚函数父类只是一个接口，必须依赖子类的实现。<strong>只有类的非构造析构非静态成员函数可以作为虚函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hungry--;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 纯虚函数，包含纯虚函数的类叫纯虚类，不能构造对象</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为何要使用纯虚函数？因为在有些情况下，基类本身生成对象是不合理的，比如交通工具可以派生出火车汽车，但是交通工具本身生成对象是不合常理的。</p>
</blockquote>
<h5 id="在派生类中重写虚函数"><a href="#在派生类中重写虚函数" class="headerlink" title="在派生类中重写虚函数"></a>在派生类中重写虚函数</h5><ul>
<li>函数参数列表和返回值必须和基类完全一致</li>
<li>virtual关键字非必须，但建议写上</li>
<li>如果不提供重写的函数，那么会继承基类函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checking</span> :</span> <span class="keyword">public</span> Account &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="虚析构函数（防止内存泄漏）"><a href="#虚析构函数（防止内存泄漏）" class="headerlink" title="虚析构函数（防止内存泄漏）"></a>虚析构函数（防止内存泄漏）</h5><p>当我们销毁多态对象，可能会发生一些问题：当派生类对象申请的内存空间通过基类指针被销毁时，同时基类中的析构函数为普通析构函数，那么我们的派生类对象可能按照不正确的顺序被销毁，或者有一部分根本就不会被销毁，产生了内存泄漏的问题。<strong>我们要确保派生类对象从正确的析构函数开始销毁（先销毁派生部分，再销毁基类部分，基类和子类中的析构函数都会被调用）</strong>。解决方法也很简单，一旦一个类有虚函数，那就把析构函数定义为虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">virtual</span> ~Account();</span><br></pre></td></tr></table></figure>
<h5 id="override关键字"><a href="#override关键字" class="headerlink" title="override关键字"></a>override关键字</h5><p>函数的重载与重写一个是静态绑定一个是动态绑定，重写要求函数结构和返回值必须严格对应，我们有时候可能将两者混淆，因此C++11中提供了一个override关键字，强制保证重写。参考下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say_hello</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello - I am a base class object"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;   <span class="comment">// ! ! ! 粗心！忘了写const，不再是函数重写，而是重载，编译没有错误，但是并不是我们所想的</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello - I am a derived class object"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Derived()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们用基类指针方式调用父类和子类的say_hello时，出现的是静态绑定，因此调用的都是基类的say_hello，改进如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say_hello</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;   <span class="comment">// 加了override却没有重写，编译器报错！</span></span><br><span class="line">        <span class="comment">//正确应该为 virtual void say_hello() const override</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello - I am a derived class object"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Derived()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><p>当我们的类包含虚函数时，会构建一个虚表，同时，如果一个类继承了一个有虚函数的类，他也会有一个虚表。虚表为一个指针数组，指向对应的虚函数。由于虚函数采用了虚表，调用时增加了一次内存开销。</p>
<pre class="mermaid">graph LR
    subgraph A的虚表
        node0["0x401ED0"]
        node1["0x401F10"]
    end

    subgraph A的虚函数
        node2["A::vfun1"]
        node3["A::vfun2"]
    end

    subgraph A的非虚函数
        node4["A::fun1"]
        node5["A::fun2"]
    end
    node0-->node2
    node1-->node3</pre>

<h5 id="虚表的特点："><a href="#虚表的特点：" class="headerlink" title="虚表的特点："></a>虚表的特点：</h5><ul>
<li>构建于编译期，虚表的地址是固定不变的，执行期间不能新增或替换。</li>
<li>属于类而非对象，意味着一个类只需要一个虚表供所有对象使用，对象有一个虚表指针，指向使用的虚表 <code>*_vptr</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/virtual_table.png" width = "550"  alt="图片名称" align=center /></p>
<h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p>动态绑定是通过虚表和虚表指针实现的，例如，假设我们有如下类和及类间继承关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1;</span><br><span class="line">    <span class="keyword">int</span> m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其对象模型如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/virtual_function2.png" width = "550"  alt="图片名称" align=center /></p>
<p>三个类均有虚函数，因此每个类都含有虚表，每个类的每个对象都有虚表指针，A有两个虚函数，故其有两个虚表，分别指向<code>A::vfunc1()</code>和<code>A::vfunc2()</code>，B继承于A，故B可以调用A的函数，但B重写了<code>vfunc1()</code>，故B的虚表的两个虚表指针分别指向<code>A::vfunc2()</code>和<code>B::vfunc1()</code>，而C继承于B，故类C可以调用B的函数，但类C重写了<code>vfunc2()</code>，故C的两个虚表指针分别指向<code>B::vfunc1()</code>和<code>C::vfunc2()</code>。(指向最近的继承的类的虚函数)。</p>
<p>下面，我们定义一个B对象，用A指针指向B</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B bObject;</span><br><span class="line">    A *p = &amp; bObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于p是类型为A*的指针，故p只能访问指向基类的部分，但是虚表指针虽然属于基类，但是指向派生类B的虚函数表，故p可以访问B的虚函数，这便是动态绑定的原理。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>在很多情况下，基类直接生成对象是不合理的，为了解决上述问题，我们引入了纯虚函数(<code>virtual returnType func() = 0;</code>)，纯虚函数必须由子类进行实现，<strong>注意是必须实现</strong>。</p>
<h4 id="虚函数表的底层实现"><a href="#虚函数表的底层实现" class="headerlink" title="虚函数表的底层实现"></a>虚函数表的底层实现</h4><p>在了解了虚函数的工作机制后，我们进一步看一下，虚函数在底层是如何实现的，为了了解其底层，我们有必要探寻C++在产生汇编以及机器码时的工作过程，这里推荐一个网站<a href="https://godbolt.org/">C++转汇编</a>，如果使用g++也可以实现类似的功能，就是不太方便，目前还没找到比较好的IDE能够实现该功能<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。在探寻底层概念时，我们先明确以下几点：</p>
<ul>
<li>在每个包含虚函数的类中，编译器秘密地放置了一个成为vpointer的指针，指向vtable</li>
</ul>
<p>一段C++代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"I'm Animal\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"I'm Cat\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal *animal)</span> </span>&#123;</span><br><span class="line">    animal-&gt;name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    func(<span class="keyword">new</span> Animal());</span><br><span class="line">    func(<span class="keyword">new</span> Cat());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转为汇编之后代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.LC0:     # local constant</span><br><span class="line">        .string &quot;I&apos;m Animal&quot;    #这些string都在.rodata段，即只读数据段</span><br><span class="line">Animal::name():</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        mov     edi, OFFSET FLAT:.LC0</span><br><span class="line">        call    puts</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">.LC1:</span><br><span class="line">        .string &quot;I&apos;m Cat&quot;</span><br><span class="line">Cat::name():</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        mov     edi, OFFSET FLAT:.LC1</span><br><span class="line">        call    puts</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">func(Animal*):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     rax, QWORD PTR [rax]</span><br><span class="line">        mov     rdx, QWORD PTR [rax]</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    rdx</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">Animal::Animal() [base object constructor]:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        mov     edx, OFFSET FLAT:vtable for Animal+16</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     QWORD PTR [rax], rdx</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">Cat::Cat() [base object constructor]:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    Animal::Animal() [base object constructor]</span><br><span class="line">        mov     edx, OFFSET FLAT:vtable for Cat+16</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     QWORD PTR [rax], rdx</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        push    rbx</span><br><span class="line">        sub     rsp, 8</span><br><span class="line">        mov     edi, 8</span><br><span class="line">        call    operator new(unsigned long)</span><br><span class="line">        mov     rbx, rax</span><br><span class="line">        mov     QWORD PTR [rbx], 0</span><br><span class="line">        mov     rdi, rbx</span><br><span class="line">        call    Animal::Animal() [complete object constructor]</span><br><span class="line">        mov     rdi, rbx</span><br><span class="line">        call    func(Animal*)</span><br><span class="line">        mov     edi, 8</span><br><span class="line">        call    operator new(unsigned long)</span><br><span class="line">        mov     rbx, rax</span><br><span class="line">        mov     QWORD PTR [rbx], 0</span><br><span class="line">        mov     rdi, rbx</span><br><span class="line">        call    Cat::Cat() [complete object constructor]</span><br><span class="line">        mov     rdi, rbx</span><br><span class="line">        call    func(Animal*)</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        mov     rbx, QWORD PTR [rbp-8]</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">vtable for Cat:</span><br><span class="line">        .quad   0</span><br><span class="line">        .quad   typeinfo for Cat</span><br><span class="line">        .quad   Cat::name()</span><br><span class="line">vtable for Animal:</span><br><span class="line">        .quad   0</span><br><span class="line">        .quad   typeinfo for Animal</span><br><span class="line">        .quad   Animal::name()</span><br><span class="line">typeinfo for Cat:</span><br><span class="line">        .quad   vtable for __cxxabiv1::__si_class_type_info+16</span><br><span class="line">        .quad   typeinfo name for Cat</span><br><span class="line">        .quad   typeinfo for Animal</span><br><span class="line">typeinfo name for Cat:</span><br><span class="line">        .string &quot;3Cat&quot;</span><br><span class="line">typeinfo for Animal:</span><br><span class="line">        .quad   vtable for __cxxabiv1::__class_type_info+16</span><br><span class="line">        .quad   typeinfo name for Animal</span><br><span class="line">typeinfo name for Animal:</span><br><span class="line">        .string &quot;6Animal&quot;</span><br></pre></td></tr></table></figure>
<p>从上面的汇编代码中，我们可以看到其生成了类的虚函数表vtable，.quad代表产生一个64位的数值作为地址，不过仅从以上信息，我们并不能知道vtable存放在哪里，为了探究虚函数的位置，我们需要考虑其相对基址的偏移量</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://blog.csdn.net/zhangpeterx/article/details/100120219">C++转汇编</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++前置声明与头文件使用</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%89%8D%E7%BD%AE%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是前置声明"><a href="#什么是前置声明" class="headerlink" title="什么是前置声明"></a>什么是前置声明</h2><blockquote>
<p>前置声明（Forward declaration）是尚未给出完整定义前针对类型、变量或者函数的声明</p>
</blockquote>
<p>前置声明用来告诉编译器，我有这个东西，但是这个东西具体是什么样子的，我现在还不知道。</p>
<a id="more"></a>
<h2 id="何时用前置声明"><a href="#何时用前置声明" class="headerlink" title="何时用前置声明"></a>何时用前置声明</h2><ol>
<li>调用函数前必须针对函数进行声明。</li>
<li>如果一个类仅仅是使用了指针，或者作为返回类型，而没有访问具体的类成员，那么使用前置声明，不使用头文件，因为指针所占空间大小是确定的，编译器可以提前获知。</li>
</ol>
<p>同理，如果需要访问具体类成员，那么就必须给出具体定义，所以这种情况下只能使用头文件，而不能用前置声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Level</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Enemy e;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码如果不包含头文件会报错，如果修改的话我们可以引入头文件，也可以使用指针代替。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enemy</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Level</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Enemy *e;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="头文件使用原则"><a href="#头文件使用原则" class="headerlink" title="头文件使用原则"></a>头文件使用原则</h2><ol>
<li>尽可能避免包含头文件，因为可能增加编译时间，尽量用引用或指针代替</li>
<li>尽可能在.cpp文件中包含头文件而不是.h文件中，在.cpp文件中的头文件只有当文件被编译时才会被included，而在.h文件中的头文件会被每一个包含该头文件的文件使用。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://jatinganhotra.com/blog/2012/11/25/forward-class-declaration-in-c-plus-plus/">关于前置声明的讲解</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>库</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>站在巨人的肩膀上</p>
</blockquote>
<a id="more"></a>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>谎言的代价是什么<br>并不是它会被错当成真相<br>真正的危险是 如果我们听了太多谎言<br>会再无法分辨出真相</p>
</blockquote>
<a id="more"></a>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p>异常允许我们将问题检测与解决过程分离</p>
<h2 id="异常使用准则"><a href="#异常使用准则" class="headerlink" title="异常使用准则"></a>异常使用准则</h2><h3 id="何时使用异常"><a href="#何时使用异常" class="headerlink" title="何时使用异常"></a>何时使用异常</h3>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>宏定义</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%AE%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<h1 id="define"><a href="#define" class="headerlink" title="define :-)"></a>define :-)</h1></blockquote>
<a id="more"></a>
<p>宏定义是C/C++系中的重要组成部分，一般在一些底层框架性代码中起着非常重要的作用，本文将以循序渐进的方式，对宏的使用进行一些总结。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="宏的基本规则"><a href="#宏的基本规则" class="headerlink" title="宏的基本规则"></a>宏的基本规则</h3><p>宏定义可以理解为简单地对于文本进行替换，宏的替换发生在预编译的阶段，编译器根据语义分析，将宏替换为原有的字符，这个过程称为宏的展开。也正因为宏是简单的进行文本替换，所以可能会发生许多意想不到的情况，在Effective C++中，其实作者并不建议我们滥用宏定义。</p>
<h4 id="多行宏"><a href="#多行宏" class="headerlink" title="多行宏"></a>多行宏</h4><p>在宏中，我们使用<code>\</code>进行换行，一个多行宏如下所示，最后一行不加<code>\</code>代表结束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define SYSCALL(name) \</span><br><span class="line">  .globl name; \</span><br><span class="line">  name: \</span><br><span class="line">    movl $SYS_ ## name, %eax; \</span><br><span class="line">    int $T_SYSCALL; \</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h3 id="宏的分类"><a href="#宏的分类" class="headerlink" title="宏的分类"></a>宏的分类</h3><p>我们可以按照功能将宏进行分类，分为对象宏和函数宏两种，对象宏一般用于定义一些常数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI 3.</span></span><br></pre></td></tr></table></figure>
<p>这一句将<code>M_PI</code>定义为了圆周率，那么程序在预编译过程中就会将<code>M_PI</code>替换为魔数。</p>
<p>而函数宏，就是行为类似函数，可以接收参数的宏，当我们定义宏的时候在宏名字后加一对括号，就创建了函数宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(A,B) A &lt; B ? A : B</span></span><br><span class="line"><span class="comment">// 一个漏洞百出的函数宏</span></span><br></pre></td></tr></table></figure>
<p>上面这个函数宏接受两个参数，返回较小的那个值.当然这个宏函数存在非常大的问题，因为宏是文本替换，而这个宏非常粗糙 ，甚至不能进行下面的计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span> * MIN(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// =&gt; int a = 2 * 3 &lt; 4 ? 3 : 4;</span></span><br><span class="line"><span class="comment">// =&gt; int a = 6 &lt; 4 ? 3 : 4;</span></span><br><span class="line"><span class="comment">// =&gt; int a = 4; 错误结果</span></span><br></pre></td></tr></table></figure>
<h3 id="为何要使用宏"><a href="#为何要使用宏" class="headerlink" title="为何要使用宏"></a>为何要使用宏</h3><h2 id="宏的一些高级用法"><a href="#宏的一些高级用法" class="headerlink" title="宏的一些高级用法"></a>宏的一些高级用法</h2><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>通过<code>##</code>可以实现对于宏的拼接过程，考虑下面这个场景，系统调用中，sys_重复出现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_chdir</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_close</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_dup</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_exec</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这种情况下，可以定义如下宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL(name) \</span></span><br><span class="line">  .globl name; \</span><br><span class="line">  name: \</span><br><span class="line">    movl $SYS_ #<span class="meta"># name, %eax; \</span></span><br><span class="line">    <span class="keyword">int</span> $T_SYSCALL; \</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>当我们要用到SYS_fork时，就可以写为<code>SYSCALL(fork)</code>，起到了精简代码的作用</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://onevcat.com/2014/01/black-magic-in-macro/">宏定义的黑魔法</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>引用</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><a id="more"></a>
<h2 id="函数返回引用"><a href="#函数返回引用" class="headerlink" title="函数返回引用"></a>函数返回引用</h2><p>使用引用作为函数的返回值，效率更高，但是需要注意，<strong>返回引用需要保证对象存在，不允许返回局部变量的引用</strong>。<br>下面是一个函数返回引用的例子：<br>在使用链表构建堆栈的过程中，返回栈顶元素的函数可以返回引用，因为栈顶元素还在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T&amp; <span class="title">top_element</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lst.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是pop函数就不能返回引用了，因为在弹出栈之后，该元素作为局部变量已经消失，因此不能返回引用，只能退而求其次，返回对象的值（返回一个拷贝）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    T el = lst.back();</span><br><span class="line">    lst.pop_back();</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载返回引用"><a href="#运算符重载返回引用" class="headerlink" title="运算符重载返回引用"></a>运算符重载返回引用</h2><p>运算符重载使用对象的引用作为返回值，主要是从如下两个方面进行考虑：</p>
<ol>
<li>减少创建临时对象的开销（和函数返回引用原因相同）</li>
<li>允许进行链式操作</li>
</ol>
<p>例如现在有一个Mystring类，为了进行赋值操作，类中对赋值操作符进行了重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mystring&amp; Mystring::<span class="keyword">operator</span>=(<span class="keyword">const</span> Mystring&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] str;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(rhs.str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(str,rhs.str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，函数内部已经对被赋值的对象进行了修改，为什么还要返回对象的引用呢？返回void不可以么？返回void的问题是会导致链式赋值失效，当然如果不进行链式赋值，返回void也是可以的。</p>
<p>关于链式赋值失效，还需要从赋值语句的值谈起，赋值语句的值是赋值对象的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a=b=c;</span><br></pre></td></tr></table></figure>
<p>上面的语句可以视为如下语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a=(b=c);</span><br></pre></td></tr></table></figure>
<p><code>b=c</code>这条语句的值就是c，或者说是被赋值之后的b，然后再用这条语句的值，为a赋值。而如果重载的赋值语句返回void，那么造成的结果是<code>b=c</code>这条语句返回值为void，利用void给a进行赋值，会导致类型不匹配的问题，所以为了使链式赋值生效，<code>b=c</code>必须返回c的值，或者被赋值之后的b的值，此时给a进行赋值，就没有任何问题。不返回对象引用而返回对象本身也没有问题，但是会重复调用多次构造函数和析构函数，导致性能下降。##</p>
<h2 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h2><p>初学引用时，可能会与指针混淆，在此处总结二者区别：</p>
<ol>
<li>指针是一个变量，引用是一个对象的别名；（你在学校叫张含韵，在家叫二丫子）</li>
<li>指针大小为4字节（32位）或8字节（64位），引用大小为对象大小</li>
<li>指针可以为null，引用必须初始化</li>
<li>指针修改对象需要解引用，而修改引用会直接修改变量</li>
<li>指针可以指向别的对象（花心），引用只能是一个对象的引用（专一）</li>
<li>指针可以有多级，引用没有</li>
<li>指针++和引用++含义不同</li>
<li>返回动态内存分配的对象必须返回指针</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Animals can eat</p>
</blockquote>
<a id="more"></a>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>我们经常会听到“面向接口编程”这个概念，那么问题来了，什么是接口？它和面向对象有什么区别？实际上面向接口是面向对象的一种更加抽象化的表示，本质上还是面向对象的一种。</p>
<h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>接口是什么？在C++中它是纯虚类，在Java中是Interface。从形式上来看，接口是一系列仅提供声明的方法组成的集合。而方法的具体实现需要由接口的继承者们实现，一个接口形式可能是如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceName</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~InterfaceName() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InterfaceMethod1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InterfaceMethod2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么问题又来了，我们为何需要接口，接口的本质是什么？我们可以从如下两个方面进行考虑<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>
<h3 id="接口规定了特定事物所必须包含（或至少可以）的一系列方法"><a href="#接口规定了特定事物所必须包含（或至少可以）的一系列方法" class="headerlink" title="接口规定了特定事物所必须包含（或至少可以）的一系列方法"></a>接口规定了特定事物所必须包含（或至少可以）的一系列方法</h3><p>例如我们要去创造一个动物类，那么按照我们的常识，动物们必须（或至少可以）具有如下一些方法：吃饭、睡觉、跑等。那么如果你要创造一个具体的动物，例如猫，那么猫应该具有吃饭、睡觉和跑等功能。所以你创建的猫，应该必须实现这些功能，才能称之为一个合格的动物。（将具体的对象进行了抽象，提取出必备的功能特征）</p>
<h3 id="接口是某一个层次上同一类事物的抽象表示"><a href="#接口是某一个层次上同一类事物的抽象表示" class="headerlink" title="接口是某一个层次上同一类事物的抽象表示"></a>接口是某一个层次上同一类事物的抽象表示</h3><p>猫和狗都是动物，那么它们之间的一些方法就可以被提取出来作为共同特征，所以我们可以用一个Animal接口，来保存所有动物都应该具有的特性，在动物这个层次上，猫和狗是同一类事物，它们都可以被抽象为animal。因此在动物这个层次上，我们能够忽略两者之间的差异，将其按照相同或相似的方式进行处理（多态）。</p>
<p>需要注意的是，客观世界是非常复杂的，我们往往只能在相同或相近的层次上对事物进行抽象，但是如果事物之间相差太大，我们很难定义出统一的接口。例如我们能够将猫和狗抽象为动物。但是一只猫和一杆枪，我们可能只能说他们都是物体，这个抽象层次就非常高了。所以在接口定义过程中，我们要先找到相似物体之间的一个层次，在这个层次上对它们进行抽象。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.cnblogs.com/leoo2sk/archive/2008/04/10/1146447.html">面向接口编程详解（一）——思想基础</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>拷贝与移动</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E6%8B%B7%E8%B4%9D%E4%B8%8E%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>拷贝：创造新对象</p>
<p>移动：移动旧对象</p>
</blockquote>
<a id="more"></a>
<p>在C++中，当我们处理对象时，经常会遇到拷贝或移动的场景，本文将针对拷贝与移动进行相关总结。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>指针就像陷阱，你得主动跳进去</p>
</blockquote>
<a id="more"></a>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>由于指针的位数相同，在64位机器下均为8 byte，所以转换后的指针的值也是相同的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>];              <span class="comment">// a: 0x7ffc2a11b080</span></span><br><span class="line"><span class="keyword">char</span> *c = (<span class="keyword">char</span> *) a;  <span class="comment">// c: 0x7ffc2a11b080</span></span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，不同类型的指针做偏移运算时，偏移的大小是不同的，一个int指针的偏移量为4byte，但是一个char指针偏移量为1byte。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *d = a;</span><br><span class="line"></span><br><span class="line">// d+1 = 0x7ffc2a11b080+0x4 = 0x7ffc2a11b084</span><br><span class="line">// c+1 = 0x7ffc2a11b080+0x1 = 0x7ffc2a11b081</span><br></pre></td></tr></table></figure>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><h5 id="指针不能想加，但能相减"><a href="#指针不能想加，但能相减" class="headerlink" title="指针不能想加，但能相减"></a>指针不能想加，但能相减</h5><p>两个指针相加是没有任何意义的，一个指针和一个偏移量相加，可以代表将这个指针偏移某个位置，但是两个指针相加能代表什么呢？nothing。但是<strong>两个指针相减是有意义的</strong>，代表两个指针之间的距离，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;b;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> distance = p1 - p2;</span><br></pre></td></tr></table></figure>
<p>如果打印的distace值为5，代表p1和p2之间间隔着能够容纳5个int的空间，我们可以借此得到两个指针中间的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mid = (low+high)/<span class="number">2</span>;     <span class="comment">//Error</span></span><br><span class="line">mid = low+(high-low)/<span class="number">2</span>  <span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，指针相减必须是相同类型的。</p>
<h2 id="地址表示"><a href="#地址表示" class="headerlink" title="地址表示"></a>地址表示</h2><p>在64位的PC上，指针所占的长度为8个字节，但是如果实际打印会发现输出只有6个字节，这是因为6字节寻址范围已经非常大了，基本上没有什么软件能够使用6个字节寻址的空间。</p>
<h2 id="不同类型在内存中的表示"><a href="#不同类型在内存中的表示" class="headerlink" title="不同类型在内存中的表示"></a>不同类型在内存中的表示</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>整型的表示方式为：先计算整型的补码，然后按照低地址放低位，高地址放高位的方式，将整型进行存储，以int类型为例，该类型占据4个byte。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>有一段代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">&gt; <span class="keyword">int</span> *c = a;</span><br><span class="line">&gt; a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">300</span>, a[<span class="number">2</span>] = <span class="number">301</span>, a[<span class="number">3</span>] = <span class="number">302</span>;</span><br><span class="line">&gt; c = c + <span class="number">1</span>;</span><br><span class="line">&gt; *c = <span class="number">400</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; c = (<span class="keyword">int</span> *)(((<span class="keyword">char</span> *) a) + <span class="number">1</span> );</span><br><span class="line">&gt; *c = <span class="number">500</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>请问上述代码执行完后，a[0]~a[3]的值各为多少？</p>
</blockquote>
<p>这里实际考察了不同类型指针的计算以及整数在内存中的存储，首先，<code>c=c+1</code>执行完后，指针向后偏移一个int类型的大小，那么此时c指向a[1]，<code>*c=400</code>即<code>a[1] = 400</code>，现在a[0]~a[3]的值为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">400</span>, a[<span class="number">2</span>] = <span class="number">301</span>, a[<span class="number">3</span>] = <span class="number">302</span>;</span><br></pre></td></tr></table></figure>
<p>而下一句语句执行了指针类型转换，将int类型转换为了char类型，char类型指针+1向后偏移一个char类型的大小，即1byte，此时需要将内存画出具体进行判断。过程如下：</p>
<ul>
<li>(200)DEC = (11001000)BIN，所以200在a[0]中排布如下，(400)DEC=(000110010000)BIN同理</li>
<li>c在转换成为char *类型后，+1偏移1byte，指向内存序号5所在的byte</li>
<li>随即c又被转换为int类型，那么现在c指向的就是从5开始到8结束这4byte，对其赋值会导致5~8所在内存被覆盖掉</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> *c = a;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">300</span>, a[<span class="number">2</span>] = <span class="number">301</span>, a[<span class="number">3</span>] = <span class="number">302</span>;</span><br><span class="line">c = c + <span class="number">1</span>;</span><br><span class="line">*c = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">c = (<span class="keyword">int</span> *)(((<span class="keyword">char</span> *) a) + <span class="number">1</span> );</span><br><span class="line"><span class="comment">/***************************************************************************************</span></span><br><span class="line"><span class="comment">                                                  c'--------&gt;c      </span></span><br><span class="line"><span class="comment">     0           1          2         3           4          5          6          7</span></span><br><span class="line"><span class="comment">+----------+----------+----------+----------+----------+----------+----------+----------+</span></span><br><span class="line"><span class="comment">|1100 1000 | 00000000 | 00000000 | 00000000 | 10010000 | 00000001 | 00000000 | 00000000 |</span></span><br><span class="line"><span class="comment">+----------+----------+----------+----------+----------+----------+----------+----------+</span></span><br><span class="line"><span class="comment">                     a[0]                                        a[1]</span></span><br><span class="line"><span class="comment">                     </span></span><br><span class="line"><span class="comment">     8           9         10         11          12         13         14         15</span></span><br><span class="line"><span class="comment">+----------+----------+----------+----------+----------+----------+----------+----------+</span></span><br><span class="line"><span class="comment">|          |          |          |          |          |          |          |          |</span></span><br><span class="line"><span class="comment">+----------+----------+----------+----------+----------+----------+----------+----------+</span></span><br><span class="line"><span class="comment">                     a[2]                                        a[3]</span></span><br><span class="line"><span class="comment">*****************************************************************************************/</span></span><br><span class="line"></span><br><span class="line">*c = <span class="number">500</span>;</span><br><span class="line"><span class="comment">/***************************************************************************************</span></span><br><span class="line"><span class="comment">                                                             c      </span></span><br><span class="line"><span class="comment">     0           1          2         3           4          5          6          7</span></span><br><span class="line"><span class="comment">+----------+----------+----------+----------+----------+----------+----------+----------+</span></span><br><span class="line"><span class="comment">|1100 1000 | 00000000 | 00000000 | 00000000 | 10010000 | 11110100 | 00000001 | 00000000 |</span></span><br><span class="line"><span class="comment">+----------+----------+----------+----------+----------+----------+----------+----------+</span></span><br><span class="line"><span class="comment">                     a[0]                                        a[1]</span></span><br><span class="line"><span class="comment">                     </span></span><br><span class="line"><span class="comment">     8           9         10         11          12         13         14         15</span></span><br><span class="line"><span class="comment">+----------+----------+----------+----------+----------+----------+----------+----------+</span></span><br><span class="line"><span class="comment">| 00000000 |          |          |          |          |          |          |          |</span></span><br><span class="line"><span class="comment">+----------+----------+----------+----------+----------+----------+----------+----------+</span></span><br><span class="line"><span class="comment">                     a[2]                                        a[3]</span></span><br><span class="line"><span class="comment">*****************************************************************************************/</span></span><br></pre></td></tr></table></figure>
<p>从上面的分析过程可以看出，最终，<code>*c = 500;</code>会使5~8的内存被修改，而此时计算a[1]得到的结果即为128144：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(00000000 00000001 11110100 10010000)BIN = (128144)DEC</span><br></pre></td></tr></table></figure>
<p>这个例子告诉我们，尽量不要进行指针类型转换，如果转换，也要尽可能保证转换的指针所指向的类型占用空间一致。否则可能会出现非常奇怪的问题。</p>
<h2 id="指针使用Checklist"><a href="#指针使用Checklist" class="headerlink" title="指针使用Checklist"></a>指针使用Checklist</h2><ul>
<li>[ ] 检查指针是否为空：为空一般说明内存分配不正确</li>
<li>[ ] 检查指针是否指向明确地址空间：是否在该用指针的场合错误使用了对象</li>
<li>[ ] 检查是否需要对指针解引用：该用对象的场合错误使用了指针</li>
</ul>
<h2 id="如何正确理解指针"><a href="#如何正确理解指针" class="headerlink" title="如何正确理解指针"></a>如何正确理解指针</h2><p>指针是非常难以驾驭的存在，即使是有经验的程序员，也会陷入指针的陷阱当中，所以我们不妨在这里做一个抽象：</p>
<ul>
<li><p>指针本身是一张表，用于分配空间，我们说指针的时候，实际上是在讨论这段空间</p>
</li>
<li><p>指针内容是这张表中的具体项目，我们使用指针解引用后的对象，就是在使用这个具体的项目</p>
</li>
</ul>
<p>在使用指针过程中，一定要注意，是在处理空间，还是在处理对象。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c">一个关于指针实验的代码</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>那时我还年轻，没有意识到这个世界到底有多么深刻而复杂。</p>
</blockquote>
<a id="more"></a>
<p>模板，可以理解为函数的函数，或类的类，当你学习过时变泛函这门课程之时，将会对模板有更为深入的理解。</p>
<h2 id="模板基本语法总结"><a href="#模板基本语法总结" class="headerlink" title="模板基本语法总结"></a>模板基本语法总结</h2><h3 id="模板定义及嵌套模板"><a href="#模板定义及嵌套模板" class="headerlink" title="模板定义及嵌套模板"></a>模板定义及嵌套模板</h3><p>模板的定义以关键字<code>template</code>开始，后面跟一个模板参数列表，其实和函数列表差不多，也可以有默认的模板类型参数（C++11新增功能）。需要注意的是，如果有嵌套的模板参数列表，那么都需要添加<code>typename</code>关键字，因为如果把模板列表视为一个函数参数列表，那么这个参数列表中应该只是代表抽象的参数类型，而非具体的某个值，所以都要添加<code>typename</code>表示抽象的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">vector</span>&lt;T&gt;,      // 默认模板参数为<span class="title">vector</span>&lt;T&gt;类型</span></span><br><span class="line"><span class="class">         <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;typename Sequence::value_type&gt;&gt;   // 默认模板参数为<span class="title">Sequence</span>:</span>:value_type，必须加<span class="keyword">typename</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">priority_queue</span>&#123;</span>...&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面这个代码中，有一点很令人困惑，即<code>less&lt;typename Sequence::value_type&gt;&gt;</code>，为什么要加<code>typename</code>呢？不加可以吗？答案是不行，这里的一个原因是C++的编译器无法区分<code>Sequence::value_type</code>到底是一个类型，还是Sequence下的一个成员变量。实际上，<code>Sequence::value_type</code>是一个嵌套从属类型（从属于模板参数Sequence），为了消除二义性，我们必须明确告知编译器，这是一个模板类型，所以需要添加typename。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://github.com/wuye9036/CppTemplateTutorial">C++模板</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>谁开发谁保护，谁污染谁治理——C++县政府宣</p>
</blockquote>
<a id="more"></a>
<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p>在了解智能指针之前，先明确C++几种内存管理的形式：</p>
<ul>
<li>静态内存：用于保存局部static对象、类static数据成员及全局变量（使用前存在，程序结束时销毁）</li>
<li>栈内存：用于保存局部非static对象（程序块运行时存在）</li>
<li>动态内存：通过指针及new与delete管理的对象，位于堆上</li>
</ul>
<h3 id="动态内存隐患"><a href="#动态内存隐患" class="headerlink" title="动态内存隐患"></a>动态内存隐患</h3><p>由于通过动态内存获得的对象生命周期与创建位置无关，需要显式释放，因此使用new和delete进行动态内存存在下列两个隐患：</p>
<ul>
<li>内存泄漏：忘记释放内存</li>
<li>野指针：尚有指针指向内存时，就释放了该内存，指针指向已经删除的对象或访问受限的内存区域的指针</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>为了克服手动进行动态内存管理的弊端，我们引入了只能指针的概念，对动态内存进行自动管理，智能指针模板定义在memory头文件中。智能指针实际上是将普通指针封装成了栈对象。</p>
<h3 id="智能指针的种类"><a href="#智能指针的种类" class="headerlink" title="智能指针的种类"></a>智能指针的种类</h3><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>共享智能指针，多个智能指针指向相同对象，通过计数器实现记录指针的数目，一旦一个shared_ptr计数器变为0，自动释放该对象。</p>
<h5 id="使用make-shared函数进行动态内存分配"><a href="#使用make-shared函数进行动态内存分配" class="headerlink" title="使用make_shared函数进行动态内存分配"></a>使用make_shared函数进行动态内存分配</h5><p>该函数是一个模板函数，返回一个shared_ptr指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">45</span>);  <span class="comment">//p1-&gt;int(45)</span></span><br><span class="line"><span class="keyword">auto</span> p2 = p1;</span><br></pre></td></tr></table></figure>
<pre class="mermaid">graph LR
    node((p1))
    node1((p2))
    node2[45]
    node-->node2
    node1-->node2</pre>

<p>下面的代码解释了shared_ptr自动管理内存的原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">45</span>);</span><br><span class="line">r = q;            <span class="comment">//给r赋值令其指向另一个地址</span></span><br><span class="line">                  <span class="comment">//递增q指向对象的引用计数器</span></span><br><span class="line">                  <span class="comment">//递减r指向对象的引用计数器</span></span><br><span class="line">                  <span class="comment">//r计数器清0,销毁r原先指向的对象</span></span><br></pre></td></tr></table></figure>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>不支持强拷贝与赋值，但一个unique_ptr如果快要被销毁了（临时右值），那么可以进行拷贝。</p>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><h5 id="智能指针的潜在风险"><a href="#智能指针的潜在风险" class="headerlink" title="智能指针的潜在风险"></a>智能指针的潜在风险</h5><p>在讲解weak_ptr时，我们先看一下只能指针的潜在风险：当shared_ptr相互引用时，导致计数器永远无法清空，从而死锁，造成内存泄漏。</p>
<h5 id="weak-ptr的作用"><a href="#weak-ptr的作用" class="headerlink" title="weak_ptr的作用"></a>weak_ptr的作用</h5><p>与shared_ptr配合使用，不改变引用计数器，当最后一个shared_ptr指针被释放，即使仍有weak_ptr，对象依然被销毁。所以该指针只是提供了一种访问对象的手段。weak_ptr可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="">C++ primer</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>一些C++测试框架使用说明</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对谷歌测试框架以及Qt测试框架的使用方法进行总结。</p>
<a id="more"></a>
<h2 id="google框架1"><a href="#google框架1" class="headerlink" title="google框架1"></a>google框架<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><h3 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h3><h4 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="编写测试函数"><a href="#编写测试函数" class="headerlink" title="编写测试函数"></a>编写测试函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * TEST(TLENodeTest, TLENodeCheckFileIsValid) -- Test module of TLENode      *</span></span><br><span class="line"><span class="comment"> *                                                                           *</span></span><br><span class="line"><span class="comment"> *    This function is the test module of the TLENode which varifies whether *</span></span><br><span class="line"><span class="comment"> *    the TLE file is valid or not.                                          *</span></span><br><span class="line"><span class="comment"> *                                                                           *</span></span><br><span class="line"><span class="comment"> * INPUT:      The first parameter is the info of the                        *</span></span><br><span class="line"><span class="comment"> *             Test, and the second is the function of the test              *</span></span><br><span class="line"><span class="comment"> *                                                                           *</span></span><br><span class="line"><span class="comment"> * OUTPUT:     none                                                          *</span></span><br><span class="line"><span class="comment"> *                                                                           *</span></span><br><span class="line"><span class="comment"> * WARNINGS:   none                                                          *</span></span><br><span class="line"><span class="comment"> *                                                                           *</span></span><br><span class="line"><span class="comment"> * REMARKS:    none                                                          *</span></span><br><span class="line"><span class="comment"> *                                                                           *</span></span><br><span class="line"><span class="comment"> * HISTORY:                                                                  *</span></span><br><span class="line"><span class="comment"> *   2020-06-14 DSQ : Created.                                               *</span></span><br><span class="line"><span class="comment"> *===========================================================================*/</span></span><br><span class="line"></span><br><span class="line">TEST(TLENodeTest, TLENodeCheckFileIsValid)&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    EXPECT_EQ(<span class="number">0</span>, i);              <span class="comment">//This will test whether i == 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在主函数中启动测试"><a href="#在主函数中启动测试" class="headerlink" title="在主函数中启动测试"></a>在主函数中启动测试</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    testing::InitGoogleTest(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和CMake进行结合"><a href="#和CMake进行结合" class="headerlink" title="和CMake进行结合"></a>和CMake进行结合</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(test_QNPSapp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">find_package</span>(GTest REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;GTEST_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#  Add the executable test files</span></span><br><span class="line"><span class="comment">#--------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">TEST</span> test_TLENode.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="keyword">TEST</span> <span class="variable">$&#123;GTEST_LIBRARIES&#125;</span> pthread)</span><br><span class="line"><span class="keyword">add_test</span>(AllTests <span class="keyword">test</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h3><p>最好一个模块建立一个测试工程</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://raymii.org/s/tutorials/Cpp_project_setup_with_cmake_and_unit_tests.html">C++ project setup with CMake &amp; unit tests (google test) - Raymii.org</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>类</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>God said, Let there be light: and there was light.</p>
</blockquote>
<a id="more"></a>
<p>作为一门面向对象语言，C++允许我们使用类进行自定义类型，本文将针对类中的一些问题进行相关总结。</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>封装是面向对象的一个重要特点，它对外部函数或对象访问类内部的成员的过程进行限制。C++提供了三种访问修饰符，分别是public，protected和private，本节将对这三种修饰符进行总结。</p>
<h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>保密性最低，可以直接通过对象引用的方式访问，一般来说对外暴露的接口定义为<code>public</code>。</p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>保密性最高，私有成员变量或函数在类外不可访问，甚至不能查看，<strong>只有类和友元函数能访问私有成员</strong>。在实际编程中，能使用<code>private</code>，就使用<code>private</code>。</p>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>protected一般用在继承当中，它和private很相似，protected成员变量或函数在类外不能被访问，<strong>但是在派生类（子类）中是可以访问的</strong>。在继承中，如果需要子类访问基类的数据和函数，而外部成员不需要访问，那么可以将这些数据定义为protected。</p>
<h3 id="继承中的特点"><a href="#继承中的特点" class="headerlink" title="继承中的特点"></a>继承中的特点</h3><p>在继承中有三种继承的方式，这里我们总结一下不同的访问修饰符在继承下的基类成员访问属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">继承方式</th>
<th style="text-align:center">基类成员</th>
<th style="text-align:center">在子类中的访问属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">public</td>
<td style="text-align:center">public（子类可访问，外部可访问）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">protected</td>
<td style="text-align:center">protected（子类可访问，外部不能访问）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">private</td>
<td style="text-align:center">private（子类不能访问）</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">public</td>
<td style="text-align:center">protected（子类可访问，外部不能）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">protected</td>
<td style="text-align:center">protected（子类可访问，外部不能）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">private</td>
<td style="text-align:center">private（子类不能访问，外部不能）</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">public</td>
<td style="text-align:center">private (子类可以访问，对外为private)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">protected</td>
<td style="text-align:center">private（子类可以访问，对外为private）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">private</td>
<td style="text-align:center">private（子类不可访问）</td>
</tr>
</tbody>
</table>
</div>
<p>无论哪种继承，有两点没有变化</p>
<ul>
<li>private只能由本类或有源访问，子类也不能访问</li>
<li>protected成员可以被子类访问</li>
</ul>
<p>这里其实挺迷惑的，从逻辑上讲，子类是包含在基类当中的，理应具有并且能够访问基类的所有属性，但是事实上，子类也可以视为基类的使用者，也是基类的客户代码，如果基类的方法是private，但是子类可以访问，那么完全可能发生下面的事情：我创建了一个子类，然后继承这个基类，这样我就可以访问基类中的private方法，其实这样就严重破坏了数据封装性的原则。</p>
<h2 id="静态类成员"><a href="#静态类成员" class="headerlink" title="静态类成员"></a>静态类成员</h2><p>有些情况下，某个数据成员应当属于类而非具体对象本身。例如我们说正常人都有两只眼睛，那么眼睛的数量应当是与人直接相关而非与特定个体相关。当我们更改了眼睛的数量，应当所有的个体眼睛数量都会被修改。那么此时我们需要定义类的静态成员，它属于类本身，而非某个个体。</p>
<h3 id="声明及定义静态类成员"><a href="#声明及定义静态类成员" class="headerlink" title="声明及定义静态类成员"></a>声明及定义静态类成员</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> s_eye_num;     <span class="comment">//前面加上static即可，注意，此处只是声明，我们还未定义，不能直接使用，必须进行定义及初始化操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>通常情况下，我们将静态变量定义放在类外的cpp文件中进行定义，切记不要再头文件中对静态变量进行初始化。如果放在.h文件中，每一个包含该头文件的文件都会去重复定义类的静态变量，从而产生链接错误。<strong>正确的做法是对所有的类静态成员在类的实现cpp文件中进行统一定义及初始化管理。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Human::s_eye_num = <span class="number">0</span>;      <span class="comment">//定义及初始化，只能进行一次</span></span><br></pre></td></tr></table></figure>
<h3 id="访问控制-1"><a href="#访问控制-1" class="headerlink" title="访问控制"></a>访问控制</h3><p>静态类成员可以设置为public或private的，当设置为public时，可以通过作用域方式访问，即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Human duanshiqi;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Human::s_eye_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; duanshiqi.s_eye_num &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//正确！属于类的肯定也是属于每一个对象的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而私有时则必须通过相应的get函数进行访问。</p>
<h2 id="类在内存中的分布"><a href="#类在内存中的分布" class="headerlink" title="类在内存中的分布"></a>类在内存中的分布</h2><p>在内存中，类从高字节向低字节增长，例如我们给定下面一个类：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>那么这个类在内存中的分布即为，与类定义正好相反：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/trapframelayout.svg" width = "380" alt="图片名称" align=center /></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>类型</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对C++中常见类型及其特点和应用场景进行总结。</p>
<a id="more"></a>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是C/C++中非常常见的一种类型，这里总结一些常见的比较容易出错的数组相关知识。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="一种不太常见的初始化方式"><a href="#一种不太常见的初始化方式" class="headerlink" title="一种不太常见的初始化方式"></a>一种不太常见的初始化方式</h4><p>在阅读xv6操作系统源码时，看到了这样一种数组初始化方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> error_string[MAXERROR] = &#123;</span><br><span class="line">    [E_UNSPECIFIED] = <span class="string">"unspecified error"</span>,</span><br><span class="line">    [E_BAD_ENV] = <span class="string">"bad environment"</span>,</span><br><span class="line">    ...</span><br><span class="line">    [E_FAULT] = <span class="string">"segmentation fault"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>里面的大写都是宏定义，即具体的数字，实际跑了一下，发现可以部分初始化，而且最后加不加逗号均可以编译通过，这里进行一下记录。</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型属于字面值常量，它使我们可以将一组整型常量组织在一起，C++11后，我们有了两种枚举类型：限定作用域与不限定作用域的枚举类型</p>
<h3 id="限定与不限定作用域的枚举类型"><a href="#限定与不限定作用域的枚举类型" class="headerlink" title="限定与不限定作用域的枚举类型"></a>限定与不限定作用域的枚举类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123;red, yellow, green&#125;;   <span class="comment">//不限定作用域</span></span><br><span class="line"><span class="keyword">enum</span> stoplight &#123;red, yellow, green&#125;; <span class="comment">//错误，重复定义枚举成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">peppers</span> &#123;</span>red, yellow, green&#125;; <span class="comment">//正确，限定作用域，枚举成员被隐藏</span></span><br><span class="line"></span><br><span class="line">color hair = red; <span class="comment">//正确，使用不限定作用域的枚举成员</span></span><br><span class="line">peppers p2 = peppers::red; <span class="comment">//正确，使用限定作用域的枚举成员</span></span><br></pre></td></tr></table></figure>
<h3 id="枚举的应用场景"><a href="#枚举的应用场景" class="headerlink" title="枚举的应用场景"></a>枚举的应用场景</h3><p>在使用常量的场合，我们可以广泛使用枚举类型，例如我们要去造一辆小汽车，这个汽车可以向前后左右四个方向行驶，那么我们可以定义如下枚举体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Movement &#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">    Forward,</span><br><span class="line">    Backward</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="一些特殊的类型"><a href="#一些特殊的类型" class="headerlink" title="一些特殊的类型"></a>一些特殊的类型</h2><h3 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h3><p>在很多代码中我们都见过size_t这个类型，它被定义为”某个对象的大小（单位byte）”，同时，这个类型也是sizeof 操作符的返回类型。这个类型可以保证容纳系统能够处理的最大对象的size值，如果系统是32位，那么size_t为<code>typedef size_t unsigned int</code>，而如果是64位，则为unsigned long long。需要注意的是size_t永远为正。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Here argument of 'n' refers to maximum blocks that can be </span></span><br><span class="line"><span class="comment">// allocated which is guaranteed to be non-negative. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// While copying 'n' bytes from 's2' to 's1' </span></span><br><span class="line"><span class="comment">// n must be non-negative integer. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">size_t</span> n)</span></span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// strlen() uses size_t because the length of any string </span></span><br><span class="line"><span class="comment">// will always be at least 0. </span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>凡是涉及到类型大小的，尽量使用size_t</p>
<h2 id="类型处理"><a href="#类型处理" class="headerlink" title="类型处理"></a>类型处理</h2><h3 id="定义类型别名（typedef）"><a href="#定义类型别名（typedef）" class="headerlink" title="定义类型别名（typedef）"></a>定义类型别名（typedef）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="comment">// typedef 原在前，新在后，和define正好相反</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;        <span class="comment">// wages 是 double同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages  base, *p;     <span class="comment">// base是double同义词，p是double* 同义词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">uint32_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>
<h4 id="一些比较复杂的typedef理解"><a href="#一些比较复杂的typedef理解" class="headerlink" title="一些比较复杂的typedef理解"></a>一些比较复杂的typedef理解</h4><p>1 定义函数指针</p>
<p>有时候我们会看到这样的typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef  返回类型 (*新类型) (参数表)</span></span><br></pre></td></tr></table></figure>
<p>实际上是给函数指针起了一个别名，首先，我们先来看一下：<code>void (*new_handler)();</code>，这个语句定义了一个函数指针，其返回类型为void，参数为void，函数名为new_handler。使用typedef可以令函数指针的使用更直观，此时我们可以直接使用<code>new_handler</code>定义一个函数指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//定义了一个函数，其返回值为new_handler类型，即函数指针，输入参数也是一个函数指针</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++提供了四种强制类型转换</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>CMake基本语句</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/CMake/CMake%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<ol>
<li>Declare a target</li>
<li>Declare target’s traits</li>
<li>It’s all about targets</li>
</ol>
</blockquote>
<a id="more"></a>
<h2 id="Hello-CMake"><a href="#Hello-CMake" class="headerlink" title="Hello CMake"></a>Hello CMake</h2><p>一个最简单的CMake：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set the minimum version of CMake that can be used</span></span><br><span class="line"><span class="comment"># To find the cmake version run</span></span><br><span class="line"><span class="comment"># $ cmake --version</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the project name</span></span><br><span class="line"><span class="keyword">project</span> (hello_cmake VERSION <span class="number">1.0</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add an executable file</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp)</span><br></pre></td></tr></table></figure>
<h2 id="基本语句及功能"><a href="#基本语句及功能" class="headerlink" title="基本语句及功能"></a>基本语句及功能</h2><h3 id="cmake-minimum-required"><a href="#cmake-minimum-required" class="headerlink" title="cmake_minimum_required"></a>cmake_minimum_required</h3><p>指定最小的cmake版本</p>
<h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><p>指定project的名称和版本号</p>
<h3 id="add-subdirectory"><a href="#add-subdirectory" class="headerlink" title="add_subdirectory"></a>add_subdirectory</h3><p><code>add_subdirectory(src)</code>会跳转到对应的src文件中，并寻找<code>src/CMakeLists.txt</code>，更新环境变量</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>CMake</category>
      </categories>
  </entry>
  <entry>
    <title>使用Travis CI自动管理Git库</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Git/%E4%BD%BF%E7%94%A8Travis%20CI%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86git%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有时候我们希望有一个工具能够自动帮我们管理Git库，每当有commit后，能够自动进行发布，这样可以帮助我们节约很多操作。</p>
<a id="more"></a>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="1-申请Travis-CI账号"><a href="#1-申请Travis-CI账号" class="headerlink" title="1 申请Travis CI账号"></a>1 申请Travis CI账号</h3><p>在<a href="https://travis-ci.com/">Travis CI - Test and Deploy with Confidence (travis-ci.com)</a>这个网站申请一个账号和自己的git账号关联。</p>
<h3 id="2-在Travis-CI上选择需要托管的project"><a href="#2-在Travis-CI上选择需要托管的project" class="headerlink" title="2 在Travis CI上选择需要托管的project"></a>2 在Travis CI上选择需要托管的project</h3><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201125205458.png" width = "380" alt="图片名称" align=center /></p>
<p>注册登录后，在用户中心处点击Setting，再点击” Manage repositories on GitHub”，选择待托管的库。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201125205710.png" width = "480" alt="图片名称" align=center /></p>
<h3 id="3-申请Github-Access-Token"><a href="#3-申请Github-Access-Token" class="headerlink" title="3 申请Github Access Token"></a>3 申请Github Access Token</h3><p>申请一个github access token，权限视情况而定：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201125210122.png" width = "680" alt="图片名称" align=center /></p>
<p>然后将这个token放到Travis CI需要托管的仓库中，方式如下：</p>
<p>1 点击想要托管的仓库的Settings：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201125210459.png" width = "680" alt="图片名称" align=center /></p>
<p>2 在下面的环境变量这一栏中，填写token，名称随便写，value写token，branch看你想要托管哪一个分支而定。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201125210411.png" width = "780" alt="图片名称" align=center /></p>
<h3 id="4-在project中加入Travis-CI的配置"><a href="#4-在project中加入Travis-CI的配置" class="headerlink" title="4 在project中加入Travis CI的配置"></a>4 在project中加入Travis CI的配置</h3><p>这里以我的hexo博客为例，在其根目录下添加一个<code>.travis.yml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"12"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">cl</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$github_token</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是这里要修改node js的版本为你电脑上的版本，然后 github-token也要和你设置的环境变量一致，最后script和before_script换成你需要执行的命令。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.slmt.tw/blog/2019/04/26/hexo-auto-deploy/">SLMT's Blog | 使用 Travis CI 來自動發布 Hexo Blog</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git commit规范</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Git/Git%20commit%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这里给出了一个比较合理的git规范，在commit的时候使用这个规范进行填写。关于这个规范参考下面的连接：<a href="https://thoughtbot.com/blog/5-useful-tips-for-a-better-commit-message">5 Useful Tips For A Better Commit Message</a></p>
<a id="more"></a>
<p>使用<code>git commit</code>，会打开一个文件，允许你填写更多的commit内容，请参考下面的commit样本，每次详细填写自己的commit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 50-character subject line</span><br><span class="line">#</span><br><span class="line"># 72-character wrapped longer description. This should answer:</span><br><span class="line">#</span><br><span class="line"># * Why was this change necessary?</span><br><span class="line"># * How does it address the problem?</span><br><span class="line"># * Are there any side effects?</span><br><span class="line">#</span><br><span class="line"># Include a link to the ticket, if any.</span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redirect user to the requested page after login</span><br><span class="line"></span><br><span class="line">https://trello.com/path/to/relevant/card</span><br><span class="line"></span><br><span class="line">Users were being redirected to the home page after login, which is less</span><br><span class="line">useful than redirecting to the page they had originally requested before</span><br><span class="line">being redirected to the login form.</span><br><span class="line"></span><br><span class="line">* Store requested path in a session variable</span><br><span class="line">* Redirect to the stored location after successfully logging in the user</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git常用操作</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Git/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在项目开发过程中，经常需要引入第三方库，因此需要一套合适的方法对于第三方库进行有效管理，本文将对利用git进行第三方库管理的方式进行总结。</p>
<p>本文将针对Git中常用操作进行总结</p>
<a id="more"></a>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git最常用的操作"><a href="#git最常用的操作" class="headerlink" title="git最常用的操作"></a>git最常用的操作</h3><p>我们修改文件后将文件提交至本地分支并推送到远程服务器的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "string"</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>上面的三个步骤可以简化为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -am "str"</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>push会将本地commit推送至服务器端，常用push命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h4 id="常见问题及解决"><a href="#常见问题及解决" class="headerlink" title="常见问题及解决"></a>常见问题及解决</h4><h5 id="ssh权限异常"><a href="#ssh权限异常" class="headerlink" title="ssh权限异常"></a>ssh权限异常</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh: connect to host gitlab.com port 22: Network is unreachable</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br></pre></td></tr></table></figure>
<p>有可能是又被ban了，或者代理配置不正确，这种情况下可以尝试换个网试一试。或者直接重启，目前还掌握配置代理的方法，这里挖个坑</p>
<h5 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h5><p>通过<code>git config --global http.proxy</code>命令，我们可以查询git当前使用的代理。</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>diff可以对于commits进行比较</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>使用<code>git log</code>命令可以回顾提交历史，在一个项目下我们运行<code>git log</code>命令，可以得到如下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git log</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>
<h2 id="省略文件"><a href="#省略文件" class="headerlink" title="省略文件"></a>省略文件</h2><p>有些文件是中间编译生成的，这些文件我们不需要进行跟踪，因此我们可以使用<em>.gitignore</em>文件对这些文件进行忽略，步骤如下：</p>
<ul>
<li>在仓库根目录创建<code>.gitignore</code></li>
<li>编辑文件，忽略不需要的后缀</li>
</ul>
<p>常用的省略文件可以在<a href="https://github.com/github/gitignore">GitHub - github/gitignore: A collection of useful .gitignore templates</a>这个网站上找到</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>分支</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Git/%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Listen, a tree is growing</p>
</blockquote>
<a id="more"></a>
<h2 id="分支介绍"><a href="#分支介绍" class="headerlink" title="分支介绍"></a>分支介绍</h2><h3 id="分支及其作用"><a href="#分支及其作用" class="headerlink" title="分支及其作用"></a>分支及其作用</h3><p>当我们开发主线时，如果要添加新的功能，我们一般不会直接在主线上改动，而是创建分支并修改分支，以免影响主线开发。所以分支的作用就是创建副本，使我们能够在副本上添加功能，而不影响主线。git采用指针的方式管理分支，速度非常快。</p>
<h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a           #列举出所有分支以及当前分支</span><br></pre></td></tr></table></figure>
<h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b dev /origin/dev</span><br></pre></td></tr></table></figure>
<p>这个命令做了下面两件事：</p>
<ul>
<li>创建一个名为dev的基于远程/origin/dev的本地分支</li>
<li>将当前分支切换为dev</li>
</ul>
<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>如果要切换到一个已经存在的分支，可以使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev   # 将分支切换为dev</span><br></pre></td></tr></table></figure>
<p>有些时候，我们需要切换到历史版本，也可以使用checkout，我们可以利用<code>git log</code>查看历史提交记录，然后使用<code>git checkout xxxxxxxxxxxxxx</code>的方式切换到指定版本号对应的分支，其中xxxxxxxxxxxxxx是版本号。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">commit 72df7ffjasdddf8fdfdf9ccc</span><br><span class="line"></span><br><span class="line">git checkout 72df7ffjasdddf8fdfdf9ccc</span><br></pre></td></tr></table></figure>
<p>当然，切换分支后，本地的修改会被保留，使用<code>git stash</code>可以删除这些修改（慎用！）</p>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>假设我们的当前分支为master，那么如果我们要将分支dev合并至master，可以执行下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>
<h3 id="分支删除"><a href="#分支删除" class="headerlink" title="分支删除"></a>分支删除</h3><p>删除本地和远程的分支，可以使用如下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -D branch_name       # 删除本地分支</span><br><span class="line"></span><br><span class="line">git push origin --delete new    # 删除远程分支</span><br><span class="line">FETCH_HEAD      master          origin/master</span><br><span class="line">HEAD            ORIG_HEAD       origin/new</span><br><span class="line"><span class="meta">#</span>删除后远程的分支就没有了</span><br></pre></td></tr></table></figure>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>使用分支开发过程中一个很大的问题就是解决冲突，当多个开发者试图编辑相同文件的同一行时，就可能发生冲突。Git对冲突的解决方式是：保留多个分支中的冲突的内容，然后人工进行冲突处理后再允许合并。冲突只影响合并过程。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>在下面的分支中，两个分支各自有增有减，因此需要手动合并</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  (Current change)</span><br><span class="line">    <span class="comment">// 当前分支的修改</span></span><br><span class="line">    <span class="comment">// Handle spurious interrupts</span></span><br><span class="line">    <span class="comment">// The hardware sometimes raises these because of noise on the</span></span><br><span class="line">    <span class="comment">// IRQ line or other reasons. We don't care.</span></span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) &#123;</span><br><span class="line">        cprintf(<span class="string">"Spurious interrupt on irq 7\n"</span>);</span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">=======</span><br><span class="line">    <span class="comment">// 合并入的分支的修改</span></span><br><span class="line">    <span class="comment">// Handle the trap according to the trap num</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Handle the breakpoint fault (vector 3)</span></span><br><span class="line">        <span class="keyword">case</span> T_BRKPT:</span><br><span class="line">            breakpoint_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// Handle the page fault (vector 14)</span></span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; lab3  (并入的分支)</span><br></pre></td></tr></table></figure>
<p>上半部分为当前分支中的内容，而下半部分为合并入的分支的内容</p>
<h4 id="常见的引起冲突的情况"><a href="#常见的引起冲突的情况" class="headerlink" title="常见的引起冲突的情况"></a>常见的引起冲突的情况</h4><h5 id="字符集错误"><a href="#字符集错误" class="headerlink" title="字符集错误"></a>字符集错误</h5><p>不同的编辑器使用的字符集可能不一样，例如在windows环境下的换行在linux下会显示为行尾的<code>^M</code>字符。所以如果需要多个人对同一个文件进行修改，尽可能使用相同的开发环境。针对行尾的<code>^M</code>处理方式如下：</p>
<ol>
<li><p>在linux的vim下命令格式输入：<code>:e ++ff=unix</code>，显示结尾的^M</p>
</li>
<li><p>输入<code>:%s/\r//g</code>删除</p>
</li>
</ol>
<h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><p>解决方式一般就是手工修改代码，让冲突的部分不再冲突即可。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>推送与获取</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Git/%E6%8E%A8%E9%80%81%E4%B8%8E%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>昔我往矣，杨柳依依，今我来思，雨雪霏霏</p>
</blockquote>
<a id="more"></a>
<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 推送到远程origin的new上面</span><br><span class="line">git push origin new</span><br></pre></td></tr></table></figure>
<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>获取远程代码主要有两个命令，<code>fetch</code>和<code>pull</code></p>
<h3 id="fetch-更加安全的代码"><a href="#fetch-更加安全的代码" class="headerlink" title="fetch : 更加安全的代码"></a>fetch : 更加安全的代码</h3><p>首先，我们在github网页端直接添加一个文件<code>fetch_test</code>，现在，网页端提交超前于本地分支，我们想获取远程的最新分支，可以执行fetch命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<p>例如，我们要取回<code>origin</code>主机的<code>new</code>分支，可以执行下列命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch origin new</span><br></pre></td></tr></table></figure>
<p>然后查看本地文件，我们会发现并没有新添加的<code>fetch_test</code>这个文件，说明<code>git fetch</code>并不会直接影响本地的代码仓</p>
<h3 id="merge：合并分支"><a href="#merge：合并分支" class="headerlink" title="merge：合并分支"></a>merge：合并分支</h3><p>在fetch之后，修改只是暂存起来，尚未合并到本地分支，如果要和本地某个分支合并，我们可以执行如下指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout &lt;本地分支名&gt;</span><br><span class="line">git merge origin/new # 将new分支合并到本地当前分支</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>撤销与恢复</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Git/%E6%92%A4%E9%94%80%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>给我一杯忘情水，换我一生不流泪</p>
</blockquote>
<a id="more"></a>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>有时我们进行了错误的<code>commit</code>，但是还未<code>push</code>到远程分支，可以使用<code>git reset</code>撤销commit。<code>git reset</code>命令用于回退版本或某一个特定文件，其参数如下：</p>
<ul>
<li><code>--soft</code>：回退到某个版本，只回退<code>commit</code>信息，但是</li>
<li><code>--hard</code>：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git reset --soft HEAD~1               # 回退所有内容到上一个版本  </span><br><span class="line"><span class="meta">$</span> git reset --soft HEAD~1 hello.php     # 回退 hello.php 文件的版本到上一个版本  </span><br><span class="line"><span class="meta">$</span> git reset --soft efc793226            # 回退到指定版本</span><br></pre></td></tr></table></figure>
<p>现在我们以实际的例子展示一下soft和hard的区别，假设我们有一个仓库，当前<code>commit</code>为efc793226d，然后添加了一个test.txt文件，再次<code>commit</code>，现在使用<code>git log</code>得到的版本信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git log</span><br><span class="line">commit b3a357e3bc2exxxxxxxxxxxxxxxxxxxxxxxx (HEAD -&gt; master)</span><br><span class="line">Author: sqduan &lt;xxxx.edu.cn&gt;</span><br><span class="line">Date:   Tue Aug 24 22:48:39 2021 +0800</span><br><span class="line"></span><br><span class="line">    add test1.txt</span><br><span class="line"></span><br><span class="line">commit efc793226d2e5b98b54735b70d08d37d1cd0973e</span><br><span class="line">Author: sqduan &lt;sqduan@mail.ustc.edu.cn&gt;</span><br><span class="line">Date:   Tue Aug 24 22:48:08 2021 +0800</span><br><span class="line"></span><br><span class="line">    add a readme</span><br></pre></td></tr></table></figure>
<p>假设我们不想要这次操作了，需要回退到上一个版本，如果执行软回退命令<code>git reset --soft HEAD~1</code>，那么结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git restore --staged &lt;file&gt;..." to unstage)</span><br><span class="line">        new file:   test1.txt</span><br></pre></td></tr></table></figure>
<p>可以看到我们提交的<code>commit</code>已经被撤回了，但是已经<code>add</code>的文件还在，我们可以再次进行<code>commit</code>，重新提交，得到结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git log</span><br><span class="line">commit c3a154aea8fxxxxxxxxxxxxx (HEAD -&gt; master)</span><br><span class="line">Author: sqduan &lt;sqduan@mail.ustc.edu.cn&gt;</span><br><span class="line">Date:   Tue Aug 24 22:57:53 2021 +0800</span><br><span class="line"></span><br><span class="line">    add new file</span><br><span class="line"></span><br><span class="line">commit efc793226d2e5b98b54735b70d08d37d1cd0973e</span><br><span class="line">Author: sqduan &lt;sqduan@mail.ustc.edu.cn&gt;</span><br><span class="line">Date:   Tue Aug 24 22:48:08 2021 +0800</span><br><span class="line"></span><br><span class="line">    add a readme</span><br></pre></td></tr></table></figure>
<p>现在我们进行<code>hard</code>回退，回退完后结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">asus@LAPTOP-961FE4JM MINGW64 /f/Code/Projects/GitTest (master)</span><br><span class="line"><span class="meta">$</span> git reset --hard HEAD~1</span><br><span class="line">HEAD is now at efc7932 add a readme</span><br><span class="line"></span><br><span class="line">asus@LAPTOP-961FE4JM MINGW64 /f/Code/Projects/GitTest (master)</span><br><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>可以看到此时的状态是<code>nothing to commit</code>，而查看我们的本地代码仓，发现<code>test1.txt</code>也没了，所以<code>hard</code>指令会撤销工作区中所有未提交的修改内容，并将暂存区和工作区同时回退至前面的版本，删除信息提交。<strong>这个命令很危险，谨慎使用</strong>。</p>
<h2 id="恢复操作"><a href="#恢复操作" class="headerlink" title="恢复操作"></a>恢复操作</h2><h3 id="版本恢复"><a href="#版本恢复" class="headerlink" title="版本恢复"></a>版本恢复</h3><p>以上面的版本回退过程为例，假如我们执行了<code>git reset --hard HEAD~1</code>回到了以前的分支，而现在需要恢复到现在的分支，同样地，我们可以使用<code>reset</code>进行操作，首先我们需要查看对应的操作记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们的操作记录如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git reflog</span><br><span class="line">efc7932 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD~1</span><br><span class="line">c3a154a HEAD@&#123;1&#125;: commit: add new file</span><br><span class="line">efc7932 (HEAD -&gt; master) HEAD@&#123;2&#125;: reset: moving to HEAD~1</span><br><span class="line">b3a357e HEAD@&#123;3&#125;: commit: add test1.txt</span><br><span class="line">efc7932 (HEAD -&gt; master) HEAD@&#123;4&#125;: commit (initial): add a readme</span><br></pre></td></tr></table></figure>
<p><code>reflog</code>不是记录<code>commit</code>号，而是记录了几乎所有的操作，因此我们可以很方便地进行回退，我们需要回到最后一次<code>reset</code>之前的<code>commit</code>，即<code>HEAD@{1}</code>，那么只需要<code>reset</code>到对应的<code>commit</code>号即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset c3a154a</span><br></pre></td></tr></table></figure>
<p>回退之后再看一下<code>git status</code>，发现虽然<code>commit</code>回退了，但是我们的本地文件并没有恢复，而且这个删掉的文件也作为了一个需要提交的修改，这也说明使用<code>--hard</code>是非常危险的，即使<code>commit</code>能回退，工作区中的内容也无法恢复。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add/rm &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        deleted:    test1.txt</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo绘图教程</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E7%BB%98%E5%9B%BE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文针对Hexo的Markdown写作中绘图教程进行讲解</p>
<a id="more"></a>
<h2 id="PlantUML绘图"><a href="#PlantUML绘图" class="headerlink" title="PlantUML绘图"></a>PlantUML绘图</h2><h3 id="介绍及安装"><a href="#介绍及安装" class="headerlink" title="介绍及安装"></a>介绍及安装</h3><p>PlantUML是一个脚本画图语言，能够快速生成各种UML及非UML图，比较好用，一个简单的实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% plantuml %&#125;    </span><br><span class="line">    Bob-&gt;Alice : hello</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img  src=http://www.plantuml.com/plantuml/svg/Kr1Gu7BAJzArSyp9J4vLi5B8ICt9oGS0>
<p>缺点是没办法在markdown中实时显示，但是可以在<a href="https://plantuml.com/zh/">官网</a>上进行绘制，然后将代码拷贝回来。安装方式也比较简单，执行下面语句即可</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-tag</span><span class="literal">-plantuml</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>
<h3 id="绘制类图"><a href="#绘制类图" class="headerlink" title="绘制类图"></a>绘制类图</h3><p>使用PlantUML进行类图绘制的教程：<a href="https://plantuml.com/zh/class-diagram#9dd2a6eca0c2a0e7">类图绘制</a>，常见的六种类间关系（泛化、实现、聚合、组合、关联、依赖）图及代码如下：</p>
<img  src=http://www.plantuml.com/plantuml/svg/Kr1GKE3YSauiKh2fqTKD3WtZ2alDo4pEIGNozVGKW19SpZc9nSKA-Rgw2i4bfIcfUILS7gMvYNaAMa0HZzJ48XWVoFLq0Mf8uNBAp0Rg1sg7QG00>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% plantuml %&#125;    </span><br><span class="line"></span><br><span class="line">Car &lt;|--SUV             //泛化</span><br><span class="line">Vehicle &lt;|.. Car        //实现</span><br><span class="line">Class o-- Student       //聚合</span><br><span class="line">Human *-- Heart         //组合</span><br><span class="line">Human -- IDCard         //关联</span><br><span class="line">Bike &lt;.. Student        //依赖</span><br><span class="line"></span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>SVG指可缩放向量图，是一种不失真的网页图片，建议以后都使用SVG进行绘图，在Hexo中嵌入SVG的方式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"40"</span> <span class="attr">stroke</span>=<span class="string">"green"</span> <span class="attr">stroke-width</span>=<span class="string">"4"</span> <span class="attr">fill</span>=<span class="string">"yellow"</span> /&gt;</span></span><br><span class="line">   Sorry, your browser does not support inline SVG.</span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下图所示：</p>
<div style="text-align:center;">
<svg width="100" height="100">
   <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
   Sorry, your browser does not support inline SVG.
</svg> 
</div>
也可以将svg传到图床上，然后用图片的形式添加

<img src="https://raw.githubusercontent.com/sqduan/hexoimg/c4812a90dbb8ac08e6f639bacdc2f96230f1570f/%E7%BB%98%E5%9B%BE1.svg" width = "370" alt="" align=center />

### 属性

**`width`**：宽度





## 参考文献



<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.w3schools.com/graphics/svg_examples.asp">一些SVG实例</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>第三方库管理</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Git/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在项目开发过程中，经常需要引入第三方库，因此需要一套合适的方法对于第三方库进行有效管理，本文将对利用git进行第三方库管理的方式进行总结。</p>
<a id="more"></a>
<h2 id="子模块添加"><a href="#子模块添加" class="headerlink" title="子模块添加"></a>子模块添加</h2><p>一般会在自己的工程目录下建立一个third_party目录，专门进行第三方库的管理，进入third_party，通过<code>git submodule add</code>命令对第三方库进行添加，例如我想添加一个名为rack的库，相应命令为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git submodule add git://github.com/chneukirchen/rack.git rack</span><br></pre></td></tr></table></figure></p>
<p>那么在/third_party/rack下就有了rack项目。</p>
<h2 id="子模块删除"><a href="#子模块删除" class="headerlink" title="子模块删除"></a>子模块删除</h2><p>当我们弃用某一个库时，可以在当前项目目录下执行如下操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule deinit -f -- third_party/submodule_name</span><br><span class="line">rm -rf .git/modules/third_party/submodule_name</span><br><span class="line">git rm -f third_party/submodule_name</span><br></pre></td></tr></table></figure></p>
<h2 id="Clone包含子模块的库"><a href="#Clone包含子模块的库" class="headerlink" title="Clone包含子模块的库"></a>Clone包含子模块的库</h2><p>当我们克隆一个含有子模块的项目时，默认会包含该子模块目录，但是其中没有任何文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/chaconinc/MainProject</span><br><span class="line">Cloning into 'MainProject'...</span><br><span class="line">remote: Counting objects: 14, done.</span><br><span class="line">remote: Compressing objects: 100% (13/13), done.</span><br><span class="line">remote: Total 14 (delta 1), reused 13 (delta 0)</span><br><span class="line">Unpacking objects: 100% (14/14), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> cd MainProject</span><br><span class="line"><span class="meta">$</span> ls -la</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .</span><br><span class="line">drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..</span><br><span class="line">drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git</span><br><span class="line">-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules</span><br><span class="line">drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector</span><br><span class="line">-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile</span><br><span class="line">drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src</span><br><span class="line"><span class="meta">$</span> cd DbConnector/</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<p>其中，DbConnector是子模块目录，但是为空，我们要运行两个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git submodule init</span><br><span class="line"><span class="meta">$</span> git submodule update</span><br></pre></td></tr></table></figure>
<p>或者在运行clone时加入如下后缀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --recurse-submodules https://github.com/chaconinc/MainProject</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">git官方关于子模块管理的教程</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown常用写作语法及功能</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E5%B8%B8%E7%94%A8%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文针对Hexo中常用写作的功能及语法进行总结。</p>
<a id="more"></a>
<h2 id="站内引用"><a href="#站内引用" class="headerlink" title="站内引用"></a>站内引用</h2><p><a id="站内引用"/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125;</span><br></pre></td></tr></table></figure>
<p>举例，引用继承.md，<strong>注意，这里必须填写完整的相对路径，否则找不到文件，同时，文件名不可以加后缀，否则还是找不到</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 工具/C++/继承 C++关于继承的讲解 %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% fold 点击显/隐内容 %&#125;</span><br><span class="line">something you want to fold, include code block.</span><br><span class="line">&#123;% endfold %&#125;</span><br></pre></td></tr></table></figure>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">something you want to fold, include code block.</span><br></pre></td></tr></table></figure>

</div></div>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-09%20213937.jpg&quot; width = &quot;300&quot; height = &quot;200&quot; alt=&quot;图片名称&quot; align=center /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="章节跳转"><a href="#章节跳转" class="headerlink" title="章节跳转"></a>章节跳转</h2><p>如果想在文章内直接跳转，可以现在被跳转的地方设置锚点，然后在想要跳转的地方添加参考。具体操作如下，我们已经在文章中站内引用章节设置了一个锚点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"站内引用"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在想跳转，那么在想跳转的地方输入如下代码:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#站内引用"</span>&gt;</span>`点这里从头再读一遍`<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即可实现章节跳转功能，<a href="#站内引用">点击阅读本文“站内引用章节”</a></p>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>在source文件夹下建立一个目录，专门用于存放下载的文件，例如</p>
<p><code>./source/downloads/</code></p>
<p>然后写一个链接<code>[Download text file!](/downloads/text.txt)</code>，或者</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"window.open('/downloads/text.txt')"</span>&gt;</span>Download<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<button onclick="window.open('/downloads/text.txt')">Download</button>

<h2 id="字体2"><a href="#字体2" class="headerlink" title="字体2"></a>字体<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h2><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>  <table><tr><td bgcolor=#2ECC71  style="vertical-align:middle; text-align:center;">Light green</td></tr></table><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#2ECC71  style=&quot;vertical-align:middle; text-align:center;&quot;&gt;Light green&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="字体、颜色及大小"><a href="#字体、颜色及大小" class="headerlink" title="字体、颜色及大小"></a>字体、颜色及大小</h3><font face="黑体">我是黑体字</font>
<font face="微软雅黑">我是微软雅黑</font>
<font face="STCAIYUN">我是华文彩云</font>
<font color=#0099ff size=7 face="黑体">color=#0099ff size=72 face="黑体"</font>
<font color=#00ffff size=72>color=#00ffff</font>
<font color=gray size=72>color=gray</font>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>我是黑体字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span>我是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span>我是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">7</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>color=#0099ff size=72 face="黑体"<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ffff</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>color=#00ffff<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>color=gray<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用mermaid进行绘图"><a href="#使用mermaid进行绘图" class="headerlink" title="使用mermaid进行绘图"></a>使用mermaid进行绘图</h2><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">T(x,c) &amp;= \Theta(x)\ \ \ \ \ \ \ \ \ \textrm&#123;for&#125;\ \ c\le2\\</span><br><span class="line">T(c,y) &amp;= \Theta(y)\ \ \ \ \ \ \ \ \ \textrm&#123;for&#125;\ \ c\le2\\</span><br><span class="line">T(x,y) &amp;=\Theta(x+y)+T(x/2,y/2)</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(x,c) &= \Theta(x)\ \ \ \ \ \ \ \ \ \textrm{for}\ \ c\le2\\
T(c,y) &= \Theta(y)\ \ \ \ \ \ \ \ \ \textrm{for}\ \ c\le2\\
T(x,y) &=\Theta(x+y)+T(x/2,y/2)
\end{aligned}
\end{equation}</script><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125; </span><br><span class="line">xxxxxxxxxxxxxxxxxxx </span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<div class="note default">
            <p>内容内容内容内容</p>
          </div>
<p>其中，class_name的值可以有如下几种：</p>
<ul>
<li>default</li>
</ul>
<div class="note default">
            <p>xxxxxxxxxxxxxxxxxxx </p>
          </div>
<ul>
<li>primary</li>
</ul>
<div class="note primary">
            <p>xxxxxxxxxxxxxxxxxxx </p>
          </div>
<ul>
<li>success</li>
</ul>
<div class="note success">
            <p>xxxxxxxxxxxxxxxxxxx </p>
          </div>
<ul>
<li>info</li>
</ul>
<div class="note info">
            <p>xxxxxxxxxxxxxxxxxxx </p>
          </div>
<ul>
<li>warning</li>
</ul>
<div class="note warning">
            <p>xxxxxxxxxxxxxxxxxxx </p>
          </div>
<ul>
<li>danger</li>
</ul>
<div class="note danger">
            <p>xxxxxxxxxxxxxxxxxxx </p>
          </div>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown 语法</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://blog.csdn.net/u010177286/article/details/50358720">markdown 字体颜色</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>公式</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Latex/%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将提供一些常用的latex公式实例</p>
<a id="more"></a>
<h2 id="单行公式"><a href="#单行公式" class="headerlink" title="单行公式"></a>单行公式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;equation&#125;</span><br><span class="line">f(x)=3x^&#123;2&#125;+6(x-2)-1</span><br><span class="line">\end&#123;equation&#125;$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{equation}
f(x)=3x^{2}+6(x-2)-1
\end{equation}</script><h2 id="多行对齐公式"><a href="#多行对齐公式" class="headerlink" title="多行对齐公式"></a>多行对齐公式</h2><p>多行公式对齐要使用<code>align</code>环境，不要使用<code>array</code>环境</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">t_L&amp;=\frac&#123;2&#125;&#123;c&#125;\left[ \left| \mathbf&#123;r&#125;_o-\mathbf&#123;R&#125;_1 \right|+\left| \mathbf&#123;R&#125;_1-\mathbf&#123;r&#125;_1 \right| \right]  \\</span><br><span class="line">t_R&amp;=\frac&#123;2&#125;&#123;c&#125;\left[ \left| \mathbf&#123;r&#125;_o-\mathbf&#123;R&#125;_2 \right|+\left| \mathbf&#123;r&#125;_1-\mathbf&#123;R&#125;_2 \right|+\left( n-1 \right) d \right]  </span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
t_L&=\frac{2}{c}\left[ \left| \mathbf{r}_o-\mathbf{R}_1 \right|+\left| \mathbf{R}_1-\mathbf{r}_1 \right| \right]  \\
t_R&=\frac{2}{c}\left[ \left| \mathbf{r}_o-\mathbf{R}_2 \right|+\left| \mathbf{r}_1-\mathbf{R}_2 \right|+\left( n-1 \right) d \right]  
\end{aligned}
\end{equation}</script><h2 id="常用命令代码"><a href="#常用命令代码" class="headerlink" title="常用命令代码"></a>常用命令代码</h2><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>\pmb</td>
<td>加粗</td>
<td>$\pmb{B}$</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>工具</category>
        <category>Latex</category>
      </categories>
  </entry>
  <entry>
    <title>Next主题配置高级教程</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Hexo/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文针对Hexo的经典主题Next进行相关高级配置的过程进行总结</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了对主题进行有效修改，我们首先要清晰地了解Hexo和Next主题的目录结构<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>
<p>Hexo目录结构：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy          <span class="comment">#部署文件夹</span></span><br><span class="line">├── public           <span class="comment">#html源码，hexo g生成</span></span><br><span class="line">├── scaffolds        <span class="comment">#模板</span></span><br><span class="line">├── scripts          <span class="comment">#扩展脚本</span></span><br><span class="line">├── <span class="built_in">source</span>           <span class="comment">#文章源码</span></span><br><span class="line">|   ├── _drafts      <span class="comment">#草稿</span></span><br><span class="line">|   └── _posts       <span class="comment">#文章</span></span><br><span class="line">├── themes           <span class="comment">#主题</span></span><br><span class="line">|   ├── next         <span class="comment">#NexT主题</span></span><br><span class="line">├── _config.yml      <span class="comment">#博客配置</span></span><br><span class="line">└── package.json     <span class="comment">#应用程序数据</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>Next主题目录结构</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── .github                <span class="comment">#github信息</span></span><br><span class="line">├── languages              <span class="comment">#多语言</span></span><br><span class="line">|   ├── _en.yml            <span class="comment">#默认语言</span></span><br><span class="line">|   └── zh-CN.yml          <span class="comment">#简体中文</span></span><br><span class="line">|   └── zh-TW.yml          <span class="comment">#繁体中文</span></span><br><span class="line">├── layout                 <span class="comment">#布局，根目录下的*.swig文件是对主页，分页，存档等的控制</span></span><br><span class="line">|   ├── _custom            <span class="comment">#可以自定义的模板，覆盖原有模板</span></span><br><span class="line">|   |   ├── head.swig      <span class="comment">#文首样式</span></span><br><span class="line">|   |   ├── header.swig    <span class="comment">#头部样式</span></span><br><span class="line">|   |   ├── sidebar.swig   <span class="comment">#侧边栏样式</span></span><br><span class="line">|   ├── _macro             <span class="comment">#可以自定义的模板，覆盖原有模板</span></span><br><span class="line">|   |   ├── post.swig      <span class="comment">#文章模板</span></span><br><span class="line">|   |   ├── reward.swig    <span class="comment">#打赏模板</span></span><br><span class="line">|   |   ├── sidebar.swig   <span class="comment">#侧边栏模板</span></span><br><span class="line">|   ├── _partial           <span class="comment">#局部的布局</span></span><br><span class="line">|   |   ├── head           <span class="comment">#头部模板</span></span><br><span class="line">|   |   ├── search         <span class="comment">#搜索模板</span></span><br><span class="line">|   |   ├── share          <span class="comment">#分享模板</span></span><br><span class="line">|   ├── _script            <span class="comment">#局部的布局</span></span><br><span class="line">|   ├── _third-party       <span class="comment">#第三方模板</span></span><br><span class="line">|   ├── _layout.swig       <span class="comment">#主页面模板</span></span><br><span class="line">|   ├── index.swig         <span class="comment">#主页面模板</span></span><br><span class="line">|   ├── page               <span class="comment">#页面模板</span></span><br><span class="line">|   └── tag.swig           <span class="comment">#tag模板</span></span><br><span class="line">├── scripts                <span class="comment">#script源码</span></span><br><span class="line">|   ├── tags               <span class="comment">#tags的script源码</span></span><br><span class="line">|   ├── marge.js           <span class="comment">#页面模板</span></span><br><span class="line">├── <span class="built_in">source</span>                 <span class="comment">#源码</span></span><br><span class="line">|   ├── css                <span class="comment">#css源码</span></span><br><span class="line">|   |   ├── _common        <span class="comment">#*.styl基础css</span></span><br><span class="line">|   |   ├── _custom        <span class="comment">#*.styl自定义局部css</span></span><br><span class="line">|   |   └── _mixins        <span class="comment">#mixins的css</span></span><br><span class="line">|   ├── fonts              <span class="comment">#字体</span></span><br><span class="line">|   ├── images             <span class="comment">#图片</span></span><br><span class="line">|   ├── js                 <span class="comment">#javascript源代码</span></span><br><span class="line">|   └── lib                <span class="comment">#引用库</span></span><br><span class="line">├── _config.yml            <span class="comment">#主题配置文件</span></span><br><span class="line">└── README.md              <span class="comment">#说明文件</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>此外，我们还需要了解css，swig语法与js语法。 </p>
<h2 id="背景优化"><a href="#背景优化" class="headerlink" title="背景优化"></a>背景优化</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://blog.bill.moe/hexo-theme-next-config-optimization/">Next主题高级配置</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>绘图</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Latex/%E6%8F%92%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Latex中常用绘图命令进行总结</p>
<a id="more"></a>
<h2 id="图片排版"><a href="#图片排版" class="headerlink" title="图片排版"></a>图片排版</h2><h3 id="基本绘图（浮动体）"><a href="#基本绘图（浮动体）" class="headerlink" title="基本绘图（浮动体）"></a>基本绘图（浮动体）</h3><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;figure&#125;[ht]</span><br><span class="line">\centering</span><br><span class="line">\includegraphics[scale=0.6]&#123;fullscreen.png&#125;</span><br><span class="line">\caption&#123;this is a figure demo&#125;</span><br><span class="line">\label&#123;fig:label&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p>相关参数解释如下：</p>
<ul>
<li><strong>h</strong> 此处（here）</li>
<li><strong>t</strong> 页顶（top）</li>
<li><strong>b</strong> 页底（bottom）</li>
<li><strong>p</strong> 独立一页（page）</li>
</ul>
<h3 id="并列子图"><a href="#并列子图" class="headerlink" title="并列子图"></a>并列子图</h3><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%latex 实现3张图并排</span><br><span class="line">\begin&#123;figure*&#125;[t!]</span><br><span class="line">    \centering</span><br><span class="line">    \begin&#123;subfigure&#125;[t]&#123;0.3\textwidth&#125;</span><br><span class="line">        \centering</span><br><span class="line">        \includegraphics[height=1.7in]&#123;figure14(a).pdf&#125;</span><br><span class="line">        \caption&#123;&#125;</span><br><span class="line">    \end&#123;subfigure&#125;%</span><br><span class="line">    ~</span><br><span class="line">    \begin&#123;subfigure&#125;[t]&#123;0.3\textwidth&#125;</span><br><span class="line">        \centering</span><br><span class="line">        \includegraphics[height=1.7in]&#123;figure14(b).pdf&#125;</span><br><span class="line">        \caption&#123;&#125;</span><br><span class="line">    \end&#123;subfigure&#125;</span><br><span class="line">    ~</span><br><span class="line">    \begin&#123;subfigure&#125;[t]&#123;0.3\textwidth&#125;</span><br><span class="line">        \centering</span><br><span class="line">        \includegraphics[height=1.7in]&#123;figure14(c).pdf&#125;</span><br><span class="line">        \caption&#123;&#125;</span><br><span class="line">    \end&#123;subfigure&#125;</span><br><span class="line">    ~</span><br><span class="line">    \caption&#123;The diagram of the simulation results of ATP system with MRAC and ASTKF&#125;</span><br><span class="line">\end&#123;figure*&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p>效果如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-02%20104803.jpg" alt=""></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://tex.stackexchange.com/questions/119984/subfigures-side-by-side-with-captions">latex子图绘制</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Latex</category>
      </categories>
  </entry>
  <entry>
    <title>iframe框架</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Hexo/iframe/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文针对HTML内联框架元素 (<code>&lt;iframe&gt;</code>)进行讲解</p>
<a id="more"></a>
<p>Hexo 是静态网页渲染工具，有些情况我们想要动态网页，那么可以采用iframe框架嵌套另一个HTML实现一种伪动态网页的效果，例如，我们这里嵌入一个谷歌地图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p align=&quot;center&quot;&gt;</span><br><span class="line">&lt;iframe id=&quot;inlineFrameExample&quot;</span><br><span class="line">    title=&quot;Inline Frame Example&quot;</span><br><span class="line">    width=&quot;300&quot;</span><br><span class="line">    height=&quot;200&quot;</span><br><span class="line">    src=&quot;https://www.openstreetmap.org/export/embed.html?bbox=-0.004017949104309083%2C51.47612752641776%2C0.00030577182769775396%2C51.478569861898606&amp;layer=mapnik&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<iframe id="inlineFrameExample"
    title="Inline Frame Example"
    width="300"
    height="200"
    src="https://www.openstreetmap.org/export/embed.html?bbox=-0.004017949104309083%2C51.47612752641776%2C0.00030577182769775396%2C51.478569861898606&layer=mapnik">
</iframe>


<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><strong><code>allow</code></strong>：用于为iframe指定特征策略</p>
<h2 id="嵌入自定义网页"><a href="#嵌入自定义网页" class="headerlink" title="嵌入自定义网页"></a>嵌入自定义网页</h2><h3 id="在source文件夹下创建保存网页的文件夹"><a href="#在source文件夹下创建保存网页的文件夹" class="headerlink" title="在source文件夹下创建保存网页的文件夹"></a>在source文件夹下创建保存网页的文件夹</h3><p>我们在source文件夹下创建一个webs文件夹，专门用于保存自定义的网页。</p>
<h3 id="跳过网页渲染"><a href="#跳过网页渲染" class="headerlink" title="跳过网页渲染"></a>跳过网页渲染</h3><p>为了使我们能够正确嵌入自定义网页，我们需要跳过自定义网页的渲染，方式如下，在<code>_config.yml</code>下添加不需要渲染的网页的相对路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">    - webs\helloworld\clock.html</span><br></pre></td></tr></table></figure>
<h3 id="插入自定义网页"><a href="#插入自定义网页" class="headerlink" title="插入自定义网页"></a>插入自定义网页</h3><p>插入自定义网页的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;div style=<span class="string">"width:100%; height:350px;border:none;text-align:center"</span>&gt;</span><br><span class="line">        &lt;iframe allowtransparency=<span class="string">"yes"</span> frameborder=<span class="string">"0"</span> width=<span class="string">"300"</span> height=<span class="string">"300"</span> src=<span class="string">"/webs/helloworld/clock.html"</span>/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>其中，src即为网页在source文件夹下的路径，style中的height和width为分配给网页的大小，而iframe中的width和height是网页的实际大小，使用时应保证分配大小大于实际大小</p>
<p>
    <div style="width:100%; height:350px;border:none;text-align:center">
        <iframe allowtransparency="yes" frameborder="0" width="300" height="300" src="/webs/helloworld/clock.html"/>
    </div>
</p>

<p>这里插入一个HTML的时钟作为展示：</p>
<p>
    <div style="width:100%; height:350px;border:none;text-align:center">
        <iframe allowtransparency="yes" frameborder="0" width="300" height="300" src="/webs/helloworld/clock2.html"/>
    </div>
</p>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe">iframe</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>表格</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Latex/%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将提供一些常用的latex三线表格模板。表格依赖于booktabs包。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;table&#125;[htbp]</span><br><span class="line">    \centering</span><br><span class="line">    \caption&#123;\label&#123;tab:test&#125;Calibration results&#125;</span><br><span class="line">    \begin&#123;tabular&#125;&#123;ccc&#125;</span><br><span class="line">        \toprule</span><br><span class="line">        Parameters&amp;  Estimates &amp; Relative errors \\</span><br><span class="line">        \midrule</span><br><span class="line">         $f_c$(pixels)    &amp; $454.28\pm5.17$    &amp;  $1.1\%$ \\</span><br><span class="line">         $k_c$            &amp; $236.75\pm14.49$   &amp;  $4.7\%$ \\</span><br><span class="line">         $c_c$            &amp; $-0.42\pm0.02$     &amp;  $3.9\%$ \\     </span><br><span class="line">         $error$          &amp; $0.17$      &amp;   \\</span><br><span class="line">        \bottomrule</span><br><span class="line">    \end&#123;tabular&#125;</span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/latex_table_example1.png" alt=""></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Latex</category>
      </categories>
  </entry>
  <entry>
    <title>GDB基本使用方法</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/GDB/GDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>while(i &gt; 0)</p>
<p>​    i++;</p>
</blockquote>
<a id="more"></a>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="调试类操作"><a href="#调试类操作" class="headerlink" title="调试类操作"></a>调试类操作</h3><h4 id="生成可调试文件"><a href="#生成可调试文件" class="headerlink" title="生成可调试文件"></a>生成可调试文件</h4><p>在使用GCC编译时，必须添加<code>-g</code>选项，生成用于调试的符号表，才能使用GCC对可执行文件进行调试。</p>
<h4 id="加载调试文件"><a href="#加载调试文件" class="headerlink" title="加载调试文件"></a>加载调试文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) file prog1</span><br></pre></td></tr></table></figure>
<h4 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h4><p>有些时候我们的程序需要用户输入参数，这种情况下我们可以将输入写入一个文件<code>input.txt</code>当中，然后执行下列语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb helloworld</span><br><span class="line">(gdb) run params ... &lt; input.txt</span><br></pre></td></tr></table></figure>
<h4 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h4><h5 id="starti"><a href="#starti" class="headerlink" title="starti"></a>starti</h5><p>starti是GDB8.1之后的一个命令，作用是在载入待调试的程序后，在第一个指令前设置一个断点，然后执行到该断点。相当于从第一条指令开始调试。</p>
<h5 id="si"><a href="#si" class="headerlink" title="si"></a>si</h5><p>si命令将会执行一条汇编命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) si</span><br><span class="line">mov 0x8(%ebp), %esi     # 下一条要执行的语句</span><br></pre></td></tr></table></figure>
<p>需要注意的是，si打印的是下一条要执行的语句</p>
<h5 id="n"><a href="#n" class="headerlink" title="n"></a>n</h5><p>n命令会一次执行一个函数，如果没有符号表，那么不能使用n命令。<code>n x</code>表示某一行x次</p>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><h5 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h5><p>在指定的地址设置断点的语句如下，其中0x0010000c为程序执行的断点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) br * 0x0010000c</span><br><span class="line">Breakpoint 1 at 0x10000c</span><br></pre></td></tr></table></figure>
<p>其中，断点可以是一个实际内存地址，也可以是描述符（”mon_backtrace”或者”monitor.c:71”）。注意，如果使用描述符，那么在编译的时候gcc必须给定<code>-g</code>选项并重新编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) br monitor.c:71      #在monitor.c 71行设置断点</span><br><span class="line">(gdb) br mem_init          #在mem_init处设置断点</span><br></pre></td></tr></table></figure>
<p>如果想要在特定条件下触发断点，可以使用条件断点，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) br *0x0010000c if</span><br></pre></td></tr></table></figure>
<p>这里总结一下断点的类型：</p>
<ul>
<li>特定内存地址</li>
<li>描述符（例如某个具体函数）</li>
<li>行号（某个文件的行号）</li>
</ul>
<h5 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info b</span><br></pre></td></tr></table></figure>
<h5 id="删除-禁用-使能断点"><a href="#删除-禁用-使能断点" class="headerlink" title="删除/禁用/使能断点"></a>删除/禁用/使能断点</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete 1      # 删除第一个断点</span><br><span class="line">enable 3</span><br><span class="line">disable 2</span><br></pre></td></tr></table></figure>
<h4 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h4><p>watchpoints（监视点）和端点不同，当检测到某个表达式或变量的值发生改变时，将会停止运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) watch &lt;expression&gt;   #如果指定表达式内容改变，则停止</span><br><span class="line">(gdb) watch -l &lt;address&gt;   #如果指定内存内容改变，则停止</span><br><span class="line">(gdb) rwatch &lt;expression&gt;  #如果指定表达式被读取，那么停止</span><br></pre></td></tr></table></figure>
<h4 id="继续执行类"><a href="#继续执行类" class="headerlink" title="继续执行类"></a>继续执行类</h4><h5 id="继续直行至断点"><a href="#继续直行至断点" class="headerlink" title="继续直行至断点"></a>继续直行至断点</h5><p>继续执行命令为<code>c</code>，程序会执行至下一个断点处</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x10000c:	mov    %cr4,%eax</span><br></pre></td></tr></table></figure>
<h5 id="继续直行至当前函数返回"><a href="#继续直行至当前函数返回" class="headerlink" title="继续直行至当前函数返回"></a>继续直行至当前函数返回</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) finish</span><br></pre></td></tr></table></figure>
<p>如果不在函数内，那么finish没有意义</p>
<h5 id="继续执行至特定位置"><a href="#继续执行至特定位置" class="headerlink" title="继续执行至特定位置"></a>继续执行至特定位置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) advance _start</span><br><span class="line">(gdb) advance *0x0010000c</span><br></pre></td></tr></table></figure>
<p>advance 将会执行代码至特定的符号或地址所在位置处</p>
<h4 id="符号相关"><a href="#符号相关" class="headerlink" title="符号相关"></a>符号相关</h4><h5 id="切换符号文件"><a href="#切换符号文件" class="headerlink" title="切换符号文件"></a>切换符号文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbol-file obj/kern/kernel   # 这个命令将会加载kernel中的符号</span><br></pre></td></tr></table></figure>
<h3 id="显示类操作"><a href="#显示类操作" class="headerlink" title="显示类操作"></a>显示类操作</h3><h4 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h4><p>反汇编指令为<code>x/N addr</code>，该指令可以将addr开始的N个连续指令进行反汇编</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/10 0x7c00</span><br><span class="line">=&gt; 0x7c00:	cli    </span><br><span class="line">   0x7c01:	cld    </span><br><span class="line">   0x7c02:	xor    %ax,%ax</span><br><span class="line">   0x7c04:	mov    %ax,%ds</span><br><span class="line">   0x7c06:	mov    %ax,%es</span><br><span class="line">   0x7c08:	mov    %ax,%ss</span><br><span class="line">   0x7c0a:	in     $0x64,%al</span><br><span class="line">   0x7c0c:	test   $0x2,%al</span><br><span class="line">   0x7c0e:	jne    0x7c0a</span><br><span class="line">   0x7c10:	mov    $0xd1,%al</span><br></pre></td></tr></table></figure>
<h4 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h4><h5 id="x命令"><a href="#x命令" class="headerlink" title="x命令"></a>x命令</h5><p>使用<code>x/Nxw addr</code>可以以16进制（后面的x）查看从addr开始的N个word大小的内存中的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766</span><br><span class="line">0x100010:	0x34000004	0x1000b812	0x220f0011	0xc0200fd8</span><br></pre></td></tr></table></figure>
<p>有些情况下要看栈中内存的情况，由于栈是向下生长的，所以我们可以用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/-8x 0x00100000</span><br></pre></td></tr></table></figure>
<p>反向打印内存。如果想查看当前内存，可以使用<code>x/i $pc</code></p>
<h5 id="p命令"><a href="#p命令" class="headerlink" title="p命令"></a>p命令</h5><p>相比于x命令，p命令能够检验一个c语言表达式，并用合适的类型对结果进行打印，例如我们要打印某个内存位置处特定类型的变量，可以使用下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p *((struct Elf*)0x10000)</span><br></pre></td></tr></table></figure>
<p>这个命令将会打印从0x10000开始的Elf类型的变量，其结果非常清晰，可以将结构体中的所有内容展示出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$1 = &#123;e_magic = 0, e_elf = &apos;\000&apos;,...&#125;</span><br></pre></td></tr></table></figure>
<h4 id="info命令"><a href="#info命令" class="headerlink" title="info命令"></a>info命令</h4><p>info命令能够查看相关信息，功能比较全，所以单独列出</p>
<h5 id="查看寄存器的值"><a href="#查看寄存器的值" class="headerlink" title="查看寄存器的值"></a>查看寄存器的值</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 查看所有寄存器</span><br><span class="line">(gdb) info reg</span><br><span class="line">eax            0x0                 0</span><br><span class="line">ecx            0x0                 0</span><br><span class="line">edx            0x663               1635</span><br><span class="line">ebx            0x0                 0</span><br><span class="line">esp            0x0                 0x0</span><br><span class="line">ebp            0x0                 0x0</span><br><span class="line">esi            0x0                 0</span><br><span class="line">edi            0x0                 0</span><br><span class="line">eip            0xfff0              0xfff0</span><br><span class="line">eflags         0x2                 [ IOPL=0 ]</span><br><span class="line">cs             0xf000              61440</span><br><span class="line">ss             0x0                 0</span><br><span class="line">ds             0x0                 0</span><br><span class="line">es             0x0                 0</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x0                 0</span><br><span class="line">fs_base        0x0                 0</span><br><span class="line">gs_base        0x0                 0</span><br><span class="line">k_gs_base      0x0                 0</span><br><span class="line">cr0            0x60000010          [ CD NW ET ]</span><br><span class="line">cr2            0x0                 0</span><br><span class="line">cr3            0x0                 [ PDBR=0 PCID=0 ]</span><br><span class="line">cr4            0x0                 [ ]</span><br><span class="line">cr8            0x0                 0</span><br><span class="line">efer           0x0                 [ ]</span><br><span class="line"></span><br><span class="line">// 查看某个寄存器</span><br><span class="line">(gdb) info reg eax</span><br></pre></td></tr></table></figure>
<h5 id="查看c语言类型"><a href="#查看c语言类型" class="headerlink" title="查看c语言类型"></a>查看c语言类型</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info types</span><br></pre></td></tr></table></figure>
<h5 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info variables # 打印全局变量</span><br><span class="line">info locals    # 打印局部变量</span><br><span class="line">info args      # 打印当前frame的参数（函数输入参数）</span><br></pre></td></tr></table></figure>
<h5 id="查看当前函数栈"><a href="#查看当前函数栈" class="headerlink" title="查看当前函数栈"></a>查看当前函数栈</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) info frame</span><br><span class="line">Stack level 0, frame at 0xb75f7390:</span><br><span class="line"> eip = 0x804877f in base::func() (testing.cpp:16); saved eip 0x804869a</span><br><span class="line"> called by frame at 0xb75f73b0</span><br><span class="line"> source language c++.</span><br><span class="line"> Arglist at 0xb75f7388, args: this=0x0</span><br><span class="line"> Locals at 0xb75f7388, Previous frame&apos;s sp is 0xb75f7390</span><br><span class="line"> Saved registers:</span><br><span class="line">  ebp at 0xb75f7388, eip at 0xb75f738c</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><strong>stack level 0</strong>：表示frame的序号</li>
<li><strong>frame at 0xb75f7390</strong>：表示栈的起始地址</li>
<li><strong>eip = 0x804877f in base::func() (testing.cpp:16); saved eip 0x804869a</strong><ul>
<li>eip = 0x804877f表示下一条语句在0x804877fc处，在testing.cpp的16行</li>
<li>saved eip 0x804869a表示函数返回地址，即返回后执行0x804869a</li>
</ul>
</li>
<li><strong>called by frame at 0xb75f73b0</strong>：表示调用者的栈位于0xb75f73b0</li>
<li><strong>Arglist at 0xb75f7388, args: this=0x0</strong>：表示参数的起始地址以及参数</li>
<li><strong>Locals at 0xb75f7388</strong>：表示局部变量的位置</li>
<li><strong>Previous frame’s sp is 0xb75f7390</strong>：表示前一个栈帧（调用者栈的栈顶或被调用者栈的栈底）的栈顶</li>
<li>还有一些保存的寄存器的值</li>
</ul>
<h4 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h4><p>使用list可以查看某个位置处的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) list 123   # 打印源文件123行开始的几行代码</span><br></pre></td></tr></table></figure>
<h4 id="查看函数调用栈"><a href="#查看函数调用栈" class="headerlink" title="查看函数调用栈"></a>查看函数调用栈</h4><p>使用bt命令可以查看函数的调用栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0 readseg (pa=65536, count=4096,offset=0) at boot/main.c:73</span><br><span class="line">#1 0x00007d26 in bootmain() at boot/main.c:44</span><br><span class="line">#2 0x00007c4a in protcseg() at boot/boot.S:69</span><br></pre></td></tr></table></figure>
<p>每调用一个函数，则压入现在所在的函数，同时前面的序号依次递增，最上面的就是当前所在的函数，其中，序号后面的0x00007d26为函数栈中函数的返回地址，即被保存的eip值。</p>
<h4 id="查看具体变量"><a href="#查看具体变量" class="headerlink" title="查看具体变量"></a>查看具体变量</h4><p>当程序中断时，我们可以使用p命令查看具体的变量，例如现在我们所在的函数有一个输入参数<code>cmd</code>，是一个结构体类型指针，那么我们可以用如下命令查看指针值及结构体中内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print cmd</span><br><span class="line">$3 = (struct cmd *) 0x555555559ac0</span><br><span class="line"></span><br><span class="line">(gdb) print *cmd</span><br><span class="line">$5 = &#123;type = 32&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h2><p>首先，我们要确保在gcc编译过程中加入了<code>-g</code>选项，生成调试信息，否则gdb调试过程中能够查看的信息很少。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c -o build -g</span><br></pre></td></tr></table></figure>
<p>然后打开gdb，</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>多进程调试</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/GDB/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>人不能一次踏进两条河流</p>
</blockquote>
<a id="more"></a>
<p>当我们使用<code>fork()</code>创建多进程程序后，会出现进程分支，而此时如果想使用gdb调试特定进程，就必须进行相应的设置，方法如下：</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="查看当前跟随的进程"><a href="#查看当前跟随的进程" class="headerlink" title="查看当前跟随的进程"></a>查看当前跟随的进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) show follow-fork-mode</span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;parent&quot;.</span><br></pre></td></tr></table></figure>
<p>可以看到默认情况下为parent。</p>
<h3 id="设置跟随进程"><a href="#设置跟随进程" class="headerlink" title="设置跟随进程"></a>设置跟随进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set follow-fork-mode &lt;mode&gt;</span><br></pre></td></tr></table></figure>
<p>mode可以是parent或child，分别对应父进程和子进程，这样当gdb执行代码时，会进入特定的进程分支。</p>
<h3 id="查看当前运行的进程"><a href="#查看当前运行的进程" class="headerlink" title="查看当前运行的进程"></a>查看当前运行的进程</h3><p>输入如下命令可以查看并切换到指定进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info threads</span><br><span class="line">t 8 #切换至进程8</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/objdump.html">objdump命令</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>TUI调试模式</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/GDB/TUI/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>GDB text user interface（TUI）是GDB的一个多窗口的符号终端，能够同时显示源文件、汇编输出、寄存器等情况，本文将针对tui的使用进行一些总结。</p>
<a id="more"></a>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="在GDB中激活TUI"><a href="#在GDB中激活TUI" class="headerlink" title="在GDB中激活TUI"></a>在GDB中激活TUI</h3><p>在使用GDB时，可以通过<code>gdb -tui</code>的方式打开tui，也可以打开gdb后，输入<code>tui enable/disable</code>激活、关闭TUI，TUI的界面如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20210211184604.png" width = "550" alt="图片名称" align=center /></p>
<p>上中下分别为源代码窗口、汇编代码窗口和命令行窗口</p>
<h3 id="不同的窗口"><a href="#不同的窗口" class="headerlink" title="不同的窗口"></a>不同的窗口</h3><p>在TUI中，一共可以显示如下四种窗口：</p>
<ul>
<li>命令窗口：用于GDB调试时命令输入</li>
<li>源代码窗口：显示程序源代码，当前行及断点等信息，（命令窗口中输入<code>layout src</code>）</li>
<li>汇编窗口：显示程序汇编代码，（命令窗口中输入<code>layout asm</code>）</li>
<li>寄存器窗口：显示寄存器中的内容，（命令行窗口中输入<code>layout regs</code>）</li>
</ul>
<p>如果需要切分窗口，输入<code>layout split</code>，可以增加显示窗口的数目</p>
<h2 id="tui配置"><a href="#tui配置" class="headerlink" title="tui配置"></a>tui配置</h2><p>每次打开GDB，我们都需要手动输入上面的命令激活tui，不太方便。我们可以将上述命令写入<code>~/.gdbinit</code>中，每次打开gdb，都会执行上述指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tui enable</span><br><span class="line">layout asm</span><br><span class="line">layout reg</span><br></pre></td></tr></table></figure>
<h2 id="查看调试历史"><a href="#查看调试历史" class="headerlink" title="查看调试历史"></a>查看调试历史</h2><p>在TUI模式下，无法通过鼠标滑轮查看历史调试信息，这种情况下我们一般将调试log输出到其他文件，并进行查看，在<code>.gdbinit</code>文件种加入如下两句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set trace-commands on</span><br><span class="line">set logging on</span><br></pre></td></tr></table></figure>
<p>此时在gdb中运行命令，会在启动gdb的路径建立<code>gdb.txt</code>文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f gdb.txt</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://unix.stackexchange.com/questions/243350/why-does-using-yes-on-bash-pipelines-not-cause-infinite-loops">shell - Why does using <code>yes</code> on bash pipelines <em>not</em> cause infinite loops? - Unix &amp; Linux Stack Exchange</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>反编译基本方法</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/GDB/%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>8010717f:    5b                        pop    %ebx<br>80107180:    5e                       pop    %esi<br>80107181:    5f                        pop    %edi<br>80107182:    5d                       pop    %ebp</p>
</blockquote>
<a id="more"></a>
<p>为了配合GDB进行调试，有时我们需要将源码进行反编译，从而得到汇编代码，查看对应的地址上的语句。</p>
<h2 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h2><h3 id="objdump：二进制文件分析"><a href="#objdump：二进制文件分析" class="headerlink" title="objdump：二进制文件分析"></a>objdump：二进制文件分析</h3><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-f 显示文件头信息</li>
<li>-D 反汇编所有section (-d反汇编特定section)</li>
<li>-h 显示目标文件各个section的头部摘要信息</li>
<li>-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。</li>
<li>-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。</li>
<li>-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。</li>
<li>-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。</li>
<li>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。</li>
<li>-t 显示文件的符号表入口。类似于nm -s提供的信息</li>
<li>-G 显示一个ELF文件中.stab/.stab.index/.stab.excl段（symbol-table）的内容</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>1 查看本机是大端存储还是小端存储</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">duan@husky:~/Code/linux/6.828/lab/obj/kern (lab1 *%) $ objdump -i</span><br><span class="line">BFD 头文件版本 (GNU Binutils) 2.35.1</span><br><span class="line">elf64-x86-64</span><br><span class="line">(header 小端序, data 小端序)</span><br><span class="line">i386</span><br></pre></td></tr></table></figure>
<p>2 反汇编程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d kernel | grep %cr4  # 将kernel进行反编译，然后查看cr4寄存器所在的所有命令</span><br><span class="line"></span><br><span class="line">8010000c:	0f 20 e0             	mov    %cr4,%eax</span><br><span class="line">80100012:	0f 22 e0             	mov    %eax,%cr4</span><br></pre></td></tr></table></figure>
<p>3 显示目标文件各个section的头部摘要信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -h kernel </span><br><span class="line"></span><br><span class="line">kernel：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001a1d  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000006bc  f0101a20  00101a20  00002a20  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  9 .bss          00000661  f0112060  00112060  00013060  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      00000012  00000000  00000000  000136c1  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<p>4 显示程序头信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -x kernel</span></span><br><span class="line">kernel：     文件格式 elf32-i386</span><br><span class="line">kernel</span><br><span class="line">体系结构：i386，标志 0x00000112：</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">起始地址 0x0010000c</span><br><span class="line"></span><br><span class="line">程序头：</span><br><span class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</span><br><span class="line">         filesz 0x00006d62 memsz 0x00006d62 flags r-x</span><br><span class="line">    LOAD off    0x00008000 vaddr 0xf0107000 paddr 0x00107000 align 2**12</span><br><span class="line">         filesz 0x0000b6c1 memsz 0x0000b6c1 flags rw-</span><br><span class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</span><br><span class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</span><br></pre></td></tr></table></figure>
<p>5 显示文件头信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -f obj/kern/kernel</span></span><br><span class="line"></span><br><span class="line">obj/kern/kernel：     文件格式 elf32-i386</span><br><span class="line">体系结构：i386，标志 0x00000112：</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">起始地址 0x0010000c</span><br></pre></td></tr></table></figure>
<p>比较重要的是起始地址，这里显示为0x0010000c</p>
<h3 id="nm：显示文件中的符号"><a href="#nm：显示文件中的符号" class="headerlink" title="nm：显示文件中的符号"></a>nm：显示文件中的符号</h3><p>nm命令用于显示文件中的符号，对于一般的文件，我们能够直接读，而对于二进制可执行文件以及一些动态链接库，我们有必要通过nm命令查看其中的一些符号。相当于是将二进制转换为汇编，然后读取其中的符号内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nm kernel | grep _start</span><br><span class="line">8010a48c D _binary_entryother_start</span><br><span class="line">8010a460 D _binary_initcode_start</span><br><span class="line">0010000c T _start</span><br></pre></td></tr></table></figure>
<p>上面的命令查看了一个kernel可执行文件，然后抓取_start关键字，得到三行结果。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/objdump.html">objdump命令</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>一些常用的调试命令</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/GDB/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对一些常用的调试命令进行总结。</p>
<a id="more"></a>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="strace1"><a href="#strace1" class="headerlink" title="strace1"></a>strace<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3><p>strace命令通过调用调试API，查看某个命令执行过程，例如我们使用strace调试下列命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace yes | true</span><br></pre></td></tr></table></figure>
<p>会得到如下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">write(1, "y\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\n"..., 4096) = -1 EPIPE (Broken pipe)</span><br><span class="line">--- SIGPIPE &#123;si_signo=SIGPIPE, si_code=SI_USER, si_pid=17556, si_uid=1000&#125; ---</span><br><span class="line">+++ killed by SIGPIPE +++</span><br></pre></td></tr></table></figure>
<p>我们会看到这个命令最终的结局，触发了一个broken pipe，然后被SIGPIPE杀死</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://unix.stackexchange.com/questions/243350/why-does-using-yes-on-bash-pipelines-not-cause-infinite-loops">shell - Why does using <code>yes</code> on bash pipelines <em>not</em> cause infinite loops? - Unix &amp; Linux Stack Exchange</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>一个简单的QML工程</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/QML1%20%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84QML%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是QML"><a href="#什么是QML" class="headerlink" title="什么是QML"></a>什么是QML</h2><blockquote>
<p>QML是一套基于JavaScript的用于设计界面的框架，其优点是实现了界面设计和业务逻辑设计的分离</p>
</blockquote>
<a id="more"></a>
<h2 id="一个简单的QML工程"><a href="#一个简单的QML工程" class="headerlink" title="一个简单的QML工程"></a>一个简单的QML工程</h2><p>一个简单的QML工程包含两个部分：</p>
<ol>
<li>C++部分，主要用于初始化QML引擎并载入qml文件</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QQmlApplicationEngine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QQmlApplicationEngine engine;</span><br><span class="line">    engine.load(QUrl(QStringLiteral(<span class="string">"qrc:/main.qml"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>qml部分，包含着我们用于编写界面的QML文件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.6</span>             <span class="comment">// Text</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.2</span>      <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    width: <span class="number">640</span></span><br><span class="line">    height: <span class="number">480</span></span><br><span class="line">    title: qsTr(<span class="string">"Hello World"</span>)  <span class="comment">// title of your gui</span></span><br><span class="line"></span><br><span class="line">    Text&#123;</span><br><span class="line">        anchors.centerIn: parent  <span class="comment">// center</span></span><br><span class="line">        text : <span class="string">"Hello World"</span>;</span><br><span class="line">        color: <span class="string">"red"</span>;</span><br><span class="line">        font.pointSize: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何预览写好的QML界面"><a href="#如何预览写好的QML界面" class="headerlink" title="如何预览写好的QML界面"></a>如何预览写好的QML界面</h2><p>第一种方式就是直接编译工程，即可看到界面。</p>
<p>二是使用命令qml.exe或者qmlscene.exe后面跟着qml文件即可预览，如果没有该命令，那么先在QT安装文件夹下找到添加到环境变量里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qmlscene main.qml</span><br></pre></td></tr></table></figure>
<p>或者如果不使用命令行，可以新建一个qt prototype工程，将qml文件拷贝进去预览。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>QML基本类型及语法</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/QML2%20QML%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对QML基本类型进行相关总结</p>
<a id="more"></a>
<h2 id="QML基本类型"><a href="#QML基本类型" class="headerlink" title="QML基本类型"></a>QML基本类型</h2><p>QML的基本类型主要包括两类：</p>
<ul>
<li>单值（int、var等）</li>
<li>符合类型（size是一个由width和height属性组成的类型）</li>
</ul>
<h3 id="QML语言提供的基本类型"><a href="#QML语言提供的基本类型" class="headerlink" title="QML语言提供的基本类型"></a>QML语言提供的基本类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">real</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">enumeration</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">QML object 的列表</td>
</tr>
<tr>
<td style="text-align:center">var</td>
<td style="text-align:center">通用属性类型，类似于C++中的auto</td>
</tr>
<tr>
<td style="text-align:center">url</td>
<td style="text-align:center">资源定位器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="QML模块提供的基本类型"><a href="#QML模块提供的基本类型" class="headerlink" title="QML模块提供的基本类型"></a>QML模块提供的基本类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型名</th>
<th style="text-align:center">属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">时间</td>
</tr>
<tr>
<td style="text-align:center">point</td>
<td style="text-align:center">(x,y)</td>
</tr>
<tr>
<td style="text-align:center">rect</td>
<td style="text-align:center">(x,y,width,height)</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">(width,height)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>property是对象的一个属性，一个property的值可以被其他的对象进行访问和修改。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    property color previousColor</span><br><span class="line">    property color nextColor</span><br><span class="line">    onNextColorChanged: console.log("The next color will be: " + nextColor.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本类型行为改变"><a href="#基本类型行为改变" class="headerlink" title="基本类型行为改变"></a>基本类型行为改变</h3><p>一些基本类型具有属性，例如font类型包括pixelSize，family等属性，基本类型具有属性改变的信号，但是基本类型的属性不具有类型改变的信号，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Text&#123;</span><br><span class="line">    onFont.pixelSizeChanged: doSomething()   <span class="comment">//非法，pixelSize是font的属性，font是基本类型，基本类型的属性不具有类型改变信号</span></span><br><span class="line">    font&#123;</span><br><span class="line">        onPixelSizeChanged: doSomething()   <span class="comment">//非法，同上理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onFontChanged: doSomething()     <span class="comment">//合法，基本类型具有属性改变信号，改变font的任意属性，就会触发属性改变信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="QML语法"><a href="#QML语法" class="headerlink" title="QML语法"></a>QML语法</h2><h3 id="QML文件基本结构"><a href="#QML文件基本结构" class="headerlink" title="QML文件基本结构"></a>QML文件基本结构</h3><p>一个QML文档包括两个部分：</p>
<ul>
<li>import部分：引入所需模块</li>
<li>QML元素部分：构成窗口的基本元素</li>
</ul>
<p>需要注意的是，一个QML有且只有一个根元素，根元素与其子元素一起，构成了一棵多叉树，QML元素可以嵌套，并使用{}划分范围，{}中是元素的属性，属性以键值对的方式<code>name:value</code>提供，元素可以有一个<code>id</code>属性，相当于该元素的指针，<code>id</code>属性必须唯一，一般来说，根元素的<code>id</code>为<code>root</code>，子元素可以使用parent关键字访问元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Window&#123;</span><br><span class="line">    id: rootID;</span><br><span class="line">    visible: true</span><br><span class="line">    width: 640</span><br><span class="line">    height: 480</span><br><span class="line">    title: qsTr("QML Syntax Demo")</span><br><span class="line"></span><br><span class="line">    Row&#123;</span><br><span class="line">        id : row1</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">        spacing: 20</span><br><span class="line"></span><br><span class="line">        Rectangle&#123;</span><br><span class="line">            width: 150;</span><br><span class="line">            height: 150</span><br><span class="line">            color: "red"</span><br><span class="line">            radius: 20</span><br><span class="line">            MouseArea&#123;</span><br><span class="line">                anchors.fill: parent</span><br><span class="line">                onClicked: &#123;</span><br><span class="line">                    console.log("clicked on the red rect")</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的qml文件中各个模块之间关系如下：</p>
<pre class="mermaid">graph TB
    subgraph Window
    subgraph Row
        Rectangle
    end
    end</pre>

<h3 id="QML属性"><a href="#QML属性" class="headerlink" title="QML属性"></a>QML属性</h3><p>（这一部分还不是很懂，先不写了）</p>
<h3 id="QML对象间交互"><a href="#QML对象间交互" class="headerlink" title="QML对象间交互"></a>QML对象间交互</h3><p>在进行GUI设计时，我们往往需要在对象之间进行互动，例如点击一个方块，修改另一个方块的颜色，这种功能是通过对象id实现的，直接放一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Rectangle&#123;</span><br><span class="line">    id: redRectId</span><br><span class="line">    width: <span class="number">50</span></span><br><span class="line">    height: width * <span class="number">1.5</span></span><br><span class="line">    color: <span class="string">"red"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle&#123;</span><br><span class="line">    id: blueRectId</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">    width: <span class="number">100</span></span><br><span class="line">    height: <span class="number">100</span></span><br><span class="line">    anchors.bottom: parent.bottom</span><br><span class="line"></span><br><span class="line">    MouseArea&#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            redRectId.width = redRectId.width + <span class="number">10</span>   <span class="comment">// 通过redRectId修改其大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="值与绑定"><a href="#值与绑定" class="headerlink" title="值与绑定"></a>值与绑定</h3><p>我们可以创造一个Rectangle，其height随width变化而变化，这里的隐含意思是，height和width进行了绑定。绑定关系可以被打破或重建，具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rectangle&#123;</span><br><span class="line">    id: redRectId</span><br><span class="line">    width: 50</span><br><span class="line">    height: width * 1.5</span><br><span class="line">    color: &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle&#123;</span><br><span class="line">    id: blueRectId</span><br><span class="line">    color: &quot;blue&quot;</span><br><span class="line">    width: 100</span><br><span class="line">    height: 100</span><br><span class="line">    anchors.bottom: parent.bottom</span><br><span class="line"></span><br><span class="line">    MouseArea&#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            redRectId.width = redRectId.width + 10   // 通过redRectId修改其大小，由于redRectId 中width和height绑定，所以两个值均会被修改</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle&#123;</span><br><span class="line">    id: greenRectId</span><br><span class="line">    color: &quot;green&quot;</span><br><span class="line">    width: 100</span><br><span class="line">    height: 100</span><br><span class="line">    anchors.bottom: parent.bottom</span><br><span class="line">    anchors.left: blueRectId.right</span><br><span class="line">    MouseArea&#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            redRectId.height = 100 //绑定关系被打破！！！如果点击了绿色方块，再点击蓝色，会发现高度不随宽度变化而变化</span><br><span class="line">            redRectId.height = 2 * redRectId.width //绑定关系依然被打破！！！这里只是简单地将width×2的值给了height</span><br><span class="line">            rectRectId.height = Qt.binding(function()&#123;</span><br><span class="line">            	return 2 * redRectId.width</span><br><span class="line">            &#125;)   // 重新建立绑定关系</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全局对象-global-object"><a href="#全局对象-global-object" class="headerlink" title="全局对象(global object)"></a>全局对象(global object)</h3><p>qml中有一个全局对象叫做Qt，方便我们建立一些类型，使用方法为调用其内部的函数或者成员，具体例子如下如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Text&#123;</span><br><span class="line">    color: Qt.rgba(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)    <span class="comment">//调用Qt中的rgba方法创建一个颜色对象</span></span><br><span class="line">    text: Qt.md5(<span class="string">"hello world"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">property <span class="keyword">var</span> fonts : Qt.fontFamilies()</span><br><span class="line"></span><br><span class="line">Rectangle&#123;</span><br><span class="line">    width : <span class="number">200</span></span><br><span class="line">    height: <span class="number">200</span></span><br><span class="line">    color: <span class="string">"red"</span></span><br><span class="line">    anchors.centerIn: parent</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*下面是一些Qt Object的例子*/</span></span><br><span class="line">    MouseArea&#123;</span><br><span class="line">        anchors.fill : parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"quiting"</span>)</span><br><span class="line">            Qt.quit()   <span class="comment">//关闭</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;fonts.length;i++)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"["</span> + i + <span class="string">"]:"</span> + fonts[i])</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> mName = <span class="string">"Duan"</span></span><br><span class="line">            <span class="keyword">var</span> mNameHash = Qt.md5(mName)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"The hash of the name:"</span> + nNameHash)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//打开外部链接</span></span><br><span class="line">            Qt.openUrlExternally(<span class="string">"http://www.alittlehusky.cn"</span>)</span><br><span class="line">            <span class="comment">//打开本地文件</span></span><br><span class="line">            Qt.openUrlExternally(<span class="string">"file:///filelink"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Qt对象的一些常用方法如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Qt.quit()</td>
<td style="text-align:center">退出</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>详细内容请参考：<a href="https://doc.qt.io/qt-5/qml-qtqml-qt.html">Qt Global Object</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>QML基本元素和自定义元素</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/QML3%20QML%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对QML基本元素进行讲解</p>
<a id="more"></a>
<h2 id="常用基本元素"><a href="#常用基本元素" class="headerlink" title="常用基本元素"></a>常用基本元素</h2><h3 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h3><p>Item是Qt Quick中所有可视化物体的基本类型，所有可视化物体均继承自该类型。Item不可见，但是他定义了其他可视化物体的基本属性，例如坐标<code>x,y</code>，<code>anchor</code>等等。Item最大的作用就是对对象进行分组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.0</span></span><br><span class="line"><span class="comment">// 下面的Item包含了3个Image 对象 和一个用于给Item添加背景的Rectangle对象</span></span><br><span class="line">Item &#123;</span><br><span class="line">    </span><br><span class="line">    width = <span class="number">400</span></span><br><span class="line">    height = <span class="number">300</span></span><br><span class="line">    </span><br><span class="line">    Rectangle&#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        color : <span class="string">"blue"</span></span><br><span class="line">        border.color: <span class="string">"black"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Image &#123;</span><br><span class="line">        source: <span class="string">"tile.png"</span></span><br><span class="line">    &#125;</span><br><span class="line">    Image &#123;</span><br><span class="line">        x: <span class="number">80</span></span><br><span class="line">        width: <span class="number">100</span></span><br><span class="line">        height: <span class="number">100</span></span><br><span class="line">        source: <span class="string">"tile.png"</span></span><br><span class="line">    &#125;</span><br><span class="line">    Image &#123;</span><br><span class="line">        x: <span class="number">190</span></span><br><span class="line">        width: <span class="number">100</span></span><br><span class="line">        height: <span class="number">100</span></span><br><span class="line">        fillMode: Image.Tile</span><br><span class="line">        source: <span class="string">"tile.png"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="font"><a href="#font" class="headerlink" title="font"></a>font</h3><p>QML中的字体类型，用于定义字体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Text&#123;</span><br><span class="line">    x : <span class="number">100</span></span><br><span class="line">    y : <span class="number">100</span></span><br><span class="line">    id: mTextId</span><br><span class="line">    font&#123;</span><br><span class="line">        family: <span class="string">"Helvetica"</span></span><br><span class="line">        pointSize: <span class="number">13</span></span><br><span class="line">        bold: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>用于显示图片的element</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Image &#123;</span><br><span class="line">    id: image1Id</span><br><span class="line">    x: <span class="number">10</span></span><br><span class="line">    y: <span class="number">10</span></span><br><span class="line">    width: <span class="number">100</span></span><br><span class="line">    height: <span class="number">100</span></span><br><span class="line">    source: <span class="string">"image/bullet.png"</span>   <span class="comment">//也可以使用网页URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h2><h3 id="Column-amp-Row"><a href="#Column-amp-Row" class="headerlink" title="Column &amp; Row"></a>Column &amp; Row</h3><p>Column和Row的作用是将元素按列和按行排布</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Row&#123;</span><br><span class="line">    spacing: 20</span><br><span class="line">    Rectangle&#123;</span><br><span class="line">        width: 300</span><br><span class="line">        height:100</span><br><span class="line">        color: &quot;red&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    Rectangle&#123;</span><br><span class="line">        width: 300</span><br><span class="line">        height: 100</span><br><span class="line">        color: &quot;blue&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用Rectangle创建自定义元素"><a href="#利用Rectangle创建自定义元素" class="headerlink" title="利用Rectangle创建自定义元素"></a>利用Rectangle创建自定义元素</h3><p>最常用的用于自定义元素的基本元素就是Rectangle，一个功能完善的使用rectangle制作的按钮如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Rectangle&#123;</span><br><span class="line">    x: <span class="number">200</span></span><br><span class="line">    y:<span class="number">200</span></span><br><span class="line">    height: buttonTextId.implicitHeight + <span class="number">20</span></span><br><span class="line">    width: buttonTextId.implicitWidth + <span class="number">20</span></span><br><span class="line">    color: <span class="string">"green"</span></span><br><span class="line">    boarder&#123;<span class="attr">color</span>: blue; width: <span class="number">3</span>&#125;</span><br><span class="line">    Text &#123;</span><br><span class="line">        id: buttonTextId</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">        text: qsTr(<span class="string">"This is a button"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MouseArea&#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"clicked On:"</span> + buttonTextId.text)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义元素的封装"><a href="#自定义元素的封装" class="headerlink" title="自定义元素的封装"></a>自定义元素的封装</h3><p>在我们设计好了自定义元素后，我们可以将其封装至一个独立的文件中，方便下次使用。同时，我们可以对外提供一些接口，方便我们对自定义元素进行配置。我们对上面的按钮进行封装，将其放入一个MButton.qml文件中。同时，我们将其放入一个Item中，可以向用户隐藏一些属性，例如此时用户无法修改MButton的颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// MButton.qml</span><br><span class="line">import QtQuick 2.11</span><br><span class="line"></span><br><span class="line">Item&#123;</span><br><span class="line">    id: rootId</span><br><span class="line">    // 提供接口，方便外部使用者修改元素，例如我们将buttonText和buttonTextId.text进行绑定，从而可以修改button的文本</span><br><span class="line">    width: containerRectId.width</span><br><span class="line">    height: containerRectId.height</span><br><span class="line">    property alias buttonText: buttonTextId.text</span><br><span class="line">    signal buttonClicked     //通过信号让用户自定义button的行为</span><br><span class="line">    </span><br><span class="line">    Rectangle&#123;</span><br><span class="line">        </span><br><span class="line">        id: containerRectId</span><br><span class="line">        height: buttonTextId.implicitHeight + 20</span><br><span class="line">        width: buttonTextId.implicitWidth + 20</span><br><span class="line">        color: &quot;green&quot;</span><br><span class="line">        boarder&#123;color: blue; width: 3&#125;</span><br><span class="line">        Text &#123;</span><br><span class="line">            id: buttonTextId</span><br><span class="line">            anchors.centerIn: parent</span><br><span class="line">            text: qsTr(&quot;This is a button&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MouseArea&#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            onClicked: &#123;</span><br><span class="line">                rootId.buttonClicked()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以在其他的qml中调用MButton，需要注意要正确提供MButton的路径，使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MButton&#123;</span><br><span class="line">    buttonText: <span class="string">"Button1"</span></span><br><span class="line">    onButtonClicked: &#123;    <span class="comment">//触发signal</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"clicked on button 1 from main qml"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>QML学习之路(3)——QML文件加载</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/QML%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(3)%E2%80%94%E2%80%94QML%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>QML文件有两种加载方式：QQmlApplicationEngine 和 QQuickView，QQmlApplicationEngine的方式更新，且功能更强大，因此本文重点针对使用QQmlApplicationEngine加载QML文件的方式进行讲解。</p>
<a id="more"></a>
<h2 id="QQmlApplicationEngine"><a href="#QQmlApplicationEngine" class="headerlink" title="QQmlApplicationEngine"></a>QQmlApplicationEngine</h2><h3 id="QQmlApplicationEngine特点"><a href="#QQmlApplicationEngine特点" class="headerlink" title="QQmlApplicationEngine特点"></a>QQmlApplicationEngine特点</h3><ul>
<li>使QQuickView  APP可以由C++进行控制</li>
<li>将Qt.quit()和QCoreApplication::quit()进行了connect</li>
<li>自动从mail QML文件的相邻i18n文件夹中读取翻译文件</li>
<li>如果场景包含QQuickWindow，则自动设置孵化控制器。</li>
<li>自动将QQmlFileSelector设置为url解析器</li>
</ul>
<h3 id="engine方式加载qml的方法"><a href="#engine方式加载qml的方法" class="headerlink" title="engine方式加载qml的方法"></a>engine方式加载qml的方法</h3><p>使用QMl加载时，我们要保证以下几点：</p>
<ul>
<li>加载的qml文件为一个Window而非item</li>
<li><code>visible</code>必须为<code>true</code>，否则无法显示</li>
</ul>
<p>qml文件如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.6</span>             <span class="comment">// Text</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.2</span>      <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line">Window &#123;                          <span class="comment">//parent</span></span><br><span class="line">    visible: <span class="literal">true</span>                 <span class="comment">//是否可见</span></span><br><span class="line">    width: <span class="number">640</span>                    </span><br><span class="line">    height: <span class="number">480</span></span><br><span class="line">    title: qsTr(<span class="string">"Hello World"</span>)    <span class="comment">// title of your gui</span></span><br><span class="line"></span><br><span class="line">    Text&#123;</span><br><span class="line">        anchors.centerIn: parent  <span class="comment">// center</span></span><br><span class="line">        text : <span class="string">"Hello World"</span>;</span><br><span class="line">        color: <span class="string">"red"</span>;</span><br><span class="line">        font.pointSize: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>engine方式加载qml文件非常简单，只要定义一个engine，同时加载对应的qml文件即可。</p>
<h2 id="QQuickView"><a href="#QQuickView" class="headerlink" title="QQuickView"></a>QQuickView</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">Item &#123;             <span class="comment">//Item可以被视作是包含其他组件的容器</span></span><br><span class="line">    id: container</span><br><span class="line">    property alias cellColor: rectangle.color    <span class="comment">//属性，可以被外界访问 alias代表别名</span></span><br><span class="line">    signal clicked(color cellColor)</span><br><span class="line"></span><br><span class="line">    width: <span class="number">40</span>; height: <span class="number">25</span></span><br><span class="line"></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        id: rectangle</span><br><span class="line">        border.color: <span class="string">"white"</span></span><br><span class="line">        anchors.fill: parent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: container.clicked(container.cellColor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://doc.qt.io/qt-5/qqmlapplicationengine.html">qt官方文档</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>QML学习之路(4)——QML与C++交互</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/QML%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(4)%E2%80%94%E2%80%94QML%E4%B8%8EC++%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在QML编程中，C++往往用于编写后台逻辑，而QML用于进行界面端编写，因此利用C++与QML进行交互就成为了重点。由于C++与QML交互具有灵活的方式，本文将针对其中一种方式进行讲解。该方式的基本思想为：</p>
<ol>
<li><strong>处理用户交互事件的逻辑在QML中进行</strong></li>
<li><strong>接收到用户交互事件后，由QML发送信号至APP</strong></li>
<li><strong>在负责业务逻辑的C++文件中找到QML中对应的QObject，并将其信号与指定槽函数绑定</strong></li>
</ol>
<p>在这个过程中，QML可以被视作一个黑盒子，通过属性、信号和函数与外界进行交互。</p>
<a id="more"></a>
<h2 id="在QML中处理用户交互事件"><a href="#在QML中处理用户交互事件" class="headerlink" title="在QML中处理用户交互事件"></a>在QML中处理用户交互事件</h2><p>假如我有一个MainMenu.qml，用于实现应用程序的菜单栏，其部分代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in MainMenu.qml</span></span><br><span class="line">Menu &#123;</span><br><span class="line">    title: <span class="string">"&amp;File"</span></span><br><span class="line">    MenuItem &#123;</span><br><span class="line">        action: newAction</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面包含了一个MenuItem，他有一个指定的action，action中代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Action &#123;</span><br><span class="line">    id: newAction</span><br><span class="line">    objectName: <span class="string">"newAction"</span></span><br><span class="line">    text: <span class="string">"New Project"</span></span><br><span class="line">    signal clicked()</span><br><span class="line">    onTriggered: &#123;</span><br><span class="line">        newAction.clicked()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当触发Action之后，qml会发送一条signal，内容为clicked()，此时我们可以在C++中接收这个信号，并进行相应处理。</p>
<h2 id="在负责业务逻辑的C-文件中找到QML中对应的QObject"><a href="#在负责业务逻辑的C-文件中找到QML中对应的QObject" class="headerlink" title="在负责业务逻辑的C++文件中找到QML中对应的QObject"></a>在负责业务逻辑的C++文件中找到QML中对应的QObject</h2><p>假设我们现在有了一个engine，并加载了对应的qml文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in main.cpp</span></span><br><span class="line">QQmlApplicationEngine engine;</span><br><span class="line">engine.load(QUrl(QStringLiteral(<span class="string">"qrc:/MainMenu.qml"</span>)));</span><br></pre></td></tr></table></figure>
<p>我们现在要在qml中找到能够发送signal的对应的action，其代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QObject *root = engine.rootObjects().first();</span><br><span class="line">QObject *newAction  = root-&gt;findChild&lt;QObject* &gt;(<span class="string">"newAction"</span>);   <span class="comment">//这个"newAction"就是qml中id为newAction的Action的objectName</span></span><br></pre></td></tr></table></figure>
<h2 id="将信号与槽函数绑定"><a href="#将信号与槽函数绑定" class="headerlink" title="将信号与槽函数绑定"></a>将信号与槽函数绑定</h2><p>在接收到信号后，我们所要做的就是将信号与指定槽函数进行绑定即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QObject::connect(newAction,SIGNAL(clicked()),&amp;w,SLOT(newSlot()));   <span class="comment">//clicked即为qml中的信号cllicked()</span></span><br></pre></td></tr></table></figure>
<p>经过一系列操作，即可实现由QML到C++进行通信的过程</p>
<h2 id="在C-中创建QML对象"><a href="#在C-中创建QML对象" class="headerlink" title="在C++中创建QML对象"></a>在C++中创建QML对象</h2><p>有时我们希望能够从C++中向QML发送数据，这种情况需要我们在C++中创建QML可以识别的对象，本节将对C++中创建QML对象的方法进行总结。</p>
<h3 id="继承QQuickItem类"><a href="#继承QQuickItem类" class="headerlink" title="继承QQuickItem类"></a>继承QQuickItem类</h3><p>当我们需要创建一个QML对象时，我们需要继承QQuickItem类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Squircle</span> :</span> <span class="keyword">public</span> QQuickItem</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PROPERTY(qreal t READ t WRITE setT NOTIFY tChanged)</span><br><span class="line">    QML_ELEMENT   <span class="comment">//声明该类为QML下的一个element</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Squircle();</span><br><span class="line"></span><br><span class="line">    <span class="function">qreal <span class="title">t</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">m_t</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setT</span><span class="params">(qreal t)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleWindowChanged</span><span class="params">(QQuickWindow *win)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseResources</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    qreal <span class="keyword">m_t</span>;</span><br><span class="line">    SquircleRenderer *m_renderer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="属性系统"><a href="#属性系统" class="headerlink" title="属性系统"></a>属性系统</h4><p>一个类的属性就是一个类的成员变量，由于QML与C++语法不互通，我们需要一个属性声明系统，让QML能够辨识C++中的成员及成员函数，这个属性系统能够声明C++中的一个成员变量，并提供访问的读/写操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q_PROPERTY(qreal t READ t WRITE setT NOTIFY tChanged)</span><br></pre></td></tr></table></figure>
<p>在上面这行语句中，我们声明了一个类型为qreal的t变量，同时赋予了读方法<code>t</code>和写方法<code>setT</code>，NOTIFY为给属性值设置相应信号。</p>
<h4 id="Q-PROPERTY常用格式"><a href="#Q-PROPERTY常用格式" class="headerlink" title="Q_PROPERTY常用格式"></a>Q_PROPERTY常用格式</h4><p>此处列举一些常用格式，更常见的请参考参考文献<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p>
<h5 id="指定读取属性的函数"><a href="#指定读取属性的函数" class="headerlink" title="指定读取属性的函数"></a>指定读取属性的函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Widget : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_PROPERTY(<span class="keyword">bool</span> focus READ hasFocus)</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasFocus</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改属性的函数"><a href="#修改属性的函数" class="headerlink" title="修改属性的函数"></a>修改属性的函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Widget : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_PROPERTY(<span class="keyword">bool</span> focus WRITE setFocus)</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasFocus</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFocus</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们限定set函数无返回值且只能有一个输入参数</p>
<h5 id="导出成员变量为属性值"><a href="#导出成员变量为属性值" class="headerlink" title="导出成员变量为属性值"></a>导出成员变量为属性值</h5><p>上面两个读/写的属性值都不是类中的成员变量，是凭空声明出来的一个属性值。要想将类中已有的成员变量设置为属性值，需要用 <code>MEMBER</code> 关键字。这样<code>focus</code> 这个属性值就变的可读可写了。要读可以用类自己的 <code>hasFocus()</code> 函数，要写用自带的<code>setFocus()</code> 修改 <code>m_focus</code> 变量就可以了，属性值会自动更新。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Widget : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_PROPERTY(<span class="keyword">bool</span> focus MEMBER m_focus)</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasFocus</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFocus</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_focus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然<code>READ</code>、<code>WRITE</code>、<code>MEMBER</code>这三个关键字都可以赋予属性值可读可写的特性，但是 <code>READ</code>、<code>WRITE</code>和 <code>MEMBER</code>不能同时使用，赋予可读可写特性一次就够了，不能赋予两次。就好像一个对象不能被析构两次一样。</p>
<h5 id="给属性设置关联信号"><a href="#给属性设置关联信号" class="headerlink" title="给属性设置关联信号"></a>给属性设置关联信号</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Widget : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_PROPERTY(<span class="keyword">bool</span> focus MEMBER m_focus NOTIFY focusChanged)</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasFocus</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFocus</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">focusChanged</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_focus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在<code>m_focus</code>发生变化时，可以自动发送信号<code>focusChanged</code>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://doc.qt.io/qt-5/qqmlapplicationengine.html">qt官方文档</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://zhuanlan.zhihu.com/p/43348546">Qt属性系统</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://doc.qt.io/qt-5/properties.html">The Property System</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>QML学习之路(6)——多窗口互动</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/QML%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(6)%E2%80%94%E2%80%94%E5%A4%9A%E7%AA%97%E5%8F%A3%E4%BA%92%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在GUI程序中，有时需要进行多窗口互动，本文将介绍几种多窗口互动的方式。</p>
<a id="more"></a>
<h2 id="两个窗口相互切换"><a href="#两个窗口相互切换" class="headerlink" title="两个窗口相互切换"></a>两个窗口相互切换</h2><p>假设我们有两个窗口，需要实现窗口间的相互切换，其代码如下：</p>
<p>main.qml</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.5</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">1.4</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">ApplicationWindow &#123;</span><br><span class="line">    id: mainWindow</span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    width: <span class="number">640</span></span><br><span class="line">    height: <span class="number">480</span></span><br><span class="line">    title: qsTr(<span class="string">"Main"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义了一个Welcome窗口对象，其定义见Welcome.qml</span></span><br><span class="line">    Welcome &#123;</span><br><span class="line">        id: welcomeWindow</span><br><span class="line">        title: qsTr(<span class="string">"Main Window"</span>)</span><br><span class="line">        <span class="comment">//由于一开始没有设置visible属性为true，所以Welcome不会出现</span></span><br><span class="line">        <span class="comment">// The signal handler for the opening of the main window</span></span><br><span class="line">        onSignalEnter: &#123;</span><br><span class="line">            welcomeWindow.close()     <span class="comment">// Close the first window</span></span><br><span class="line">            mainWindow.show()       <span class="comment">// Shows the main window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主窗口</span></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        color: <span class="string">"white"</span></span><br><span class="line"></span><br><span class="line">        GridLayout &#123;</span><br><span class="line">            id: grid</span><br><span class="line">            anchors.fill: parent</span><br><span class="line"></span><br><span class="line">            rows: <span class="number">2</span></span><br><span class="line">            columns: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            Rectangle &#123;</span><br><span class="line">                Layout.fillHeight: <span class="literal">true</span></span><br><span class="line">                Layout.fillWidth: <span class="literal">true</span></span><br><span class="line">                Layout.column: <span class="number">1</span></span><br><span class="line">                Layout.row: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Button to open the first secondary application window</span></span><br><span class="line">                Button &#123;</span><br><span class="line">                    text: qsTr(<span class="string">"Enter Welcome Window"</span>)</span><br><span class="line">                    anchors.centerIn: parent</span><br><span class="line">                    width: <span class="number">300</span></span><br><span class="line">                    height: <span class="number">50</span></span><br><span class="line"></span><br><span class="line">                    onClicked: &#123;</span><br><span class="line">                        welcomeWindow.show()  <span class="comment">// Open the first window</span></span><br><span class="line">                        mainWindow.hide()   <span class="comment">// Hide the main window</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Welcome.qml</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.5</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">1.4</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.2</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    id: welcomeWindow</span><br><span class="line">    signal signalEnter   <span class="comment">// Set signal</span></span><br><span class="line">    width:<span class="number">480</span></span><br><span class="line">    height:<span class="number">320</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Button to open the main application window</span></span><br><span class="line">    Button &#123;</span><br><span class="line">        text: qsTr(<span class="string">"Enter Main Window"</span>)</span><br><span class="line">        width: <span class="number">180</span></span><br><span class="line">        height: <span class="number">50</span></span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            welcomeWindow.signalEnter() <span class="comment">// invoke signal</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以看到，两个窗口间通过信号机制，实现了相互切换的功能。</p>
<h2 id="QML实现Login界面"><a href="#QML实现Login界面" class="headerlink" title="QML实现Login界面"></a>QML实现Login界面</h2><p>有些应用程序需要用户登录后，才会显示主界面，或者先打开一个Welcome界面，当用户点击进入程序后，才会进入主界面，如果在Welcome界面就点击了退出，那么相应的程序会直接退出，这个逻辑的状态机可以由下图表示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Diagram1.png" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.5</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">1.4</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.2</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    id: root</span><br><span class="line">    width: <span class="number">600</span></span><br><span class="line">    height: <span class="number">600</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    flags: Qt.Dialog</span><br><span class="line">    modality: Qt.ApplicationModal</span><br><span class="line"></span><br><span class="line">    Component &#123;</span><br><span class="line">        id:  mainWindow</span><br><span class="line">        Window &#123;</span><br><span class="line">            title: <span class="string">"mainWindow"</span></span><br><span class="line">            width: <span class="number">400</span></span><br><span class="line">            height: <span class="number">400</span></span><br><span class="line">            visible: <span class="literal">true</span></span><br><span class="line">            flags: Qt.Dialog</span><br><span class="line">            modality: Qt.ApplicationModal</span><br><span class="line">            Text &#123;</span><br><span class="line">                anchors.centerIn: parent</span><br><span class="line">                text: <span class="string">"Close me to quit program"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Button &#123;</span><br><span class="line">        anchors.centerIn: parent效果</span><br><span class="line">        text: <span class="string">"Enter main window"</span></span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="built_in">window</span> = mainWindow.createObject(root);    </span><br><span class="line">            root.hide();</span><br><span class="line">            <span class="comment">//conn.target = window;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果添加了connections部分，会实现关闭住窗口后再次回到登录界面的效果</span></span><br><span class="line">    <span class="comment">//Connections &#123;</span></span><br><span class="line">        <span class="comment">//id: conn</span></span><br><span class="line">        <span class="comment">//onVisibleChanged: &#123;</span></span><br><span class="line">            <span class="comment">//root.show();</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种方式是采用了一个Component实现的。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://doc.qt.io/qt-5/qqmlapplicationengine.html">qt官方文档</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>QML学习之路(5)——QML应用结构划分</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/QML%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(5)%E2%80%94%E2%80%94QML%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>随着QML应用的复杂化，往往需要将复杂应用划分为小单元，本文将介绍对QML进行划分的方法。</p>
<a id="more"></a>
<h2 id="文件划分"><a href="#文件划分" class="headerlink" title="文件划分"></a>文件划分</h2><p>一般来说，我们将一个具有明确功能的窗口写在一个文件里，然后写一个main.qml文件进行统一管理，例如，一个简单的main.qml文件如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.5</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">1.4</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.0</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Dialogs <span class="number">1.1</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"."</span></span><br><span class="line"></span><br><span class="line">QtObject &#123;</span><br><span class="line">    property real defaultSpacing: <span class="number">10</span></span><br><span class="line">    id: root</span><br><span class="line"></span><br><span class="line">    property <span class="keyword">var</span> splashWindow: Splash &#123;</span><br><span class="line">        onTimeout: mainWindow.visible = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property <span class="keyword">var</span> mainWindow: MainWindow &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将main.qml设置一个QtObject根元素，然后在根元素中添加相应的子元素，这里有两个子元素，一个Splash一个MainWindow，均为用户定义的QML元素，其文件如下：</p>
<p>Splash.qml</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.0</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! [splash-properties]</span></span><br><span class="line">Window &#123;</span><br><span class="line">    id: splash</span><br><span class="line">    color: <span class="string">"transparent"</span></span><br><span class="line">    title: <span class="string">"Splash Window"</span></span><br><span class="line">    modality: Qt.ApplicationModal</span><br><span class="line">    flags: Qt.SplashScreen</span><br><span class="line">    property int timeoutInterval: <span class="number">2000</span></span><br><span class="line">    signal timeout</span><br><span class="line"><span class="comment">//! [splash-properties]</span></span><br><span class="line"><span class="comment">//! [screen-properties]</span></span><br><span class="line">    x: (Screen.width - splashImage.width) / <span class="number">2</span></span><br><span class="line">    y: (Screen.height - splashImage.height) / <span class="number">2</span></span><br><span class="line"><span class="comment">//! [screen-properties]</span></span><br><span class="line">    width: splashImage.width</span><br><span class="line">    height: splashImage.height</span><br><span class="line"></span><br><span class="line">    Image &#123;</span><br><span class="line">        id: splashImage</span><br><span class="line">        source: <span class="string">"qrc:/software_images/src/timg.jpeg"</span></span><br><span class="line">        MouseArea &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            onClicked: Qt.quit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! [timer]</span></span><br><span class="line">    Timer &#123;</span><br><span class="line">        interval: timeoutInterval; running: <span class="literal">true</span>; repeat: <span class="literal">false</span></span><br><span class="line">        onTriggered: &#123;</span><br><span class="line">            visible = <span class="literal">false</span></span><br><span class="line">            splash.timeout()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! [timer]</span></span><br><span class="line">    Component.onCompleted: visible = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Component（静态划分）"><a href="#Component（静态划分）" class="headerlink" title="Component（静态划分）"></a>Component（静态划分）</h2><h2 id="Loader（动态划分）"><a href="#Loader（动态划分）" class="headerlink" title="Loader（动态划分）"></a>Loader（动态划分）</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://doc.qt.io/qt-5/qqmlapplicationengine.html">qt官方文档</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt Widget多窗口互动</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Qt%20Widget%20%E5%A4%9A%E7%AA%97%E5%8F%A3%E4%BA%92%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Qt Widget程序的多窗口互动实现进行讲解</p>
<a id="more"></a>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt信号与槽——原理分析</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>知其然，知其所以然</p>
</blockquote>
<a id="more"></a>
<p>今天面试的时候问到了Qt信号槽底层原理的实现，然后发现自己不懂，很尴尬，现在需要过来恶补一下相关的知识，同时也给自己一个教训，以后学习新内容不能只知道怎么用，还要尽可能掌握底层原理的实现。</p>
<h2 id="信号——槽机制复习"><a href="#信号——槽机制复习" class="headerlink" title="信号——槽机制复习"></a>信号——槽机制复习</h2><p>我们首先看一下官方文档是如何使用信号与槽的，我们定义一个计数器，其头文件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">valueChanged</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在cpp文件中，我们定义<code>setValue</code>函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Counter::setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != m_value) &#123;</span><br><span class="line">        m_value = value;</span><br><span class="line">        <span class="function">emit <span class="title">valueChanged</span><span class="params">(value)</span></span>;       <span class="comment">//发射信号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以这样使用我们的计数器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Counter a, b;</span><br><span class="line">QObject::connect(&amp;a, SIGNAL(valueChanged(<span class="keyword">int</span>)),</span><br><span class="line">&amp;b, SLOT(setValue(<span class="keyword">int</span>)));</span><br><span class="line"></span><br><span class="line">a.setValue(<span class="number">12</span>);  <span class="comment">// a.value() == 12, b.value() == 12</span></span><br></pre></td></tr></table></figure>
<p>从Qt诞生之初，我们就延续着这样的使用方式，但是其具体实现经历了几次变革，我们来看一下现在的Qt是如何实现信号与槽机制的。</p>
<h2 id="MOC——元对象编译"><a href="#MOC——元对象编译" class="headerlink" title="MOC——元对象编译"></a>MOC——元对象编译</h2><p>Qt的信号与槽基于运行期对对象的解析，这个解析的意思是能够在运行期列出对象的方法和属性，同时获得这些方法及属性的全部信息，例如变量的类型等等。C++采用RTTI(Runtime Type Information)来获取运行期信息。而Qt自己提供了一套工具实现内省功能，即MOC，一个代码生成器(不是预处理器)，MOC会解析头文件，生成一个额外的C++文件，在Qt中我们看到的是文件名中包含moc的文件，该文件包含了需要进行运行期内省(introspection)的代码。</p>
<blockquote>
<p>内省（Introspection）是面向对象语言和环境的一个强大特性，内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息</p>
</blockquote>
<h2 id="一些宏定义"><a href="#一些宏定义" class="headerlink" title="一些宏定义"></a>一些宏定义</h2><p>我们在使用Qt的过程中，经常会用到一些非C++本身的关键字，例如 <code>signals, slots, Q_OBJECT, emit, SIGNAL, SLOT</code>，这些是Qt对C++的一个扩展，实际上是一些简单的宏定义，在<a href="https://code.woboq.org/qt5/qtbase/src/corelib/kernel/qobjectdefs.h.html#66">qobjectdefs.h</a>文件中给出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> signals public</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slots <span class="comment">/* nothing */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> emit <span class="comment">/* nothing */</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，实际上public和slots根本什么也没有给出，更多的是对开发人员的一种提示，同理还有emit，即使你不写emit，直接写信号函数，也会触发相应的connect，说明信号本身就是一种函数。然后是著名的Q_Object宏，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_OBJECT \</span></span><br><span class="line"><span class="keyword">public</span>: \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> QMetaObject staticMetaObject; \</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> QMetaObject *<span class="title">metaObject</span><span class="params">()</span> <span class="keyword">const</span></span>; \</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> *<span class="title">qt_metacast</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>; \</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">qt_metacall</span><span class="params">(QMetaObject::Call, <span class="keyword">int</span>, <span class="keyword">void</span> **)</span></span>; \</span><br><span class="line">    QT_TR_FUNCTIONS <span class="comment">/* translations helper */</span> \</span><br><span class="line"><span class="keyword">private</span>: \</span><br><span class="line">    <span class="function">Q_DECL_HIDDEN <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qt_static_metacall</span><span class="params">(QObject *, QMetaObject::Call, <span class="keyword">int</span>, <span class="keyword">void</span> **)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，该宏定义了一系列的function和一个静态的<code>QMetaObject</code>，这些函数在哪里实现呢？就在我们的MOC文件中。</p>
<p>对于SLOT和SIGNAL，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Q_CORE_EXPORT <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">qFlagLocation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *method)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QT_NO_DEBUG</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> QLOCATION <span class="meta-string">"\0"</span> __FILE__ <span class="meta-string">":"</span> QTOSTRING(__LINE__)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SLOT(a)     qFlagLocation(<span class="meta-string">"1"</span>#a QLOCATION)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIGNAL(a)   qFlagLocation(<span class="meta-string">"2"</span>#a QLOCATION)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SLOT(a)     <span class="meta-string">"1"</span>#a</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIGNAL(a)   <span class="meta-string">"2"</span>#a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这两个宏定义就是简单地把函数名转换为字符串，然后添加到代码中。</p>
<h2 id="MOC生成了哪些代码"><a href="#MOC生成了哪些代码" class="headerlink" title="MOC生成了哪些代码"></a>MOC生成了哪些代码</h2><p>接下来我们分析MOC具体生成的代码有什么作用。</p>
<h3 id="The-QMetaObject"><a href="#The-QMetaObject" class="headerlink" title="The QMetaObject"></a>The QMetaObject</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static const QMetaObject staticMetaObject; </span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> QMetaObject Counter::staticMetaObject = &#123;</span><br><span class="line">    &#123; &amp;QObject::staticMetaObject, qt_meta_stringdata_Counter.data,</span><br><span class="line">      qt_meta_data_Counter,  qt_static_metacall, Q_NULLPTR, Q_NULLPTR&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//virtual const QMetaObject *metaObject() const; </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> QMetaObject *<span class="title">Counter::metaObject</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QObject::d_ptr-&gt;metaObject ? QObject::d_ptr-&gt;dynamicMetaObject() : &amp;staticMetaObject;  <span class="comment">//QObject::d_ptr-&gt;metaObject 被用于动态元对象，如果是静态的，直接返回staticMetaObject</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义在<a href="https://code.woboq.org/qt5/qtbase/src/corelib/kernel/qobjectdefs.h.html#QMetaObject">qobjectdefs.h</a>的元对象如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QMetaObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* ... Skiped all the public functions ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Call &#123; InvokeMetaMethod, ReadProperty, WriteProperty, <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">// private data</span></span><br><span class="line">        <span class="keyword">const</span> QMetaObject *superdata;</span><br><span class="line">        <span class="keyword">const</span> QByteArrayData *stringdata;</span><br><span class="line">        <span class="keyword">const</span> uint *data;</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*StaticMetacallFunction)</span><span class="params">(QObject *, QMetaObject::Call, <span class="keyword">int</span>, <span class="keyword">void</span> **)</span></span>;</span><br><span class="line">        StaticMetacallFunction static_metacall;</span><br><span class="line">        <span class="keyword">const</span> QMetaObject **relatedMetaObjects;</span><br><span class="line">        <span class="keyword">void</span> *extradata; <span class="comment">//reserved for future use</span></span><br><span class="line">    &#125; d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此处的间接<code>d</code>表示这些对象应当为私有的，但实际并不是私有的，是为了能够静态初始化以及让其作为POD类</p>
<blockquote>
<p>POD类类型就是指class、struct、union，且不具有用户定义的构造函数、析构函数、拷贝算子、赋值算子；不具有继承关系，因此没有基类；不具有虚函数，所以就没有虚表；非静态数据成员没有私有或保护属性的、没有引用类型的、没有非POD类类型的（即嵌套类都必须是POD）、没有指针到成员类型的（因为这个类型内含了this指针）。</p>
</blockquote>
<p><code>QMetaObject *superdata</code>和父类的元对象一起初始化（此处为QObject::staticMetaObject，因为Counter继承自QObject），<code>stringdata</code> and <code>data</code>稍后解释。</p>
<h3 id="Introspection-Tables——内省表"><a href="#Introspection-Tables——内省表" class="headerlink" title="Introspection Tables——内省表"></a>Introspection Tables——内省表</h3><p>我们首先分析一下元对象集成的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint qt_meta_data_Counter[] = &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// content:</span></span><br><span class="line">       <span class="number">7</span>,       <span class="comment">// revision</span></span><br><span class="line">       <span class="number">0</span>,       <span class="comment">// classname</span></span><br><span class="line">       <span class="number">0</span>,    <span class="number">0</span>, <span class="comment">// classinfo</span></span><br><span class="line">       <span class="number">2</span>,   <span class="number">14</span>, <span class="comment">// methods</span></span><br><span class="line">       <span class="number">0</span>,    <span class="number">0</span>, <span class="comment">// properties</span></span><br><span class="line">       <span class="number">0</span>,    <span class="number">0</span>, <span class="comment">// enums/sets</span></span><br><span class="line">       <span class="number">0</span>,    <span class="number">0</span>, <span class="comment">// constructors</span></span><br><span class="line">       <span class="number">0</span>,       <span class="comment">// flags</span></span><br><span class="line">       <span class="number">1</span>,       <span class="comment">// signalCount</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// signals: name, argc, parameters, tag, flags</span></span><br><span class="line">       <span class="number">1</span>,    <span class="number">1</span>,   <span class="number">24</span>,    <span class="number">2</span>, <span class="number">0x06</span> <span class="comment">/* Public */</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// slots: name, argc, parameters, tag, flags</span></span><br><span class="line">       <span class="number">4</span>,    <span class="number">1</span>,   <span class="number">27</span>,    <span class="number">2</span>, <span class="number">0x0a</span> <span class="comment">/* Public */</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// signals: parameters</span></span><br><span class="line">    QMetaType::Void, QMetaType::Int,    <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// slots: parameters</span></span><br><span class="line">    QMetaType::Void, QMetaType::Int,    <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">0</span>        <span class="comment">// eod</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前13个整数如果包含两列，第一列为计数，第二列表示方法描述在该array中的index，在本例中，我们有2个方法，同时方法的描述从14位开始。方法的描述由5个整数组成，具体如下：</p>
<ul>
<li>name：一个string table中的索引</li>
<li>argc：参数个数</li>
<li>parameters：参数位置索引</li>
<li>tag和flags暂略</li>
</ul>
<p>对于每个函数，moc还会保存每个parameter的返回类型，以及他们对于name的类型和索引位置。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://woboq.com/blog/how-qt-signals-slots-work.html">信号与槽底层内容讲解</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt学习之路——Model/View</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Qt%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94ModelView/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Qt中的Model/View结构进行介绍。</p>
<a id="more"></a>
<h2 id="Model-View结构"><a href="#Model-View结构" class="headerlink" title="Model/View结构"></a>Model/View结构</h2><p>Qt通过Model/View实现了数据与接口的分离，降低了耦合性，在该结构中：</p>
<ul>
<li>View是前端，是用于展示、编辑数据的可视化组件</li>
<li>Model是后端，是视图与原始数据的接口</li>
</ul>
<p>Model/View的一个典型应用是数据库应用，例如将数据库中一个页在view中进行展示与编辑。Model/View基本结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/modelview-overview.png" alt=""></p>
<p>图中还有一个代理环节，可以方便用户定制数据的显示方式和编辑方式。</p>
<h2 id="Model-View在Qt中的实现"><a href="#Model-View在Qt中的实现" class="headerlink" title="Model/View在Qt中的实现"></a>Model/View在Qt中的实现</h2><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>基于项数据（item data）的数据模型（Model）都是基于QAbstractItemModel类，该类定义了两个主要部件：</p>
<ul>
<li>视图组件：用于显示</li>
<li>数据处理接口：用于数据存取</li>
</ul>
<p>根据数据结构的不同，Qt提供了若干模型类，其层次结构如下图。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Models.png" alt=""></p>
<p>其中的抽象类不能直接使用，如果里面的模型类无法实现，我们可以基于抽象类构建自己的Model</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><h2 id="自定义Model"><a href="#自定义Model" class="headerlink" title="自定义Model"></a>自定义Model</h2><h3 id="QAbstractTableModel使用2"><a href="#QAbstractTableModel使用2" class="headerlink" title="QAbstractTableModel使用2"></a>QAbstractTableModel使用<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3><p>这里以QAbstractTableModel为例，介绍如何自定义Model</p>
<h4 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h4><ul>
<li>main.cpp</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"currencymodel.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//数据源  </span></span><br><span class="line">    QMap&lt;QString, <span class="keyword">double</span>&gt; currencyMap;  </span><br><span class="line">    currencyMap.insert(<span class="string">"AUD"</span>, <span class="number">1.3259</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"CHF"</span>, <span class="number">1.2970</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"CZK"</span>, <span class="number">24.510</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"DKK"</span>, <span class="number">6.2168</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"EUR"</span>, <span class="number">0.8333</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"GBP"</span>, <span class="number">0.5661</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"HKD"</span>, <span class="number">7.7562</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"JPY"</span>, <span class="number">112.92</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"NOK"</span>, <span class="number">6.5200</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"NZD"</span>, <span class="number">1.4697</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"SEK"</span>, <span class="number">7.8180</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"SGD"</span>, <span class="number">1.6901</span>);  </span><br><span class="line">    currencyMap.insert(<span class="string">"USD"</span>, <span class="number">1.0000</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//自定义表模型  </span></span><br><span class="line">    CurrencyModel currencyModel;  </span><br><span class="line">    currencyModel.setCurrencyMap(currencyMap);  </span><br><span class="line">    <span class="comment">//表视图  </span></span><br><span class="line">    QTableView tableView;  </span><br><span class="line">    <span class="comment">//设置视图模型  </span></span><br><span class="line">    <span class="comment">//********************重点是这句话，用标准的QTableView载入我们自己定义的模型</span></span><br><span class="line">    tableView.setModel(&amp;currencyModel);    </span><br><span class="line">    <span class="comment">//设置交替颜色  </span></span><br><span class="line">    tableView.setAlternatingRowColors(<span class="literal">true</span>);  </span><br><span class="line">  </span><br><span class="line">    tableView.setWindowTitle(QObject::tr(<span class="string">"Currencies"</span>));  </span><br><span class="line">    tableView.show();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> app.exec();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<ul>
<li>currencymodel.h</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CURRENCYMODEL_H  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENCYMODEL_H  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAbstractTableModel&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMap&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurrencyModel</span> :</span> <span class="keyword">public</span> QAbstractTableModel  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    CurrencyModel(QObject *parent = <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCurrencyMap</span><span class="params">(<span class="keyword">const</span> QMap&lt;QString, <span class="keyword">double</span>&gt; &amp;<span class="built_in">map</span>)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rowCount</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;parent)</span> <span class="keyword">const</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">columnCount</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;parent)</span> <span class="keyword">const</span></span>;  </span><br><span class="line">    <span class="function">QVariant <span class="title">data</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index, <span class="keyword">int</span> role)</span> <span class="keyword">const</span></span>;  </span><br><span class="line">    <span class="function">QVariant <span class="title">headerData</span><span class="params">(<span class="keyword">int</span> section, Qt::Orientation orientation,  </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> role)</span> <span class="keyword">const</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function">QString <span class="title">currencyAt</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span></span>;  </span><br><span class="line">  </span><br><span class="line">    QMap&lt;QString, <span class="keyword">double</span>&gt; currencyMap;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</div></div>
<ul>
<li>currencymodel.cpp</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"currencymodel.h"</span>  </span></span><br><span class="line">  </span><br><span class="line">CurrencyModel::CurrencyModel(QObject *parent)  </span><br><span class="line">    : QAbstractTableModel(parent)  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CurrencyModel::setCurrencyMap</span><span class="params">(<span class="keyword">const</span> QMap&lt;QString, <span class="keyword">double</span>&gt; &amp;<span class="built_in">map</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    currencyMap = <span class="built_in">map</span>;  </span><br><span class="line">    <span class="comment">//重置模型至原始状态，告诉所有视图，他们数据都无效，强制刷新数据  </span></span><br><span class="line">    reset();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//返回行数  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CurrencyModel::rowCount</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp; <span class="comment">/* parent */</span>)</span> <span class="keyword">const</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> currencyMap.count();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//返回列数  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CurrencyModel::columnCount</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp; <span class="comment">/* parent */</span>)</span> <span class="keyword">const</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> currencyMap.count();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//返回一个项的任意角色的值，这个项被指定为QModelIndex  </span></span><br><span class="line"><span class="function">QVariant <span class="title">CurrencyModel::data</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index, <span class="keyword">int</span> role)</span> <span class="keyword">const</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!index.isValid())  </span><br><span class="line">        <span class="keyword">return</span> QVariant();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (role == Qt::TextAlignmentRole) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(Qt::AlignRight | Qt::AlignVCenter);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (role == Qt::DisplayRole) &#123;  </span><br><span class="line">        QString rowCurrency = currencyAt(index.row());  </span><br><span class="line">        QString columnCurrency = currencyAt(index.column());  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (currencyMap.value(rowCurrency) == <span class="number">0.0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"####"</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">double</span> amount = currencyMap.value(columnCurrency)  </span><br><span class="line">                        / currencyMap.value(rowCurrency);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> QString(<span class="string">"%1"</span>).arg(amount, <span class="number">0</span>, <span class="string">'f'</span>, <span class="number">4</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> QVariant();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//返回表头名称,(行号或列号，水平或垂直，角色)  </span></span><br><span class="line"><span class="function">QVariant <span class="title">CurrencyModel::headerData</span><span class="params">(<span class="keyword">int</span> section,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                   Qt::Orientation <span class="comment">/* orientation */</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> role)</span> <span class="keyword">const</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (role != Qt::DisplayRole)  </span><br><span class="line">        <span class="keyword">return</span> QVariant();  </span><br><span class="line">    <span class="keyword">return</span> currencyAt(section);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//获取当前关键字  </span></span><br><span class="line"><span class="function">QString <span class="title">CurrencyModel::currencyAt</span><span class="params">(<span class="keyword">int</span> offset)</span> <span class="keyword">const</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (currencyMap.begin() + offset).key();  </span><br><span class="line">&#125;  &#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p>注意：<strong>在上面的代码中，headerData函数是必须实质性实现的，否则运行时会抛出std::bad_alloc导致异常</strong>。具体原因在view的setModel函数中，这里不深究了，总之要将这个函数实质性实现</p>
<h2 id="自定义代理"><a href="#自定义代理" class="headerlink" title="自定义代理"></a>自定义代理</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="">qt官方教程</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt处理Json文件</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Qt%E5%A4%84%E7%90%86json%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对使用Qt处理Json文件的过程进行讲解。</p>
<a id="more"></a>
<h2 id="Json介绍"><a href="#Json介绍" class="headerlink" title="Json介绍"></a>Json介绍</h2><p>Json是一种轻量化的数据交换格式，使用非常方便，采用键值对的方式进行数据保存及索引。同时，Json支持多级嵌套格式，一个Json文件下，可以包含多个子Json内容。一个典型的Json文件格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">   <span class="comment">/*JSON 块1*/</span></span><br><span class="line">   <span class="string">"appDesc"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"SomeDescription"</span>,</span><br><span class="line">      <span class="string">"message"</span>: <span class="string">"SomeMessage"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">/*JSON 块2*/</span></span><br><span class="line">   <span class="string">"appName"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"Home"</span>,</span><br><span class="line">      <span class="string">"message"</span>: <span class="string">"Welcome"</span>,</span><br><span class="line">      <span class="string">"imp"</span>:[<span class="string">"awesome"</span>,<span class="string">"best"</span>,<span class="string">"good"</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Qt读取Json文件的步骤"><a href="#使用Qt读取Json文件的步骤" class="headerlink" title="使用Qt读取Json文件的步骤"></a>使用Qt读取Json文件的步骤</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p>在Qt中，提供了一些处理Json文件的类，本节列举一些重要的类对其作用和使用方法进行总结。</p>
<h4 id="QJsonDocument"><a href="#QJsonDocument" class="headerlink" title="QJsonDocument"></a>QJsonDocument</h4><p>这个类的作用是将一个Utf8类型的字符串转换为一个Json Document对象，其使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString val = file.readAll();</span><br><span class="line">file.close();</span><br><span class="line">QJsonDocument d = QJsonDocument::fromJson(val.toUtf8());</span><br></pre></td></tr></table></figure>
<h4 id="QJsonObject"><a href="#QJsonObject" class="headerlink" title="QJsonObject"></a>QJsonObject</h4><p>该类是最关键的一个json类，能够获得一个json对象，通过键即可返回相应的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QJsonDocument d = QJsonDocument::fromJson(val.toUtf8());</span><br><span class="line">QJsonObject sett2 = d.object();   <span class="comment">//将json document 转换为json object</span></span><br></pre></td></tr></table></figure>
<h4 id="QJsonValue"><a href="#QJsonValue" class="headerlink" title="QJsonValue"></a>QJsonValue</h4><p>保存解析json对象得到的值，类型根据值的类型确定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QJsonValue value = sett2.value(QString(<span class="string">"appName"</span>));  <span class="comment">//获得"appName"键对应的值</span></span><br></pre></td></tr></table></figure>
<h4 id="QJsonArray"><a href="#QJsonArray" class="headerlink" title="QJsonArray"></a>QJsonArray</h4><p>获得一系列的json值组成的array，在很多情况下，json键值对保存的不是单一的值，而是若干值组成的列表，通过QJsonArray我们就能得到一个由QJsonValue组成的array，然后可以和vector、string等进行转换，从而完成矩阵或向量数据的导入及处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QJsonArray test = item[&quot;imp&quot;].toArray();</span><br></pre></td></tr></table></figure>
<h3 id="获得所有键值"><a href="#获得所有键值" class="headerlink" title="获得所有键值"></a>获得所有键值</h3><p>有些情况下我们需要遍历所有的键值，便利过程的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QJsonObject json = doc.object();</span><br><span class="line">foreach(<span class="keyword">const</span> QString&amp; key, json.keys()) &#123;</span><br><span class="line">    QJsonValue value = json.value(key);</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Key = "</span> &lt;&lt; key &lt;&lt; <span class="string">", Value = "</span> &lt;&lt; value.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* test.json */</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"appDesc"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"SomeDescription"</span>,</span><br><span class="line">      <span class="string">"message"</span>: <span class="string">"SomeMessage"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"appName"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"Home"</span>,</span><br><span class="line">      <span class="string">"message"</span>: <span class="string">"Welcome"</span>,</span><br><span class="line">      <span class="string">"imp"</span>:[<span class="string">"awesome"</span>,<span class="string">"best"</span>,<span class="string">"good"</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readJson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    QString val;</span><br><span class="line">    QFile file;</span><br><span class="line">    file.setFileName(<span class="string">"test.json"</span>);</span><br><span class="line">    file.open(QIODevice::ReadOnly | QIODevice::Text);</span><br><span class="line">    val = file.readAll();</span><br><span class="line">    file.close();</span><br><span class="line"></span><br><span class="line">    QJsonDocument d = QJsonDocument::fromJson(val.toUtf8());</span><br><span class="line">    QJsonObject sett2 = d.object();</span><br><span class="line">    QJsonValue value = sett2.value(QString(<span class="string">"appName"</span>));</span><br><span class="line">    </span><br><span class="line">    QJsonObject item = value.toObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* in case of string value get value and convert into string*/</span></span><br><span class="line">    qWarning() &lt;&lt; tr(<span class="string">"QJsonObject[appName] of description: "</span>) &lt;&lt; item[<span class="string">"description"</span>];</span><br><span class="line">    QJsonValue subobj = item[<span class="string">"description"</span>];</span><br><span class="line">    qWarning() &lt;&lt; subobj.toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* in case of array get array and convert into string*/</span></span><br><span class="line">    qWarning() &lt;&lt; tr(<span class="string">"QJsonObject[appName] of value: "</span>) &lt;&lt; item[<span class="string">"imp"</span>];</span><br><span class="line">    QJsonArray test = item[<span class="string">"imp"</span>].toArray();</span><br><span class="line">    qWarning() &lt;&lt; test[<span class="number">1</span>].toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt学习之路——单元测试</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Qt%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>测试不规范，亲人两行泪</p>
</blockquote>
<a id="more"></a>
<p>在编程过程中，我们往往需要针对模块进行测试，特别是针对某些边界输入条件，从而保证程序的Robustness，本文将针对Qt下进行单元测试的过程进行讲解</p>
<h2 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h2><p>假设我们需要针对QString进行单元测试，首先，我们需要一个类包含测试函数，该类继承自QObject</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtTest/QtTest&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestQString</span> :</span> <span class="keyword">public</span> QObject&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toUpper</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQString::toUpper</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str = <span class="string">"Hello"</span>;</span><br><span class="line">    QVERIFY(str.toUpper() == <span class="string">"HELLO"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要更详细的testlog，可以使用<code>QCOMPARE()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQString::toUpper</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str = <span class="string">"Hello"</span>;</span><br><span class="line">    QCOMPARE(str.toUpper(), QString(<span class="string">"HELLO"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后加入这两句话进行测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTEST_MAIN(TestQString)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"testqstring.moc"</span>  <span class="comment">//如果类的定义和声明在一起，那么把这一句加上</span></span></span><br></pre></td></tr></table></figure>
<h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><p>假设我们的test文件在一个空文件夹中被保存为<code>testqstring.cpp</code> ，那么我们可以使用qmake创建并产生一个makefile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/myTestDirectory$ qmake -project &quot;QT += testlib&quot;</span><br><span class="line">/myTestDirectory$ qmake</span><br><span class="line">/myTestDirectory$ make</span><br></pre></td></tr></table></figure>
<p><strong>注意，在测试过程中必须要把被测试文件放在和测试文件一个目录下，否则会造成：[Qt undefined reference to vtable</strong>，这个问题是由于MOC文件需要知道被测试文件所在位置，但是如果不在一个文件夹下，.pro文件不会自动把被测试文件添加进来，这里还需要改进。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://doc.qt.io/qt-5/qttestlib-tutorial1-example.html">Qt测试</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt程序基本框架</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Qt%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Qt：HelloWorld"><a href="#Qt：HelloWorld" class="headerlink" title="Qt：HelloWorld"></a>Qt：HelloWorld</h2><p>本文将针对Qt程序的基本框架进行讲解。</p>
<a id="more"></a>
<h2 id="一个简单的Qt工程"><a href="#一个简单的Qt工程" class="headerlink" title="一个简单的Qt工程"></a>一个简单的Qt工程</h2><p>一个简单的Qt工程主函数代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;       <span class="comment">//建立app</span></span><br><span class="line">    TetrixWindow window;</span><br><span class="line">    window.show();</span><br><span class="line">    qsrand(QTime(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>).secsTo(QTime::currentTime()));</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中主要包括两个部分</p>
<ol>
<li>QApplication的建立，QApplication主要用于为QWidget应用程序提供特定的初始化及定制化，<strong>一个Qt程序可能有多个窗口，但只有一个QApplication对象</strong>。</li>
<li>窗口的定制与显示</li>
</ol>
<p>关于QApplication需要注意的两点</p>
<ul>
<li>如果不使用QWidget，那么应当使用QGuiApplication</li>
<li>如果需要同时提供GUI和非GUI版本，可以使用下面的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QCoreApplication* <span class="title">createApplication</span><span class="params">(<span class="keyword">int</span> &amp;argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!qstrcmp(argv[i], <span class="string">"-no-gui"</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> QCoreApplication(argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> QApplication(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QScopedPointer&lt;QCoreApplication&gt; <span class="title">app</span><span class="params">(createApplication(argc, argv))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qobject_cast&lt;QApplication *&gt;(app.data())) &#123;</span><br><span class="line">       <span class="comment">// start GUI version...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// start non-GUI version...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app-&gt;exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt知识库导航</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Qt%E7%9F%A5%E8%AF%86%E5%BA%93%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>花里胡哨的，但是我喜欢</p>
</blockquote>
<a id="more"></a>
<h2 id="课程视频"><a href="#课程视频" class="headerlink" title="课程视频"></a>课程视频</h2><h3 id="qml-tutorial-for-beginners"><a href="#qml-tutorial-for-beginners" class="headerlink" title="qml tutorial for beginners"></a>qml tutorial for beginners</h3><div class="table-container">
<table>
<thead>
<tr>
<th>章节</th>
<th>内容</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>01 Introduction</td>
<td></td>
<td>完成</td>
</tr>
<tr>
<td>07 Positioning</td>
<td>Anchors</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt Widget程序布局</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Qt%20Widget%E7%A8%8B%E5%BA%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Qt Widget程序的布局进行讲解</p>
<a id="more"></a>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt调用数据库</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Qt%E8%B0%83%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Qt调用数据库的过程进行讲解。</p>
<a id="more"></a>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>本文使用的数据库是MySQL。由于Qt提供了多个数据库的驱动，因此对于其他数据库，调用方法大同小异。</p>
<h3 id="pro文件修改"><a href="#pro文件修改" class="headerlink" title="pro文件修改"></a>pro文件修改</h3><p>在项目工程文件中加入下列语句使用数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QT       += sql</span><br></pre></td></tr></table></figure>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>在需要使用数据库的代码中加入下面的头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtSql&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="数据库调用"><a href="#数据库调用" class="headerlink" title="数据库调用"></a>数据库调用</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>创建数据库对象的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::addDatabase(<span class="string">"QMYSQL"</span>);   <span class="comment">// 载入QMYSQL驱动支持MySQL</span></span><br><span class="line">db.setHostName(<span class="string">"127.0.0.1"</span>);                             <span class="comment">// 数据库服务器</span></span><br><span class="line">db.setPort(<span class="number">3306</span>);                                        <span class="comment">// 数据库端口</span></span><br><span class="line">db.setDatabaseName(<span class="string">"test"</span>);                              <span class="comment">// 数据库名称</span></span><br><span class="line">db.setUserName(<span class="string">"root"</span>);                                  <span class="comment">// 用户名</span></span><br><span class="line">db.setPassword(<span class="string">"duan"</span>);                                  <span class="comment">// 密码</span></span><br></pre></td></tr></table></figure>
<h3 id="判断数据库状态"><a href="#判断数据库状态" class="headerlink" title="判断数据库状态"></a>判断数据库状态</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!db.open()) &#123;</span><br><span class="line">    QMessageBox::critical(<span class="number">0</span>, <span class="string">"Cannot open database1"</span>,</span><br><span class="line">                          <span class="string">"Unable to establish a database connection."</span>, QMessageBox::Cancel);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h2><p>当没有数据库的驱动时，运行程序会提示驱动未加载，并给出可以使用的驱动。这里还没有搞定，因此暂时放一下。（傻逼windows，艹，建议果断放弃转投linux，总之搞了半天没装上驱动。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QSqlDatabase: QMYSQL driver not loaded</span><br><span class="line">QSqlDatabase: available drivers: QSQLITE QODBC QODBC3 QPSQL QPSQL7</span><br></pre></td></tr></table></figure>
<p>由于Qt不再提供MySQL的驱动支持，需要我们自己安装，安装方法包括自己编译与下载编译好的DLL（Windows真是麻烦）</p>
<h3 id="手工编译"><a href="#手工编译" class="headerlink" title="手工编译"></a>手工编译</h3><p>1 在Qt安装目录下找到Qt\5.15.0\Src\qtbase\src\plugins\sqldrivers这个文件夹并进入</p>
<p>2 执行下列命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qmake -- MYSQL_INCDIR="C:/Program Files/MySQL/MySQL Server 8.0/include" MYSQL_LIBDIR="C:/Program Files/MySQL/MySQL Server 8.0/lib"</span><br></pre></td></tr></table></figure>
<p>将命令中的<code>MySQL Server 8.0/include</code>和<code>MySQL Server 8.0/lib</code>更换为自己的MySQL安装路径。</p>
<p>3 运行<code>make &amp;&amp; make install</code></p>
<h3 id="下载DLL"><a href="#下载DLL" class="headerlink" title="下载DLL"></a>下载DLL</h3><p>下载<code>libmysqld.dll</code>和<code>libmysql.dll</code>两个文件，放到qt的编译器目录下，我的是<code>Qt\5.15.0\mingw81_64\bin</code></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Splash Window</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/Splash%20Window/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在编写QML应用程序时，有时我们希望添加一个Splash Window（就是各种应用启动时的加载界面），本文将针对如何在纯QML环境下实现Splash Window进行总结，本教程基于Qt官方Example：Window and Screen</p>
<a id="more"></a>
<h2 id="Splash-WIndow定义"><a href="#Splash-WIndow定义" class="headerlink" title="Splash WIndow定义"></a>Splash WIndow定义</h2><p>创建一个QML文件Splash.qml，单独对Splash Window进行定义，一般的Splash文件是一张图片，附带一些程序加载的信息即可，代码如下：</p>
<p>Splash.qml</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.0</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! [splash-properties]</span></span><br><span class="line">Window &#123;</span><br><span class="line">    id: splash</span><br><span class="line">    color: <span class="string">"transparent"</span>       <span class="comment">//方便加载splash image的透明部分，从而创建异形splash window</span></span><br><span class="line">    title: <span class="string">"Splash Window"</span>     </span><br><span class="line">    modality: Qt.ApplicationModal   </span><br><span class="line">    flags: Qt.SplashScreen    </span><br><span class="line">    property int timeoutInterval: <span class="number">2000</span>   <span class="comment">//splash持续两秒钟</span></span><br><span class="line">    signal timeout      <span class="comment">//时间结束信号</span></span><br><span class="line"><span class="comment">//! [splash-properties]</span></span><br><span class="line"><span class="comment">//! [screen-properties]</span></span><br><span class="line">    <span class="comment">//splash window长宽</span></span><br><span class="line">    x: (Screen.width - splashImage.width) / <span class="number">2</span> </span><br><span class="line">    y: (Screen.height - splashImage.height) / <span class="number">2</span></span><br><span class="line"><span class="comment">//! [screen-properties]</span></span><br><span class="line">    width: splashImage.width</span><br><span class="line">    height: splashImage.height</span><br><span class="line"></span><br><span class="line">    Image &#123;</span><br><span class="line">        id: splashImage</span><br><span class="line">        source: <span class="string">"../shared/images/qt-logo.png"</span></span><br><span class="line">        MouseArea &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            onClicked: Qt.quit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! [timer]</span></span><br><span class="line">    <span class="comment">//创建一个定时器用于记录splash window的显示时间，从而自动隐藏splash window</span></span><br><span class="line">    Timer &#123;</span><br><span class="line">        interval: timeoutInterval; running: <span class="literal">true</span>; repeat: <span class="literal">false</span></span><br><span class="line">        onTriggered: &#123; 内容略</span><br><span class="line">            visible = <span class="literal">false</span>   <span class="comment">//触发后隐藏splash window，然后发送timeout信号</span></span><br><span class="line">            splash.timeout()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! [timer]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当作为Component启动时，设为可见</span></span><br><span class="line">    Component.onCompleted: visible = <span class="literal">true</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Root-Window定义"><a href="#Root-Window定义" class="headerlink" title="Root Window定义"></a>Root Window定义</h2><p>一般我们的QML程序都需要一个root object，用于管理所有的属性，我们的root object文件如下：</p>
<p>main.qml</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.5</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">1.4</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.0</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Dialogs <span class="number">1.1</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"."</span></span><br><span class="line"></span><br><span class="line">QtObject &#123;</span><br><span class="line">    property real defaultSpacing: <span class="number">10</span></span><br><span class="line">    property SystemPalette palette: SystemPalette &#123; &#125;</span><br><span class="line">    id: root</span><br><span class="line"></span><br><span class="line">    property <span class="keyword">var</span> splashWindow: Splash &#123;</span><br><span class="line">        onTimeout: mainWindow.visible = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property <span class="keyword">var</span> mainWindow: MainWindow &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内容很简单，只有splash window和main window两个属性，其中main window受splash控制，一旦接收到超时信号，便将mainWindow显示出来，通过上述举措，就可以实现一个Splash效果，mainWindow内容略。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="">Qt Examples：window and screen</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt Quick StackView介绍</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/StackView/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Qt中的页面或视图管理组件StackView进行讲解</p>
<a id="more"></a>
<h2 id="StackView介绍"><a href="#StackView介绍" class="headerlink" title="StackView介绍"></a>StackView介绍</h2><p>StackView实现了对于页面或视图的栈方式导航（FIFO）</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>以飞机大战为例讲解Qt Scene的基本使用原理</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/%E4%BB%A5%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E4%B8%BA%E4%BE%8B%E8%AE%B2%E8%A7%A3Qt%20Scene%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Let’s make a GAME!!!!</p>
</blockquote>
<a id="more"></a>
<p>本文将以Qt设计的一个飞机大战为例，讲解小游戏开发的一些基本要素。</p>
<h2 id="基于Qt-Scene的场景构建"><a href="#基于Qt-Scene的场景构建" class="headerlink" title="基于Qt Scene的场景构建"></a>基于Qt Scene的场景构建</h2><h3 id="场景、视窗和对象"><a href="#场景、视窗和对象" class="headerlink" title="场景、视窗和对象"></a>场景、视窗和对象</h3><h4 id="QGraphicsScene"><a href="#QGraphicsScene" class="headerlink" title="QGraphicsScene"></a>QGraphicsScene</h4><p>这个类就像一个场景类，你可以向场景类中添加各种各样的对象，例如放入一只猫或者一个英雄等等</p>
<h4 id="QGraphicsView"><a href="#QGraphicsView" class="headerlink" title="QGraphicsView"></a>QGraphicsView</h4><p>这个类用于将场景进行可视化，如果不可视化场景，我们便看不到任何东西</p>
<h4 id="QGraphicsItem"><a href="#QGraphicsItem" class="headerlink" title="QGraphicsItem"></a>QGraphicsItem</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>这个类就是我们可以向场景中添加的对象，例如一个矩形（QGraphicsRectItem）</p>
<h5 id="Item的组合"><a href="#Item的组合" class="headerlink" title="Item的组合"></a>Item的组合</h5><p>每个item可以有自己的parent，从而我们可以将多个item进行组合，这对于创造复杂的对象很有帮助，例如如果我们想创建一个坦克，坦克包含如下部分：</p>
<ul>
<li>炮管</li>
<li>车身</li>
</ul>
<p>我们可以令车身为炮管的parent，当parent被销毁时，child也会被销毁；而当chlid被销毁时，parent不会被销毁，这样我们可以实现如下的逻辑：当车身被打坏时，炮管连带也被销毁，而当炮管被打坏时，车身还在。</p>
<h3 id="构建一个基本场景"><a href="#构建一个基本场景" class="headerlink" title="构建一个基本场景"></a>构建一个基本场景</h3><h4 id="综合代码"><a href="#综合代码" class="headerlink" title="综合代码"></a>综合代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGraphicsScene&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGraphicsItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QGraphicsView&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a scene</span></span><br><span class="line">    QGraphicsScene *scene = <span class="keyword">new</span> QGraphicsScene();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create an item </span></span><br><span class="line">    QGraphicsRectItem *rect = <span class="keyword">new</span> QGraphicsRectItem();</span><br><span class="line">    rect-&gt;setRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);    <span class="comment">//0,0代表在view中的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add the item to the scene</span></span><br><span class="line">    scene-&gt;addItem(rect);   <span class="comment">//在场景中添加item</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add a view, Without a view, nothing can be seen</span></span><br><span class="line">    QGraphicsView* view = <span class="keyword">new</span> QGraphicsView(scene);</span><br><span class="line">    view-&gt;show();  <span class="comment">//显示</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h4><p>三者关系可以用下图进行表示</p>
<pre class="mermaid">graph TB
    subgraph QGraphicsScene

        subgraph QGraphicsView
            object1[QGraphicsRectItem]
        end

    end</pre>

<p>视觉效果从上图可以看出，QGraphicsView其实就是可见区域，需要注意的是，当存在多个Item时，View默认是以多个Item的中心作为中心的，我们可以设置以某一个具体的Item作为中心或者以整个Scene作为中心。</p>
<h4 id="坐标系系统"><a href="#坐标系系统" class="headerlink" title="坐标系系统"></a>坐标系系统</h4><p>在Qt中，有三个坐标系系统需要我们注意：Scene、View和Item，左上角是三个坐标系的原点，通过改变其位置，我们能够得到不同的视觉效果。</p>
<h3 id="对场景类的修改"><a href="#对场景类的修改" class="headerlink" title="对场景类的修改"></a>对场景类的修改</h3><h4 id="尺寸修改"><a href="#尺寸修改" class="headerlink" title="尺寸修改"></a>尺寸修改</h4><p>我们可以设置场景类的一些关键参数，从而实现理想的场景效果，例如在QGraphcsScene中，如果我们不限定其大小，随着场景中item越来越多，那么我们的Scene尺寸会越来越大，一般来说，我们会将Scene的尺寸和view的尺寸设置为一致。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">view-&gt;setFixedSize(<span class="number">800</span>,<span class="number">600</span>);</span><br><span class="line">scene-&gt;setSceneRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">800</span>,<span class="number">600</span>);</span><br><span class="line">player-&gt;setPos(view-&gt;width()/<span class="number">2</span>-player-&gt;rect().width()/<span class="number">2</span>,view-&gt;height() - player-&gt;rect().height()); <span class="comment">//设置玩家相对与view的位置</span></span><br><span class="line">view-&gt;show();</span><br></pre></td></tr></table></figure>
<h3 id="对Item类的修改"><a href="#对Item类的修改" class="headerlink" title="对Item类的修改"></a>对Item类的修改</h3><h4 id="添加item"><a href="#添加item" class="headerlink" title="添加item"></a>添加item</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> Qt::Key_Space:    <span class="comment">//按下空格键</span></span><br><span class="line">    Bullet* bullet = <span class="keyword">new</span> Bullet();  <span class="comment">//创建一个新item</span></span><br><span class="line">    bullet-&gt;setPos(x(),y());         <span class="comment">//设置item的位置</span></span><br><span class="line">    scene()-&gt;addItem(bullet);        <span class="comment">//添加item至场景中</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h4 id="删除item"><a href="#删除item" class="headerlink" title="删除item"></a>删除item</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(pos().y() &lt; <span class="number">0</span> - <span class="keyword">this</span>-&gt;rect().height())&#123;</span><br><span class="line">    scene()-&gt;removeItem(<span class="keyword">this</span>);   <span class="comment">//当子弹跑出场景外时，从场景中移除对象</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="音频和图像"><a href="#音频和图像" class="headerlink" title="音频和图像"></a>音频和图像</h2><h3 id="音频及图像Resources管理"><a href="#音频及图像Resources管理" class="headerlink" title="音频及图像Resources管理"></a>音频及图像Resources管理</h3><p>一般来说，我们将多媒体素材放置在Qt的resourse中，右键项目，Add New，在Qt一栏中选择resource，即可添加，其后缀为.qrc。点击add prefix可以添加前缀，就是划分文件夹以便分类保管不同的资源。</p>
<h3 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h3><h4 id="配置工程文件"><a href="#配置工程文件" class="headerlink" title="配置工程文件"></a>配置工程文件</h4><p>为了添加声音，我们需要使用多媒体，修改项目工程文件，在Qt组件中添加多媒体</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">QT       += core gui \</span><br><span class="line">            multimedia</span><br></pre></td></tr></table></figure>
<h4 id="添加背景音乐"><a href="#添加背景音乐" class="headerlink" title="添加背景音乐"></a>添加背景音乐</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMediaPlayer* bgm = <span class="keyword">new</span> QMediaPlayer();</span><br><span class="line">bgm-&gt;setMedia(QUrl(<span class="string">"qrc:/sound/fire.wav"</span>));</span><br><span class="line">bgm-&gt;play();</span><br></pre></td></tr></table></figure>
<h4 id="添加开火音效"><a href="#添加开火音效" class="headerlink" title="添加开火音效"></a>添加开火音效</h4><p>在添加开火音效时，我们要注意音效的重复播放问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Player::fireSound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    **    Play fire sound effect, if the sound effect is playing</span></span><br><span class="line"><span class="comment">    **    we set the sound track to the beginning to make a continue</span></span><br><span class="line"><span class="comment">    **    firing sound effect, and if the sound effect is finished</span></span><br><span class="line"><span class="comment">    **    we replay it</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(bullet_sound-&gt;state() == QMediaPlayer::PlayingState)&#123;</span><br><span class="line">        bullet_sound-&gt;setPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bullet_sound-&gt;state() == QMediaPlayer::StoppedState)&#123;</span><br><span class="line">        bullet_sound-&gt;play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><h4 id="背景设置"><a href="#背景设置" class="headerlink" title="背景设置"></a>背景设置</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">scene  = <span class="keyword">new</span> QGraphicsScene();</span><br><span class="line">scene-&gt;setSceneRect(posX,posY,width,height);</span><br><span class="line">scene-&gt;setBackgroundBrush(QBrush(<span class="string">":/images/bg.png"</span>));</span><br></pre></td></tr></table></figure>
<h4 id="游戏角色设置"><a href="#游戏角色设置" class="headerlink" title="游戏角色设置"></a>游戏角色设置</h4><h5 id="QGraphicsPixmapItem"><a href="#QGraphicsPixmapItem" class="headerlink" title="QGraphicsPixmapItem"></a>QGraphicsPixmapItem</h5><p>为了使用具有图片属性的对象，我们需要使用QGraphicsPixmapItem类，该类能够为对象添加图元</p>
<h5 id="创建一个具有图元属性的对象并进行处理"><a href="#创建一个具有图元属性的对象并进行处理" class="headerlink" title="创建一个具有图元属性的对象并进行处理"></a>创建一个具有图元属性的对象并进行处理</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**    Player image set</span></span><br><span class="line"><span class="comment">**      setPixmap -- set the image of the player</span></span><br><span class="line"><span class="comment">**      setTransformOriginPoint -- set the origin of the player</span></span><br><span class="line"><span class="comment">**      setRotation -- rotate the player around origin</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">player-&gt;setPixmap(QPixmap(<span class="string">":/images/player.png"</span>));</span><br><span class="line"><span class="comment">//player-&gt;setRect(0,0,100,100);</span></span><br><span class="line">player-&gt;setTransformOriginPoint(player-&gt;boundingRect().width()/<span class="number">2</span>,</span><br><span class="line">                                player-&gt;boundingRect().height()/<span class="number">2</span>);</span><br><span class="line">player-&gt;setRotation(<span class="number">180</span>);</span><br></pre></td></tr></table></figure>
<h2 id="人机交互事件"><a href="#人机交互事件" class="headerlink" title="人机交互事件"></a>人机交互事件</h2><p>人机交互有多种事件，例如鼠标点击，键盘点击等等，本文将使用键盘触发相应事件</p>
<h3 id="keyPressEvent-和-QKeyEvent"><a href="#keyPressEvent-和-QKeyEvent" class="headerlink" title="keyPressEvent() 和 QKeyEvent"></a>keyPressEvent() 和 QKeyEvent</h3><p>我们定义好了一个对象叫MyRect，继承自QGraphicsRectItem，同时定义了keyPressEvent()函数如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyRect::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"MyRect knows that you pressed a key"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们按下键盘，发现并没有事情发生，因为在Qt中，同一时刻只能有一个focus的对象响应键盘事件，因此我们要将我们的MyRect对象设置为focus的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">rect-&gt;setFlag(QGraphicsItem::ItemIsFocusable);   <span class="comment">//设置为可Focus的</span></span><br><span class="line">rect-&gt;setFocus();                                <span class="comment">//Focus rect，使其能够响应键盘事件</span></span><br></pre></td></tr></table></figure>
<h3 id="event-传递系统"><a href="#event-传递系统" class="headerlink" title="event 传递系统"></a>event 传递系统</h3><p>对于一个事件，我们要知道以下几点：</p>
<ul>
<li>事件从何而来</li>
<li>事件到哪里去</li>
<li>事件何时触发</li>
</ul>
<p>我们需要Qt中的event propogation system来控制事件的传递。具体原理如下</p>
<ol>
<li>QGraphicsView 监听键盘事件</li>
<li>当键盘事件来临后，QGraphicsView通知QGraphicsScene</li>
<li>QGraphicsScene查看当前被Focus的QGraphicsItem，控制其动作</li>
<li>QGraphicsItem检查并调用其keyPressEvent函数，完成动作</li>
</ol>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>一些情况下我们需要触发定时器中断，此时我们需要设置Timer，例如在游戏中我们需要子弹自己运动，那么设置好定时器，然后将定时器与运动函数进行connect，从而实现子弹的自动移动</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bullet::Bullet()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the rect</span></span><br><span class="line">    setRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> QTimer();</span><br><span class="line">    connect(timer, SIGNAL(timeout()), <span class="keyword">this</span>, SLOT(move()));</span><br><span class="line">    timer-&gt;start(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="游戏机制"><a href="#游戏机制" class="headerlink" title="游戏机制"></a>游戏机制</h2><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>在子弹的飞行过程中，我们需要对子弹碰撞的物体进行检测，如果发现子弹碰撞到了飞机，那么立刻将子弹和飞机都销毁，</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QList&lt;QGraphicsItem*&gt; colliding_item = collidingItems();  <span class="comment">//获取碰撞的物体并保存在列表中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; colliding_item.size();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span> (*(colliding_item[i])) == <span class="keyword">typeid</span> (Enemy))&#123;  <span class="comment">//如果碰撞的物体类型为 Enemy</span></span><br><span class="line">        <span class="comment">//从场景中移除</span></span><br><span class="line">        scene() -&gt; removeItem(colliding_item[i]); <span class="comment">//remove the enemy</span></span><br><span class="line">        scene() -&gt; removeItem(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        <span class="keyword">delete</span> colliding_item[i];                </span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>使用C++创建QML对象</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/%E4%BD%BF%E7%94%A8C++%E5%88%9B%E5%BB%BAQML%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对使用C++创建QML对象的方式进行总结。</p>
<a id="more"></a>
<h3 id="在C-中创建QML对象"><a href="#在C-中创建QML对象" class="headerlink" title="在C++中创建QML对象"></a>在C++中创建QML对象</h3><p>有时我们希望能够从C++中向QML发送数据，这种情况需要我们在C++中创建QML可以识别的对象，本节将对C++中创建QML对象的方法进行总结。</p>
<h4 id="继承QQuickItem类"><a href="#继承QQuickItem类" class="headerlink" title="继承QQuickItem类"></a>继承QQuickItem类</h4><p>当我们需要创建一个QML对象时，我们需要继承QQuickItem类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Squircle</span> :</span> <span class="keyword">public</span> QQuickItem</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PROPERTY(qreal t READ t WRITE setT NOTIFY tChanged)</span><br><span class="line">    QML_ELEMENT   <span class="comment">//声明该类为QML下的一个element</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Squircle();</span><br><span class="line"></span><br><span class="line">    <span class="function">qreal <span class="title">t</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">m_t</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setT</span><span class="params">(qreal t)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleWindowChanged</span><span class="params">(QQuickWindow *win)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseResources</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    qreal <span class="keyword">m_t</span>;</span><br><span class="line">    SquircleRenderer *m_renderer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="属性系统"><a href="#属性系统" class="headerlink" title="属性系统"></a>属性系统</h4><p>一个类的属性就是一个类的成员变量，由于QML与C++语法不互通，我们需要一个属性声明系统，让QML能够辨识C++中的成员及成员函数，这个属性系统能够声明C++中的一个成员变量，并提供访问的读/写操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q_PROPERTY(qreal t READ t WRITE setT NOTIFY tChanged)</span><br></pre></td></tr></table></figure>
<p>在上面这行语句中，我们声明了一个类型为qreal的t变量，同时赋予了读方法<code>t</code>和写方法<code>setT</code>，NOTIFY为给属性值设置相应信号。</p>
<h4 id="Q-PROPERTY常用格式"><a href="#Q-PROPERTY常用格式" class="headerlink" title="Q_PROPERTY常用格式"></a>Q_PROPERTY常用格式</h4><h5 id="指定读取属性的函数"><a href="#指定读取属性的函数" class="headerlink" title="指定读取属性的函数"></a>指定读取属性的函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Widget : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_PROPERTY(<span class="keyword">bool</span> focus READ hasFocus)</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasFocus</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改属性的函数"><a href="#修改属性的函数" class="headerlink" title="修改属性的函数"></a>修改属性的函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Widget : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_PROPERTY(<span class="keyword">bool</span> focus WRITE setFocus)</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasFocus</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFocus</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们限定set函数无返回值且只能有一个输入参数</p>
<h5 id="导出成员变量为属性值"><a href="#导出成员变量为属性值" class="headerlink" title="导出成员变量为属性值"></a>导出成员变量为属性值</h5><p>上面两个读/写的属性值都不是类中的成员变量，是凭空声明出来的一个属性值。要想将类中已有的成员变量设置为属性值，需要用 <code>MEMBER</code> 关键字。这样<code>focus</code> 这个属性值就变的可读可写了。要读可以用类自己的 <code>hasFocus()</code> 函数，要写用自带的<code>setFocus()</code> 修改 <code>m_focus</code> 变量就可以了，属性值会自动更新。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Widget : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_PROPERTY(<span class="keyword">bool</span> focus MEMBER m_focus)</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasFocus</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFocus</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_focus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然<code>READ</code>、<code>WRITE</code>、<code>MEMBER</code>这三个关键字都可以赋予属性值可读可写的特性，但是 <code>READ</code>、<code>WRITE</code>和 <code>MEMBER</code>不能同时使用，赋予可读可写特性一次就够了，不能赋予两次。就好像一个对象不能被析构两次一样。</p>
<h5 id="给属性设置关联信号"><a href="#给属性设置关联信号" class="headerlink" title="给属性设置关联信号"></a>给属性设置关联信号</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Widget : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_PROPERTY(<span class="keyword">bool</span> focus MEMBER m_focus NOTIFY focusChanged)</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasFocus</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFocus</span><span class="params">(<span class="keyword">bool</span> on)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">focusChanged</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_focus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在<code>m_focus</code>发生变化时，可以自动发送信号`focusChanged</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>利用QSortFilterProxyModel创建代理模型</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Qt/%E5%88%A9%E7%94%A8QSortFilterProxyModel%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对利用QSortFilterProxyModel进行自定义模型的过程进行讲解</p>
<a id="more"></a>
<p>我们可以通过QAbstract类对某些组件进行自定义，在有些情况下，我们想要获得一些通过自定义才能获得的效果，例如对于某个数据进行排序或筛选，这种情况下我们可以使用代理模型来实现该功能。这里给出了一个QSortFilterProxyModel模型，该模型可以实现数据排序及过滤。通过和其他模型组合使用（例如用户自定义的表格模型），我们可以获得更强大的自定义模型（例如一个拥有排序和过滤功能的表格模型）。</p>
<h2 id="QSortFilterProxyModel使用1"><a href="#QSortFilterProxyModel使用1" class="headerlink" title="QSortFilterProxyModel使用1"></a>QSortFilterProxyModel使用<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionTableModel</span> :</span> <span class="keyword">public</span> QAbstractTableModel</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ConnectionTableModel</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~ConnectionTableModel();</span><br><span class="line"></span><br><span class="line">    <span class="function">ConnectionItem *<span class="title">getItem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;row)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rowCount</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">columnCount</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function">QVariant <span class="title">data</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index, <span class="keyword">int</span> role = Qt::DisplayRole)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function">QVariant <span class="title">headerData</span><span class="params">(<span class="keyword">int</span> section, Qt::Orientation orientation, <span class="keyword">int</span> role = Qt::DisplayRole)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function">QModelIndex <span class="title">index</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">removeRows</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> count, <span class="keyword">const</span> QModelIndex &amp; parent = QModelIndex())</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> target, <span class="keyword">const</span> QModelIndex &amp;parent = QModelIndex())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">appendConnection</span><span class="params">(Connection *con, <span class="keyword">const</span> QModelIndex &amp;parent = QModelIndex())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconnectConnectionsAt</span><span class="params">(<span class="keyword">const</span> QString &amp;addr, quint16 port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAllLatency</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">message</span><span class="params">(<span class="keyword">const</span> QString &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rowStatusChanged</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">bool</span> running)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QList&lt;ConnectionItem*&gt; items;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> QString <span class="title">convertLatencyToString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> latency)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnectionStateChanged</span><span class="params">(<span class="keyword">bool</span> running)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnectionLatencyChanged</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnectionDataUsageChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在头文件中，我们声明了一个类<code>ConnectionTableModel</code>，继承自<code>QAbstractTableModel</code>。它有四个成员变量以及一个私有槽函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    ctr = <span class="keyword">new</span> Controller();</span><br><span class="line">    update_button();</span><br><span class="line"></span><br><span class="line">    timer=<span class="keyword">new</span> QTimer(<span class="keyword">this</span>);</span><br><span class="line">    connect(timer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(on_timeout()));</span><br><span class="line">    timer-&gt;start(<span class="number">500</span>); <span class="comment">//开始计时</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*注意这几句话*/</span></span><br><span class="line">    model      = <span class="keyword">new</span> ConnectionTableModel(<span class="keyword">this</span>);</span><br><span class="line">    proxyModel = <span class="keyword">new</span> QSortFilterProxyModel(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    proxyModel-&gt;setSourceModel(model);</span><br><span class="line">    proxyModel-&gt;setSortRole(Qt::EditRole);</span><br><span class="line">    proxyModel-&gt;setFilterCaseSensitivity(Qt::CaseInsensitive);</span><br><span class="line">    proxyModel-&gt;setFilterKeyColumn(<span class="number">-1</span>);<span class="comment">//read from all columns</span></span><br><span class="line"></span><br><span class="line">    ui-&gt;tableView-&gt;setModel(proxyModel);   <span class="comment">//某些条件不满足导致不能使用</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;move(QApplication::desktop()-&gt;screen()-&gt;rect().center() -</span><br><span class="line">               <span class="keyword">this</span>-&gt;rect().center()); <span class="comment">//程序居中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主窗口构造函数中，我们首先定义了一个ConnectionTableModel模型，然后我们建立了一个代理模型，并将代理模型的源模型设置为了model，这样我们就拥有了一个能够排序及筛选的表格模型。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.devbean.net/2013/04/qt-study-road-2-qsortfilterproxymodel/">QSortFilterProxyModel使用</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Archlinux作为ssh服务器</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/Archlinux%E4%BD%9C%E4%B8%BAssh%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>port: 22</p>
</blockquote>
<a id="more"></a>
<h2 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h2><p>archlinux 使用OpenSSH作为ssh通讯的软件，运行如下命令安装openssh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S openssh</span><br></pre></td></tr></table></figure>
<h2 id="ssh服务端配置"><a href="#ssh服务端配置" class="headerlink" title="ssh服务端配置"></a>ssh服务端配置</h2><p>安装完成后，我们可以用如下命令查看openssh server运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl status sshd</span></span><br></pre></td></tr></table></figure>
<p>由于还未启动服务，所以Active状态为inactive。为了使archlinux作为ssh服务器，我们要开启这个服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start sshd</span></span><br></pre></td></tr></table></figure>
<p>再一次查看状态，就能发现服务已经启动。为了使archlinux每次开机后自动运行该服务，我们需要执行下列命令进行enable</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> sshd</span></span><br></pre></td></tr></table></figure>
<p>至此我们的服务已经打开，如果需要关闭，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl end sshd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">disable</span> sshd</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，我们已经打开了SSH server的守护进程，现在客户端应该可以通过ssh命令进行连接，当然，现在还存在一些问题。当我们尝试连接服务器时，会发现服务器在连接后会立刻断开，我们还需要对sshd进行一些配置，配置文件为<code>etc/ssh/sshd_config</code>。打开后配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Port 888</span><br><span class="line">AddressFamily any</span><br><span class="line">ListenAddress 0.0.0.0</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>
<p>然后重启服务器即可连接。</p>
<h2 id="连接ssh服务器"><a href="#连接ssh服务器" class="headerlink" title="连接ssh服务器"></a>连接ssh服务器</h2><h3 id="查询ssh服务器的地址"><a href="#查询ssh服务器的地址" class="headerlink" title="查询ssh服务器的地址"></a>查询ssh服务器的地址</h3><p>为了连接ssh服务器，我们需要知道ssh服务器的hostname和IP地址，运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ip a</span></span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: enp0s31f6: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN group default qlen 1000</span><br><span class="line">    link/ether a6:1e:84:b7:1d:06 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: wlp3s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 3c:f7:62:09:99:76 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet xxx.xxx.85.194/22 brd 222.195.87.255 scope global dynamic noprefixroute wlp3s0</span><br><span class="line">       valid_lft 2766sec preferred_lft 2766sec</span><br><span class="line">    inet6 2001:da8:d880:199:b698:1f99:37fe:b408/64 scope global dynamic noprefixroute</span><br><span class="line">       valid_lft 253084sec preferred_lft 166684sec</span><br><span class="line">    inet6 fe80::f15d:42c:011:d6ee/64 scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>可以看到SSH的IP地址为xxx.xxx.85.194</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Archlinux桌面环境</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/Archlinux%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Archlinux下的桌面环境相关配置进行介绍。</p>
<a id="more"></a>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看当前桌面环境"><a href="#查看当前桌面环境" class="headerlink" title="查看当前桌面环境"></a>查看当前桌面环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$XDG_CURRENT_DESKTOP</span></span></span><br></pre></td></tr></table></figure>
<h3 id="查看已经安装的桌面环境"><a href="#查看已经安装的桌面环境" class="headerlink" title="查看已经安装的桌面环境"></a>查看已经安装的桌面环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /usr/share/xsession/</span></span><br></pre></td></tr></table></figure>
<h3 id="删除Deepin桌面环境"><a href="#删除Deepin桌面环境" class="headerlink" title="删除Deepin桌面环境"></a>删除Deepin桌面环境</h3><p>首先卸载deepin</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Rs deepin deepin-extra</span><br></pre></td></tr></table></figure>
<p>然后修改下列文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/lightdm/lightdm.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Archlinux系统运维</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/Archlinux%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Archlinux下的系统运维进行介绍。</p>
<a id="more"></a>
<h2 id="内核相关"><a href="#内核相关" class="headerlink" title="内核相关"></a>内核相关</h2><h3 id="查看当前内核版本"><a href="#查看当前内核版本" class="headerlink" title="查看当前内核版本"></a>查看当前内核版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> uname -r</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">4.19.67-1-lts</span><br></pre></td></tr></table></figure>
<h3 id="内核版本更换"><a href="#内核版本更换" class="headerlink" title="内核版本更换"></a>内核版本更换</h3><p>最新的内核版本滚动过于频繁，新增的许多特性也不稳定，因此将archlinux运行在稳定版本的内核上，即lts kernel</p>
<p>直接用pacman进行安装即可</p>
<h3 id="旧内核删除"><a href="#旧内核删除" class="headerlink" title="旧内核删除"></a>旧内核删除</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -f /boot/vmlinuz-kernel_3.xxx</span><br><span class="line">sudo rm -f /boot/initrd.img-kernel_3.xxx</span><br><span class="line">sudo rm -rf /lib/modules/kernel_3.xxx</span><br></pre></td></tr></table></figure>
<h2 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h2><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><h4 id="开启和停止服务"><a href="#开启和停止服务" class="headerlink" title="开启和停止服务"></a>开启和停止服务</h4><h5 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mariadb.service      # 立即启动，一次性生效</span><br><span class="line">sudo systemctl enable mariadb.service     # 会在下一次boot后自动启动，如果需要开机自启动用enable</span><br></pre></td></tr></table></figure>
<h5 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop mariadb.service</span><br><span class="line">systemctl disable mariadb.service</span><br></pre></td></tr></table></figure>
<h3 id="检查运行失败的service"><a href="#检查运行失败的service" class="headerlink" title="检查运行失败的service"></a>检查运行失败的service</h3><ol>
<li>找到运行失败的service</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl --failed  </span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">systemd-modules-load.service   loaded failed failed  Load Kernel Modules</span><br></pre></td></tr></table></figure>
<ol>
<li>查看运行失败的原因</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl status systemd-modules-load.service</span></span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">● systemd-modules-load.service - Load Kernel Modules</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/systemd-modules-load.service; static; vendor preset: dis&gt;</span><br><span class="line">   Active: failed (Result: exit-code) since Fri 2019-08-23 12:16:54 CST; 6min ago</span><br><span class="line">     Docs: man:systemd-modules-load.service(8)</span><br><span class="line">           man:modules-load.d(5)</span><br><span class="line">  Process: 190 ExecStart=/usr/lib/systemd/systemd-modules-load (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 190 (code=exited, status=1/FAILURE)</span><br></pre></td></tr></table></figure>
<ol>
<li>根据Main PID查看对应的问题</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> journalctl _PID=190</span></span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">-- Logs begin at Thu 2019-04-25 23:48:52 CST, end at Fri 2019-08-23 12:24:50 CST. --</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: Failed to find module 'vfs_monitor'</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: Failed to find module 'vboxdrv'</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: Failed to find module 'vboxpci'</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: libkmod: kmod_config_parse: /etc/modprobe.d/iwlwif&gt;</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: libkmod: kmod_config_parse: /etc/modprobe.d/iwlwif&gt;</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: libkmod: kmod_config_parse: /etc/modprobe.d/iwlwif&gt;</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: libkmod: kmod_config_parse: /etc/modprobe.d/iwlwif&gt;</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: libkmod: kmod_config_parse: /etc/modprobe.d/iwlwif&gt;</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: Failed to find module 'vboxnetadp'</span><br><span class="line">8月 23 12:16:54 husky systemd-modules-load[190]: Failed to find module 'vboxnetflt'</span><br></pre></td></tr></table></figure>
<ol>
<li>我们有一些module系统没有找到，因此在<code>/etc/modules-load.d/</code>下查看对应设置</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -Al /etc/modules-load.d </span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">总用量 0</span><br></pre></td></tr></table></figure>
<p>结果发现什么都没有，通过<code>modinfo</code>命令检查对应模块，发现找不到对应的模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modinfo vfs_monitor</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">modinfo: ERROR: Module vfs_monitor not found.</span><br></pre></td></tr></table></figure>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>有些情况下，我们需要查看系统发生了哪些动作，此时需要命令<code>journalctl</code>，当不带任何选项时，该命令将会无脑输出所有日志记录，基本没什么用，我们要进行一些筛选。</p>
<h3 id="检查高优先级错误"><a href="#检查高优先级错误" class="headerlink" title="检查高优先级错误"></a>检查高优先级错误</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> journalctl -p 3 -xb</span></span><br></pre></td></tr></table></figure>
<h2 id="清理文件系统"><a href="#清理文件系统" class="headerlink" title="清理文件系统"></a>清理文件系统</h2><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><h3 id="官方包管理-pacman"><a href="#官方包管理-pacman" class="headerlink" title="官方包管理 pacman"></a>官方包管理 pacman</h3><p>archlinux下的包管理软件为pacman（吃豆人），这个软件非常好用，能够有效解决不同包之间的依赖问题。</p>
<h4 id="更新包数据库"><a href="#更新包数据库" class="headerlink" title="更新包数据库"></a>更新包数据库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syy</span><br></pre></td></tr></table></figure>
<p>建议安装软件前先执行这个命令。</p>
<h4 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h4><p>搜索包的命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -Ss pacname</span><br></pre></td></tr></table></figure>
<p>其中pacname为待搜索的包的名称</p>
<h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><p>安装包的命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S pacname</span><br></pre></td></tr></table></figure>
<h4 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h4><p>删除包的命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Rs pacname</span><br></pre></td></tr></table></figure>
<p>其中s表示没有被其他已经安装的软件包使用的依赖关系。</p>
<h4 id="包查看"><a href="#包查看" class="headerlink" title="包查看"></a>包查看</h4><ul>
<li>查看所有已经安装的包：<code>$pacman -Qq</code></li>
<li>查看所有显式安装的包：<code>$pacman -Qqe</code></li>
<li>列出孤立包（并删除）：<code>pacman -Qqdt | sudo pacman -Rs -</code></li>
<li>按照包大小排列：<code>expac &quot;%n %m&quot; -l&#39;\n&#39; -Q $(pacman -Qq) | sort -rhk 2 | less</code></li>
</ul>
<h3 id="非官方包管理"><a href="#非官方包管理" class="headerlink" title="非官方包管理"></a>非官方包管理</h3><p>对于一些非官方包，我们可以使用AUR（Archlinux user repository）进行管理。AUR是一个社区驱动的软件仓库，包含了非官方的软件或包</p>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>我们使用yay对AUR中的包进行管理，下载命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://aur.archlinux.org/yay.git</span><br><span class="line">cd yay</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure>
<h4 id="安装包-1"><a href="#安装包-1" class="headerlink" title="安装包"></a>安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yay -S gparted</span></span><br></pre></td></tr></table></figure>
<h2 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h2><p>Archlinux是滚动更新的系统，不支持局部更新，所以尽可能定期更新系统。更新系统的命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure>
<h3 id="文件损坏处理"><a href="#文件损坏处理" class="headerlink" title="文件损坏处理"></a>文件损坏处理</h3><p>在有一些情况下，无效的或者已经损坏的文件可能会导致签名错误，从而使更新失败，这种情况的处理过程如下：</p>
<ol>
<li>安装archlinux-keyring，这个包用于</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Archlinux网络配置</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/Archlinux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Archlinux下的网络配置进行介绍。</p>
<a id="more"></a>
<h2 id="无线网络配置"><a href="#无线网络配置" class="headerlink" title="无线网络配置"></a>无线网络配置</h2><p>无线网络的配置分为两个步骤：硬件驱动配置及网络接口配置</p>
<h3 id="检查设备状态"><a href="#检查设备状态" class="headerlink" title="检查设备状态"></a>检查设备状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lspci -k </span><br><span class="line">03:00.0 Network controller: Intel Corporation Dual Band Wireless-AC 3165 Plus Bluetooth (rev 99)</span><br><span class="line">    Subsystem: Intel Corporation Dual Band Wireless-AC 3165 Plus Bluetooth</span><br><span class="line">    Kernel driver in use: iwlwifi</span><br><span class="line">    Kernel modules: iwlwifi</span><br></pre></td></tr></table></figure>
<h2 id="科学上网配置"><a href="#科学上网配置" class="headerlink" title="科学上网配置"></a>科学上网配置</h2><h3 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h3><p>这里科学上网使用v2ray协议（虽然可能有一天也要被封了），首先下载Qv2ray，AUR地址为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://aur.archlinux.org/qv2ray.git</span><br></pre></td></tr></table></figure>
<p>下载并安装这个软件，如果不想用GUI，也可以直接使用命令行，就是服务器配置文件的更新麻烦一些。打开<code>config.json</code>，查看v2ray服务的本地端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;                                                                           </span><br><span class="line">          "tag": "proxy",                                                           </span><br><span class="line">          "port": 10808,                                                            </span><br><span class="line">          "listen": "127.0.0.1",                                                    </span><br><span class="line">          "protocol": "socks",                                                      </span><br><span class="line">          "sniffing": &#123;                                                             </span><br><span class="line">            "enabled": true,                                                        </span><br><span class="line">            "destOverride": [                                                       </span><br><span class="line">              "http",                                                               </span><br><span class="line">              "tls"                                                                 </span><br><span class="line">            ]                                                                       </span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure>
<p>我这里是127.0.0.1:10808，记下这个端口。需要注意的是，在使用代理时，要保证代理时间戳和主机的时间戳保持一致，否则会导致代理错误的情况。</p>
<h3 id="代理软件安装及配置"><a href="#代理软件安装及配置" class="headerlink" title="代理软件安装及配置"></a>代理软件安装及配置</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>代理软件选择proxychains4，这个软件可以进行局部代理，即每个命令之前如果加上proxychains4，就会走代理，否则不会。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>编辑<code>/usr/local/etc/proxychains.conf</code>，修改代理地址及端口为上面的<code>config.json</code>中的端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> meanwile                                                                      </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> defaults <span class="built_in">set</span> to <span class="string">"tor"</span>                                                         </span></span><br><span class="line"><span class="meta">#</span><span class="bash">socks4     127.0.0.1 9050                                                      </span></span><br><span class="line">socks5  127.0.0.1 10808                                                                                                                                                                </span><br><span class="line"><span class="meta">#</span><span class="bash">proxy_dns 8.8.8.8</span></span><br></pre></td></tr></table></figure>
<p>然后保存即可。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用方法为在要代理的命令前加上proxychains4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains4 wget https://www.google.com</span><br><span class="line">[proxychains] preloading /usr/lib/libproxychains4.so</span><br><span class="line">[proxychains] DLL init: proxychains-ng 4.14</span><br><span class="line">--2020-11-11 19:48:33--  https://www.google.com/</span><br><span class="line">已载入 CA 证书“/etc/ssl/certs/ca-certificates.crt”</span><br><span class="line">正在解析主机 www.google.com (www.google.com)... 64.13.192.74, 2001::6ca0:a9ab</span><br><span class="line">正在连接 www.google.com (www.google.com)|64.13.192.74|:443... [proxychains] Strict chain  ...  127.0.0.1:10808  ...  64.13.192.74:443  ...  OK</span><br><span class="line">已连接。</span><br></pre></td></tr></table></figure>
<p>如果要为浏览器添加代理，可以下载proxy switchyomega插件然后安装，如果要临时在命令行下添加代理，推荐使用chromium浏览器，代理方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chromium --proxy-server="socks5://127.0.0.1:1080"</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux内核管理</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/Linux%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Look, this is my heart</p>
</blockquote>
<a id="more"></a>
<h2 id="内核运维"><a href="#内核运维" class="headerlink" title="内核运维"></a>内核运维</h2><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><h4 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line">linux 5.9.8.arch1-1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者在archlinux下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pacman -Q linux </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pacman -Q | grep linux</span></span><br><span class="line"></span><br><span class="line">archlinux-keyring 20201028-1</span><br><span class="line">lib32-util-linux 2.36-1</span><br><span class="line">linux 5.9.8.arch1-1                      #内核版本</span><br><span class="line">linux-api-headers 5.8-1</span><br><span class="line">linux-firmware 20201023.dae4b4c-1</span><br><span class="line">linux-lts 5.4.77-1                       #安装的某个内核</span><br><span class="line">linux-lts-headers 5.4.77-1</span><br><span class="line">util-linux 2.36-4</span><br><span class="line">util-linux-libs 2.36-4</span><br></pre></td></tr></table></figure>
<h4 id="卸载旧内核-危险操作，请谨慎进行"><a href="#卸载旧内核-危险操作，请谨慎进行" class="headerlink" title="卸载旧内核(危险操作，请谨慎进行)"></a>卸载旧内核(危险操作，请谨慎进行)</h4><p>进入<code>/boot/</code>中，然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm vmlinuz-linux-lts</span><br><span class="line">sudo rm initramfs-linux-lts*</span><br></pre></td></tr></table></figure>
<p>重启后可以发现只剩下最新的内核了。</p>
<h4 id="内核恢复"><a href="#内核恢复" class="headerlink" title="内核恢复"></a>内核恢复</h4><p>有一次手贱不小心把grub引导的内核删掉了，但好在还有一个非引导的内核，这里讲一下如何对grub进行修改从而引导非引导内核。进入系统后选择内核，发现错误信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Loading Linux linux-lts ...</span><br><span class="line">错误：file `vmlinuz-linux-lts` not found</span><br></pre></td></tr></table></figure>
<p>这个时候按任意键退出，然后按<code>e</code>进行编辑，发现此处可以使用emacs临时进行内核更换，将命令中的vmlinuz-linux-lts换成非引导内核，按下Ctrl+x进行引导，然后就可以利用非引导内核进入系统。这个时候再进行内核更换即可。</p>
<h4 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S linux-lts</span><br></pre></td></tr></table></figure>
<p>安装某个版本的新内核。</p>
<h4 id="更新grub"><a href="#更新grub" class="headerlink" title="更新grub"></a>更新grub</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo grub<span class="literal">-mkconfig</span> <span class="literal">-o</span> /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<p>每次安装了新内核后，都要执行一次这个命令，否则进入grub加载系统界面后，将看不到新安装的内核。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux学习资料总结</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/Linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Stay hungry, stay foolish</p>
</blockquote>
<a id="more"></a>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p><a href="https://elixir.bootlin.com/linux/latest/source">Linux source code</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令总结</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>And God said, Let us make a man</p>
</blockquote>
<a id="more"></a>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。在linux命令行中，管道命令使用<code>|</code>作为界定符号，将第一个命令的输入作为下一个命令的输出，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -al /etc | less</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串处理类命令"><a href="#字符串处理类命令" class="headerlink" title="字符串处理类命令"></a>字符串处理类命令</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>分析一行信息，如果其中有我们需要的信息，就将该行拿出来</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote>
<p><strong>-a 或 —text</strong> : 不要忽略二进制的数据。</p>
<p><strong>-c 或 —count</strong> : 计算符合样式的列数。</p>
<p><strong>-i 或 —ignore-case</strong> : 忽略字符大小写的差别。</p>
</blockquote>
<h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo | grep -c <span class="string">'physical id'</span>   <span class="comment">#查看有几个物理CPU</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo | grep -c <span class="string">'processor'</span>     <span class="comment">#查看cpu核心数</span></span></span><br></pre></td></tr></table></figure>
<h2 id="文件查看类命令"><a href="#文件查看类命令" class="headerlink" title="文件查看类命令"></a>文件查看类命令</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>查看指定文件下内容 </p>
<h2 id="系统相关命令"><a href="#系统相关命令" class="headerlink" title="系统相关命令"></a>系统相关命令</h2><h3 id="系统负载查询命令"><a href="#系统负载查询命令" class="headerlink" title="系统负载查询命令"></a>系统负载查询命令</h3><h4 id="w-amp-uptime"><a href="#w-amp-uptime" class="headerlink" title="w &amp; uptime"></a>w &amp; uptime</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@centos6 ~ 10:56 #37]# w</span><br><span class="line">10:57:38 up 14 min,  1 user,  load average: 0.00, 0.00, 0.00  </span><br><span class="line">USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    192.168.147.1    18:44    0.00s  0.10s  0.00s w</span><br><span class="line"></span><br><span class="line">[root@centos6 ~ 10:56 #37]# uptime</span><br><span class="line">10:57:47 up 14 min,  1 user,  load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure>
<p>load average即系统负载，三个数值分别表示一分钟、五分钟、十五分钟内系统的平均负载，即平均任务数。</p>
<h3 id="系统资源查询命令"><a href="#系统资源查询命令" class="headerlink" title="系统资源查询命令"></a>系统资源查询命令</h3><h4 id="top：查询"><a href="#top：查询" class="headerlink" title="top：查询"></a>top：查询</h4><h4 id="free：查询内存使用情况"><a href="#free：查询内存使用情况" class="headerlink" title="free：查询内存使用情况"></a>free：查询内存使用情况</h4><h3 id="系统任务查询命令"><a href="#系统任务查询命令" class="headerlink" title="系统任务查询命令"></a>系统任务查询命令</h3><h4 id="ps：查看当前系统进程"><a href="#ps：查看当前系统进程" class="headerlink" title="ps：查看当前系统进程"></a>ps：查看当前系统进程</h4><h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><h3 id="netstat：网络状态查询"><a href="#netstat：网络状态查询" class="headerlink" title="netstat：网络状态查询"></a>netstat：网络状态查询</h3><h2 id="硬盘相关命令"><a href="#硬盘相关命令" class="headerlink" title="硬盘相关命令"></a>硬盘相关命令</h2><h3 id="挂载与卸载操作"><a href="#挂载与卸载操作" class="headerlink" title="挂载与卸载操作"></a>挂载与卸载操作</h3><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>linux下只有一个根目录，在装系统时，我们分配给linux的所有区都在<code>/</code>下的某个位置，所以linux下mount挂载的作用，就是将一个设备（一般为块设备）挂载到一个已存在的目录上，这样访问这个目录就是访问这个块设备（通过文件的方式使用该设备）。</p>
<p>虽然我们可以在<code>/dev</code>下找到硬盘的盘符比如<code>/dev/sdb1</code>，但是这个并不是他的目录，而是一个类似指针的东西，指向分区的原始数据块，在挂载之前，系统并不知道这个数据块代表什么，所以也就无法对其进行操作。</p>
<h3 id="硬盘查找"><a href="#硬盘查找" class="headerlink" title="硬盘查找"></a>硬盘查找</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>
<p>这个命令将会打印所有的硬盘设备的信息</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://zhuanlan.zhihu.com/p/32250942">Linux39条常用命令</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>双系统安装</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对windows下安装linux的过程进行讲解</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><h5 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h5><ul>
<li>一个足够大的U盘</li>
</ul>
<h5 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h5><ul>
<li>系统镜像</li>
<li>烧录软件</li>
</ul>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>将系统镜像烧录至U盘中</p>
<h3 id="为linux预留分区"><a href="#为linux预留分区" class="headerlink" title="为linux预留分区"></a>为linux预留分区</h3><p>在windows磁盘管理中为linux划分一块区域，划分后的区域应当是干净的经过格式化的。</p>
<h2 id="从U盘中启动"><a href="#从U盘中启动" class="headerlink" title="从U盘中启动"></a>从U盘中启动</h2><p>插入U盘启动电脑，在windows启动前，按F2（不同电脑不一样）进入BIOS界面，选择从U盘中启动，进入linux安装界面</p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>我们将预留的分区一整块都分配给<code>/</code>目录，格式为ext4，同时将<code>boot/efi</code>分配给windows的<code>efi</code>引导卷（注意不是覆盖，而是分配），这样启动后UEFI就能识别双系统并根据用户的选择加载对应的系统。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux磁盘管理</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对linux进行磁盘管理的过程进行介绍</p>
<a id="more"></a>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="查看磁盘信息"><a href="#查看磁盘信息" class="headerlink" title="查看磁盘信息"></a>查看磁盘信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo fdisk -l</span></span><br></pre></td></tr></table></figure>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkfs.ext* /dev/sda   <span class="comment"># 将sda格式化为ext*类型，*可以为2、3或4</span></span></span><br></pre></td></tr></table></figure>
<h3 id="挂载及卸载"><a href="#挂载及卸载" class="headerlink" title="挂载及卸载"></a>挂载及卸载</h3><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>在<code>~</code>目录下创建一个文件叫disk，然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount /dev/sda disk</span></span><br></pre></td></tr></table></figure>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ umount /dev/sda</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Tmux快捷键</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/Tmux%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对linux中多终端控制命令Tmux常用快捷键进行总结。</p>
<a id="more"></a>
<ul>
<li>CTRL+a: 自定义的Tmux命令前缀，默认是ctrl-b，这里缩写为Ca<ul>
<li>Ca + c  创建新window</li>
<li>Ca + ,   重命名window</li>
<li>Ca + w 选择window，p和n可以选择window</li>
<li>Ca + |  垂直分解</li>
<li>Ca + -  水平分解</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux开发环境搭建</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/linux%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在linux内核开发过程中，我们一般会将编译环境放在linux下，将开发环境放在windows中，本文将基于vscode + ssh，搭建一个在windows下远程访问linux的开发环境</p>
<a id="more"></a>
<h1 id="ssh免密登录及vscode插件配置"><a href="#ssh免密登录及vscode插件配置" class="headerlink" title="ssh免密登录及vscode插件配置"></a>ssh免密登录及vscode插件配置</h1><h2 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h2><p>首先我们配置在windows下对linux的免密登录，进入<code>C:\Users\用户名</code>目录下，右键打开powershell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@xxx.xxx.xxx.xxx # 此处输入用户名</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，我们现在应该能够在windows下直接免密登录linux。</p>
<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>在插件市场中搜索<code>Remote Development</code>插件并安装，安装完成后侧边栏会有一个对应的图标，点击图标，在远程资源管理器中选择<code>SSH Targets</code></p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220701230605.png"  alt="图片名称" align=center /></p>
<p>点击小齿轮，进行配置，在弹出的配置项中选择第一个</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220701230649.png"  alt="图片名称" align=center /></p>
<p>在配置文件中填写如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Read more about SSH config files: https://linux.die.net/man/5/ssh_config</span></span><br><span class="line">Host HuaweiServer</span><br><span class="line">    HostName xxx.xxx.xxx.xxx  # 此处填写你的ip地址</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure>
<p>如果配置正确，你会在<code>SSH TARGETS</code>下看到你的服务器，右键点击，选择<code>Connect to host in current window</code></p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220701230649.png"  alt="图片名称" align=center /></p>
<p>点击<code>文件-打开文件夹</code>，即可选择远程服务器的相关文件夹。点击<code>终端-打开终端</code>，即可打开linux服务器下的中断</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220701231238.png"  alt="图片名称" align=center /></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL管理</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/SQL/MySQL%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对MySQL管理的一些相关操作进行总结。</p>
<a id="more"></a>
<h2 id="服务器管理1"><a href="#服务器管理1" class="headerlink" title="服务器管理1"></a>服务器管理<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><h3 id="启动及关闭服务器"><a href="#启动及关闭服务器" class="headerlink" title="启动及关闭服务器"></a>启动及关闭服务器</h3><h4 id="Windows下"><a href="#Windows下" class="headerlink" title="Windows下"></a>Windows下</h4><p>在windows系统下，使用命令行进行MySQL的启动与关闭操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动操作</span></span><br><span class="line">mysqld --console</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭操作</span></span><br><span class="line">mysqladmin -uroot shutdown</span><br></pre></td></tr></table></figure>
<h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>在安装完MySQL后，可以使用如下语句修改root用户密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root password "password";</span><br></pre></td></tr></table></figure>
<p>在创建root用户密码后，可以使用如下命令连接服务器，登录SQL服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">Enter password:*******</span><br></pre></td></tr></table></figure>
<h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p>MySQL的配置文件为<code>my.ini</code>，文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=C:\\web\\mysql-8.0.11</span><br><span class="line"># 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</span><br><span class="line"># datadir=C:\\web\\sqldata</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.runoob.com/mysql/mysql-install.html">MySQL 安装</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>linux内核编译与虚拟机启动</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Linux/%E7%BC%96%E8%AF%91aarch64%E5%B9%B3%E5%8F%B0%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对AArch64平台进行linux内核编译，并使用qemu虚拟机运行linux内核<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p>
<a id="more"></a>
<h1 id="工具链准备"><a href="#工具链准备" class="headerlink" title="工具链准备"></a>工具链准备</h1><p>为了编译linux内核，需要准备相关的构建工具链，我们要编译AArch64平台的，所以需要安装<code>aarch64-linux-gnu-</code>编译工具链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>
<h1 id="编译busybox（根文件系统）"><a href="#编译busybox（根文件系统）" class="headerlink" title="编译busybox（根文件系统）"></a>编译busybox（根文件系统）</h1><p>busybox是一个广泛应用于嵌入式linux的工具箱，集成了一些很常用的linux命令，我们首先需要编译一个busybox做准备，然后作为rootfs进行加载，从而使用户迅速方便地构建相对完整、功能丰富的文件系统。<a href="https://busybox.net/downloads/">点击此处下载对应busybox版本</a>，下载解压后，进入对应的目录下，然后执行如下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">make O=build ARCH=arm64 defconfig</span><br><span class="line">make O=build ARCH=arm64 menuconfig</span><br></pre></td></tr></table></figure>
<p>在弹出的配置菜单中，在[settings]里修改如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] Don&apos;t use /usr</span><br><span class="line">[*] Build static binary (no shared libs)</span><br><span class="line">(aarch64-linux-gnu-) Cross compiler prefix</span><br></pre></td></tr></table></figure>
<p>运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make O=build # -j16</span><br><span class="line">make O=build install</span><br></pre></td></tr></table></figure>
<p>进入<code>build/_install</code>目录下，该目录结构为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree -L 1 .</span></span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── linuxrc -&gt; bin/busybox</span><br><span class="line">└── sbin</span><br><span class="line"></span><br><span class="line">2 directories, 1 file</span><br></pre></td></tr></table></figure>
<p>创建一些空的目录作为<code>rootfs</code>中的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -pv &#123;etc,proc,sys,usr/&#123;bin,sbin&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个init文件并执行<code>chmod +x init</code>，该文件将会在系统启动后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line"></span><br><span class="line">echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"</span><br><span class="line"></span><br><span class="line">exec /bin/sh</span><br></pre></td></tr></table></figure>
<p>此时<code>build/_install</code>目录如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree -L 1 .</span></span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── etc</span><br><span class="line">├── init</span><br><span class="line">├── linuxrc -&gt; bin/busybox</span><br><span class="line">├── proc</span><br><span class="line">├── sbin</span><br><span class="line">├── sys</span><br><span class="line">└── usr</span><br><span class="line"></span><br><span class="line">6 directories, 2 files</span><br></pre></td></tr></table></figure>
<p>将上述目录与文件进行打包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -print0 | cpio --null -ov --format=newc | gzip &gt; ../initramfs.cpio.gz</span><br></pre></td></tr></table></figure>
<p>生成的cpio映像位于build目录下，实际就是将initramfs打包成了cpio格式的压缩包。</p>
<h1 id="编译最小配置的linux内核"><a href="#编译最小配置的linux内核" class="headerlink" title="编译最小配置的linux内核"></a>编译最小配置的linux内核</h1><p>在<a href="https://www.kernel.org/">kernel</a>下载适当版本的内核源码并解压，然后执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd linux-5.10.127   # 这里选择长期支持版本的5.10内核</span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line">make O=build ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- allnoconfig</span><br><span class="line">make O=build ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br></pre></td></tr></table></figure>
<p>这会首先初始化一个最小的配置（<code>allnoconfig</code>），然后打开配置菜单。在配置菜单中做以下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; General setup</span><br><span class="line">[*] Initial RAM filesystem and RAM disk (initramfs/initrd) support</span><br><span class="line"></span><br><span class="line">-&gt; General setup</span><br><span class="line">  -&gt; Configure standard kernel features</span><br><span class="line">[*] Enable support for printk</span><br><span class="line"></span><br><span class="line">-&gt; Executable file formats / Emulations</span><br><span class="line">[*] Kernel support for ELF binaries</span><br><span class="line">[*] Kernel support for scripts starting with #!</span><br><span class="line"></span><br><span class="line">-&gt; Device Drivers</span><br><span class="line">  -&gt; Generic Driver Options</span><br><span class="line">[*] Maintain a devtmpfs filesystem to mount at /dev</span><br><span class="line">[*]   Automount devtmpfs at /dev, after the kernel mounted the rootfs</span><br><span class="line"></span><br><span class="line">-&gt; Device Drivers</span><br><span class="line">  -&gt; Character devices</span><br><span class="line">[*] Enable TTY</span><br><span class="line"></span><br><span class="line">-&gt; Device Drivers</span><br><span class="line">  -&gt; Character devices</span><br><span class="line">    -&gt; Serial drivers</span><br><span class="line">[*] ARM AMBA PL010 serial port support</span><br><span class="line">[*]   Support for console on AMBA serial port</span><br><span class="line">[*] ARM AMBA PL011 serial port support</span><br><span class="line">[*]   Support for console on AMBA serial port</span><br><span class="line"></span><br><span class="line">-&gt; File systems</span><br><span class="line">  -&gt; Pseudo filesystems</span><br><span class="line">[*] /proc file system support</span><br><span class="line">[*] sysfs file system support</span><br></pre></td></tr></table></figure>
<p>完成后保存并退出，再运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make O=build ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- # -j16</span><br></pre></td></tr></table></figure>
<p>编译完成后有两个东西比较有用，一个是<code>build/vmlinux</code>，ELF格式的内核，可以在GDB中加载调试信息。另一个是<code>build/arch/arm64/boot/Image</code>，是可以加载的内核镜像文件。</p>
<h1 id="qemu启动"><a href="#qemu启动" class="headerlink" title="qemu启动"></a>qemu启动</h1><p>在ubuntu上执行如下命令安装对应架构的qemu</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install qemu-system-arm</span><br></pre></td></tr></table></figure>
<p>创建一个<code>qemu</code>文件夹，将上面编译好的<code>Image</code>和<code>initramfs.cpio.gz</code>拷贝到<code>qemu</code>文件夹下，然后执行如下脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">    -machine virt -cpu cortex-a72 -smp 4 -m 2G \    # 4个cortex-a72 CPU，2GB内存</span><br><span class="line">    -kernel ./Image \</span><br><span class="line">    -append &quot;console=ttyAMA0&quot; \</span><br><span class="line">    -initrd ./initramfs.cpio.gz \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure>
<p>系统启动非常快，用了不到1秒中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Booting Linux on physical CPU 0x0000000000 [0x410fd083]</span><br><span class="line">Linux version 5.10.127 (root@hecs-198689) (aarch64-linux-gnu-gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #1 SMP Wed Jun 29 21:48:32 CST 2022</span><br><span class="line">... 省略若干启动信息</span><br><span class="line">Run /init as init process</span><br><span class="line"></span><br><span class="line">Boot took 0.51 seconds</span><br><span class="line"></span><br><span class="line">/bin/sh: can&apos;t access tty; job control turned off</span><br></pre></td></tr></table></figure>
<p>启动后可以看到位于我们打包的busybox文件夹下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ # ls</span><br><span class="line">bin      etc      linuxrc  root     sys</span><br><span class="line">dev      init     proc     sbin     usr</span><br></pre></td></tr></table></figure>
<p>可以执行一些简单的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ # top</span><br><span class="line">Mem: 13660K used, 2042812K free, 0K shrd, 0K buff, 3592K cached</span><br><span class="line">CPU:  0.0% usr  0.0% sys  0.0% nic 99.9% idle  0.0% io  0.0% irq  0.0% sirq</span><br><span class="line">Load average: 0.00 0.00 0.00 1/55 59</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND</span><br><span class="line">   59     1 0        R     2284  0.1   1  0.0 top</span><br><span class="line">    1     0 0        S     2284  0.1   0  0.0 /bin/sh</span><br><span class="line">   14     2 0        SW       0  0.0   1  0.0 [migration/1]</span><br><span class="line">   34     2 0        SW       0  0.0   5  0.0 [migration/5]</span><br><span class="line"></span><br><span class="line">/ # free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        2056472        9728     2042568           0        4176     2033024</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>
<p>使用<code>ctrl a + x</code>可以关闭qemu</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://stdrc.cc/post/2020/09/12/minimal-linux-with-busybox/">编译一个 AArch64 平台的最小 Linux 内核 - Project RC (stdrc.cc)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>创建、删除与选择数据库</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/SQL/%E5%88%9B%E5%BB%BA%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对MySQL创建、删除与选择数据库的过程进行总结。</p>
<a id="more"></a>
<h2 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h2><p>使用show命令可以显示数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">| world              |</span><br><span class="line">+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到本机一共有7个数据库。</p>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>在登录数据库后，我们可以通过<code>create</code>命令创建数据库，具体语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create DATABASE database_name;    # 注意分号</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.runoob.com/mysql/mysql-create-database.html">MySQL 创建数据库</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>UE4</category>
      </categories>
  </entry>
  <entry>
    <title>UE4界面、工程及基本介绍</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/UE4/UE4%E7%95%8C%E9%9D%A2%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Let’s make a game</p>
</blockquote>
<a id="more"></a>
<h2 id="基本界面及操作"><a href="#基本界面及操作" class="headerlink" title="基本界面及操作"></a>基本界面及操作</h2><h3 id="基本界面"><a href="#基本界面" class="headerlink" title="基本界面"></a>基本界面</h3><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/ue4engine.JPG" width = "1000" alt="UE4界面" align=center /></p>
<p>一个打开了第一人称射击游戏工程的UE4界面如上图所示，可以看到UE4界面整体可以分为五个部分，上边为调试部分；右侧为世界大纲视图和细节，选择对应的对象，会出现相应的细节，包括位置、旋转、材质等等；中间为具体场景；左侧为可以放置的actor，下边为内容浏览器，显示project中的相关资源文件。</p>
<h4 id="左侧界面"><a href="#左侧界面" class="headerlink" title="左侧界面"></a>左侧界面</h4><p>点击调试部分的模式，可以选择多种编辑器模式，包括地形、植物、笔刷编辑以及网格体绘制。</p>
<h4 id="内容浏览器"><a href="#内容浏览器" class="headerlink" title="内容浏览器"></a>内容浏览器</h4><p>在内容浏览器中可以浏览到源文件，比较重要的包括源码、材质、音效、网格对象等等。点击新增可以添加材质、关卡、蓝图类、粒子系统等。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="经常用到的操作及快捷键"><a href="#经常用到的操作及快捷键" class="headerlink" title="经常用到的操作及快捷键"></a>经常用到的操作及快捷键</h4><h5 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h5><p>shift+1 2 3 4 5切换模式，其中1为选择场景中对象，2为地形，3为植物，4为笔刷绘制，5为网格体绘制。</p>
<h5 id="场景中的操作"><a href="#场景中的操作" class="headerlink" title="场景中的操作"></a>场景中的操作</h5><ul>
<li><p><strong>旋转</strong>：鼠标右键</p>
</li>
<li><p><strong>飞行</strong>：键盘WASD+鼠标右键，在场景中自由飞行，点击场景右上角相机速度，可以调节移动速度快慢</p>
</li>
<li><strong>对象移动、旋转与缩放</strong>：在场景中上面三个小图标分别是移动物体、旋转物体和缩放物体，快捷键是W、E、和R。网格对齐值可以调节移动物体时移动的网格数。旋转网格可以调节旋转大小，缩放对齐可以选择缩放的大小。需要注意的是如果要等比例缩放，需要选中物体，然后点击中间的白色方块，等三个坐标轴都变黄再进行缩放。如果按住shift移动对象，可以令摄像机进行跟随</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/suofang.JPG" width = "500" alt="UE4界面" align=center /></p>
<ul>
<li><strong>对象复制</strong>：在世界大纲地图中选中对象，ctrlc+v即可对对象进行copy</li>
</ul>
<h2 id="新建关卡及对象——建造一个场景"><a href="#新建关卡及对象——建造一个场景" class="headerlink" title="新建关卡及对象——建造一个场景"></a>新建关卡及对象——建造一个场景</h2><h3 id="基本集合体放置"><a href="#基本集合体放置" class="headerlink" title="基本集合体放置"></a>基本集合体放置</h3><p>UE4的项目是以关卡为单元进行组织的，在创建一个默认项目后，UE4会自动提供一个默认关卡，当然我们也可以自己创建新的关卡，点击文件——新建关卡，创建一个默认关卡。在创建关卡后，我们可以在其中填充actor。最基本的actor是几何体，我们从中选取一个盒体作为floor，设置x/y/z分别为2000/2000/20。这里显示我们的对象是一个盒体 画刷，意思是我们可以对这个对象进行修改。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/ue4box.JPG" width = "220" alt="UE4界面" align=center /></p>
<p>在放置集合体的栏目中，我们可以看到放置包括添加和减去两种操作，即与和非的操作，我们可以利用这两种操作构造自定义的几何体</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200826152937.png" width = "220" alt="UE4界面" align=center /></p>
<p>通过一些加减操作，我们创建了一个房子，然后把默认的玩家放置进去，即可获得一个简单的房间内部射击游戏的场景。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/UE4simpledemo.JPG" width="500" alt="UE4界面" align=center /></p>
<h3 id="几何体修改"><a href="#几何体修改" class="headerlink" title="几何体修改"></a>几何体修改</h3><p>按shift+4打开笔刷绘制模式，对几何体进行修改，通过对点、线和面进行分割以及三维操作，我们可以得到自定义的几何体，这一部分一般是游戏3d建模师的工作，此处可以略看了解。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200826155437.png" width="700" alt="UE4界面" align=center /></p>
<p>利用三角剖分（将多面体分割为三角形）和分割（将一条线段在锚点处垂直切分）绘制的不规则形体。点击透视可以改变物体的视图，可以通过利用画笔绘制三视图的方式绘制几何体。</p>
<h3 id="添加材质"><a href="#添加材质" class="headerlink" title="添加材质"></a>添加材质</h3><p>UE4添加材质的过程非常简单，只需要将材质文件拖动至具体的对象上即可，在我们上一步构造的几何体中，将材质拖到对应的面上，即可完成材质的添加。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200826161852.png" width="700" alt="UE4界面" align=center /></p>
<p>同时，在细节部分，我们可以修改表面属性，例如对表面的UV坐标系进行旋转、平移等，在几何体中，我们还可以调节材质的一些对齐方式。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200826163308.png" width="300" alt="UE4界面" align=center /></p>
<h3 id="添加互动对象（静态网格物体）"><a href="#添加互动对象（静态网格物体）" class="headerlink" title="添加互动对象（静态网格物体）"></a>添加互动对象（静态网格物体）</h3><p>当我们进行游戏时，除了场景以外，还会有一些互动对象，我们可以添加静态网格物体作为互动对象，其效率更高，但是没有动画，或者不能以其他任何形式进行变化（动态网格可以发生形变），静态网格对象可以设置一些物理或命中特效，例如此处我们打开了方块的物理特效，可以发生碰撞及移动，并设置了相关的物理参数。此外，我们还可以添加命中事件，即当方块被某些物体击中时会发生什么效果。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/staticMesh.JPG" width="500" alt="UE4界面" align=center /></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>UE4</category>
      </categories>
  </entry>
  <entry>
    <title>材质与纹理</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/UE4/%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>月亮和雪，是一样的颜色，一样的触感。</p>
</blockquote>
<a id="more"></a>
<p>材质是反应物体对光的交互，供渲染器读取的数据集，包括贴图纹理、光照等。材质赋予了游戏更加真实的体验，本文将针对UE4中材质相关的一些问题进行总结。</p>
<h2 id="创建并编辑材质"><a href="#创建并编辑材质" class="headerlink" title="创建并编辑材质"></a>创建并编辑材质</h2><h3 id="创建材质"><a href="#创建材质" class="headerlink" title="创建材质"></a>创建材质</h3><p>在内容浏览器Material文件夹下，右键选择创建材质。命名后我们就有了一个自定义的材质，虽然什么效果也没有，但是我们已经可以将材质赋予网格对象。双击材质文件，我们即可进入材质编辑界面：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200826221826.png" width = "700" alt="UE4界面" align=center /></p>
<h3 id="编辑材质"><a href="#编辑材质" class="headerlink" title="编辑材质"></a>编辑材质</h3><p>材质编辑是通过一种块的拖放方式进行编辑的，通过将块连接至不同的节点，我们即可调节材质的相关属性，类似simulink。下面我们来编辑一个简单的材质。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>移动材质图标：按住鼠标右键拖动</li>
<li>放大缩小窗口：鼠标右键+调节滚轮</li>
<li>返回最终输入节点：点击主页</li>
</ul>
<h4 id="设置材质属性"><a href="#设置材质属性" class="headerlink" title="设置材质属性"></a>设置材质属性</h4><p>选择一个Constant Vector3d节点，然后设置数值，将其连接至Material的基础颜色，即可对Material颜色进行修改。其他的什么高光度、粗糙度（磨砂效果）、Metallic类似，只是向量维数不同。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200826222801.png" width = "300" alt="UE4界面" align=center /></p>
<h5 id="材质属性解释"><a href="#材质属性解释" class="headerlink" title="材质属性解释"></a>材质属性解释</h5><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
<th>维数</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础颜色</td>
<td>调节材质基础颜色</td>
<td>3d</td>
</tr>
<tr>
<td>金属</td>
<td>赋予材质金属质感</td>
<td>1</td>
</tr>
<tr>
<td>高光</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td>粗糙度</td>
<td>磨砂或光华效果</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>UE4</category>
      </categories>
  </entry>
  <entry>
    <title>碰撞检测</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/UE4/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>长安街禁止碰瓷</p>
</blockquote>
<a id="more"></a>
<p>碰撞检测是游戏中非常关键的机制，同时也是一个问题非常多的机制，处理不好就可能会导致对象抽搐、穿模以及漏检等情况。本文将对碰撞检测的机理进行总结，并对UE4中实现碰撞检测的过程进行总结。</p>
<h2 id="碰撞检测技术"><a href="#碰撞检测技术" class="headerlink" title="碰撞检测技术"></a>碰撞检测技术</h2><h3 id="BSP树的碰撞检测技术"><a href="#BSP树的碰撞检测技术" class="headerlink" title="BSP树的碰撞检测技术"></a>BSP树的碰撞检测技术</h3><h3 id="曲面物体及碰撞检测"><a href="#曲面物体及碰撞检测" class="headerlink" title="曲面物体及碰撞检测"></a>曲面物体及碰撞检测</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>UE4</category>
      </categories>
  </entry>
  <entry>
    <title>模型</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/UE4/%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>俗說天地開辟，未有人民，女媧搏黃土作人。 劇務，力不暇供，乃引繩於泥中，舉以為人。 </p>
</blockquote>
<a id="more"></a>
<h2 id="导入第三方模型"><a href="#导入第三方模型" class="headerlink" title="导入第三方模型"></a>导入第三方模型</h2><p>UE4支持ASCII Scene Export（*.ASE）格式文件的静态网格模型，以及AutoDesk的FBX格式文件。导入静态网格模型时，直接拖入UE4即可。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>UE4</category>
      </categories>
  </entry>
  <entry>
    <title>UML类图</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/UML/UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对UML使用方法进行总结。其中用到的plantUML绘图请详见<a href="/2024/10/13/工具/Hexo/Hexo绘图教程/" title="使用plantUML进行绘图的教程">使用plantUML进行绘图的教程</a>。</p>
<a id="more"></a>
<h2 id="UML类及类间关系实例1"><a href="#UML类及类间关系实例1" class="headerlink" title="UML类及类间关系实例1"></a>UML类及类间关系实例<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><p>我们从一个具体的类图来表示UML类常见的一些关系：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201129173530.png" width="600" alt="类图示例" align=center /></p>
<p>在上面的图中，我们可以读出如下信息：</p>
<ul>
<li>车的类图结构为&lt;<abstract>&gt;，代表抽象类</li>
<li>有两个继承类，汽车和自行车；它们之间为实现关系</li>
<li>小汽车与SUV为继承关系，它们之间为泛化关系，使用带空心箭头的实线表示</li>
<li>小汽车与发动机和轮胎之间为组合关系，使用带实心菱形箭头的实线表示</li>
<li>学生对自行车是依赖关系，使用带箭头虚线表示</li>
<li>学生和身份证是强关联关系，使用一根实现表示</li>
<li>学生和班级是聚合关系，使用带空心菱形箭头的实线表示</li>
</ul>
<h2 id="UML类图组成"><a href="#UML类图组成" class="headerlink" title="UML类图组成"></a>UML类图组成</h2><p>一个由UML表示的类如下图所示，包括属性与方法两个部分。</p>
<img  src=http://www.plantuml.com/plantuml/svg/Kr1GKE3YIiv9B2vMS2dDpQrKgEPIK0WkAShCIrT8IIn91FBAyZDJ579JIpBoKuerDBbgkG00>
<h2 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h2><h3 id="类间常用关系一览"><a href="#类间常用关系一览" class="headerlink" title="类间常用关系一览"></a>类间常用关系一览</h3><h4 id="1-泛化关系（继承非抽象类）"><a href="#1-泛化关系（继承非抽象类）" class="headerlink" title="1 泛化关系（继承非抽象类）"></a>1 泛化关系（继承非抽象类）</h4><p>如果一个模型元素（子代）基于另一个模型元素（父代），那么这两个元素之间就存在泛化关系，例如汽车是父类，而跑车作为汽车的一种，是汽车定义的具体的对象，两者之间为泛化关系，跑车继承自汽车。在最终代码中，<strong>泛化关系表示为继承非抽象类</strong>。</p>
<img  src=http://www.plantuml.com/plantuml/svg/Kr1GKE3YSauiKh2fqTKD3WtZ0W00>
<h4 id="2-实现关系（继承抽象类）"><a href="#2-实现关系（继承抽象类）" class="headerlink" title="2 实现关系（继承抽象类）"></a>2 实现关系（继承抽象类）</h4><p>实现关系用于表示某物是另一物的具体实现，如果给定一个抽象概念，例如动物，现实中无法直接用动物定义对象，只有指明具体物种子类例如猫，才能进行定义。在上面的例子中动物是抽象类，猫是具体类，两者之间为实现关系，在代码中，<strong>实现关系表示为继承抽象类。</strong></p>
<img  src=http://www.plantuml.com/plantuml/svg/Kr1GKE3Y2alDo4pEILMmgT7JKt1EBE820000>
<h4 id="3-聚合关系（整体由部分构成）"><a href="#3-聚合关系（整体由部分构成）" class="headerlink" title="3 聚合关系（整体由部分构成）"></a>3 聚合关系（整体由部分构成）</h4><p>聚合关系用于表示实体对象间关系，例如班级是由学生组成的，与组合关系不同，聚合是一种弱组织，整体消失，个体依然存在，例如一个班级被撤销了，但是学生还是存在的，在代码中，聚合关系表示为采用某种数据结构对个体进行组织，例如可以定义一个班级类，其中由指针数组指向多个学生实体。</p>
<img  src=http://www.plantuml.com/plantuml/svg/Kr1GKE3YSiv9B2vMoDVLLGWkAKr9pIlX0W00>
<h4 id="4-组合关系"><a href="#4-组合关系" class="headerlink" title="4 组合关系"></a>4 组合关系</h4><p>组合关系表示整体是由部分组成的，但是是一种强组织关系，一旦整体不存在，部分也就不存在。例如一个汽车是由发动机、轮胎等组成的，一旦汽车消失，这些部件也将消失。在代码中，组合关系可以表示为<strong>Has-a</strong>的关系，一般以成员变量的形式存在。</p>
<img  src=http://www.plantuml.com/plantuml/svg/Kr1GKE3YyYZDJSnJqDBLLV18JImguG80>
<h4 id="5-关联关系"><a href="#5-关联关系" class="headerlink" title="5 关联关系"></a>5 关联关系</h4><p>关联关系表示两者之间是一一对应的关系，用于描述对象间静态的，天然的关系，与运行状态无关。例如学生和学生证，天然构成了一种一一对应的关联关系。关联关系一般不强调方向，表示对象间互相关联，通常以成员变量的形式存在。</p>
<img  src=http://www.plantuml.com/plantuml/svg/Kr1GKE3YyYZDJSnJqDLLy7HnJYnAuG80>
<h4 id="6-依赖关系"><a href="#6-依赖关系" class="headerlink" title="6 依赖关系"></a>6 依赖关系</h4><p>依赖关系是一种很弱的关系，表示一个对象在运行期间可能会使用另一个对象，例如在一个游戏中，人使用自行车，两者就构成了依赖关系，但是人可以扔到自行车转而使用汽车，此时依赖关系就发生了改变。依赖关系应当尽可能保证单向性，避免双向依赖。在最终代码中，依赖关系体现为类方法的传入参数的。</p>
<img  src=http://www.plantuml.com/plantuml/svg/Kr1GKE3YSihCJbMmqTDJ22ufJKdDA-420000>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">看懂UML类图和时序图</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>UML</category>
      </categories>
  </entry>
  <entry>
    <title>YouCompleteMe在Archlinux下的安装使用</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Vim/YouCompleteMe%E5%9C%A8archlinux%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对VIM代码补全插件YouCompleteMe在Archlinux下的安装使用进行总结。</p>
<a id="more"></a>
<h2 id="YouCompleteMe安装"><a href="#YouCompleteMe安装" class="headerlink" title="YouCompleteMe安装"></a>YouCompleteMe安装</h2><p>安装过程参考如下博文<a href="https://zzz.buzz/zh/2016/04/16/install-vim-youcompleteme-on-archlinux/">YouCompleteMe在Archlinux下的安装</a>安装过程需要挂载代理，否则无法下载谷歌的go工具包。<br>需要注意的是，文章给出的.vimrc文件的配置需要进行修改，将<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let g:ycm_server_python_interpreter = &apos;/usr/bin/python2&apos;</span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let g:ycm_server_python_interpreter = &apos;/usr/bin/python3&apos;</span><br></pre></td></tr></table></figure></p>
<p>YouCompleteMe的服务器才能正确启动，否则在打开vim后，服务器会崩溃。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title>Unity学习资料总结</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Unity/Unity%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文对Unity相关学习资料进行了总结。</p>
<a id="more"></a>
<h2 id="视频资料"><a href="#视频资料" class="headerlink" title="视频资料"></a>视频资料</h2><h3 id="How-to-make-a-2D-Game-in-Unity-YouTube"><a href="#How-to-make-a-2D-Game-in-Unity-YouTube" class="headerlink" title="How to make a 2D Game in Unity - YouTube"></a><a href="https://www.youtube.com/watch?v=on9nwbZngyw&amp;list=RDCMUCYbK_tjZ2OrIZFBvU6CCMiA&amp;start_radio=1&amp;t=2&amp;ab_channel=Brackeys">How to make a 2D Game in Unity - YouTube</a></h3><div class="table-container">
<table>
<thead>
<tr>
<th>课程</th>
<th>内容</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.youtube.com/watch?v=on9nwbZngyw&amp;list=RDCMUCYbK_tjZ2OrIZFBvU6CCMiA&amp;start_radio=1&amp;t=2&amp;ab_channel=Brackeys">How to make a 2D Game in Unity - YouTube</a></td>
<td>介绍Unity工程创建、资源下载（Ctrl + 9），Asset导入</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>vimIDE配置</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Vim/vimIDE%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将对利用VIM作为IDE的配置过程进行介绍。</p>
<a id="more"></a>
<h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><p>关于vim的配置基本均在~/.vimrc文件中进行。</p>
<h2 id="界面配置"><a href="#界面配置" class="headerlink" title="界面配置"></a>界面配置</h2><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h2 id="关键插件及配置"><a href="#关键插件及配置" class="headerlink" title="关键插件及配置"></a>关键插件及配置</h2><h3 id="NerdTree"><a href="#NerdTree" class="headerlink" title="NerdTree"></a>NerdTree</h3><p>NerdTree是VIM的目录插件</p>
<h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">" =============================================================================</span></span><br><span class="line"><span class="string">"</span> 使用 NERDTree 插件查看工程文件。设置快捷键F3打开NerdTree区域</span><br><span class="line"><span class="string">" =============================================================================</span></span><br><span class="line"><span class="string">map &lt;F3&gt; :NERDTreeMirror&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let NERDTreeWinSize=32            "</span> 设置NERDTree子窗口宽度</span><br><span class="line"><span class="built_in">let</span> NERDTreeWinPos=<span class="string">"left"</span>         <span class="string">" 设置NERDTree子窗口位置</span></span><br><span class="line"><span class="string">let NERDTreeShowHidden=1          "</span> 显示隐藏文件</span><br><span class="line"><span class="built_in">let</span> NERDTreeMinimalUI=1           <span class="string">" NERDTree 子窗口中不显示冗余帮助信息</span></span><br><span class="line"><span class="string">let NERDTreeAutoDeleteBuffer=1    "</span> 删除文件时自动删除文件对应 buffer</span><br><span class="line"></span><br><span class="line"><span class="string">" NerdTree ignore certain type files</span></span><br><span class="line"><span class="string">"</span> put this <span class="keyword">in</span> your .vimrc</span><br><span class="line"><span class="built_in">set</span> wildignore+=*.toc,*.pyc,*.o,*.obj,*.svn,*.swp,*.class,*.hg,*.DS_Store,*.min.*,*.aux,*.<span class="built_in">log</span>,*.pdf,*.gz,*.dvi,*.png,*.jpg,*.xcf</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> NERDTreeRespectWildIgnore=1   <span class="string">" Nerdtree config for wildignore</span></span><br></pre></td></tr></table></figure>
<h2 id="多语言环境"><a href="#多语言环境" class="headerlink" title="多语言环境"></a>多语言环境</h2><p>本节将针对vim配置多语言开发环境的方法进行总结</p>
<h3 id="配置latex"><a href="#配置latex" class="headerlink" title="配置latex"></a>配置latex</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>在~/.vimrc文件下添加如下命令<code>nnoremap &lt;C-F6&gt; &lt;ESC&gt;:w&lt;CR&gt;:!xelatex %&lt;CR&gt;</code>，即可使用Ctrl+F6利用xelatex进行编译。</p>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><h5 id="Place-Holder跳转：Ctrl-j"><a href="#Place-Holder跳转：Ctrl-j" class="headerlink" title="Place Holder跳转：Ctrl+j"></a>Place Holder跳转：Ctrl+j</h5><p>在我们编辑latex代码时，会出现<code>&lt;++&gt;</code>这样的占位符号，此时我们只需要按<code>Ctrl+j</code>就可以实现快速跳转，例如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;figure&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">centering</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;figure&#125;</span></span>&lt;++&gt;</span><br></pre></td></tr></table></figure>
<p>当我们创建了figure环境后，只需要按下<code>Ctrl+j</code>即可使光标快速跳至&lt;++&gt;所在位置。</p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>映射可以令我们方便地输入latex中的环境或公式命令等代码，相关映射的使用如下所示：</p>
<h5 id="环境映射：F5"><a href="#环境映射：F5" class="headerlink" title="环境映射：F5"></a>环境映射：F5</h5><p>当我们想快速插入环境时，只要按下F5，就会弹出环境选择面板，可以按序号添加想要的环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Choose which environment to insert:</span><br><span class="line">(1) equation    (2) equation*</span><br><span class="line">(3) align       (4) align*</span><br><span class="line">(5) enumerate   (6) itemize</span><br><span class="line">(7) figure      (8) table</span><br><span class="line"></span><br><span class="line">Enter name or number of environment :</span><br></pre></td></tr></table></figure>
<h5 id="命令映射"><a href="#命令映射" class="headerlink" title="命令映射"></a>命令映射</h5><p>如果我们想得到<code>\frac{&lt;++&gt;}{&lt;++&gt;}&lt;++&gt;</code>，可以在输入模式下输入frac，然后输入F7，即可得到完整的命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">frac</span><span class="string">&#123;&lt;+n+&gt;&#125;</span><span class="string">&#123;&lt;+d+&gt;&#125;</span></span>&lt;++&gt;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.jianshu.com/p/ddd825064062">VIM Latex 使用</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title>信号分析基本术语</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对信号分析中的基本术语进行总结。</p>
<a id="more"></a>
<h2 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h2><h3 id="信号的能量、功率及谱密度"><a href="#信号的能量、功率及谱密度" class="headerlink" title="信号的能量、功率及谱密度"></a>信号的能量、功率及谱密度</h3><h4 id="信号的能量及功率在时频域下的表示"><a href="#信号的能量及功率在时频域下的表示" class="headerlink" title="信号的能量及功率在时频域下的表示"></a>信号的能量及功率在时频域下的表示</h4><p>对于一个信号$x(t)$，该信号可以是任意随着时间变化的物理量，那么我们可以对该信号进行能量分析。例如对于一个电流信号$I$，其能量如下：</p>
<script type="math/tex; mode=display">
W=\lim _{T \rightarrow \infty} \int_{-T}^{T} I^{2} R \mathrm{d} t</script><p>推广至一般情况，一个信号的能量$W$为：</p>
<script type="math/tex; mode=display">
W=\lim _{T \rightarrow \infty} \int_{-T}^{T} x^{2}(t) \mathrm{d} t</script><p>同时，我们可以对信号进行频域分析，获得信号在频域下的能量表示：</p>
<script type="math/tex; mode=display">
W=\frac{1}{2 \pi} \int_{-\infty}^{\infty}|X(\omega)|^{2} \mathrm{d} \omega, X(\omega)=\int_{-\infty}^{+\infty} x(t) \mathrm{e}^{-\mathrm{j} \omega t} \mathrm{d} t</script><p>信号的平均功率为：</p>
<script type="math/tex; mode=display">
P=\lim _{T \rightarrow \infty} \frac{1}{2T} \int_{-T}^{T} x^{2}(t) \mathrm{d} t</script><p>对于不同的信号，上面关于能量或功率的极限可能并不存在，如果$W$的极限存在，那么该信号为能量信号，如果$P$极限存在，该信号为功率信号。一个信号可以既不是能量也不是功率信号，但是不能即是能量信号又是功率信号。</p>
<h4 id="谱密度"><a href="#谱密度" class="headerlink" title="谱密度"></a>谱密度</h4><h5 id="能量谱密度（能量在频率上的密度）"><a href="#能量谱密度（能量在频率上的密度）" class="headerlink" title="能量谱密度（能量在频率上的密度）"></a>能量谱密度（能量在频率上的密度）</h5><p>对于一个能量信号，通过傅立叶变换可以分离不同频域分量对应的能量，频率$\omega$对应的能量为：</p>
<script type="math/tex; mode=display">
dW=|X(\omega)|^{2}d(\omega/2\pi)</script><p>对$\omega$积分就能得到信号总能量，那么$|X(\omega)|^{2}$即为能量谱密度，是能量在某一频率上的分布密度，实际即为能量相对于频率的密度</p>
<h5 id="功率谱密度"><a href="#功率谱密度" class="headerlink" title="功率谱密度"></a>功率谱密度</h5><p>根据能量谱密度的含义，那么功率谱密度实际就是功率相对于频率的密度。我们选取一个周期功率信号$x(t)$，其在时间上无始无终，能量是无限的，但是功率是有限的，对信号进行傅立叶展开，可以写为：</p>
<script type="math/tex; mode=display">
x(t)=\sum_{n=1}^{\infty} A_{n} \sin \left(n \Omega_{0} t+\varphi_{n}\right), \Omega_{0}=\frac{2 \pi}{T_{0}}</script><p>或表示为复指数形式：</p>
<script type="math/tex; mode=display">
x(t)=\sum_{n=-\infty}^{+\infty} c_{n} e^{j n \cdot \Omega_{0} t}</script><p>我们选取一个周期进行能量平均，可以得到一个周期内的平均功率为：</p>
<script type="math/tex; mode=display">

P=\frac{1}{T_{0}} \int_{0}^{T_{0}} x^{2}(t) \mathrm{d} t=\frac{1}{T_{0}} \int_{0}^{T_{0}}\left[\sum_{n=1}^{\infty} A_{n} \sin \left(n \Omega_{0} t+\varphi_{n}\right)\right]^{2} \mathrm{d} t</script><p>或</p>
<script type="math/tex; mode=display">
P=\frac{1}{T_{0}} \int_{0}^{T_{0}}\left(\sum_{n=-\infty}^{+\infty} c_{n} \mathrm{e}^{j n \Omega_{0} t}\right)^{2} \mathrm{d} t</script><p>根据正交性，我们可以得到：</p>
<script type="math/tex; mode=display">

P=\sum_{n=1}^{\infty}\left(A_{n}^{2} / 2\right)=\sum_{n=1}^{\infty} P_{n}</script><p>或</p>
<script type="math/tex; mode=display">
P=\sum_{n=-\infty}^{+\infty}\left(\left|c_{n}\right|^{2} / 2\right)=\sum_{n=-\infty}^{+\infty} P_{n}^{*}</script><p>其中$A_n$为谐波分量的幅值，$P_n$为谐波分量的功率。结论为：周期信号的平均功率等于各谐波分量幅值的平方和，我们的结论就是周期信号的功率是离散地分布在频率为基频$\Omega_0$整数倍的谐波分量上的。如果我们以频率为横坐标，功率为纵坐标，可以得到功率随频率的分布。容易观察到，周期信号的功率谱分布是离散的，等间隔的，间隔长度即为基频。</p>
<h4 id="谱密度分布"><a href="#谱密度分布" class="headerlink" title="谱密度分布"></a>谱密度分布</h4><h5 id="均匀分布（不相关）"><a href="#均匀分布（不相关）" class="headerlink" title="均匀分布（不相关）"></a>均匀分布（不相关）</h5><p>当功率谱密度服从均匀分布时，意味着任意时刻出现的噪声幅值是随机的，即某一时刻噪点孤立，不受其他时间点噪声的影响。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.zhihu.com/question/29520851">信号的功率谱密度</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>信号分析</category>
      </categories>
  </entry>
  <entry>
    <title>Vim常用基本命令</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/Vim/vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Vim中的基本命令进行介绍。</p>
<a id="more"></a>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul>
<li>y<n>y 复制n行</li>
<li>剪贴板复制：”+y<n>y (先按”再按+再按y<n>y) 将内容复制进系统粘贴板，”+p粘贴</li>
<li>复制制定行，在命令行模式下，输入<code>: 13, 16 co 24</code>就可以将13至16行复制到24行的位置</li>
</ul>
<h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><ul>
<li>p</li>
</ul>
<h3 id="删除与剪切"><a href="#删除与剪切" class="headerlink" title="删除与剪切"></a>删除与剪切</h3><ul>
<li>d 剪切整行</li>
<li>d<n>d 剪切n行</li>
</ul>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul>
<li>0(zero) 光标移至行首</li>
<li>$ 光标移至行尾</li>
<li><n>gg 光标跳转至第n行 </li>
</ul>
<h3 id="窗口切换"><a href="#窗口切换" class="headerlink" title="窗口切换"></a>窗口切换</h3><ul>
<li>CTRL+w+方向键上下左右</li>
<li>CTRL+w 连续切换</li>
<li>CTRL+6 在两个文件中进行切换</li>
</ul>
<h3 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h3><ul>
<li>zc 折叠</li>
<li>zo 展开</li>
</ul>
<h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><h3 id="窗口切分"><a href="#窗口切分" class="headerlink" title="窗口切分"></a>窗口切分</h3><ul>
<li>:sp 水平切分</li>
<li>:vsp 竖直拆分</li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>在命令模式下，输入/及带查找的字符串，按下回车会跳转至第一个符合条件的结果处，按<code>n</code>查看下一个匹配</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title>扰动与噪声</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/%E6%89%B0%E5%8A%A8%E4%B8%8E%E5%99%AA%E5%A3%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在理想情况下，我们希望自己的模型建模完美并处于理想的工作环境下，但现实是设计的系统时时刻刻处于扰动及噪声之下，本文将对控制系统的扰动与噪声以及应对措施进行总结。</p>
<a id="more"></a>
<h2 id="扰动与噪声"><a href="#扰动与噪声" class="headerlink" title="扰动与噪声"></a>扰动与噪声</h2><h3 id="扰动"><a href="#扰动" class="headerlink" title="扰动"></a>扰动</h3><h3 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h3><h4 id="常见噪声类型及数学模型"><a href="#常见噪声类型及数学模型" class="headerlink" title="常见噪声类型及数学模型"></a>常见噪声类型及数学模型</h4><p>我们可以根据功率谱密度，对常见的噪声进行分类。</p>
<h5 id="高斯噪声（加性噪声）"><a href="#高斯噪声（加性噪声）" class="headerlink" title="高斯噪声（加性噪声）"></a>高斯噪声（加性噪声）</h5><p>高斯噪声即概率密度函数服从高斯分布的一类噪声，与椒盐噪声相反，高斯噪声是一种几乎每个点都会出现的噪声，并且噪点深度随机。</p>
<h5 id="椒盐噪声"><a href="#椒盐噪声" class="headerlink" title="椒盐噪声"></a>椒盐噪声</h5><p>椒盐噪声是出现在随机位置、噪点深度基本固定的噪声。</p>
<h5 id="白噪声"><a href="#白噪声" class="headerlink" title="白噪声"></a>白噪声</h5><h5 id="高斯白噪声（高斯噪声-白噪声）"><a href="#高斯白噪声（高斯噪声-白噪声）" class="headerlink" title="高斯白噪声（高斯噪声+白噪声）"></a>高斯白噪声（高斯噪声+白噪声）</h5><p>高斯白噪声幅度服从高斯分布，而功率谱密度服从均匀分布，即在每个频率分量上，其对应的功率是均匀的</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>控制科学</category>
        <category>信号分析</category>
      </categories>
  </entry>
  <entry>
    <title>Kalman Filter</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/Kalman_Filter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Kalman filter is <strong>an optimal estimation algorithm.</strong> It can help us to estimate a system state when it cannot be measured directly. This blog discusses the Kalman Filter which is widely used to filtering the noise and disturbance in a random system. </p>
<a id="more"></a>
<p>In a practical dynamic system, there are three types of uncertainties:</p>
<ul>
<li>random disturbance </li>
<li>measurement noise</li>
<li>uncertainty of system parameters</li>
</ul>
<p>So we encounter such a problem: how we estimate the state of a system from the measurement affected by noises? Here the Kalman filter gives an answer.</p>
<h2 id="Prior-knowledge"><a href="#Prior-knowledge" class="headerlink" title="Prior knowledge"></a>Prior knowledge</h2><ul>
<li>Bayesian estimation, see , you should look for the prior and posterior.</li>
</ul>
<h2 id="What-is-Kalman-filter"><a href="#What-is-Kalman-filter" class="headerlink" title="What is Kalman filter"></a>What is Kalman filter</h2><p>First, always remember that the Kalman filter is an optimal algorithm, when we mention optimal, that means we are going to solve an optimal problem</p>
<script type="math/tex; mode=display">
\min E\left \| x-\hat{x} \right \|^{2}</script><p>So now, let’s give out the basic dynamic system model we are going to deal with and the mathematical description about Kalman filter.</p>
<h3 id="Basic-dynamic-system"><a href="#Basic-dynamic-system" class="headerlink" title="Basic dynamic system"></a>Basic dynamic system</h3><p>In a Kalman filter, we assume that the real state at time $k$ is determined by last time $k-1$:</p>
<script type="math/tex; mode=display">
\mathbf{x}_{k}=\mathbf{F}_{k} \mathbf{x}_{k-1}+\mathbf{B}_{k} \mathbf{u}_{k}+\mathbf{w}_{k}</script><p>where </p>
<ul>
<li>$\mathbf{F}_{k}$ is the transfer matrix</li>
<li>$\mathbf{B}_{k}$ is the input matrix</li>
<li>$\mathbf{w}<em>{k}$ is the process noise satisfies $\mathbf{w}</em>{k} \sim N\left(0, \mathbf{Q}_{k}\right)$.</li>
</ul>
<p>At time $k$, a measurement $\mathbf{z}<em>{k}$ of $\mathbf{x}</em>{k}$ satisfies:</p>
<script type="math/tex; mode=display">
\mathbf{z}_{k}=\mathbf{H}_{k} \mathbf{x}_{k}+\mathbf{v}_{k}</script><p>where</p>
<ul>
<li>$\mathbf{H}_{k}$ is the observation matrix</li>
<li>$ \mathbf{v}<em>{k} $ is the measurement noise satisfies $ \mathbf{v}</em>{k} \sim N\left(0, \mathbf{R}_{k}\right) $.</li>
</ul>
<h3 id="Mathematical-description"><a href="#Mathematical-description" class="headerlink" title="Mathematical description"></a>Mathematical description</h3><p>The state of a Kalman filter can be represented by the following two variables:</p>
<ul>
<li><p>$\hat{\mathbf{x}}_{k|k-1}$: estimation at time $k-1$ without current measurement（先验状态估计，不太好的估计）.</p>
</li>
<li><p>$\hat{\mathbf{x}}_{k|k}$: estimation at time $k$ based on the current measurement（后验状态估计，比较好的估计）.</p>
</li>
<li>$\hat{\mathbf{P}}_{k|k-1}$: prior covariance matrix of estimation error </li>
<li>$\hat{\mathbf{P}}_{k|k}$: posterior covariance matrix of estimation error, used for judge the estimation precision. </li>
</ul>
<script type="math/tex; mode=display">
\hat{\mathbf{P}}_{k|k}=E[(\mathbf{x}_k-\hat{\mathbf{x}}_{k|k})(\mathbf{x}_k-\hat{\mathbf{x}}_{k|k})^T]</script><p>There are two main steps in Kalman filter, estimation and update:</p>
<h4 id="Estimation-“Predict-with-prior-knowledge”"><a href="#Estimation-“Predict-with-prior-knowledge”" class="headerlink" title="Estimation (“Predict with prior knowledge”)"></a>Estimation (“Predict with prior knowledge”)</h4><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned} \hat{\mathbf{x}}_{k | k-1} &=\mathbf{F}_{k} \hat{\mathbf{x}}_{k-1 | k-1}+\mathbf{B}_{k} \mathbf{u}_{k}\\ \mathbf{P}_{k | k-1} &=\mathbf{F}_{k} \mathbf{P}_{k-1 | k-1} \mathbf{F}_{k}^{T}+\mathbf{Q}_{k} \end{aligned}
\end{equation}</script><h4 id="Update-based-on-measurement-“Correct-using-posterior-knowledge”"><a href="#Update-based-on-measurement-“Correct-using-posterior-knowledge”" class="headerlink" title="Update based on measurement (“Correct using posterior knowledge”)"></a>Update based on measurement (“Correct using posterior knowledge”)</h4><p>First we need to compute three variables:</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{array}{l}{\tilde{\mathbf{y}}_{k}=\mathbf{z}_{k}-\mathbf{H}_{k} \hat{\mathbf{x}}_{k | k-1} } \\ {\mathbf{S}_{k}=\mathbf{H}_{k} \mathbf{P}_{k | k-1} \mathbf{H}_{k}^{T}+\mathbf{R}_{k}} \\ {\mathbf{K}_{k}=\mathbf{P}_{k | k-1} \mathbf{H}_{k}^{T} \mathbf{S}_{k}^{-1}}\end{array}
\end{equation}</script><ul>
<li>$\tilde{\mathbf{y}}_{k}$ is the measurement residual (error between measurement and estimation)</li>
<li>$\mathbf{S}_{k}$ is the covariance matrix of measurement residual</li>
<li>$\mathbf{K}_{k}$ is the optimal Kalman gain</li>
</ul>
<p>Then we use them to update variable $\mathbf{x}$ and $\mathbf{P}$</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned} \hat{\mathbf{x}}_{k | k} &=\hat{\mathbf{x}}_{k | k-1}+\mathbf{K}_{k} ({\mathbf{y}}_{k}-\mathbf{H\hat{\mathbf{x}}_{k | k-1}})\\ 
\mathbf{P}_{k | k} &=\left(I-\mathbf{K}_{k} \mathbf{H}_{k}\right) \mathbf{P}_{k | k-1} \end{aligned}
\end{equation}</script><ul>
<li>The first function is the updated state estimation</li>
<li>The second is the updated covariance matrix of estimation error</li>
</ul>
<p>从上面的公式可以看出，卡尔曼增益$\mathbf{K}$实际代表了预测误差与测量误差之间的比重，当$\mathbf{K}=0$，则完全依靠预测，而当$\mathbf{K}=1$，则完全依靠测量。对于上式，两边各减去真实状态$\mathbf{x}_{k}$，可得：</p>
<script type="math/tex; mode=display">
\hat{\mathbf{x}}_{k | k} - \mathbf{x}_{k | k} =\hat{\mathbf{x}}_{k | k-1} - \mathbf{x}_{k | k}+\mathbf{K}_{k} ({\mathbf{y}}_{k}-\mathbf{H\hat{\mathbf{x}}_{k | k-1}})</script><p>即后验估计误差与先验估计误差之间的关系：</p>
<script type="math/tex; mode=display">
\mathbf{e}_{k | k} ={\mathbf{e}}_{k | k-1}+\mathbf{K}_{k} ({\mathbf{y}}_{k}-\mathbf{H\hat{\mathbf{x}}_{k | k-1}})</script><p>那么问题来了，如何选择$\mathbf{K}$，从而达到最优呢？我们可以</p>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>In this section we are going to design a Kalman filter for the inverted pendulum mentioned in <a href="/2024/10/13/控制科学/控制理论/State-space_feedback_and_estimators/" title="State feedback control">State feedback control</a>. </p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://en.wikipedia.org/wiki/Kalman_filter">Wiki about Kalman filter</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.researchgate.net/publication/243786641_Kalman_filtering_theory_and_practice_using_MATLAB">Andrews A P. Kalman Filtering: Theory and Practice Using MATLAB[M]. Wiley, 2001.</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="http://www.cs.uwc.ac.za/~kschef/papers/Kalman_tutorial.pdf.gz">Welch G, Bishop G. An introduction to the Kalman filter[J]. 1995.</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
        <category>自适应控制</category>
      </categories>
      <tags>
        <tag>Important</tag>
      </tags>
  </entry>
  <entry>
    <title>光照</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/UE4/%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>神说，要有光，于是便有了光</p>
</blockquote>
<a id="more"></a>
<h2 id="光照基本介绍"><a href="#光照基本介绍" class="headerlink" title="光照基本介绍"></a>光照基本介绍</h2><p>光照是游戏的最基本且重要的效果之一，现代游戏其中一个特性就是对于光照的尽可能真实的模拟，本文将对UE4中的光照特性进行一些总结。</p>
<h3 id="光照类型"><a href="#光照类型" class="headerlink" title="光照类型"></a>光照类型</h3><ul>
<li>定向光源：模拟平行光或者阳光</li>
<li>点光源：模拟灯泡</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200826170312.png" width = "400" alt="UE4界面" align=center /></p>
<ul>
<li>聚光源：模拟锥形光源</li>
<li>矩形光源</li>
<li>天光：模拟自然环境光线</li>
</ul>
<p>通过调节光源的细节，可以设置光照强度、范围、颜色等。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于光源的渲染需要大量的运算，所以UE4项目在每次调整后如果有影响光效的改动，是需要重新进行编译的。我们也可以仅仅构建光源，点击构建，即可对光源单独进行构建。同时，也不允许太多光源靠的太近，否则会严重影响性能。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射捕获"><a href="#反射捕获" class="headerlink" title="反射捕获"></a>反射捕获</h3><p>反射捕获的作用是在反射捕获范围内对其中的静态网格等对象计算光线反射相互作用的影响，UE4中有静态反射捕获和实时反射捕获，反射捕获球和反射方块属于</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>工具</category>
        <category>UE4</category>
      </categories>
  </entry>
  <entry>
    <title>Model Predictive Control(1)--What and why MPC</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/Model_predictive_control/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Model predictive control is like playing chess, at ,each time step, you choose the best strategy to win. In this process, you make <strong>prediction</strong> based on current situation.</p>
<a id="more"></a>
<p>Model predictive control (MPC), also known as dynamical matrix control (DMC), generalized predictive control (GPC) or receding horizon control (RHC), is an online control algorithm based on numerically solving an optimal problem at each step. This article gives a summarization about model predictive control strategy. It is mainly a summarization about reference <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>  </p>
<h2 id="Why-MPC"><a href="#Why-MPC" class="headerlink" title="Why MPC"></a>Why MPC</h2><ul>
<li>Intuitive concept, easy to understand and implement</li>
<li>Systematic handling of constrains</li>
<li>Can handle MIMO and dead-time without modification</li>
<li>Feed forward to make good use of future target information </li>
<li>Handling challenging dynamics (unlike PID)</li>
</ul>
<p>MPC has been widely used in industry because it has been proved that by giving superior control, the profits can be improved: </p>
<ul>
<li><strong>If one is confident that the variance of the output can be reduced, one can then safely operate closer to a constraint and increase quantity.</strong> </li>
<li>It has the ability to incorporate constraints explicitly enables ‘optimum’ constrained performance</li>
</ul>
<h2 id="What-is-MPC4"><a href="#What-is-MPC4" class="headerlink" title="What is MPC4"></a>What is MPC<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></h2><h3 id="Main-components-Important"><a href="#Main-components-Important" class="headerlink" title="Main components (Important)"></a>Main components (Important)</h3><ol>
<li>Prediction</li>
<li>Receding horizon (滑动窗口)</li>
<li>Modelling</li>
<li>Performance index</li>
<li>Degree of freedom</li>
<li>Constraint handling</li>
<li>Multivariable (MIMO)</li>
</ol>
<p>We will discuss them one by one</p>
<h3 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h3><p>When we talk about prediction, answer the following question:</p>
<ul>
<li>Why is prediction important</li>
</ul>
<blockquote>
<p>Think three step before do one step — 三思而后行</p>
</blockquote>
<p>Before planning an activity, always think though about all the likely consequences or there will be disasters!!!</p>
<ul>
<li><p><strong>How to predict</strong> and <strong>how far</strong> and <strong>how accurate</strong> should we predict</p>
<ul>
<li>How far</li>
</ul>
<p>Prediction horizon is often mistreated as a tuning parameters in MPC. However, in terms of normal human behavior, we all know how far we need to predict, for example:</p>
<blockquote>
<p>Q: When driving a car, what is the prediction horizon</p>
<p>A: <strong>You should predict beyond the safe braking distance, our you will die!</strong> For example, while driving 70 mph, you need to look at least 100 m ahead, while driving 20 mph, 20 m is OK.</p>
</blockquote>
<p>   <table><tr><td bgcolor=#F7DC6F   style="vertical-align:middle; text-align:center;">Prediction horizen > settling time!</td></tr></table><br><strong>Summary: </strong>always look beyond the key dynamics of a process</p>
<p>Consequence of not predicting: Low performance, maybe disasters.</p>
<h3 id="Receding-horizen"><a href="#Receding-horizen" class="headerlink" title="Receding horizen"></a>Receding horizen</h3></li>
</ul>
<p>It means that we continually update our predictions and decision making to take account of the most recent target and measurement data.</p>
<p><strong>One effect is that the prediction horizon is always relative to the current position and recedes away from the viewer as the viewer moves forward.</strong></p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/prediction.png" width = "450"  alt="图片名称" align=center /></p>
<h4 id="Feedback-from-MPC"><a href="#Feedback-from-MPC" class="headerlink" title="Feedback from MPC"></a>Feedback from MPC</h4><p>In MPC, the continual update prediction and decision making based on the measurement data introduces the feedback. (<strong>Measurement introduces feedback.</strong>)</p>
<ol>
<li>Measurement is a core part of a feedback loop</li>
<li>decision based on measurement are the second core part</li>
</ol>
<p>Predictive control incorporates both.</p>
<h3 id="Modelling"><a href="#Modelling" class="headerlink" title="Modelling"></a>Modelling</h3><p>Modelling is a core part of prediction control. People can predict based on experience, same idea, in order to make prediction, the behaviors of a system should be clear and the model is required.</p>
<p>However, here comes the problem, what is an appropriate prediction model?</p>
<h4 id="Modelling-requirements"><a href="#Modelling-requirements" class="headerlink" title="Modelling requirements"></a>Modelling requirements</h4><ul>
<li>Easy to form prediction - ideally linear</li>
<li>Easy to identify model parameters</li>
<li><p>Accurate prediction: steady-state, fast transients, mid-response…… </p>
<p> <table><tr><td bgcolor=#F7DC6F   style="vertical-align:middle; text-align:center;">The simplest model gives accurate prediction is usually the best.</td></tr> </p>
</li>
</ul>
<p>But it’s OK if the model is not that accurate, because we have feedback to deal with the small error. </p>
<h3 id="Performance-index"><a href="#Performance-index" class="headerlink" title="Performance index"></a>Performance index</h3><p>We could give out descriptions about what constitutes good or bad, for example, we use SLOW, OSCILLATORY, UNSTABLE, IDEAL to describe the step response.</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/response.jpg" width = "450"  alt="图片名称" align=center /></p>
<p>When we talk about performance index, we need to ask the following questions:</p>
<h4 id="1-What-is-the-performance-index-for"><a href="#1-What-is-the-performance-index-for" class="headerlink" title="1. What is the performance index for?"></a>1. What is the performance index for?</h4><p>In order to decide which input trajectory, we need a precise numeric definition of ‘best’, so <strong>the performance index is a numerical definition of what is the best.</strong> However, it should be note that the performance index is still have some contradiction with real situation.</p>
<h4 id="2-How-should-the-performance-index-be-designed"><a href="#2-How-should-the-performance-index-be-designed" class="headerlink" title="2. How should the performance index be designed?"></a>2. How should the performance index be designed?</h4><p>The index should be simple, you should only increase the complexity where the benefits is clear. For example:</p>
<blockquote>
<p>With the increase of the experience, people can do more complex activities and give out more challenging performance indices, because our internal model is better through experience.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/lowandhigh.png" width = "350"  alt="图片名称" align=center /></p>
<p><strong>Typically quadratic performance is used, because:</strong></p>
<ul>
<li>It give us well conditioned optimization</li>
<li>Unique minimum</li>
<li>smooth behaviours (unlike 1-norm or inf-norm)</li>
</ul>
<h4 id="3-How-should-we-make-trade-offs-between-optimal-and-safe-robust-performance"><a href="#3-How-should-we-make-trade-offs-between-optimal-and-safe-robust-performance" class="headerlink" title="3. How should we make trade offs between optimal and safe/robust performance?"></a>3. How should we make trade offs between optimal and safe/robust performance?</h4><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/lowandhigh1.png" width = "350"  alt="图片名称" align=center /></p>
<h3 id="Degree-of-freedom-DOF"><a href="#Degree-of-freedom-DOF" class="headerlink" title="Degree of freedom (DOF)"></a>Degree of freedom (DOF)</h3><p>DOF describes the complexity of the input predictions, it is closely linked to the performance index. There is no point to use high DOF with a highly performance demanding if the model is poor, it’s just like asking a beginner to play like a master!</p>
<p>  <table><tr><td bgcolor=#F7DC6F   style="vertical-align:middle; text-align:center;">The useful num of DOF is related to the prediction accuracy</td></tr> </p>
<p>An ill-posed performance index is shown below:</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-30%20102145.jpg" width = "200"  alt="图片名称" align=center /></p>
<p><em>Try to fit a second order curve with one DOF, BAD!! One degree of freedom can only be applied to simple target</em></p>
<p>In MPC, an ill-posed performance index means that <strong>a low prediction horizon (can not predict further events) compared to the system dynamic and use numerous DOF to optimal tracking with that horizon.</strong> With low prediction horizon, one cannot fully anticipate the consequence of ones actions, so the planned actions maybe poor.</p>
<h3 id="Constraint-handling"><a href="#Constraint-handling" class="headerlink" title="Constraint handling"></a>Constraint handling</h3><p>One major advantage of predictive control is that <strong>it embeds constraints to strategy.</strong> It’s critical to getting effective and robust close-loop behavior. We should know that:</p>
<ol>
<li>The proposed input trajectory is optimal only if it satisfies constraints</li>
<li>More typical control strategy treat constraints after thought (like PID)</li>
</ol>
<blockquote>
<p><strong>Example: overshooting</strong></p>
<p>In some situation, overshooting is a disaster (like the chemical tank level control, if overshooted, the chemical spills everywhere! ), it means we lost control of the system and make explosion.</p>
</blockquote>
<p>In MPC, the constraints (flow, power or speed limitations) are embedded, which means that it will not propose input flows that allow overshooting, the response time may become slower, but much more safer. In PC, the input is limited to 100% and will not allow earlier input choices which make the system unstable</p>
<h3 id="Multivariable-MIMO"><a href="#Multivariable-MIMO" class="headerlink" title="Multivariable (MIMO)"></a>Multivariable (MIMO)</h3><p>In MIMO system, often <strong>changing one input changes all the outputs,</strong> therefore we need an control law consider all the I/Os. One advantage of MPC is that we consider about the interaction, although we need to express the algorithm in mathematical form.</p>
<h2 id="How-MPC-works"><a href="#How-MPC-works" class="headerlink" title="How MPC works"></a>How MPC works</h2><h2 id="Mathematical-form-about-MPC"><a href="#Mathematical-form-about-MPC" class="headerlink" title="Mathematical form about MPC"></a>Mathematical form about MPC</h2><h3 id="Basic-of-MPC"><a href="#Basic-of-MPC" class="headerlink" title="Basic of MPC"></a>Basic of MPC</h3><p>The first thing we need to know that the implementation of MPC is usually in discrete time<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Meanwhile, due to the limitations of physical world, there are constrains:</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}{ll}{U_{\min } \leq u_{i}(k) \leq U_{\max }} & {\text { for all } i=1,2, \ldots, M \text { and } k=0,1,2, \ldots, \infty} \\ {X_{\min } \leq x_{i}(k) \leq X_{\max }} & {\text { for all } i=1,2, \ldots, N \text { and } k=0,1,2, \ldots, \infty}
\end{aligned}
\end{equation}</script><p>so in practical control system, we need to solve a constrained LQR problem, now let’s convert infinite-time limit to a $N$ step finite-time limit. Then our optimal problem becomes a set of linear equations with variables ${\mathrm{x}(1), \mathrm{x}(2), \ldots, \mathrm{x}(\mathrm{N}) ; \mathrm{u}(0), \mathrm{u}(1), \ldots, \mathrm{u}(\mathrm{N}-1)}$, the initial state is $x(0)=x_0$. Now we give out the goal of MPC</p>
<p><strong>Goal:</strong>  find the best control sequence over a future horizon of $N$ steps</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned} 
\min &\sum^{N-1}_{k=0}\left \| W^y(y_k-r(t)) \right \|^2_2+\left \| W^u(u_k-u_r(t)) \right \|^2_2\\
s.t.\quad 
&\mathrm{pridiction}\\
&x_{k+1}=f(x_k,u_k)\\
&y_k=g(x_k,u_k)\\        
&\mathrm{constraints}\\
&u_{\min}\leq u_k \leq u_{\max}\\
&y_{\min}\leq y_k \leq y_{\max}\\
&\mathrm{state\ feedback}\\
&x_0=x(t)
\end{aligned}
\end{equation}</script><h3 id="Linear-MPC-equals-to-linear-state-feedback"><a href="#Linear-MPC-equals-to-linear-state-feedback" class="headerlink" title="Linear MPC (equals to linear state-feedback!)"></a>Linear MPC (equals to linear state-feedback!)</h3><h4 id="Unconstrained-case"><a href="#Unconstrained-case" class="headerlink" title="Unconstrained case"></a>Unconstrained case</h4><p>Let’s consider our linear prediction model:</p>
<script type="math/tex; mode=display">
\begin{equation}
\left\{\begin{aligned} 
x_{k+1} &=A x_{k}+B u_{k} \\ 
y_{k} &=C x_{k} \end{aligned}\right.
\quad\begin{array}{l}{x \in \mathbb{R}^{n}}
\\ {u \in \mathbb{R}^{m}} 
\\ {y \in \mathbb{R}^{p}}\end{array}
\end{equation}</script><p>The relation between input and states is:</p>
<script type="math/tex; mode=display">
\begin{equation}
x_{k}=A^{k} x_{0}+\sum_{j=0}^{k-1} A^{j} B u_{k-1-j}
\end{equation}</script><p>and the performance index is (cost function, see ):</p>
<script type="math/tex; mode=display">
\begin{equation}
J\left(z, x_{0}\right)=x_{N}^{\prime} P x_{N}+\sum_{k=0}^{N-1} x_{k}^{\prime} Q x_{k}+u_{k}^{\prime} R u_{k} \quad \begin{aligned} R &=R^{\prime} \succ 0 \\ Q &=Q^{\prime} \succeq 0 \\ P &=P^{\prime} \succeq 0 \end{aligned} \quad z=\left[\begin{array}{c}{u_{0}} \\ {u_{1}} \\ {\vdots} \\ {u_{N-1}}\end{array}\right]
\end{equation}</script><p><strong>Goal: </strong> find a sequence $z^*$ to minimize cost function $J$. See <a href="/2024/10/13/控制科学/控制理论/LQG_regulator/" title="LQG regulator">LQG regulator</a>. </p>
<script type="math/tex; mode=display">
\begin{equation}
J\left(z, x_{0}\right)=
x_{0}^{\prime} Q x_{0}+\left[\begin{array}{c}{x_{1}} \\ {x_{2}} \\ {\vdots} \\ {x_{N-1}} \\ {x_{N}}\end{array}\right]^{\prime}\left[\begin{array}{ccccc}{Q} & {0} & {0} & {\cdots} & {0} \\ {0} & {Q} & {0} & {\cdots} & {0} \\ {\vdots} & {\vdots} & {\ddots} & {\vdots} & {\vdots} \\ {0} & {\cdots} & {0} & {Q} & {0} \\ {0} & {0} & {\cdots} & {0} & {P}\end{array}\right]\left[\begin{array}{c}{x_{1}} \\ {x_{2}} \\ {\vdots} \\ {x_{N-1}} \\ {x_{N}}\end{array}\right]\\
+\left[\begin{array}{c}{u_{0}} \\ {u_{1}} \\ {\vdots} \\ {u_{N-1}}\end{array}\right]\left[\begin{array}{cccc}{R} & {0} & {\cdots} & {0} \\ {0} & {R} & {\cdots} & {0} \\ {\vdots} & {\vdots} & {\ddots} & {\vdots} \\ {0} & {\cdots} & {0} & {R}\end{array}\right]\left[\begin{array}{c}{u_{0}} \\ {u_{1}} \\ {\vdots} \\ {u_{N-1}}\end{array}\right]
\end{equation}</script><hr>
<script type="math/tex; mode=display">
\begin{equation}
\left[\begin{array}{c}{x_{1}} \\ {x_{2}} \\ {\vdots} \\ {x_{N}}\end{array}\right]=\left[\begin{array}{cccc}{B} & {0} & {\cdots} & {0} \\ {A B} & {B} & {\cdots} & {0} \\ {\vdots} & {\vdots} & {\ddots} & {\vdots} \\ {A^{N-1} B} & {A^{N-2} B} & {\ldots} & {B}\end{array}\right]\left[\begin{array}{c}{u_{0}} \\ {u_{1}} \\ {\vdots} \\ {u_{N-1}}\end{array}\right]+\left[\begin{array}{c}{A} \\ {A^{2}} \\ {\vdots} \\ {A^{N}}\end{array}\right] x_{0}
\end{equation}</script><hr>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned} J\left(z, x_{0}\right) &=\left(\bar{S} z+\bar{T} x_{0}\right)^{\prime} \bar{Q}\left(\bar{S} z+\bar{T} x_{0}\right)+z^{\prime} \bar{R} z+x_{0}^{\prime} Q x_{0} \\ &=\frac{1}{2} z^{\prime} \underbrace{2\left(\bar{R}+\bar{S}^{\prime} \bar{Q} \bar{S}\right)}_{H} z+x_{0}^{\prime} \underbrace{2 \bar{T}^{\prime} \bar{Q} \bar{S}}_{F^{\prime}} z+\frac{1}{2} x_{0}^{\prime} \underbrace{2\left(Q+\bar{T}^{\prime} \bar{Q} \bar{T}\right)}_{Y} x_{0} \end{aligned}
\end{equation}</script><p>Now let’s take a look at the cost function</p>
<script type="math/tex; mode=display">
\begin{equation}
J\left(z, x_{0}\right)=\frac{1}{2} z^{\prime} H z+x_{0}^{\prime} F^{\prime} z+\frac{1}{2} x_{0}^{\prime} Y x_{0}
\end{equation}</script><p>the optimum is obtained by zeroing the gradient </p>
<script type="math/tex; mode=display">
\begin{equation}
\nabla_{z} J\left(z, x_{0}\right)=H z+F x_{0}=0
\end{equation}</script><p>and hence the solution is:</p>
<script type="math/tex; mode=display">
\begin{equation}
z^{*}=\left[\begin{array}{c}{u_{0}^{*}} \\ {u_{1}^{*}} \\ {\vdots} \\ {u_{N-1}^{*}}\end{array}\right]=-H^{-1} F x_{0}=-[I\ 0\ ...\ 0]H^{-1}Fx(t)=Kx(t)
\end{equation}</script><blockquote>
<p><strong>Unconstrained linear MPC = linear state-feedback! </strong></p>
</blockquote>
<h4 id="constrained-case"><a href="#constrained-case" class="headerlink" title="constrained case"></a>constrained case</h4><p>Still the prediction model above, this time we add input and output constraints to enforce, our control problem becomes</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{array}{cl}{\min _{z}} & {x_{N}^{\prime} P x_{N}+\sum^{N-1}_{k=0} x_{k}^{\prime} Q x_{k}+u_{k}^{\prime} R u_{k}} \\ {\text { s.t. }} & {u_{\min } \leq u_{k} \leq u_{\max }, k=0, \ldots, N-1} \\ {} & {y_{\min } \leq y_{k} \leq y_{\max }, k=1, \ldots, N}\end{array}
\end{equation}</script><p>write as condensed form:</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned} V\left(x_{0}\right)=\frac{1}{2} x_{0}^{\prime} Y x_{0}+& \min _{z} \frac{1}{2} z^{\prime} H z+x_{0}^{\prime} F^{\prime} z \\ \text { s.t. } & G z \leq W+S x_{0} \end{aligned}
\end{equation}</script><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-27%20114036.jpg" width = "400"  alt="图片名称" align=center /></p>
<ul>
<li>Input constraints $u<em>{\min } \leq u</em>{k} \leq u_{\max }$</li>
</ul>
<script type="math/tex; mode=display">
\begin{equation}
\left[\begin{array}{cccc}{1} & {0} & {\cdots} & {0} \\ {0} & {1} & {\cdots} & {0} \\ {\vdots} & {} & {\ddots} & {\vdots} \\ {0} & {\cdots} & {0} & {1} \\ {-1} & {0} & {\cdots} & {0} \\ {0} & {-1} & {\cdots} & {0} \\ {\vdots} & {} & {\ddots} & {\vdots} \\ {0} & {\cdots} & {0} & {-1}\end{array}\right] z \leq\left[\begin{array}{c}{u_{\max }} \\ {u_{\max }} \\ {\vdots} \\ {u_{\max }} \\ {-u_{\min }} \\ {-u_{\min }} \\ {\vdots} \\ {-u_{\min }}\end{array}\right] \quad z=\left[\begin{array}{c}{u_{0}} \\ {u_{1}} \\ {\vdots} \\ {u_{N-1}}\end{array}\right]
\end{equation}</script><ul>
<li>Output constraints $<br>y<em>{k}=C A^{k} x</em>{0}+\sum<em>{i=0}^{k-1} C A^{i} B u</em>{k-1-i} \leq y_{\max }, k=1, \ldots, N<br>$</li>
</ul>
<script type="math/tex; mode=display">
\begin{equation}
\left[\begin{array}{cccc}{C B} & {0} & {\cdots} & {0} \\ {C A B} & {C B} & {\cdots} & {0} \\ {\vdots} & {} & {} & {\vdots} \\ {C A^{N-1} B} & {\cdots} & {C A B} & {C B}\end{array}\right] z \leq\left[\begin{array}{c}{y_{\max }} \\ {y_{\max }} \\ {\vdots} \\ {y_{\max }}\end{array}\right]-\left[\begin{array}{c}{C A} \\ {C A^{2}} \\ {\vdots} \\ {C A^{N}}\end{array}\right] x_{0}
\end{equation}</script><h5 id="Linear-MPC-algorithm"><a href="#Linear-MPC-algorithm" class="headerlink" title="Linear MPC algorithm"></a>Linear MPC algorithm</h5><p>At each sampling time $t$:</p>
<ul>
<li>measure (or estimate) the current state $x(t)$</li>
<li>Get the solution $z^<em>=\left[\begin{array}{c}{u_{0}^</em>} \ {u<em>{1}^*} \ {\vdots} \ {u</em>{N-1}^*}\end{array}\right]$ of the QP</li>
</ul>
<script type="math/tex; mode=display">
\begin{equation}
\left\{\begin{array}{cc}{\min _{z}} & {\frac{1}{2} z^{\prime} H z+x^{\prime}(t) F^{\prime} z} \\ {\text { s.t. }} & {G z \leq W+Sx(t)}\end{array}\right.
\end{equation}</script><ul>
<li>Apply only $u(t)=u^<em>_0$, discarding the remaining optimal inputs $u^</em><em>1,…,u^*</em>{N-1}$</li>
</ul>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h3 id="Explicit-MPC-Control-of-a-Single-Input-Single-Output-Plant3"><a href="#Explicit-MPC-Control-of-a-Single-Input-Single-Output-Plant3" class="headerlink" title="Explicit MPC Control of a Single-Input-Single-Output Plant3"></a>Explicit MPC Control of a Single-Input-Single-Output Plant<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h3><p>This subsection is mainly a summarization about reference <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>
<h4 id="Plant-design"><a href="#Plant-design" class="headerlink" title="Plant design"></a>Plant design</h4><p> The linear open-loop dynamic model is a double integrator. </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">plant = tf(<span class="number">1</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="MPC-design"><a href="#MPC-design" class="headerlink" title="MPC design"></a>MPC design</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line">p = <span class="number">10</span>;</span><br><span class="line">m = <span class="number">3</span>;</span><br><span class="line">mpcobj = mpc(plant, Ts, p, m);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>P</code> sets the prediction horizon steps, specified as a positive integer. The product of <code>PredictionHorizon</code> and <code>Ts</code> is the prediction time; that is, <strong>how far the controller looks into the future. </strong></p>
</li>
<li><div><div class="fold_hider"><div class="close hider_title">`M`</div></div><div class="fold">
<p>Control horizon, specified as one of the following:</p>
<ul>
<li>Positive integer, <em>m</em>, <strong>between <code>1</code> and <em>p</em></strong>, inclusive, where <em>p</em> is equal to <code>PredictionHorizon</code>. In this case, the controller computes <em>m</em> free control moves occurring at times <em>k</em> through <em>k</em>+<em>m</em>-1, and holds the controller output constant for the remaining prediction horizon steps from <em>k</em>+<em>m</em> through <em>k</em>+<em>p</em>-1. Here, <em>k</em> is the current control interval.</li>
<li>Vector of positive integers [<em>m</em>1, <em>m</em>2, …], specifying the lengths of blocking intervals. By default the controller computes <em>M</em> blocks of free moves, where <em>M</em> is the number of blocking intervals. The first free move applies to times <em>k</em> through <em>k</em>+<em>m</em>1-1, the second free move applies from time <em>k</em>+<em>m</em>1 through <em>k</em>+<em>m</em>1+<em>m</em>2-1, and so on. Using block moves can improve the robustness of your controller. The sum of the values in <code>ControlHorizon</code> must match the prediction horizon <em>p</em>. If you specify a vector whose sum is:<ul>
<li>Less than the prediction horizon, then the controller adds a blocking interval. The length of this interval is such that the sum of the interval lengths is <em>p</em>. For example, if <em>p</em>=<code>10</code> and you specify a control horizon of <code>ControlHorizon</code>=<code>[1 2 3]</code>, then the controller uses four intervals with lengths <code>[1 2 3 4]</code>.</li>
<li>Greater than the prediction horizon, then the intervals are truncated until the sum of the interval lengths is equal to <em>p</em>. For example, if <em>p</em>=<code>10</code> and you specify a control horizon of <code>ControlHorizon</code>= <code>[1 2 3 6 7]</code>, then the controller uses four intervals with lengths <code>[1 2 3 4]</code>.</li>
</ul>
</li>
</ul>

</div></div>
</li>
</ul>
<p>Specify actuator saturation limits as MV constraints. </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mpcobj.MV = struct(<span class="string">'Min'</span>,<span class="number">-1</span>,<span class="string">'Max'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Generate-Explicit-MPC-Controller"><a href="#Generate-Explicit-MPC-Controller" class="headerlink" title="Generate Explicit MPC Controller"></a>Generate Explicit MPC Controller</h4><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://dl.acm.org/citation.cfm?id=3299491">Rakovi SV, Levine WS. Handbook of Model Predictive Control. Birkh&amp;#228;user Basel; 2018. </a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="http://cse.lab.imtlucca.it/~bemporad/mpc_course.html">A course from Alberto Bemporad</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.mathworks.com/help/mpc/ug/explicit-mpc-control-of-a-single-input-single-output-plant.html">Explicit MPC Control of a Single-Input-Single-Output Plant</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://www.youtube.com/watch?v=w_GA_7sNM3g&amp;list=PLs7mcKy_nInFEpygo_VrqDFCsQVnGaoy-&amp;index=2">A video course about MPC</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
        <category>自适应控制</category>
      </categories>
      <tags>
        <tag>Important</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear Quadratic Gaussian Regulator</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/LQG_regulator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Life is short, always choose the best</p>
</blockquote>
<a id="more"></a>
<p>In this article, we are going to give a summarization about the LQG regulator. Like the pole placement control law, the LQG can also guide us to determine the parameters in a full state-feedback controller. </p>
<h2 id="Prerequisite-knowledge"><a href="#Prerequisite-knowledge" class="headerlink" title="Prerequisite knowledge"></a>Prerequisite knowledge</h2><ul>
<li><a href="/2024/10/13/控制科学/控制理论/State-space_feedback_and_estimators/" title="State feedback control">State feedback control</a>
</li>
<li><a href="/2024/10/13/数学/微分方程/Riccati_equation/" title="Riccati equation">Riccati equation</a>
</li>
</ul>
<h2 id="Linear-quadratic-regulator"><a href="#Linear-quadratic-regulator" class="headerlink" title="Linear quadratic regulator"></a>Linear quadratic regulator</h2><p>Before talking about the LQG regulator, let’s first discuss about LQR since it is a simplified form about LQG. (without Gaussian noises)</p>
<h3 id="A-simple-problem"><a href="#A-simple-problem" class="headerlink" title="A simple problem"></a>A simple problem</h3><p>Consider you are going to a park (desired state) from your home (initial state), you have several choices:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Time</th>
<th style="text-align:center">Cost</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Car</td>
<td style="text-align:center">20min</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">Bike</td>
<td style="text-align:center">75min</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">Bus</td>
<td style="text-align:center">30min</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">Airplane</td>
<td style="text-align:center">4min</td>
<td style="text-align:center">400</td>
</tr>
</tbody>
</table>
</div>
<p>If you want speed, choose airplane, if you have little money, choose bike, or you can make a compromise between time and money to take a car or a bus.</p>
<p>Define a cost function:</p>
<script type="math/tex; mode=display">
\begin{equation}
J=Qt+Rm
\end{equation}
\label{JQtRm}</script><p>where $t$ is time and $m$ is money, $Q$ and $R$ are two weight matrix. <strong>Based on the cost function, we make the optimal choose.</strong> Remember that the cost is strongly related to the weight matrix.</p>
<h3 id="LQR-in-control-system"><a href="#LQR-in-control-system" class="headerlink" title="LQR in control system"></a>LQR in control system</h3><p>Now let’s consider our control system, we want to make a balance between the performance and actuator effort (energy). So we set up a cost function of the performance ($x$) and the effort ($u$):</p>
<script type="math/tex; mode=display">
\begin{equation}
J=\int_{0}^{\infty}\left(x^{\top} Q x+u^{\top} R u\right) d t
\end{equation}</script><p>by solving the LQR problem, it returns the gain matrix $K$ that produce the lowest cost given the dynamic system. We penalizing the performance by $Q$ and penalizing the effort by $R$. Thus the function of LQR is:</p>
<blockquote>
<p>Given a system function with initial state, by providing a proper control quantity, the system can be transfered to a desired terminal state with lowest cost. </p>
</blockquote>
<h4 id="Intuitive-understand-of-the-cost-in-system"><a href="#Intuitive-understand-of-the-cost-in-system" class="headerlink" title="Intuitive understand of the cost in system"></a>Intuitive understand of the cost in system</h4><p>Performance is judged by the state $x$. Suppose that our system is at a none zero initial state, we want it to get to the zero state. The faster it return to zero, the better the performance is and the lower the cost. How to measure how quickly to return the desired state is <strong>to looking at the area under the curve, this is what the integral doing, a curve with less area means a better performance.</strong> Since the state can be either positive and negative, we square the value to keep positive. </p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/MinSegModel_LQR_02.png" width = "400" alt="图片名称" align=center /></p>
<p>The operation above turns our cost function to a quadratic function with a form of $z=x^2+y^2$, <strong>it has a definite minimum value (Great!).</strong> Now let’s consider the form of $Q$, the $Q$ needs to be positive definite thus $x^{\top} Q x&gt;0$, normally it is a diagonal matrix:</p>
<script type="math/tex; mode=display">
\begin{equation}
\left[\begin{array}{ll}{x_{1}} & {x_{2} \dots x_{n}}\end{array}\right]

\begin{bmatrix}
q_1 &  &  & 0\\ 
 & q_2 & & \\ 
 &  & \ddots  & \\ 
 0&  &  & q_3
\end{bmatrix}

\left[\begin{array}{c}{x_{1}} \\ {x_{2}} \\ {\vdots} \\ {x_{n}}\end{array}\right]
\end{equation}</script><p>Similarly, the $R$ matrix can penalize the input $u$, we can rewrite the equation as follows:</p>
<script type="math/tex; mode=display">
\begin{equation}
\left[\begin{array}{ll}{x^{\top}} & {u^{\top}}\end{array}\right]\left[\begin{array}{ll}{Q} & {0} \\ {0} & {R}\end{array}\right]\left[\begin{array}{l}{x} \\ {u}\end{array}\right]
\end{equation}</script><p>Now we can make a judgment, for example, if an actuator $u_i$ is really expensive, we can penalizing it by increasing $r_i$, if lower error $x_i$ is important, you can increasing the $q_i$.</p>
<h4 id="Mathematical-form-and-solution-about-LQR"><a href="#Mathematical-form-and-solution-about-LQR" class="headerlink" title="Mathematical form and solution about LQR"></a>Mathematical form and solution about LQR</h4><p>For a continuous-time linear system, defined on $t \in\left[t<em>{0}, t</em>{1}\right]$, described by:</p>
<script type="math/tex; mode=display">
\begin{equation}
\dot{x}=A x+B u
\end{equation}</script><p>with a quadratic cost function defined as: </p>
<script type="math/tex; mode=display">
\begin{equation}
J=x^{\top}\left(t_{1}\right) F\left(t_{1}\right) x\left(t_{1}\right)+
\int_{t_{0}}^{t_{1}}\left(x^{\top} Q x+u^{\top} R u+2 x^{\top} N u\right) d t
\end{equation}</script><p>in which:</p>
<ul>
<li>$x^{\top}\left(t<em>{1}\right) F\left(t</em>{1}\right) x\left(t_{1}\right)$ is an index about steady state</li>
<li>$\int<em>{t</em>{0}}^{t_{1}}x^{\top} Q x d t$ is an index about transient process</li>
<li>$\int<em>{t</em>{0}}^{t_{1}}u^{\top} R u d t$ is an index about system energy</li>
</ul>
<p>The feedback control law that minimizes the value of the cost is: </p>
<script type="math/tex; mode=display">
\begin{equation}
u=-K x
\end{equation}</script><p><strong>Solution: </strong>Now let’s solve the LQR problem, taking discrete LQR as an example, we use Lagrangian multiplier method to solve it, given the optimization problem:</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
&J=X^{\top}(N)Q_0X(N)+\sum_{i=0}^{N-1}[X^{\top}(i)QX(i)+U^{\top}(i)RU(i)]\\
s.t.\quad &X(0)=X_0\\
&X(k+1)=AX(k)+BU(k)
\end{aligned}
\end{equation}</script><h5 id="Step1-Create-Lagrangian-function-to-combine-the-cost-function-and-constrains"><a href="#Step1-Create-Lagrangian-function-to-combine-the-cost-function-and-constrains" class="headerlink" title="Step1: Create Lagrangian function to combine the cost function and constrains."></a>Step1: Create Lagrangian function to combine the cost function and constrains.</h5><p>Using the Lagrangian multiplier $\lambda$, we can create a function combine the cost function and constrains.</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
J_l&=X^{\top}(N)Q_0X(N)+\sum_{i=0}^{N-1}[X^{\top}(i)QX(i)+U^{\top}(i)RU(i)]+2\sum_{i=0}^{N-1}\lambda^{\top}(i+1)[AX(i)+BU(i)-X(i+1)]\\
&=X^{\top}(N)Q_0X(N)-2\lambda^{\top}(N)X(N)+\sum_{i=1}^{N-1}[H(i)-2\lambda^{\top}(i)X(i)]+H(0)

\end{aligned}
\end{equation}</script><p>where </p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
H(k)=X^{\top}QX+U^{\top}RU+2\lambda^{\top}(i)X(i)[AX+BU]

\end{aligned}
\end{equation}
\label{XtopQX}</script><h5 id="Step2-Find-the-extreme-point-we-of-the-cost-function"><a href="#Step2-Find-the-extreme-point-we-of-the-cost-function" class="headerlink" title="Step2: Find the extreme point we of the cost function"></a>Step2: Find the extreme point we of the cost function</h5><p>finding the minimum of $J_l$ is to find the extreme point of $J_l$, thus we need to satisfy the following conditions:</p>
<script type="math/tex; mode=display">
\begin{equation}
\left\{
\begin{aligned}
 \frac{\partial J_{l}}{\partial X(k)}&=2 Q X(k)+2 A^{T} \lambda(k+1)-2 \lambda(k)=0 \\ \frac{\partial J_{l}}{\partial U(k)}&=2 R U(k)+2 B^{T} \lambda(k+1)=0 \\ 
 \frac{\partial J_{l}}{\partial \lambda(k+1)}&=2 A X(k)+2 B U(k)-2 X(k+1)=0
\end{aligned}
\right.
\end{equation}</script><p>meanwhile, the final state satisfies:</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{\partial J_{l}}{\partial X(N)}=2 Q_{0} X(N)-2 \lambda(N)=0
\end{equation}</script><h5 id="Step3-Solving-the-control-law-and-feedback-gain"><a href="#Step3-Solving-the-control-law-and-feedback-gain" class="headerlink" title="Step3: Solving the control law and feedback gain"></a>Step3: Solving the control law and feedback gain</h5><p>With a series transformation and solving a Riccati function, we get the control law</p>
<script type="math/tex; mode=display">
\begin{equation}
U(k)=-R^{-1} B^{T} A^{-T}[S(k)-Q] X(k)
\end{equation}</script><p>and feedback gain</p>
<script type="math/tex; mode=display">
\begin{equation}
K=R^{-1} B^{T} A^{-T}[S(k)-Q]
\end{equation}</script><p>That is the feedback regulator we need.</p>
<p>In Matlab, give $Q$ and $R$, run </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">K = lqr(A,B,Q,R)</span><br></pre></td></tr></table></figure>
<p>you get the optimal gain set. With LQR, we don’t place poles, instead, we choose $Q$ and $R$, now here’s the question, what is a proper $Q$ and $R$, it can based on our intuition and knowledge about the system, Or we can start with $Q$ and $R$ equals to identity matrix. Here we summarize the influence of $Q$ and $R$ to the system.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Overshoot</th>
<th style="text-align:center">Setting time</th>
<th style="text-align:center">Energy consumption</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Increasing $Q$</td>
<td style="text-align:center">decreasing</td>
<td style="text-align:center">decreasing</td>
<td style="text-align:center">increasing</td>
</tr>
<tr>
<td style="text-align:center">Increasing $R$</td>
<td style="text-align:center">increasing</td>
<td style="text-align:center">increasing</td>
<td style="text-align:center">decreasing</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Difference-of-LQR-and-pole-placement"><a href="#Difference-of-LQR-and-pole-placement" class="headerlink" title="Difference of LQR and pole placement"></a>Difference of LQR and pole placement</h3><p>Basically, the LQR and pole placement controllers have the exactly the same structure, so the implementation of $K$ is the same, but how we choose $K$ is different.</p>
<ul>
<li>In pole placement, we solve for $K$ by choosing pole locations.</li>
<li>In LQR, we find the optimal $K$ by choosing characteristics.</li>
</ul>
<h2 id="Linear-quadratic-estimator"><a href="#Linear-quadratic-estimator" class="headerlink" title="Linear quadratic estimator"></a>Linear quadratic estimator</h2><h3 id="Filtering-Prediction-and-Smoothing3"><a href="#Filtering-Prediction-and-Smoothing3" class="headerlink" title="Filtering, Prediction, and Smoothing3"></a>Filtering, Prediction, and Smoothing<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h3><p>There are three general types of estimators for the LQG problem:</p>
<ul>
<li><strong>Predictors</strong>: use prior observations strictly $t<em>{obs}&lt;t</em>{est}$</li>
<li><strong>Filter</strong>: use observations up to and including the time that the state of the dynamic system is to be estimated $t<em>{obs}\leq t</em>{est}$</li>
<li><strong>Smoother</strong>: use observations beyond the estimation time $t<em>{obs}&gt;t</em>{est}$</li>
</ul>
<h3 id="Kalman-Filter"><a href="#Kalman-Filter" class="headerlink" title="Kalman Filter"></a>Kalman Filter</h3><p>The Kalman filter is an optimal algorithm for state estimation, it will help us to reconstruct the state of a dynamic system uses a series measurements observed over time, containing statistical noise and other inaccuracies, and produces estimates of unknown variables that tend to be more accurate than those based on a single measurement alone. For more information about Kalman filter, please refer to <a href="/2024/10/13/控制科学/控制理论/Kalman_Filter/" title="Kalman filter">Kalman filter</a> for this section. </p>
<h2 id="Linear-quadratic-Gaussian-regulator"><a href="#Linear-quadratic-Gaussian-regulator" class="headerlink" title="Linear quadratic Gaussian regulator"></a>Linear quadratic Gaussian regulator</h2><h3 id="Mathematical-description-of-the-problem"><a href="#Mathematical-description-of-the-problem" class="headerlink" title="Mathematical description of the problem"></a>Mathematical description of the problem</h3><p>Let’s concern a linear system driven by addictive white Gaussian noise ($N(0,\Sigma)$), consider a continuous-time linear dynamic system with disturbance and measurement noise:</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-16%20101021.jpg" width = "550" alt="图片名称" align=center /></p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned} \dot{\mathbf{x}}(t) &=A(t) \mathbf{x}(t)+B(t) \mathbf{u}(t)+\mathbf{v}(t) \\ \mathbf{y}(t) &=C(t) \mathbf{x}(t)+\mathbf{w}(t) \end{aligned}
\end{equation}</script><p>here the $\mathbf{v}(t)$ and $\mathbf{w}(t)$ are the system noise and measurement noise. The objective of LQG is to find the control input history $\mathbf{u}(t)$ which at any time only depends linearly on the past measurement $\mathbf{y}\left(t^{\prime}\right), 0 \leq t^{\prime}&lt;t$ such that the following cost function is minimized:</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{array}{l}{J=\mathbb{E}\left[\mathbf{x}^{\mathrm{T}}(T) F \mathbf{x}(T)+\int_{0}^{T} \mathbf{x}^{\mathrm{T}}(t) Q(t) \mathbf{x}(t)+\mathbf{u}^{\mathrm{T}}(t) R(t) \mathbf{u}(t) d t\right]} \\ {F \geq 0, \quad Q(t) \geq 0, \quad R(t)>0}\end{array}
\end{equation}</script><p>where $\mathbb{E}$ denotes the expected value $T$ may be either finite or infinite, if infinite, the first term  $\mathbf{x}^{\mathrm{T}}(T) F \mathbf{x}(T)$ can be ignored.</p>
<blockquote>
<p>Here we gives out a simple explanation about why we regard the noise as Gaussian. A Gaussian noise means that if we added multiple noises, it will still obey the Gaussian distribution.</p>
</blockquote>
<h3 id="Regulator-design"><a href="#Regulator-design" class="headerlink" title="Regulator design"></a>Regulator design</h3><p>Now let’s design the LQG regulator, the LQG controller that solves the LQG control problem is specified by the following equations: </p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{array}{l}{\dot{\hat{\mathbf{x}}}(t)=A(t) \hat{\mathbf{x}}(t)+B(t) \mathbf{u}(t)+L(t)(\mathbf{y}(t)-C(t) \hat{\mathbf{x}}(t)), \quad \hat{\mathbf{x}}(0)=\mathbb{E}[\mathbf{x}(0)]} \\ {\mathbf{u}(t)=-K(t) \hat{\mathbf{x}}(t)}\end{array}
\end{equation}</script><p>where matrix $L(t)$ is the gain of the state estimator (Kalman gain) while $K(t)$ is the feedback gain.</p>
<h4 id="Solve-for-L-t"><a href="#Solve-for-L-t" class="headerlink" title="Solve for $L(t)$"></a>Solve for $L(t)$</h4><p>$L(t)$ is computed from $A(t),C(t),V(t),W(t)$ and finally $\mathbb{E}\left[\mathbf{x}(0) \mathbf{x}^{\mathrm{T}}(0)\right]$ through the following associated matrix Riccati differential equation:</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{array}{l}{\dot{P}(t)=A(t) P(t)+P(t) A^{\mathrm{T}}(t)-P(t) C^{\mathrm{T}}(t) W^{-1}(t) C(t) P(t)+V(t)} \\ {P(0)=\mathbb{E}\left[\mathbf{x}(0) \mathbf{x}^{\mathrm{T}}(0)\right]}\end{array}
\end{equation}</script><p>Given the solution $P(t), 0 \leq t \leq T$ the Kalman gain equals </p>
<script type="math/tex; mode=display">
\begin{equation}
L(t)=P(t) C^{\mathrm{T}}(t) W^{-1}(t)
\end{equation}</script><h4 id="Solve-for-K-t"><a href="#Solve-for-K-t" class="headerlink" title="Solve for $K(t)$"></a>Solve for $K(t)$</h4><p>Similar to solving for $L(t)$, the feedback gain $K(t)$ can be determined by the following Riccati differential equation:</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{array}{l}{-\dot{S}(t)=A^{\mathrm{T}}(t) S(t)+S(t) A(t)-S(t) B(t) R^{-1}(t) B^{\mathrm{T}}(t) S(t)+Q(t)} \\ {S(T)=F}\end{array}
\end{equation}</script><p>Given the solution $S(t), 0 \leq t \leq T$ the feedback gain equals </p>
<script type="math/tex; mode=display">
\begin{equation}
K(t)=R^{-1}(t) B^{\mathrm{T}}(t) S(t)
\end{equation}</script><p>The Riccati differential equation of $L(t)$ solves the linear–quadratic estimation problem (LQE) while the second LQR problem, together they solve the linear-quadratic Gaussian control problem. So the LQG problem separates into the LQE and LQR problem that can be solved independently. Therefore, the LQG problem is called <strong>separable</strong>. </p>
<h2 id="Application-LQG-regulator-design-for-a-inverted-pendulum-system"><a href="#Application-LQG-regulator-design-for-a-inverted-pendulum-system" class="headerlink" title="Application: LQG regulator design for a inverted pendulum system"></a>Application: LQG regulator design for a inverted pendulum system</h2><p>In this section we will design a LQG regulator for a noise added inverted pendulum system which is basically an extended part of .</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=E_RDCFOlJx4">A course about LQR</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://en.wikipedia.org/wiki/Linear%E2%80%93quadratic_regulator">Wiki about LQR</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.researchgate.net/publication/243786641_Kalman_filtering_theory_and_practice_using_MATLAB">Andrews A P. Kalman Filtering: Theory and Practice Using MATLAB[M]. Wiley, 2001.</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
        <category>自适应控制</category>
      </categories>
      <tags>
        <tag>Important</tag>
      </tags>
  </entry>
  <entry>
    <title>PID control and tuning</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/PID_control_and_tuning/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This article summarizes the PID control method and tuning strategy of PID controller.</p>
<a id="more"></a>
<h2 id="PID-controller"><a href="#PID-controller" class="headerlink" title="PID controller"></a>PID controller</h2><h3 id="What-is-PID-controller"><a href="#What-is-PID-controller" class="headerlink" title="What is PID controller"></a>What is PID controller</h3><p><strong>proportional–integral–derivative (PID) controller </strong> is a control loop which employs feedback, the block diagram of a PID controller is shown below:</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Pid-feedback-nct-int-correct.png" width = "500"  alt="图片名称" align=center /></p>
<ul>
<li><strong>Term P</strong> is  proportional  to system error $e(t)$，if the error is large and positive, then the control output will be   proportionately large and positive, use P alone shall causes the steady state error since it needs an error to generate response.</li>
<li><strong>Term I</strong> looks for the <strong>past</strong> error or the system, after the application of proportional control, there will be a residual error, and our integral controller will work to eliminate the residual error due to the historic cumulative value of the error.</li>
<li><strong>Term D</strong> estimates the <strong>future</strong> trend of the error based on current changing rate. The more rapid the change, the greater the controlling or dampening effect. </li>
</ul>
<h4 id="Mathematical-form-of-PID"><a href="#Mathematical-form-of-PID" class="headerlink" title="Mathematical form of PID"></a>Mathematical form of PID</h4><ul>
<li>Continuous form</li>
</ul>
<script type="math/tex; mode=display">
u(t)=K_p(e(t)+\frac{1}{T_i}\int_{0}^{t}e(\tau)d\tau+T_d\frac{de(t)}{dt})</script><ul>
<li>Discrete form</li>
</ul>
<script type="math/tex; mode=display">
u(k)=K_p(e(k)+\frac{T}{T_i}\sum e(j)+\frac{T_d}{T}(e(k)-e(k-1) ) )</script><h3 id="Why-we-use-PID-controller"><a href="#Why-we-use-PID-controller" class="headerlink" title="Why we use PID controller"></a>Why we use PID controller</h3><ol>
<li>Simple</li>
<li>Good performace</li>
</ol>
<h3 id="how-to-turn-a-PID-controller-Important"><a href="#how-to-turn-a-PID-controller-Important" class="headerlink" title="how to turn a PID controller (Important)"></a>how to turn a PID controller (Important)</h3><p>To implement the PID controller, it normally means to determine the three parameters, this is also called the <strong>PID tuning</strong>. This section will discuss how to tuning the PID controller</p>
<h4 id="Method-1-manual-tuning"><a href="#Method-1-manual-tuning" class="headerlink" title="Method 1 manual tuning"></a>Method 1 manual tuning</h4><p>To implement manual tuning, first we need to know the effect of increasing the PID gains on step response.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">PID gain</th>
<th style="text-align:center">Percent Overshoot</th>
<th style="text-align:center">Settling time</th>
<th style="text-align:center">Steady-state error</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Increasing $K_P$</td>
<td style="text-align:center">Increases</td>
<td style="text-align:center">-</td>
<td style="text-align:center">Decreases</td>
</tr>
<tr>
<td style="text-align:center">Increasing $K_I$</td>
<td style="text-align:center">Increases</td>
<td style="text-align:center">Increases</td>
<td style="text-align:center">Zero steady-state error</td>
</tr>
<tr>
<td style="text-align:center">Increasing $K_D$</td>
<td style="text-align:center">Decreases</td>
<td style="text-align:center">Decreases</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<p>A commonly used manual tuning method:</p>
<p>Assume we want to adjust a system shown below where $b=10,\zeta = 0.707$ and $\omega_n=4$.</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-11%20214419.jpg" width = "500"  alt="图片名称" align=center /></p>
<ol>
<li>Set $K_I$ and $K_D$ to 0</li>
<li>Increasing $K_P$ slowly until the output of the closed-loop system oscillates just on the edge of instability. Here $K_p=885.5$.</li>
</ol>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-11%20214420.jpg" width = "500"  alt="图片名称" align=center /></p>
<ol>
<li>Reduce $K_p$ to achieve <strong>quarter amplitude decay</strong>, Here $K_p=370$.</li>
</ol>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-11%20215322.jpg" width = "500"  alt="图片名称" align=center /></p>
<ol>
<li>Increasing $K_D$ to decrease setting time and overshoot.</li>
<li>Increasing $K_I$ to eliminate steady-state error.</li>
</ol>
<h4 id="Method-2-auto-tuning"><a href="#Method-2-auto-tuning" class="headerlink" title="Method 2 auto tuning"></a>Method 2 auto tuning</h4><p>In SImulink, it provides a auto tuning method of three parameters in PID controller by selecting proper performance index, then it will generate proper PID parameters automatically.</p>
<ul>
<li>Response Time (Bandwidth): Increasing the response time increases the oscillation intensity of the system output.</li>
<li>Transient Behavior (Phase Margin): Increasing the transient behavior increases the robustness of the system.</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://en.wikipedia.org/wiki/PID_controller#PID_controller_theory">Wikipedia about PID</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="">Modern Control Systems by Richard C. Dorf</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
      </categories>
      <tags>
        <tag>Important</tag>
      </tags>
  </entry>
  <entry>
    <title>Model Predictive Control(2)--Modelling</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/Model_predictive_control2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Model predictive control is like playing chess, at ,each time step, you choose the best strategy to win. In this process, you make <strong>prediction</strong> based on current situation. This article gives out the modelling in MPC</p>
<a id="more"></a>
<p>In MPC, <strong>models are needed for prediction</strong>.</p>
<h2 id="Model-requirements"><a href="#Model-requirements" class="headerlink" title="Model requirements"></a>Model requirements</h2><h3 id="Simple-model"><a href="#Simple-model" class="headerlink" title="Simple model?"></a>Simple model?</h3><p>Simple manipulation and algebra requires linear models.</p>
<ul>
<li>If these are good enough, <strong>use linear models in MPC</strong></li>
</ul>
<p>Typical linear models including transfer functions and state space model.</p>
<h3 id="Discrete-or-continuous"><a href="#Discrete-or-continuous" class="headerlink" title="Discrete or continuous?"></a>Discrete or continuous?</h3><p>Decision making requires processing time, there for, <strong>MPC laws are implemented in discrete time.</strong></p>
<h3 id="What-sample-rate"><a href="#What-sample-rate" class="headerlink" title="What sample rate?"></a>What sample rate?</h3><p>A typical argument is that one wants around 10 sample points within a typical response (settling time or rise time)</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-30%20201532.jpg" width = "350"  alt="图片名称" align=center /></p>
<h4 id="Don’t-be-too-slow-or-too-fast"><a href="#Don’t-be-too-slow-or-too-fast" class="headerlink" title="Don’t be too slow or too fast!"></a>Don’t be too slow or too fast!</h4><p>Slower decision making will reduce the performance.</p>
<p>Faster sampling rate is point less, the system cannot respond to fast input changes because of inertia; meanwhile, it will challenge the optimization process.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul>
<li>Operate in discrete time</li>
<li>Use a sample rate around 1/10 of system dynamic responses (can be modifided if performance is not good enough)</li>
</ul>
<h2 id="Model-form"><a href="#Model-form" class="headerlink" title="Model form"></a>Model form</h2><ul>
<li><p>State space model see <a href="/2024/10/13/控制科学/控制理论/State-space_feedback_and_estimators/" title="state feedback control">state feedback control</a></p>
</li>
<li><p>Transfer function model</p>
</li>
<li><p>Step response model</p>
</li>
<li>Independent model: The model G can be anything (SS, TF)</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://dl.acm.org/citation.cfm?id=3299491">Rakovi SV, Levine WS. Handbook of Model Predictive Control. Birkh&amp;#228;user Basel; 2018. </a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="http://cse.lab.imtlucca.it/~bemporad/mpc_course.html">A course from Alberto Bemporad</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.mathworks.com/help/mpc/ug/explicit-mpc-control-of-a-single-input-single-output-plant.html">Explicit MPC Control of a Single-Input-Single-Output Plant</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://www.youtube.com/watch?v=w_GA_7sNM3g&amp;list=PLs7mcKy_nInFEpygo_VrqDFCsQVnGaoy-&amp;index=2">A video course about MPC</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
        <category>自适应控制</category>
      </categories>
      <tags>
        <tag>Important</tag>
      </tags>
  </entry>
  <entry>
    <title>前馈与反馈</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E5%89%8D%E9%A6%88%E4%B8%8E%E5%8F%8D%E9%A6%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p> 往者可以谏，来者亦可追 </p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前馈与反馈，是调节控制系统的两种重要手段，下文将针对这两种控制手段分别进行讨论。</p>
<h2 id="反馈控制"><a href="#反馈控制" class="headerlink" title="反馈控制"></a>反馈控制</h2><h3 id="何为反馈系统"><a href="#何为反馈系统" class="headerlink" title="何为反馈系统"></a>何为反馈系统</h3><p>系统将输出与输入进行比较，察觉到了误差的存在，将误差信号输入系统，进行补偿操作，因此反馈从时间角度来讲，是一种对于<strong>系统误差进行补偿的后知后觉的操作</strong>。</p>
<h3 id="反馈系统适用场景"><a href="#反馈系统适用场景" class="headerlink" title="反馈系统适用场景"></a>反馈系统适用场景</h3><p>反馈适用于对模型和扰动建模不够精确的情况（事实上大多数控制系统我们很难给出精确数学模型，所以反馈应用非常广泛），所以反馈控制是模型不敏感的。</p>
<h2 id="前馈"><a href="#前馈" class="headerlink" title="前馈"></a>前馈</h2><h3 id="何为前馈系统"><a href="#何为前馈系统" class="headerlink" title="何为前馈系统"></a>何为前馈系统</h3><p>如果能够对系统扰动进行建模，就可以提前根据扰动的变化，对扰动进行补偿，因此前馈从时间角度讲，属于<strong>根据已有知识，对系统扰动进行先知先觉的补偿操作</strong>。</p>
<h3 id="前馈系统适用场景"><a href="#前馈系统适用场景" class="headerlink" title="前馈系统适用场景"></a>前馈系统适用场景</h3><p>前馈适用于我们对模型某一部分有了一定的了解，能够给出较为精确的数学描述，或者能够对扰动进行比较精确的测量，因此前馈控制对模型很敏感，如果模型不够精确，那么前馈控制效果就会很差。一般来说，前馈系统往往应用于比较平滑缓慢的过程，例如过程控制系统中的温控系统或化学反应系统。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
      </categories>
  </entry>
  <entry>
    <title>State-space, feedback and estimators</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/State-space_feedback_and_estimators/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Some reading notes about state-space, and feedback and estimators in state space method basically from chapter 8 of $\textit{Linear system theory and design}$ <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>
<a id="more"></a>
<h2 id="State-space"><a href="#State-space" class="headerlink" title="State-space"></a>State-space</h2><h3 id="What-is-a-state-space-model"><a href="#What-is-a-state-space-model" class="headerlink" title="What is a state-space model?"></a>What is a state-space model?</h3><p>A state-space model, according to reference 2<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, <strong>is a model uses  state variables to describe a system by a set of first-order differential or difference equations, rather than  by one or more nth-order differential or difference equations</strong>. In state-space models, we reconstruct state variables from input-output data rather than measure them directly.</p>
<p>Here’s the mathematical form and block diagram of SS model.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\label{equ1}
\dot x(t)&=Ax(t)+Bu(t)+
\tilde K
w(t)\\
y(t)&=Cx(t)+Du(t)+w(t)\\
x(0)&=x0
\end{aligned}</script><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/State-Space-Block-Dgrm.jpg" width = "500"  alt="图片名称" align=center /></p>
<h3 id="Why-we-need-state-space-model"><a href="#Why-we-need-state-space-model" class="headerlink" title="Why we need state-space model"></a>Why we need state-space model</h3><ul>
<li>Can be used for Linear and nonlinear systems. </li>
<li>For both SISO and MIMO systems.</li>
<li>First order ODE’s means perfect for analysis </li>
<li>working in time domain</li>
</ul>
<h3 id="State-space-and-transfer-functions-conversion"><a href="#State-space-and-transfer-functions-conversion" class="headerlink" title="State-space and transfer functions: conversion"></a>State-space and transfer functions: conversion</h3><h4 id="SS-to-TF"><a href="#SS-to-TF" class="headerlink" title="SS to TF"></a>SS to TF</h4><script type="math/tex; mode=display">
\begin{aligned}
\dot x(t)&=Ax(t)+Bu(t)\\
y(t)&=Cx(t)+Du(t)\\
x(0)&=\textbf 0
\end{aligned}</script><ul>
<li>Laplace transfer</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
sX(s)&=AX(s)+BU(s)\\
Y(s)&=CX(s)+DU(s)\\
\end{aligned}</script><ul>
<li>Shift Item</li>
</ul>
<script type="math/tex; mode=display">
H(s)=\frac{Y(s)}{U(s)}=C\Phi(s)B+D=C(sI-A)^{-1}B+D</script><p>In Matlab (God I really like Matlab)</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[n,d]=ss2tf(A,B,C,D)</span><br></pre></td></tr></table></figure>
<h4 id="TF-to-SS"><a href="#TF-to-SS" class="headerlink" title="TF to SS"></a>TF to SS</h4><script type="math/tex; mode=display">
H(s)=\frac{Y(s)}{U(s)}=\frac{b_0}{s^n+a_1s^{n-1}+\cdots +a_{n-1}s+a_n}</script><ul>
<li>Shift Item and create  differential equation</li>
</ul>
<script type="math/tex; mode=display">
y^{(n)}+a_1y^{(n-1)}+\cdots+a_{n-1}\dot y+a_ny=u</script><ul>
<li>Choose state variables</li>
</ul>
<script type="math/tex; mode=display">
\begin{bmatrix}
x_1=y\\ 
x_2=\dot y\\ 
\vdots \\ 
x_n=y^{(n-1)}

\end{bmatrix}\rightarrow \begin{bmatrix}
\dot x_1=\dot y\\ 
\dot x_2=\ddot y\\ 
\vdots \\ 
\dot x_n =y^{(n)}

\end{bmatrix}</script><ul>
<li>Write as ss form</li>
</ul>
<h2 id="State-Feedback"><a href="#State-Feedback" class="headerlink" title="State Feedback"></a>State Feedback</h2><p><a id="State Feedback"/></p>
<h3 id="What-is-state-feedback"><a href="#What-is-state-feedback" class="headerlink" title="What is state feedback"></a>What is state feedback</h3><p>Consider a simple open loop SISO ss euqation:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot x(t)&=\textbf Ax(t)+\textbf bu(t)\\
y(t)&=\textbf Cx(t)\\
\end{aligned}</script><p>We want use $u(t)$ to change system dynamics, so we introduce linear state feedback with gain $\textbf k$:</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Closed-loop-system-with-full-state-feedback.png" width = "500"  alt="图片名称" align=center /></p>
<p>Now the input u is given by $u(t)=r(t)-\textbf kx(t)$ and our ss equation becomes:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot x(t)&=(\textbf A-\textbf {bk})x(t)+\textbf bu(t)\\
y(t)&=\textbf Cx(t)\\
\end{aligned}</script><h3 id="Why-we-need-state-feedback"><a href="#Why-we-need-state-feedback" class="headerlink" title="Why we need state feedback"></a>Why we need state feedback</h3><p>From the equations above we replace $\textbf A$ with $\textbf{A-bk}$, we know that $\textbf A$’s eigenvalues give the open-loop system poles, <strong>by selecting proper $\textbf K$, we can place the eigenvalues in any positions we what</strong>. </p>
<ul>
<li>$\mathscr{Theorem}\ 1$</li>
</ul>
<p>If n-dimensional ss equation is controllable, the eigenvalues of $\textbf{A-bk}$ can be arbitrarily assigned.</p>
<h3 id="How-do-we-design-a-proper-state-feedback"><a href="#How-do-we-design-a-proper-state-feedback" class="headerlink" title="How do we design a proper state feedback"></a>How do we design a proper state feedback</h3><h4 id="Method-1-According-to-desired-pole-placement"><a href="#Method-1-According-to-desired-pole-placement" class="headerlink" title="Method 1: According to desired pole placement"></a>Method 1: According to desired pole placement</h4><p>To apply pole placement method, first we need to clear how the pole influence the system, please refer to another article:  </p>
<p>In Matlab, we give system parameters and desired eigenvalues, the <code>place</code> function will give out the feedback gains. (We choose desired eigenvalues through system performance)</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">5</span> <span class="number">0</span>]</span><br><span class="line">b=[<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">-2</span>]</span><br><span class="line">p=[<span class="number">-1.5</span>+<span class="number">0.5</span><span class="built_in">j</span> <span class="number">-1.5</span><span class="number">-0.5</span><span class="built_in">j</span> <span class="number">-1</span>+<span class="built_in">j</span> <span class="number">-1</span>-<span class="built_in">j</span>]</span><br><span class="line">k = place(a,b,p)   <span class="comment">% Or use the acker function</span></span><br></pre></td></tr></table></figure>
<h4 id="Method-2-Solving-Lyapunov-Equation"><a href="#Method-2-Solving-Lyapunov-Equation" class="headerlink" title="Method 2: Solving Lyapunov Equation"></a>Method 2: Solving Lyapunov Equation</h4><p>Same question as above, we want a proper $\textbf k$. </p>
<ul>
<li>First, we need a matrix $\textbf F$ according to eigenvalues</li>
<li>Next we select an $1\times n$ vector $\bar {\textbf{k}}$ makes $(\textbf F,\bar {\textbf{k}})$ observable</li>
<li>Then we solve the unique $T$ in Lyapunov equation $\textbf{AT-TF=b}\bar {\textbf{k}}$</li>
<li>Finally we compute feedback gain $\textbf k=\bar {\textbf{k}}\textbf T^{-1}$</li>
</ul>
<p>Matlab codes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=[0 1 0 0; 0 0 -1 0; 0 0 0 1;0 0 5 0];</span><br><span class="line">b=[0;1;0;-2];</span><br><span class="line">f = [-1 1 0 0; -1 -1 0 0; 0 0 -1.5 0.5; 0 0 -0.5 -1.5];</span><br><span class="line">kb=[1 0 1 0];</span><br><span class="line">k=kb*inv(t)</span><br></pre></td></tr></table></figure>
<h4 id="Method-3-LQR-Method"><a href="#Method-3-LQR-Method" class="headerlink" title="Method 3: LQR Method"></a>Method 3: LQR Method</h4><p><a id="LQR Method"/></p>
<p>The LQR method is an optimal control method which goal is to find the controller that minimizes a quadratic cost function subject to the linear system dynamics. It’s assumed that</p>
<ul>
<li>There is no noise</li>
<li>The full system is observerable</li>
</ul>
<p>The mathematical form of LQR is:</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min \limits_{u(\cdot )}\int_{0}^{T}(x^TQx+u^TRu)dt + x(T)^TQ_fx(T)\\

s.t.\ \ &\dot x=Ax+bu\\
&y=x\\
&x(0)-Given
\end{aligned}</script><p>The optimal controller for the LQR problem is a linear feedback controller with a form of </p>
<script type="math/tex; mode=display">
u(t)=\textbf Kx(t)</script><h2 id="State-Estimator"><a href="#State-Estimator" class="headerlink" title="State Estimator"></a>State Estimator</h2><p><a href="#State Estimator"></p>
<h3 id="What-is-a-state-estimator"><a href="#What-is-a-state-estimator" class="headerlink" title="What is a state estimator"></a>What is a state estimator</h3><p>A state estimator or observer is <strong>a device generates an estimate of the state</strong>. We hope that the output of the estimator is just the same as the behavior of the plant.</p>
<h4 id="Open-loop-state-estimator"><a href="#Open-loop-state-estimator" class="headerlink" title="Open loop state estimator"></a>Open loop state estimator</h4><h5 id="Basic-structure"><a href="#Basic-structure" class="headerlink" title="Basic structure"></a>Basic structure</h5><p>First let’s take a look at the open loop state estimator:</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/observer.png" width = "400"  alt="图片名称" align=center /></p>
<p>If we know $\textbf A $ and $\textbf b$, we can duplicate the system as:</p>
<script type="math/tex; mode=display">
\dot {\hat{x}}(t)=\textbf A\hat x(t)+\textbf bu(t)</script><p>The estimation error is $\tilde{x}(k)=A^{k}(x(0)-\hat{x}(0))$, this is not ideal because:</p>
<ul>
<li>The dynamics of the estimation error are fixed by the eigenvalues of A and cannot be modified</li>
<li>The estimation error vanishes asymptotically if and only if A is asymptotically stable<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
</ul>
<h5 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages:"></a>Disadvantages:</h5><ul>
<li>initial state must be computed and set each time we use estimator</li>
<li>There will be a difference between $x(t)$ and $\hat x(t)$ </li>
</ul>
<h4 id="Close-loop-state-estimator-Luenberger-observer"><a href="#Close-loop-state-estimator-Luenberger-observer" class="headerlink" title="Close loop state estimator (Luenberger observer)"></a>Close loop state estimator (Luenberger observer)</h4><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/observer_statefeedback_pend.png" width = "300"  alt="图片名称" align=center /></p>
<p>We modify the estimator in which the output $y(t)=c{\textbf x}(t)$ is compared with $c\hat{\textbf x}(t)$, the difference is used as a correlation term. If difference is zero, nothing to do. If the difference is nonzero and gain $\textbf l$ is proper designed, the difference will drive the estimated state to actual state.</p>
<script type="math/tex; mode=display">
\dot {\hat{\textbf x}}(t)=\textbf A\hat {\textbf x}(t)+\textbf bu(t)+\textbf l(y(t)-\textbf c\hat{\textbf x}(t))</script><p>Let’s define $\textbf e(t)$ is the evaluated error of state estimation</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
\textbf e(t):&=\textbf x(t)-{\hat{\textbf x}}(t)\\
\dot{\textbf e}(t)&=\dot{\textbf x}(t)-\dot{\hat{\textbf x}}(t)\\
&=\textbf {Ax}(t)+\textbf bu(t)-\textbf A\hat {\textbf x}(t)-\textbf bu(t)-\textbf l(y(t)-\textbf c\hat{\textbf x}(t))\\
&=(\textbf A-\textbf l\textbf c)(\textbf x(t)-{\hat{\textbf x}}(t))\\
&=(\textbf A-\textbf l\textbf c)\textbf e(t)
\end{aligned}
\end{equation}
\label{etxtxh}</script><p>This is a first order difference function, by choosing a proper $L$, we can stabilize $(\textbf A-\textbf l\textbf c)$, the solution is an exponential function, thus the state error tends to zero with an exponential form, thus the estimation is unbiased.</p>
<p>From equation $\eqref{etxtxht}$ we can also notice that it doesn’t contain any control quantity, thus it is uncontrollable. However, as long as the system is stable, the estimation error tends to zero if the roots of the characteristic equation $\det(s\textbf I-\textbf A+\textbf l\textbf c)$ fall into the left half plane.</p>
<h5 id="Observer-design"><a href="#Observer-design" class="headerlink" title="Observer design"></a>Observer design</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=[<span class="number">-1</span>;<span class="number">1</span>]; <span class="comment">% initial state</span></span><br><span class="line">xhat=[<span class="number">0</span>;<span class="number">0</span>]; <span class="comment">% initial estimate</span></span><br><span class="line"></span><br><span class="line">XX=x;</span><br><span class="line">XXhat=xhat;</span><br><span class="line">T=<span class="number">40</span>;</span><br><span class="line">UU=<span class="number">.1</span>*<span class="built_in">ones</span>(<span class="number">1</span>,T); <span class="comment">% input signal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">0</span>:T<span class="number">-1</span>,</span><br><span class="line">    u=UU(k+<span class="number">1</span>);</span><br><span class="line">    y=C*x+D*u;</span><br><span class="line">    yhat=C*xhat+D*u;</span><br><span class="line">    </span><br><span class="line">    x=A*x+B*u;</span><br><span class="line">    xhat=A*xhat+B*u+L*(y-yhat);</span><br><span class="line">    </span><br><span class="line">    XX=[XX,x];</span><br><span class="line">    XXhat=[XXhat,xhat];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0</span>:T,[XX(<span class="number">1</span>,:);XXhat(<span class="number">1</span>,:)]);</span><br></pre></td></tr></table></figure>
<h3 id="Why-we-need-a-state-estimator"><a href="#Why-we-need-a-state-estimator" class="headerlink" title="Why we need a state estimator"></a>Why we need a state estimator</h3><p>Ideally, the state variables are all available for feedback. In practice, some variables are not accessible. So we introduce observers to the system, for example, in self-driving, we have GPS, IMU, et al. as observers.</p>
<h3 id="How-to-design-a-state-estimator"><a href="#How-to-design-a-state-estimator" class="headerlink" title="How to design a state estimator"></a>How to design a state estimator</h3><p>The equation $\dot{ \textbf{e}}(t)=(\textbf A-\textbf l\textbf c)\textbf e(t)<br>$ governs the estimation error. If all eigenvalues of $(\textbf A-\textbf l\textbf c)$ can be arbitrarily assigned, we can control the rate for $\textbf e(t)$ to approach zero, so <strong>the feedback gain of $\textbf l$ help us to reduce the difference between actual state and observed state</strong>. Since we want the dynamics of the observer to be much faster than the system itself, we need to place the poles at least five times farther to the left than the dominant poles of the system. </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p=[<span class="number">-1.5</span>+<span class="number">0.5</span><span class="built_in">j</span> <span class="number">-1.5</span><span class="number">-0.5</span><span class="built_in">j</span> <span class="number">-1</span>+<span class="built_in">j</span> <span class="number">-1</span>-<span class="built_in">j</span>]</span><br><span class="line">L = place(A',C',p*<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Feedback-from-estimated-states"><a href="#Feedback-from-estimated-states" class="headerlink" title="Feedback from estimated states"></a>Feedback from estimated states</h2><p>Now let’s combine the feedback with state estimator, our state variables are not available for feedback, so we design a state estimator to get the observed variables.</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/configuration.png" width = "400"  alt="图片名称" align=center /></p>
<p>It can be proved that the feedback and estimator are independent and can be carried out independently. This is called the <strong>separation property</strong>.</p>
<h2 id="Application-State-feedback-control-of-a-inverted-pendulum-system"><a href="#Application-State-feedback-control-of-a-inverted-pendulum-system" class="headerlink" title="Application: State feedback control of a inverted pendulum system"></a>Application: State feedback control of a inverted pendulum system</h2><p>This section is mainly based on a short tutorial from reference <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>. </p>
<h3 id="Problem-setting"><a href="#Problem-setting" class="headerlink" title="Problem setting"></a>Problem setting</h3><p>Suppose we have a Pendulum-Cart system to be controlled shown below</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-13%20111223.jpg" width = "250"  alt="图片名称" align=center /></p>
<p>The overall objective will be broken down into the following tasks:</p>
<ul>
<li>Linear dynamic system modeling</li>
<li>System analysis</li>
<li>Controller designing in SS</li>
<li>State observer designing and investigating in close loop</li>
<li>Discretization  </li>
</ul>
<h3 id="Linear-dynamic-system-modeling"><a href="#Linear-dynamic-system-modeling" class="headerlink" title="Linear dynamic system modeling"></a>Linear dynamic system modeling</h3><p>We shall not focus too much on the modeling process, here we give out the linear model of inverted pendulum directly:</p>
<script type="math/tex; mode=display">
\begin{aligned}

\textbf{x} &=

\begin{pmatrix}
q_1\\ 
q_2\\ 
\dot q_1\\
\dot q_2
\end{pmatrix}
\\

\dot {\textbf{x}} &= \textbf A\textbf{x}+\textbf bu
\end{aligned}</script><p>Let $q_1$ (position) and $q2$ (angular) be the system output, $\textbf A$ and $\textbf b$ is:</p>
<script type="math/tex; mode=display">
\begin{aligned}

\textbf{A} =

\begin{pmatrix}
0& 0& 1 &0\\ 
0& 0& 0 &1\\ 
0 &\frac{gm_p}{m_c} & \frac{-d_1}{m_c} & \frac{-d_2}{Lm_c}\\
0 &\frac{g(m_c+m_p)}{Lm_c} & \frac{d_1}{Lm_c} &-\frac{d_2(m_c+m_p)}{L^2m_cm_p}
\end{pmatrix}


,\ \ \ \textbf{B} =

\begin{pmatrix}
0\\ 
0\\
\frac{1}{m_c}\\
\frac{1}{Lm_c}
\end{pmatrix}

\end{aligned}</script><p>where: $m_c = 1.5,m_p=0.5,g=9.82,L=1,d_1=d_2=0.01$.</p>
<div><div class="fold_hider"><div class="close hider_title">Unfold/Fold</div></div><div class="fold">
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line">mc = <span class="number">1.5</span>;</span><br><span class="line">mp = <span class="number">0.5</span>;</span><br><span class="line">g  = <span class="number">9.82</span>;</span><br><span class="line">L  = <span class="number">1</span>;</span><br><span class="line">d1 = <span class="number">1e-2</span>;</span><br><span class="line">d2 = <span class="number">1e-2</span>;</span><br><span class="line"></span><br><span class="line">A  = [<span class="number">0</span>,                   <span class="number">0</span>,          <span class="number">1</span>,                         <span class="number">0</span>;</span><br><span class="line">      <span class="number">0</span>,                   <span class="number">0</span>,          <span class="number">0</span>,                         <span class="number">1</span>;</span><br><span class="line">      <span class="number">0</span>,           (g*mp)/mc,     -d1/mc,                -d2/(L*mc);</span><br><span class="line">      <span class="number">0</span>,(g*(mc + mp))/(L*mc), -d1/(L*mc),-(d2*mc+d2*mp)/(L^<span class="number">2</span>*mc*mp)];</span><br><span class="line">B  = [<span class="number">0</span>; <span class="number">0</span> ; <span class="number">1</span>/mc; <span class="number">1</span>/(L*mc)];</span><br><span class="line"></span><br><span class="line">C   = [<span class="number">1</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>];          <span class="comment">% Set q_1 as output</span></span><br><span class="line">D = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">x0 = [<span class="number">0</span>;<span class="number">5</span>*<span class="built_in">pi</span>/<span class="number">180</span>;<span class="number">0</span>;<span class="number">0</span>];    <span class="comment">% Initial state of the integrator</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>And the plant in simulink is:</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/planet%20of%20pandulum.png" width = "600"  alt="图片名称" align=center /></p>
<h3 id="System-analysis"><a href="#System-analysis" class="headerlink" title="System analysis"></a>System analysis</h3><p>Given a zero input, the output of the system shows that it’s not stable:</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/zeroinputtoplant.png" width = "400"  alt="图片名称" align=center /></p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-13%20114541.jpg" width = "400"  alt="图片名称" align=center /></p>
<p>You can also refer to the eigenvalues, the root locus to see the stability of the system.</p>
<div><div class="fold_hider"><div class="close hider_title">Unfold/Fold</div></div><div class="fold">
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% System stability</span></span><br><span class="line">eig_A = eig(A);      <span class="comment">% Eigenvalue of A</span></span><br><span class="line">pole_A =pole(sys);   <span class="comment">% Has a positive pole, not stable</span></span><br><span class="line"></span><br><span class="line">Sc = ctrb(sys);      <span class="comment">% Controllability</span></span><br><span class="line">So = obsv(sys);      <span class="comment">% Observability</span></span><br><span class="line">rank(Sc)             <span class="comment">% 4</span></span><br><span class="line">rank(So)             <span class="comment">% 4</span></span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="Controller-designing-in-SS"><a href="#Controller-designing-in-SS" class="headerlink" title="Controller designing in SS"></a>Controller designing in SS</h3><p>First we give out the desire pole we want our system to be set (according to the performance of the system). Based on the desire pole, we can calculate the feedback gain $\textbf K$ (<a href="#State Feedback">Click here to review state feedback</a>).</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Controller</span></span><br><span class="line">des_pole = [<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-3</span>];</span><br><span class="line">K        = acker(A,B,des_pole);</span><br></pre></td></tr></table></figure>
<p>Or we can apply the LQR method to get the gain (<a href="#LQR Method">Click here to review LQR methood</a>).:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Q        = <span class="built_in">eye</span>(<span class="number">4</span>);</span><br><span class="line">R        = <span class="number">1</span>;</span><br><span class="line">K_lqr    = lqr(A,B,Q,R);</span><br></pre></td></tr></table></figure>
<p>The controller and it’s inner structure is shown below</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/controller.png" width = "400"  alt="Controller with it's inner structure" align=center /></p>
<p>By adding the controller to the system, now we can apply a control behavior to the plant. Given a reference trajectory pulse, we can check the out put of the system. The control system, input and output trajectories and the simulation animation is shown below.</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-13%20153846.jpg" width = "300"  alt="Controller with it's inner structure" align=center /></p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-13%20153603.jpg" width = "300"  alt="Controller with it's inner structure" align=center /></p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-13%20153625.jpg" width = "300"  alt="Controller with it's inner structure" align=center /></p>
<h3 id="State-observer-designing-and-investigating-in-close-loop"><a href="#State-observer-designing-and-investigating-in-close-loop" class="headerlink" title="State observer designing and investigating in close loop"></a>State observer designing and investigating in close loop</h3><p>So far so good, now let’s further introduce the observer to the system, <a href="#State Estimator">Click here to review the design process of a state estimator</a>.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">L       = acker(A',C,des_pole*<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>The observer and it’s inner structure is shown below</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-13%20165918.jpg" width = "300"  alt="Controller with it's inner structure" align=center /></p>
<p>And the output of the observer is quite like the original plant.</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-13%20170144.jpg" width = "300"  alt="Controller with it's inner structure" align=center /></p>
<h3 id="Discretization"><a href="#Discretization" class="headerlink" title="Discretization"></a>Discretization</h3><p>The final step is to discrete the controller and observer. First we discrete the controller, then the observer.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% discrete </span></span><br><span class="line">Ts = <span class="number">0.1</span>;</span><br><span class="line">sys_d = c2d(sys,Ts);</span><br><span class="line"></span><br><span class="line">Ad   = sys_d.a;</span><br><span class="line">Bd   = sys_d.b;</span><br><span class="line">Cd   = sys_d.c;</span><br><span class="line">Dd   = sys_d.d;</span><br><span class="line"></span><br><span class="line">des_pole_d = [<span class="number">0.3</span>; <span class="number">0.3</span>;<span class="number">0.3</span>;<span class="number">0.3</span>];  </span><br><span class="line">K_d = acker(Ad,Bd,des_pole_d);</span><br><span class="line"></span><br><span class="line">des_pole_d = [<span class="number">0.3</span>;<span class="number">0.3</span>;<span class="number">0.3</span>;<span class="number">0.3</span>]*<span class="number">0.1</span>;</span><br><span class="line">L_d  = acker(Ad',Cd',des_pole_d);</span><br></pre></td></tr></table></figure>
<p>Then replace the parameters in the system with discrete ones and add zero order holder, change integrator to unit delay model, we get our discrete control system.</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-13%20172559.jpg" width = "400"  alt="Discrete control system of an inverted pendulum" align=center /></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://www.ebadi.profcms.um.ac.ir/imagesm/474/stories/modern_control/chen%20c%20-t%20linear%20system%20theory%20and%20design.pdf">Chen C T. Linear system theory and design[M]. Oxford University Press, Inc., 1998.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="http://cse.lab.imtlucca.it/~bemporad/teaching/ac/pdf/06b-estimator.pdf">State estimation and linear observers</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.mathworks.com/help/control/ref/ss.html">Matlab documents about ss</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://www.youtube.com/watch?v=hAI8Ag3bzeE">State Space Control for the Pendulum-Cart System</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
        <category>现代控制</category>
      </categories>
      <tags>
        <tag>Important</tag>
      </tags>
  </entry>
  <entry>
    <title>Model Predictive Control(3)--Prediction</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/Model_predictive_control3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Model predictive control is like playing chess, at ,each time step, you choose the best strategy to win. In this process, you make <strong>prediction</strong> based on current situation. This article discuss about the prediction in MPC</p>
<a id="more"></a>
<h2 id="Prediction-with-SS-model"><a href="#Prediction-with-SS-model" class="headerlink" title="Prediction with SS model"></a>Prediction with SS model</h2><h3 id="Basic-concepts-of-prediction"><a href="#Basic-concepts-of-prediction" class="headerlink" title="Basic concepts of prediction"></a>Basic concepts of prediction</h3><p>Discrete models are <strong>one-step ahead prediction model</strong>, that is, given data at time $k$, we can determine data at $k+1$:</p>
<script type="math/tex; mode=display">
\begin{equation}
\left.\begin{array}{rl}{x_{k+1}} & {=A x_{k}+B u_{k}} \\ {y_{k}} & {=C x_{k}+d_{k}}\end{array}\right\} \Rightarrow \begin{array}{c}{y_{k+1}=C x_{k+1}+d_{k+1}} \\ {y_{k+1}=C A x_{k}+C B u_{k}+d_{k+1}}\end{array}
\end{equation}</script><p>Nomally we can assume that $d<em>k=d</em>{k+1}$.</p>
<p>It should be noticed that one step prediction can be used <strong>recursively</strong> to find an n-step ahead prediction as follows</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{array}{ll}{x_{k+1}=A x_{k}+B u_{k}} & {x_{k+1}=A x_{k}+B u_{k}} 
\\ {x_{k+2} = A x_{k+1}+B u_{k+1}} & {x_{k+2}={A}\left[A x_{k}+B u_{k}\right]+B u_{k+1}} \\ {x_{k+3}=Ax_{k+2}+B u_{k+2}} & {x_{k+3}=A\left(\left[A x_{k}+B u_{k}\right]+B u_{k+1}\right)+B u_{k+2}} \end{array}
\end{equation}</script><p>general step is</p>
<script type="math/tex; mode=display">
\begin{equation}
x_{k+n}=A^{n} x_{k}+A^{n-1} B u_{k}+A^{n-2} B u_{k+1}+\cdots+A B u_{k+n-2}+B u_{k+n-1}
\end{equation}</script><p><strong>Notation: double subscript</strong>, the first determines the time of the prediction and second determines the sample at which the prediction was made. For example, $x_{k+4|k}$ means prediction at sample $k+4$ where prediction was made at sample $k$. Now we can rewrite our general step as</p>
<script type="math/tex; mode=display">
\begin{equation}
x_{k+n | k}=A^{n} x_{k}+A^{n-1} B u_{k | k}+A^{n-2} B u_{k+1 k}+\cdots+A B u_{k+n-2 | k}+B u_{k+n-1 | k}
\end{equation}</script><h3 id="Splitting-predictions"><a href="#Splitting-predictions" class="headerlink" title="Splitting predictions"></a>Splitting predictions</h3><p>We can saperate the predictions into known and unknown part</p>
<script type="math/tex; mode=display">
\begin{equation}
y_{k+n| k}=C A^{n} x_{k}+d_{k}+C\left(A^{n-1} B u_{k |k}+A^{n-2} B u_{k+1 |k}+\cdots+B u_{k+n-1| k}\right)
\end{equation}</script><ul>
<li>known: $C A^{n} x<em>{k}+d</em>{k}$, based on current and past measurement</li>
<li><p>unknown: $C\left(A^{n-1} B u<em>{k |k}+A^{n-2} B u</em>{k+1 |k}+\cdots+B u_{k+n-1| k}\right)$, based on future input choices.</p>
 <table><tr><td bgcolor=#F7DC6F   style="vertical-align:middle; text-align:center;">Our aim is to choose the unknown inputs to make sure that the overall prediction is satisfactory!!</td></tr></table>  

</li>
</ul>
<h3 id="Matrix-form-of-ss-prediction"><a href="#Matrix-form-of-ss-prediction" class="headerlink" title="Matrix form of ss prediction"></a>Matrix form of ss prediction</h3><p>Now we rewrite the prediction in a more compact way, let $\mathbf{x}_{k+1}$ be</p>
<script type="math/tex; mode=display">
\begin{equation}
\left[\begin{array}{c}{x_{k+1 | k}} \\ {x_{k+2 | k}} \\ {\vdots} \\ {x_{k+n| k}}\end{array}\right]=\mathbf{x}_{k+1}
\end{equation}</script><p>where $k+1$ indicate the first value in the vector, the matrix form of ss prediction is</p>
<script type="math/tex; mode=display">
\begin{equation}
\mathbf{x}_{k+1} =
\left[
\begin{array}{c}{A \textbf{x}_{k}} 
\\ {A^{2} \textbf{x}_{k}} 
\\ {\vdots} 
\\ A^{n} \textbf{x}_k\end{array}\right]
+\left[\begin{array}{c}{B u_{k |k}} 
\\ {A B u_{k| k}+B u_{k+1| k}} \\ {\vdots} \\ {A^{n-1} B u_{k| k}+\cdots+A B u_{k+n-2| k}+B u_{k+n-1 |k}}\end{array}\right]
\end{equation}</script><p>make seperation, we get</p>
<script type="math/tex; mode=display">
\begin{equation}
\textbf{x}_{k+1}=\left[\begin{array}{c}{A} \\ {A^{2}} \\ {\vdots} \\ {A^{n}}\end{array}\right] \textbf{x}_{k}+\left[\begin{array}{cccc}{B} & {0} & {\cdots} & {0} \\ {A B} & {B} & {\cdots} & {0} \\ {\vdots} & {\vdots} & {\ddots} & {\vdots} \\ {A^{n-1} B} & {A^{n-2} B} & {\cdots} & {B}\end{array}\right]\left[\begin{array}{c}{u_{k| k}} \\ {u_{k+1 |k}} \\ {\vdots} \\ {u_{k+n-1 |k}}\end{array}\right]
\end{equation}</script><p>the vector $\mathbf{u}_k$ is the decision variables, replace the matrix with some notation, we get</p>
<script type="math/tex; mode=display">
\begin{equation}
\textbf{x}_{k+1}=P_{x} \textbf{x}_{k}+H_{x} \textbf{u}_{k}
\end{equation}</script><p>Similarly, we get the output predictions</p>
<script type="math/tex; mode=display">
\begin{equation}
\textbf{y}_{k+1}=P \textbf{x}_{k}+L d_{k}+H \textbf{u}_{k}
\end{equation}</script><h2 id="Prediction-with-TF-model-Mainly-focus-on-SISO-systems"><a href="#Prediction-with-TF-model-Mainly-focus-on-SISO-systems" class="headerlink" title="Prediction with TF model (Mainly focus on SISO systems)"></a>Prediction with TF model (Mainly focus on SISO systems)</h2><h3 id="Carima-model"><a href="#Carima-model" class="headerlink" title="Carima model"></a>Carima model</h3><p>The most common tf model in MPC is carima model which includes the uncertainty with a form of</p>
<script type="math/tex; mode=display">
\begin{equation}
a(z) y_{k}=b(z) u_{k}+T(z) \frac{\zeta_{k}}{\Delta}
\end{equation}</script><p>$\frac{G_{k}}{\Delta}$ is a zero mean random variable, although $T(z)$ could arise from a model identification, in practice it is treated as a design paramter.</p>
<h3 id="Basic-concepts-of-prediction-1"><a href="#Basic-concepts-of-prediction-1" class="headerlink" title="Basic concepts of prediction"></a>Basic concepts of prediction</h3><p>We consider the discrete model</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{array}{l}{a(z) y_{k}=b(z) u_{k}+d_{k}} \\ {a(z)=1+a_{1} z^{-1}+\cdots+a_{n} z^{-n}} \\ {b(z)=b_{1} z^{-1}+\cdots+b_{m} z^{-m}}\end{array}
\end{equation}</script><p>thus</p>
<script type="math/tex; mode=display">
\begin{equation}

y_{k-1}=b_{1} u_{k}+b_{2} u_{k-1}+\cdots+b_{m} u_{k-m+1}+d_{k}-a_{1} y_{k}-\cdots-a_{n} y_{k-n+1}
\end{equation}</script><h3 id="Significance-of-Carima-model"><a href="#Significance-of-Carima-model" class="headerlink" title="Significance of Carima model"></a>Significance of Carima model</h3><p>It incorporates a disturbance estimate and therefore can give unbiased predictions in steady-state, irrespective of some parameter uncertainty.</p>
<p>In practice, the incremental form is used for predictions:</p>
<script type="math/tex; mode=display">
\begin{equation}
a(z) \Delta y_{k}=b(z) \Delta u_{k}+T(z) \zeta_{k}
\end{equation}</script><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=w_GA_7sNM3g&amp;list=PLs7mcKy_nInFEpygo_VrqDFCsQVnGaoy-&amp;index=2">A video course about MPC</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
        <category>自适应控制</category>
      </categories>
      <tags>
        <tag>Important</tag>
      </tags>
  </entry>
  <entry>
    <title>控制理论经典教材、论文、课程及专家</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA%E7%BB%8F%E5%85%B8%E6%95%99%E6%9D%90%E5%8F%8A%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>站在巨人的肩膀上</p>
</blockquote>
<a id="more"></a>
<h2 id="教材"><a href="#教材" class="headerlink" title="教材"></a>教材</h2><ol>
<li><a href="Dorf R C, Bishop R H. Modern control systems[M]. Pearson, 2011.">现代控制系统</a></li>
</ol>
<p>这本书不必多介绍了，很经典的自控原理书籍，涵盖的范围非常广，给出的例子贴近实用，学控制的应该人手一本。</p>
<ol>
<li><a href="Chen C T. Linear system theory and design[M]. Oxford University Press, Inc., 1998.">Linear system theory and design</a></li>
</ol>
<p>台湾的Chi-Tsong Chen 教授关于线性系统的一本教材</p>
<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><h3 id="Model-predictive-control"><a href="#Model-predictive-control" class="headerlink" title="Model predictive control"></a>Model predictive control</h3><ol>
<li><a href="http://cse.lab.imtlucca.it/~bemporad/mpc_course.html">Alberto Bemporad’s model predictive control course</a></li>
</ol>
<h2 id="专家"><a href="#专家" class="headerlink" title="专家"></a>专家</h2><h3 id="Modern-Control"><a href="#Modern-Control" class="headerlink" title="Modern Control"></a>Modern Control</h3><ol>
<li><a href="https://profiles.stanford.edu/david-luenberger">David G. Luenberger</a>: 设计了观测器Luenberger observer</li>
</ol>
<h3 id="Model-predictive-control-1"><a href="#Model-predictive-control-1" class="headerlink" title="Model predictive control"></a>Model predictive control</h3><ol>
<li><a href="http://cse.lab.imtlucca.it/~bemporad/">Alberto Bemporad</a>: 参与设计了MATLAB的Model Predictive Control Toolbox™</li>
</ol>
]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
      </categories>
  </entry>
  <entry>
    <title>控制系统性能指标</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文将针对控制系统常用性能指标进行整理。</p>
<a id="more"></a>
<h2 id="时域指标"><a href="#时域指标" class="headerlink" title="时域指标"></a>时域指标</h2><h3 id="相关时间指标"><a href="#相关时间指标" class="headerlink" title="相关时间指标"></a>相关时间指标</h3><p>衡量控制系统阶跃响应性能的常用时间指标有三个：分别是<strong>上升时间$T_r$，峰值时间$T_p$和调节时间$T_s$</strong>，三个调节时间在阶跃响应曲线中的直观体现如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-10%20212058.jpg" width = "500" alt="阶跃响应" align=center/></p>
<h3 id="超调量"><a href="#超调量" class="headerlink" title="超调量"></a>超调量</h3><h3 id="稳态误差"><a href="#稳态误差" class="headerlink" title="稳态误差"></a>稳态误差</h3><h2 id="频域指标"><a href="#频域指标" class="headerlink" title="频域指标"></a>频域指标</h2><h3 id="系统带宽"><a href="#系统带宽" class="headerlink" title="系统带宽"></a>系统带宽</h3><h4 id="带宽的定义"><a href="#带宽的定义" class="headerlink" title="带宽的定义"></a>带宽的定义</h4><p>在《Modern Control Systems》一书中，关于带宽的定义为<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>
<blockquote>
<p>The bandwidth, $\omega_b$, is a measure of a ability of the system to faithfully reproduce an input signal.</p>
</blockquote>
<p>带宽是系统能够“忠实地”跟踪输入信号的能力，那么系统的带宽是多少呢，以二阶系统为例，其幅频特性曲线为：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E6%89%B9%E6%B3%A8%202019-11-09%20213937.jpg" width = "300" alt="二阶闭环系统幅频特性曲线" align=center/></p>
<p>那么系统的带宽就是幅值降低$-3\textrm{dB}$所对应的频率，即其中的$\omega_b$。</p>
<h4 id="带宽的作用"><a href="#带宽的作用" class="headerlink" title="带宽的作用"></a>带宽的作用</h4><p>系统带宽用于描述系统对于给定值的跟踪速度，一个系统如果要求具有良好的响应速度，有两个途径：</p>
<ol>
<li>提高系统带宽</li>
<li>增加前馈环节</li>
</ol>
<p>当带宽增加，<strong>系统阶跃响应上升时间将会下降</strong>。</p>
<h4 id="高带宽带来的问题"><a href="#高带宽带来的问题" class="headerlink" title="高带宽带来的问题"></a>高带宽带来的问题</h4><p>在工业领域，带宽即成本，高带宽提高了系统响应速度，但是也带来了一系列问题，包括但不限于：</p>
<ul>
<li>增加执行机构负担</li>
<li>激励了对象的高频动态使控制问题复杂化</li>
<li>提高了系统对噪声的敏感程度（因为噪声信号往往是高频的）</li>
<li>闭环系统稳定裕度下降，对相位滞后与时间延迟更敏感</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">[Modern control systems](Dorf R C, Bishop R H. Modern control systems[M]. Pearson, 2011.)<a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
      </categories>
  </entry>
  <entry>
    <title>模型参考自适应控制</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E6%A8%A1%E5%9E%8B%E5%8F%82%E8%80%83%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在实际物理世界中，任何一个系统都是非线性的，都不是理想的物理模型。因此针对非理想的模型，我们希望能够设计出一种控制器，使其能够有效处理系统非线性及不确定量，从而在一定程度上使其响应接近于理想模型。模型参考自适应控制（Model reference adaptive control, MRAC）就是基于这个目标提出的，本文将针对模型参考自适应控制（MRAC）过程进行总结。</p>
<a id="more"></a>
<h2 id="基本控制策略"><a href="#基本控制策略" class="headerlink" title="基本控制策略"></a>基本控制策略</h2><p>目前常见的控制策略主要有两种</p>
<ul>
<li>Robust Control：参数是固定的，<strong>系统对参数变化不敏感</strong>，如果在最坏的情况下，系统仍然能够具有良好的响应，那么系统就是robust的。</li>
<li>Adaptive Control：参数可以在线调整，系统能够随着外部扰动，及时改变参数，从而达到良好的控制效果。</li>
</ul>
<h2 id="模型参考自适应控制原理"><a href="#模型参考自适应控制原理" class="headerlink" title="模型参考自适应控制原理"></a>模型参考自适应控制原理</h2><h3 id="控制器组成"><a href="#控制器组成" class="headerlink" title="控制器组成"></a>控制器组成</h3><p>模型参考自适应控制器由两部分组成</p>
<ul>
<li>参考模型 （理想被控对象，可以通过指定控制性能确定）</li>
<li>控制器（参数可变）</li>
<li>参数调整机构 （使用一种时变非线性算法，调整控制器参数）</li>
</ul>
<h3 id="控制目标"><a href="#控制目标" class="headerlink" title="控制目标"></a>控制目标</h3><p>将参考模型的输出与被控对象输出的误差调整至最小，这样可以认为我们的被控对象与参考模型表现形式一致。</p>
<h2 id="控制器设计过程"><a href="#控制器设计过程" class="headerlink" title="控制器设计过程"></a>控制器设计过程</h2><h3 id="被控对象数学模型建立"><a href="#被控对象数学模型建立" class="headerlink" title="被控对象数学模型建立"></a>被控对象数学模型建立</h3><p>被控对象的动力学方程</p>
<script type="math/tex; mode=display">
\dot{x}_p=A_px_p+B_p\lambda u+B_p\delta_p(x_p),\ x_p(0)=x_{p0}</script><p>$A_p$和$B_p$是已知参数，$x_p$可测的（状态反馈），$u$是控制变量，$\lambda$是未知参数，可以表示为：</p>
<script type="math/tex; mode=display">
\lambda =\begin{bmatrix}
\lambda_1>0 &  & \\ 
 & ... & \\ 
 &  & \lambda_m>0 
\end{bmatrix} \in \mathbb{R}^{m\times m}</script><p>如果$\lambda$对角线元素有0，那么就是不可控情况，因为这个分量会使对应的控制量清零。</p>
<p>$\delta_p(x_p)$是非线性系统不确定量，几个关键变量所属线性空间为：</p>
<script type="math/tex; mode=display">
x_p \in \mathbb{R}^{n_p}\\
u \in \mathbb{R}^{m}\\
\delta _p:\mathbb{R}^{n_p}\rightarrow \mathbb{R}^{m}</script><p>考虑$B_p\lambda u+B_p\delta_p(x_p)$，我们可以将其写为</p>
<script type="math/tex; mode=display">
B_p\lambda [u+\lambda^{-1}\delta_p(x_p)]</script><p>从上式可以看出，$u$可以影响$\delta_p(x_p)$的每一部分，这个叫做匹配系统。如果不能，那就是非匹配系统。</p>
<p>$\delta_p(x_p)$可以进一步写为</p>
<script type="math/tex; mode=display">
\delta _p(x_p)=W^{T}_p\sigma _p(x_p)</script><p>其中$W^{T}_p$是未知部分，$\sigma _p(x_p)$是已知部分</p>
<script type="math/tex; mode=display">
W_p \in \mathbb{R}^{s\times m} \\
\sigma _p:\mathbb{R}^{n_p}\rightarrow \mathbb{R}^{s}</script><p>$\sigma _p(x_p)$可以进一步写为：</p>
<script type="math/tex; mode=display">
\sigma_p (x_p)=[\sigma_{p1}(x_1),...,\sigma_{ps}(x_p)]</script><p>我们假设$\sigma<em>{p1}$到$\sigma</em>{ps}$是Locally Lipschitz函数。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E7%BB%98%E5%9B%BE8.png" alt=""></p>
<p>考虑一个带有阻尼和弹簧的小车，对小车施加一个向前的控制力$u$，则</p>
<script type="math/tex; mode=display">
m\ddot{p}=u-\alpha p - \beta \dot{p}</script><p>假设我们并不知道$\alpha$和$\beta$的值，令</p>
<script type="math/tex; mode=display">
x_p=\begin{bmatrix}
x_{p1}\\
x_{p2} 

\end{bmatrix}</script><p>其中</p>
<script type="math/tex; mode=display">
x_{p1}=p\\
x_{p2}=\dot{p}</script><p>则</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot{x}_{p1}&=x_{p2}\\
\dot{x}_{p2}&=\frac{u}{m}-\frac{\alpha}{m}x_{p1}-\frac{\beta}{m}x_{p2}
\end{aligned}</script><p>可得到下式</p>
<script type="math/tex; mode=display">
\dot{x}_p=\begin{bmatrix}
0 &1 \\ 
0 &0 
\end{bmatrix}x_p+\begin{bmatrix}
0\\ 
1
\end{bmatrix}(1/m)u+\begin{bmatrix}
0\\1 

\end{bmatrix}\begin{bmatrix}
-\alpha/m\\-\beta/m 

\end{bmatrix}^T\begin{bmatrix}
x_{p1}\\ 
x_{p2}
\end{bmatrix}</script><p>其中</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_p &=\begin{bmatrix}
0 &1 \\ 
0 &0 
\end{bmatrix}\\

B_p &=\begin{bmatrix}
0\\ 
1
\end{bmatrix}\\
\lambda &= 1/m\\
W^{T}_{p}&=\begin{bmatrix}
-\alpha/m\\-\beta/m 

\end{bmatrix}^T\\

\sigma_p&=\begin{bmatrix}
x_{p1}\\ 
x_{p2}
\end{bmatrix}
\end{aligned}</script><p>在某些情况下，我们甚至不知道$\sigma_p$，我们可以使用拟合方式进行建模。</p>
<h3 id="控制模型建立"><a href="#控制模型建立" class="headerlink" title="控制模型建立"></a>控制模型建立</h3><p>现在我们已知被控对象和控制量分别为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot{x}_p&=A_px_p+B_p\lambda u+B_pW^{T}_p\sigma_p(x_p),\ x_p(0)=x_{p0}\\
u&=u_n+u_a
\end{aligned}</script><p>$u_n$和$u_a$分别为常规控制量和自适应控制量，我们先考虑最简单的情况：$\lambda$是一个单位矩阵，而$B_pW^{T}_p\sigma_p(x_p)$为0（考虑状态空间表达式$\dot{x}=Ax+Bu$，我们不希望后面跟了一堆累赘），此时</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot{x}_p&=A_px_p+B_p u\\
u&=u_n=-K_1x_p+K_2c
\end{aligned}</script><p>控制量由状态反馈和前馈部分组成</p>
<script type="math/tex; mode=display">
\begin{aligned}
K_1&\in \mathbb{R}^{m\times n_p}\\
K_2&\in \mathbb{R}^{m\times n_c}\\
c&\in \mathbb{R}^{n_c}
\end{aligned}</script><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><h3 id="Locally-Lipschitz"><a href="#Locally-Lipschitz" class="headerlink" title="Locally Lipschitz"></a>Locally Lipschitz</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
      </categories>
  </entry>
  <entry>
    <title>Controllability and observability</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/controllability_and_observability/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>This paper introduces the concepts of controllability and observability.</p>
<a id="more"></a>
<p>In a control system, sometimes we need to discuss about the controllability and observability, basically the <strong>controllability and observability is about the actuator and sensor, it doesn’t mind what kinds of control strategy you are applying.</strong></p>
<h2 id="Controllability"><a href="#Controllability" class="headerlink" title="Controllability"></a>Controllability</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>Controllability concerns whether the <strong>state of a state-space equation can be controlled form the input.</strong></p>
<blockquote>
<p><strong>Definition 1</strong> A state $\dot{\mathbf{x}}(t)=A(t) \mathbf{x}(t)+B(t) \mathbf{u}(t)$ is controllable if for any initial state $x_0$ and any final state $x_1$, there exists an input that transfer $x_0$ to $x_1$ in a finite time.</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Every student in control engineering knows the famous proof of controllability that if the $n\times np$ controllability matrix </p>
<script type="math/tex; mode=display">
\begin{equation}
\mathcal{C}=\left[\mathbf{B}\ \mathbf{A B}\ \mathbf{A}^{2}\ \mathbf{B}\ \cdots \ \mathbf{A}^{n-1} \mathbf{B}\right]
\end{equation}</script><p>has rank $n$ (full row rank), then the system is controllable. A detailed proof can be found from reference<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>
<h2 id="Reachability"><a href="#Reachability" class="headerlink" title="Reachability"></a>Reachability</h2><p>In a linear system, the controllability and reachability are the same concepts. </p>
<h2 id="Observability"><a href="#Observability" class="headerlink" title="Observability"></a>Observability</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><p>Observability concerns whether the <strong>initial state can be observed form the output.</strong></p>
<h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h3><p>Like the controllability, a system is observable if the $nq \times n$ observability matrix</p>
<script type="math/tex; mode=display">
\begin{equation}
\mathcal{O}=\left[\begin{array}{c}{\mathbf{C}} \\ {\mathbf{C A}} \\ {\vdots} \\ {\mathbf{C A}^{n-1}}\end{array}\right]
\end{equation}</script><p>is full col rank.</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://www.ebadi.profcms.um.ac.ir/imagesm/474/stories/modern_control/chen%20c%20-t%20linear%20system%20theory%20and%20design.pdf">Chen C T. Linear system theory and design[M]. Oxford University Press, Inc., 1998.</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
        <category>现代控制</category>
      </categories>
      <tags>
        <tag>Important</tag>
      </tags>
  </entry>
  <entry>
    <title>自适应控制系统设计方法</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文将针对自适应控制系统的设计方法进行相应总结。</p>
<a id="more"></a>
<p>自适应算法必须包括两个性质：</p>
<ul>
<li>稳定性：在有界偏差情况下系统输出保持稳定</li>
<li>收敛性：能够给出期望结果</li>
</ul>
<p>为了简化考虑，通常对系统进行如下假设：</p>
<ul>
<li>被控系统线性且结构已知（简化分析）</li>
<li>扰动有界（推导稳定性结果）</li>
<li>扰动是有有理谱密度的平稳过程</li>
</ul>
<h2 id="自适应系统设计三个步骤"><a href="#自适应系统设计三个步骤" class="headerlink" title="自适应系统设计三个步骤"></a>自适应系统设计三个步骤</h2><ol>
<li>系统参数辨识（建模）</li>
<li>根据辨识的系统参数和某一性能指标进行控制器设计</li>
<li>自校正自适应过程</li>
</ol>
<h3 id="参数辨识方法"><a href="#参数辨识方法" class="headerlink" title="参数辨识方法"></a>参数辨识方法</h3><ol>
<li>间接法（显式法）：参数辨识和控制器设计分为两个步独立问题进行，简单，但是没有考虑参数辨识和控制器间相互影响。</li>
<li>直接法（隐式法）：直接将控制器参数作为系统未知数，建立与控制器参数直接相关的估计模型。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Introduction%2Bto%2BSelf%2BTuning%2BRegulator%2B(STR" alt="">.jpg)</p>
<p>上图是一个显式自校正器框图，控制器设计步骤不能省略。</p>
<h3 id="控制器设计的性能指标"><a href="#控制器设计的性能指标" class="headerlink" title="控制器设计的性能指标"></a>控制器设计的性能指标</h3><h4 id="基于优化控制策略的自校正控制器"><a href="#基于优化控制策略的自校正控制器" class="headerlink" title="基于优化控制策略的自校正控制器"></a>基于优化控制策略的自校正控制器</h4><ul>
<li>最小方差控制（输入输出模型）</li>
</ul>
<script type="math/tex; mode=display">
J_1=E\{e^2\}</script><p>$e$为误差，可根据不同需要有不同定义，当$J_1$没有控制量，并且参数输入为0或者恒定值，仅对扰动和噪声进行抑制。</p>
<ul>
<li>广义最小方差（输入输出模型）</li>
</ul>
<script type="math/tex; mode=display">
J_2=E\{e^2+ru^2\}</script><p>加入了对控制量的控制和限制（即对能量进行限制）</p>
<ul>
<li>LQG线性高斯控制（状态空间描述）</li>
</ul>
<script type="math/tex; mode=display">
J_3= E\{x^TQx+u^TQu\}</script><h4 id="基于常规控制策略的自校正器"><a href="#基于常规控制策略的自校正器" class="headerlink" title="基于常规控制策略的自校正器"></a>基于常规控制策略的自校正器</h4><ul>
<li>极点配置</li>
<li>PID控制</li>
</ul>
<h4 id="模型参考自适应控制"><a href="#模型参考自适应控制" class="headerlink" title="模型参考自适应控制"></a>模型参考自适应控制</h4><p>参考另一篇文章</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
        <category>自适应控制</category>
      </categories>
  </entry>
  <entry>
    <title>Parzen窗函数法</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Parzen%E7%AA%97%E5%87%BD%E6%95%B0%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Parzen窗函数法是一种广泛应用的<strong>非参数估计方法</strong>（所谓非参数，就是这样的方法不需要对样本分布做出任何预先假设<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>），用于估计给定样本点的概率密度函数。</p>
<a id="more"></a>
<h2 id="一张图解释窗函数法"><a href="#一张图解释窗函数法" class="headerlink" title="一张图解释窗函数法"></a>一张图解释窗函数法</h2><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/parzen_goal.png" alt=""></p>
<p>上面这个图就描述了窗函数法的目标：</p>
<ol>
<li>我们有分布未知的样本点</li>
<li>我们希望估计特定样本点概率密度</li>
</ol>
<h2 id="模型无关的技巧"><a href="#模型无关的技巧" class="headerlink" title="模型无关的技巧"></a>模型无关的技巧</h2><p>窗函数法的基础是<strong>数数</strong>，我们要数有多少个样本落在了指定的区域$R_n$中，这个区域叫做Window，根据我们的经验，落入样本的概率为：</p>
<script type="math/tex; mode=display">
P(x)=\frac{\#\ of\ samples\ in\ R}{total\ samples}</script><p>现在，考虑我们的一个样本点$\boldsymbol{x}$，以及一个包围它的非常小的领域$R$，它的体积为$V$，则：</p>
<script type="math/tex; mode=display">
p(x)V=\int_{R}p\left ( u \right )\mathrm{d}u</script><p>这是连续平滑函数的形式，如果是离散形式，那么我们可以得到如下公式：</p>
<script type="math/tex; mode=display">
\hat{p}\left ( \boldsymbol{x} \right )\approx \frac{k/n}{V}</script><p>这个体积太小太大都不行，太小会导致不稳定，太大则过于平滑，对于这个矛盾，我们采用下面两种方法来调节：</p>
<ol>
<li>固定体积，那么概率密度与$n$成反比，此时能够得到的样本越多，我们可以把体积设定的越小，这个就是Parzen窗函数法。</li>
<li>固定$k$，根据训练集计算体积$V$，这个就是k近邻法。</li>
</ol>
<p>从上面我们可以看出，Parzen和k近邻，都不需要预先对样本分布有任何假设，所以是模型无关。但是模型无关是有代价的，虽然不需要预先假设，但也意味着一般情况下我们的数据不能太过复杂，高维情况会出现维数灾难。</p>
<h2 id="Parzen窗函数法"><a href="#Parzen窗函数法" class="headerlink" title="Parzen窗函数法"></a>Parzen窗函数法</h2><p>上节提到，我们需要选择一个合适的包围$\boldsymbol x$的足够小区域，我们可以选择立方体作为这个区域，考虑一个$d$维度的超立方体，它的边长$h(n)$是样本数$n$的函数，则该区域体积为：</p>
<script type="math/tex; mode=display">
V(n)=h^d(n)</script><p>定义如下计数函数：</p>
<script type="math/tex; mode=display">
\varphi(\boldsymbol x)=\left\{\begin{matrix}
1\ \ \ \ \ \ \ 在区域内\\
0\ \ \ \ 不在区域内
\end{matrix}\right.</script><p>那么落在区域内的样本点个数可以表示为（这里我们进行了一个比例尺变换，即除以$h(n)$）：</p>
<script type="math/tex; mode=display">
k(n)=\sum_{i=1}^{n}\varphi(\frac{x-x_i}{h(n)})</script><p>代入到上面的计算概率密度的公式中：</p>
<script type="math/tex; mode=display">
\hat{p}\left ( \boldsymbol{x},n \right )=\frac{1}{nV}\sum_{i=1}^{n}\varphi(\frac{x-x_i}{h(n)})</script><p>从上式中可知，如果领域内集中大量样本点，那么得到的概率密度会很大，否则会很小。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://sebastianraschka.com/Articles/2014_kernel_density_est.html">用Parzen窗函数估计核密度</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="http://dutiosb.twi.tudelft.nl/~cai/AS2015/Parzen1962.pdf">Parzen E. On estimation of a probability density function and mode[J]. The annals of mathematical statistics, 1962, 33(3): 1065-1076.</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3">De Sa J P M. Pattern recognition: concepts, methods and applications[M]. Springer Science &amp; Business Media, 2012.<a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>粒子群算法</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Particle Swarm Optimization (PSO) 是一种启发式学习方法，它具有简单有效特点，该方法来自于具有社会行为的动物种群例如鸟群或鱼群。</p>
<a id="more"></a>
<p>PSO的开山之作参考下面这篇论文：</p>
<div class="pdf" target="http://www.ppgia.pucpr.br/~alceu/mestrado/aula3/PSO_2.pdf" height=""></div>
<h2 id="PSO-原理"><a href="#PSO-原理" class="headerlink" title="PSO 原理"></a>PSO 原理</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>PSO的原理非常简单，可以用一句话概括成为：通过合作的方式，在给定区间中寻找全局最小值。一群粒子在给定区间中活动，一旦某个粒子探索到了一个比较小的值，那么其他粒子就会向它这边靠拢，在这个过程中，就有可能搜索到全局最小值</p>
<p>PSO过程有两个重要的原则：通信与学习。通信的意思是粒子之间会相互告知当前自己的最小值，而学习的意思是粒子能够不断学习知道当前时刻比较好的结果所在的位置。</p>
<p>根据PSO算法的原理，PSO包括如下部分</p>
<ul>
<li>粒子群：粒子群中每个粒子代表了优化问题的一个候选解<ul>
<li>粒子$i$：粒子$i$具有的属性包括其位置$\vec{x}_i(t)$和速度$\vec{v}_i(t)$，它们维度相同。此外每个粒子还应当记录自己的最优值$\vec{P}_i(t)$和全局最优值$\vec{g}(t)$。一个粒子的图示见下图，它的新位置是由当前速度、当前自身最优点和全局最优点决定的。</li>
</ul>
</li>
<li>解空间：所有可能解组成的空间</li>
<li>待优化问题：我们需要解决的问题</li>
</ul>
<p><img style="margin: auto;" src="https://raw.githubusercontent.com/sqduan/hexoimg/master/particle.jpg"></p>
<h3 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h3><p>粒子位置更新公式：</p>
<script type="math/tex; mode=display">
\vec{x}_i(t+1)=\vec{x}_i(t)+\vec{v}_i(t+1)</script><p>速度更新公式：</p>
<script type="math/tex; mode=display">
\vec{v}_i(t+1)=w\vec{v}(t)+c_1(\vec{P}_i(t)-\vec{x}_i(t))+c_2(\vec{g}(t)-\vec{x}_i(t))</script><p>写成标量的形式：</p>
<script type="math/tex; mode=display">
v_{ij}(t+1)=wv_{ij}(t)+r_1c_1(P_{ij}(t)-x_{ij}(t))+r_2c_2(g_{j}(t)-x_{ij}(t))\\
x_{ij}(t+1)=x_{ij}(t)+v_{ij}(t+1)\\
r_1,r_2\sim u(0,1)</script><p>从上式中我们可以看出，粒子群的速度更新包括两个部分：惯性部分和加速度部分，惯性部分就是说原来的速度乘以一个系数，加速度部分就是向自身最优和全局最优移动的加速度。加速度又可以根据自身和全局分为认知部分（cognitive）和社会（social）部分。</p>
<h2 id="基于MATLAB的PSO实现"><a href="#基于MATLAB的PSO实现" class="headerlink" title="基于MATLAB的PSO实现"></a>基于MATLAB的PSO实现</h2><p>PSO的实现一共分为五个部分：</p>
<h3 id="问题设置"><a href="#问题设置" class="headerlink" title="问题设置"></a>问题设置</h3><p>问题设置部分需要对我们的cost function进行设置，包括cost function形式、解空间范围、解空间维度和决策向量的维度。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">op_problem.cost_function  = @(x) optimization_problem(x); <span class="comment">% 待优化问题</span></span><br><span class="line">op_problem.solution_space = [<span class="number">0</span> <span class="number">500</span>];                      <span class="comment">% 解空间</span></span><br><span class="line">op_problem.dimension      = <span class="number">30</span>;                           <span class="comment">% 解空间维度</span></span><br><span class="line">op_problem.var_size       = [<span class="number">1</span> op_problem.dimension];     <span class="comment">% 决策向量维度</span></span><br></pre></td></tr></table></figure>
<h3 id="种群参数设置"><a href="#种群参数设置" class="headerlink" title="种群参数设置"></a>种群参数设置</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">swarm.<span class="built_in">size</span>                = <span class="number">100</span>;                          <span class="comment">% 种群规模</span></span><br><span class="line">swarm.iteration           = <span class="number">1000</span>;                         <span class="comment">% 迭代次数</span></span><br><span class="line">swarm.w                   = <span class="number">0.9</span>;                          <span class="comment">% 惯性系数</span></span><br><span class="line">swarm.c1                  = <span class="number">1.5</span>;                          <span class="comment">% 局部加速系数</span></span><br><span class="line">swarm.c2                  = <span class="number">2.5</span>;                          <span class="comment">% 全局加速系数</span></span><br></pre></td></tr></table></figure>
<h3 id="种群初始化"><a href="#种群初始化" class="headerlink" title="种群初始化"></a>种群初始化</h3><h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><h3 id="结果显示"><a href="#结果显示" class="headerlink" title="结果显示"></a>结果显示</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=sB1n9a9yxJk">youtube上面关于粒子群的讲解</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>BP网络权值更新公式</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/BP%E7%BD%91%E7%BB%9C%E6%9D%83%E5%80%BC%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>BP网络又叫做误差反向传播网络，说这么复杂，从控制理论的角度来说，这玩意儿不就是一个负反馈回路么，无非是在负反馈回路中加入了一些自适应参数调整，不得不说有些时候还是控制科学与工程的名词叫起来更顺耳一些。BP这个负反馈过程实际上就是对权值进行更新的一个方法。本文参考了斯坦福大学的CNN for visual recognition课程，国外的这些个课程设计的简直碾压国内高校课程，看看配套的网站支持就知道了。<a href="http://cs231n.github.io/">斯坦福CNN for visual recognition课程</a>。</p>
<a id="more"></a>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ol>
<li>梯度：<script type="math/tex">\nabla f=[\frac{\partial f}{\partial x} ,\frac{\partial f}{\partial y}]</script>，即偏导数组成的向量。（在感叹一句，这课程简直太详细了，完全把学生当作一张白纸，从最基本的梯度概念开始讲起）。</li>
<li>链式法则：<script type="math/tex">\frac{\partial f}{\partial x}=\frac{\partial f}{\partial q}\frac{\partial q}{\partial x}</script>。</li>
</ol>
<p>了解了这两个基本的知识后，我们来搭建一个简单的神经网络，设<script type="math/tex">f(x,y,z)=(x+y)z</script>，令$q=x+y$，则$f=qz$，令$x=-2,y=5,z=-4$，相应的几个函数输出及偏导数分别为：</p>
<script type="math/tex; mode=display">
f=-12\\
q=3\\
\frac{\partial f}{\partial x}=z=-4\\
\frac{\partial f}{\partial y}=z=-4\\
\frac{\partial f}{\partial z}=(x+y)=3\\
\frac{\partial f}{\partial q}=z=-4\\
\frac{\partial q}{\partial x}=1\\
\frac{\partial q}{\partial y}=1</script><p>用门电路的方式表示一下，<strong>下图中绿色的部分，就是网络计算的输出，它是前馈的，而红色就是$f$对各个分量进行求导得到的数值，它的方向正好是反馈过来的，所以也叫反向传播</strong>。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%94%B5%E8%B7%AF.PNG" alt=""></p>
<p>通过上面的电路，我们发现每个门可以独立（即局部地）完成两件事：</p>
<ol>
<li>前向输出的计算</li>
<li>反向传播即局部偏导数的计算（注意是局部）</li>
</ol>
<p>一旦网络前向输出过程完成，那么最终$f$对各个分量的偏导数也就可知了，即全局偏导数就已知了。</p>
<p>链式规则在这里的作用就像是齿轮一样，将每一个部分连接在一起。</p>
<p>现在假设我们想要让输出$f$变大，那么由于我们的$q$导数为负，因此我们希望$q$尽可能小一些，根据链式法则继续往前推，我们知道$q$对于$x,y$的导数为$1$，而输出$f$对于$x,y$的导数为$-4$，那么我们的目标就达到了，如果我们减小$x,y$，由于$x,y$对$f$导数为负，此时乘法门的输出会增大，也就是说我们的输出会增大。</p>
<h2 id="模块化：sigmoid函数"><a href="#模块化：sigmoid函数" class="headerlink" title="模块化：sigmoid函数"></a>模块化：sigmoid函数</h2><p>任何可微函数都可以充当门，同时我们也可以将多个门组合成一个大门来使用，例如我们的sigmoid函数，就组合了七种门。</p>
<script type="math/tex; mode=display">
f\left ( w,x \right )=\frac{1}{1+e^{-\left ( w_0x_0+ w_1x_1+w_2\right )}}</script><p>除了加法门、乘法门和最大门，还有下面四种：</p>
<p>倒数门、偏移门、指数门以及倍数门。</p>
<script type="math/tex; mode=display">
f\left ( x \right )=\frac{1}{x}\rightarrow \frac{\mathrm{d} f}{\mathrm{d} x}=-1/x^{2}\\
f_c\left ( x \right )=c+x\rightarrow \frac{\mathrm{d} f}{\mathrm{d} x}=1\\
f\left ( x \right )=e^{x}\rightarrow \frac{\mathrm{d} f}{\mathrm{d} x}=e^{x}\\
f_a\left ( x \right )=ax\rightarrow \frac{\mathrm{d} f}{\mathrm{d} x}=a</script><p>组合起来就是这个样子：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/sigmoid.png" alt=""></p>
<p>sigmoid函数会把输入向量轻柔地转换至0-1之间的一个数。</p>
<h2 id="BP过程推导"><a href="#BP过程推导" class="headerlink" title="BP过程推导"></a>BP过程推导</h2><p>那么我们现在进入重头戏，反向传播算法的推导。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`&lt;iframe width=&quot;854&quot; height=&quot;480&quot; src=&quot;https://www.youtube.com/embed/xqf2DJgucsU&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;`</span><br></pre></td></tr></table></figure>
<h3 id="多层单节点"><a href="#多层单节点" class="headerlink" title="多层单节点"></a>多层单节点</h3><p>考虑一个最简单的三层神经网络，它是下面这个样子：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.PNG" alt=""></p>
<p>输入、隐含和输出层每一个神经元包含权重$w$和偏置$b$，所以这个神经网络的cost function可以描述为：</p>
<script type="math/tex; mode=display">
C(w_1,b_1,w_2,b_2,w_3,b_3)</script><p>我们需要知道cost function对各个参数的敏感程度，这样我们就能知道调节那个参数可以最有效果地降低cost function。我们先考虑后两层神经元，即隐含层和输出层，同时令期望输出为1。这里的$L$上标代表层位置</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/BP-3.PNG" alt=""></p>
<p>那么我们输出层的代价函数就是：</p>
<script type="math/tex; mode=display">
C_0(...)=(a^{(L)}-y)^2</script><p>$a^{(L)}$是多少呢：</p>
<script type="math/tex; mode=display">
a^{(L)}=\sigma(w^{(L)}a^{(L-1)}+b^{(L)})=\sigma(z^{(L)})\\
z^{(L)}=w^{(L)}a^{(L-1)}+b^{(L)}</script><p>$\sigma$代表某种非线性函数，这里是上面提到的sigmoid函数。那么我们的计算关系树就如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/BP-4.png" alt=""></p>
<p>我们想要找到的是$C_0$和$w^{(L)}$之间的关系，就是求$\frac{\partial C_0}{\partial w^{\left ( L \right )}}$。那么怎么搞呢？用我们前面提到的链式法则。</p>
<script type="math/tex; mode=display">
\frac{\partial C_0}{\partial w^{\left ( L \right )}}=
\frac{\partial z^{(L)}}{\partial w^{\left ( L \right )}}
\frac{\partial a^{(L)}}{\partial z^{\left ( L \right )}}
\frac{\partial C_0}{\partial a^{\left ( L \right )}}\\
\frac{\partial C_0}{\partial a^{\left ( L \right )}}=2(a^{(L)}-y)\\
\frac{\partial a^{(L)}}{\partial z^{\left ( L \right )}}={\sigma}'(z^{(L)})\\
\frac{\partial z^{(L)}}{\partial w^{\left ( L \right )}}=a^{(L-1)}</script><p>代入化简我们可以得到下面的式子：</p>
<script type="math/tex; mode=display">
\frac{\partial C_0}{\partial w^{\left ( L \right )}}=2(a^{(L)}-y)
{\sigma}'(z^{(L)})
a^{(L-1)}</script><p>对于所有输入的训练样本：</p>
<script type="math/tex; mode=display">
\frac{\partial C}{\partial w^{\left ( L \right )}}=
\frac{1}{n}
\sum_{k=0}^{n-1}\frac{\partial C_k}{\partial w^{\left ( L \right )}}</script><p>其中$n$为样本数量，可以看到代价函数对$w$的导数是每一个样本输出值的均值。那么我们的整个网络的代价函数梯度可以写为：</p>
<script type="math/tex; mode=display">
\nabla C=\begin{bmatrix}
\frac{\partial C}{\partial w^{\left ( 1 \right )}}\\ 
\frac{\partial C}{\partial b^{\left ( 1 \right )}}\\ 
\vdots \\ 
\frac{\partial C}{\partial w^{\left ( L \right )}}\\ 
\frac{\partial C}{\partial b^{\left ( L \right )}}

\end{bmatrix}</script><h3 id="多层多节点"><a href="#多层多节点" class="headerlink" title="多层多节点"></a>多层多节点</h3><p>上面讨论了多层神经网络，每层只有一个神经元，这一节咱们讨论一下多层多节点的复杂神经网络，实际上就是公式变得复杂了一些，道理是一样的。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/BP-5.png" alt=""></p>
<p>这里引入了下标，代表第$i$个神经元，我们的代价函数变为：</p>
<script type="math/tex; mode=display">
C_0=\sum_{j=0}^{n_L-1}(a_j^{(L)}-y_j)^2</script><p>我们令从第$k$个神经元到第$j$个神经元的权值为$w_{kj}^{(L)}$，那么我们的$z_j$则表示为：</p>
<script type="math/tex; mode=display">
z_j^{(L)}=\sum_{k=0}^{n_L-1}w_{kj}^{(L)}a_k^{(L-1)}+b_j^{(L)}</script><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/BP-6.png" alt=""></p>
<p>对应的，我们要激活第$L$层第$j$个神经元，其输出为$\sigma(z_j^{(L)})$。最终我们的代价函数对每一个权值的偏导数可以写为：</p>
<script type="math/tex; mode=display">
\frac{\partial C_0}{\partial w_{jk}^{\left ( L \right )}}=
\frac{\partial z_j^{(L)}}{\partial w_{jk}^{\left ( L \right )}}
\frac{\partial a_j^{(L)}}{\partial z_j^{\left ( L \right )}}
\frac{\partial C_0}{\partial a_j^{\left ( L \right )}}\\</script><p>可以看出对每个权值的偏导数是没有变化的，多神经元与单神经元的区别是对上层输出的偏导数会发生变化：</p>
<script type="math/tex; mode=display">
\frac{\partial C_0}{\partial a_{k}^{\left ( L \right )}}=
\sum_{j=0}^{n_L-1}
\frac{\partial z_j^{(L)}}{\partial a_{k}^{\left ( L-1 \right )}}
\frac{\partial a_j^{(L)}}{\partial z_j^{\left ( L \right )}}
\frac{\partial C_0}{\partial a_j^{\left ( L \right )}}\\</script><p>讲到这里，基本上就可以算是把反向传播算法的基本原理写完了。后面有什么再接着补充。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://cs231n.github.io/optimization-2/">斯坦福大学人工智能课程中关于反向传播的讲解</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.youtube.com/watch?v=tIeHLnjs5U8">三蓝一棕对于反向传播的讲解</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>模型估计</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E7%B3%BB%E7%BB%9F%E8%BE%A8%E8%AF%86/%E6%A8%A1%E5%9E%8B%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在设计LQR与LQG的过程中，我们往往默认参数是已知的，但是实际情况中参数一般是未知的，所以我们需要首先进行模型估计。本文将针对常用的模型估计方法进行总结。</p>
<a id="more"></a>
<h2 id="估计方法"><a href="#估计方法" class="headerlink" title="估计方法"></a>估计方法</h2><h3 id="最小二乘法（LSM）"><a href="#最小二乘法（LSM）" class="headerlink" title="最小二乘法（LSM）"></a>最小二乘法（LSM）</h3><p>该方法使用线性系统输入（控制动作）和输出（状态轨迹）对系统参数进行辨识，一个线性系统可以表示为如下形式：</p>
<script type="math/tex; mode=display">
\begin{equation}
x_{t+1}=A x_{t}+B u_{t}
\end{equation}
\label{ss}</script><p>LSM的目标是找到关于$A$和$B$的无偏估计$\hat{A}$和$\hat{B}$，寻找方法为解决如下二次优化问题：</p>
<script type="math/tex; mode=display">
\begin{equation}
(\hat{A}, \hat{B})=\arg \min _{(A, B)} \sum_{t=0}^{T} \frac{1}{2}\left\|x_{t+1}-\left(A x_{t}+B u_{t}\right)\right\|_{2}^{2}
\end{equation}</script><p>为了解决上式，令$z<em>{t}=\left[\begin{array}{l}{x</em>{t}} \ {u_{t}}\end{array}\right] \in \mathbb{R}^{n+p}$，$\theta=[A, B] \in \mathbb{R}^{(n+p) \times n}$，在每一个采样点处进行采样，我们得到：</p>
<script type="math/tex; mode=display">
\begin{equation}
X=\left[\begin{array}{c}{x_{1}} \\ {x_{2}} \\ {\vdots} \\ {x_{T}}\end{array}\right], \quad Z=\left[\begin{array}{c}{z_{0}} \\ {z_{1}} \\ {\vdots} \\ {z_{T-1}}\end{array}\right]
\end{equation}</script><p>公式$(\ref{ss})$可以写为：</p>
<script type="math/tex; mode=display">
X=Z\theta</script><p>假设$Z^TZ$可逆，那么关于$\theta$的最小二乘估计为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\hat{\theta}=\left(Z^{T} Z\right)^{-1} Z^{T} X
\end{equation}</script><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdfs.semanticscholar.org/e43b/93c138505cf98ac75f04393bd010970e9839.pdf">Lecture 20: Linear Dynamics and LQG</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>控制科学</category>
        <category>控制理论</category>
        <category>系统辨识</category>
      </categories>
      <tags>
        <tag>Important</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习复习</title>
    <url>/2024/10/13/%E6%8E%A7%E5%88%B6%E7%A7%91%E5%AD%A6/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="1-概念学习-ID3-C4-5（概念聚类）"><a href="#1-概念学习-ID3-C4-5（概念聚类）" class="headerlink" title="1. 概念学习  ID3/C4.5（概念聚类）"></a>1. 概念学习  ID3/C4.5（概念聚类）</h3><p>考试考ID3</p>
<p>ID3采用熵作为策略，<u>ID3的选择策略是什么？</u></p>
<h3 id="2-统计学习-最小错误率-Bayes决策规则"><a href="#2-统计学习-最小错误率-Bayes决策规则" class="headerlink" title="2. 统计学习  最小错误率  Bayes决策规则"></a>2. 统计学习  最小错误率  <u>Bayes决策规则</u></h3><p>条件概率，先验概率，类条件概率，考试写出Bayes决策规则是什么。</p>
<p>参数法与非参数法（K近邻与Parzen窗函数法）</p>
<p><u>窗函数法很经典，公式记住。</u></p>
<p>K近邻（没法考），直接估计后验概率，$P<em>{e</em>{Bayes}}\le error\ rate\le 2P<em>{e</em>{Bayes}}$</p>
<a id="more"></a>
<h3 id="3-SVM"><a href="#3-SVM" class="headerlink" title="3. SVM"></a>3. SVM</h3><p>最优判别面，<u>考一个最基本的概念：什么是支持向量？</u></p>
<p>SVM是感知器的推广。</p>
<h3 id="4-人工神经网络-根据误差求偏导数"><a href="#4-人工神经网络-根据误差求偏导数" class="headerlink" title="4. 人工神经网络 根据误差求偏导数"></a>4. 人工神经网络 根据误差求偏导数</h3><p>感知器，<u>BP net</u>，RBF，SoM，联想记忆网络（霍普菲尔德网络）。</p>
<p><u>任意给BP，求其权值更新公式$\Delta w_{ij}$。</u></p>
<p>BP使用过程中最麻烦的一些问题：</p>
<ol>
<li>反向传播弥散</li>
<li>隐层节点数选择</li>
<li><u>过学习问题</u></li>
</ol>
<h3 id="5-演化计算-遗传算法"><a href="#5-演化计算-遗传算法" class="headerlink" title="5. 演化计算/遗传算法"></a>5. 演化计算/遗传算法</h3><p>在误差不可微的情况下，使用遗传算法<br><u>GA</u> EP ES GP（结构优化，求公式）…DE（数值优化） PSO  约束 多目标</p>
<p><u>GA的概念会考</u></p>
<p><u>GA的基本算法框架</u></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Elf 文件</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Elf%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
</blockquote>
<a id="more"></a>
<h2 id="概述1"><a href="#概述1" class="headerlink" title="概述1"></a>概述<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><p>在学习Elf文件的细节之前，我们先明确Elf是什么，为何要学习这种格式。</p>
<h3 id="什么是Elf"><a href="#什么是Elf" class="headerlink" title="什么是Elf"></a>什么是Elf</h3><p>Elf全称为<strong>Executable and Linkable Format</strong>，他定义了二进制可执行文件、库以及核心文件（类似于a.out）的格式结构。这个格式允许操作系统将文件翻译为对应的机器指令。一般Elf文件由编译器或链接器产生，并且是二进制格式。</p>
<h3 id="为何学习这种格式"><a href="#为何学习这种格式" class="headerlink" title="为何学习这种格式"></a>为何学习这种格式</h3><h2 id="Elf文件格式分析"><a href="#Elf文件格式分析" class="headerlink" title="Elf文件格式分析"></a>Elf文件格式分析</h2><p>在linux下我们可以使用<code>file</code>命令对文件格式进行分析，例如进入<code>/bin</code>目录下，对<code>ls</code>这个命令的可执行文件进行分析：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZuf65mbkzmyfcfo9jni4qZ bin]# file ls</span><br><span class="line">ls: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f4154ce8a36c20d9aa270cc21c6b25ec026ac00f, stripped</span><br></pre></td></tr></table></figure>
<p>可以看到他是一个64位的共享对象（竟然不是可执行对象），是动态链接的。</p>
<h3 id="Elf结构"><a href="#Elf结构" class="headerlink" title="Elf结构"></a>Elf结构</h3><p>一个Elf文件由如下部分组成：</p>
<ol>
<li>ELF 头</li>
<li>文件数据</li>
</ol>
<p>使用<code>readelf</code>命令可以看到Elf文件的结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZuf65mbkzmyfcfo9jni4qZ bin]# readelf -h ls</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2's complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x5e00</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          141384 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         10</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br></pre></td></tr></table></figure>
<h3 id="Elf头"><a href="#Elf头" class="headerlink" title="Elf头"></a>Elf头</h3><p>Elf头起始是一些魔数，提供了一些文件相关的信息，前四个十六进制数表示这是一个Elf文件：以<strong>7f</strong>开始，45=<strong>E</strong>，4c=<strong>L</strong>，46=<strong>F</strong>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/">The 101 of ELF files on Linux: Understanding and Analysis - Linux Audit (linux-audit.com)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>IO</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“Let us build ourselves a city, with a tower that reaches to the heavens, so that we may make a name for ourselves; otherwise we will be scattered over the face of the whole earth.”</p>
</blockquote>
<a id="more"></a>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>文件描述符是一个整数， 表示了进程可读写的一个对象，文件描述符的一个很重要的作用是进行抽象，使得文件、管道或者设备都能够以相同的方式（byte流）进行操作。每一个进程都有一个私有的从0开始的文件描述符空间，其中有三个常开的fd，分别为：</p>
<ul>
<li>0：标准输入（读）</li>
<li>1：标准输出（写）</li>
<li>2：标准错误（写）</li>
</ul>
<h2 id="IO-设备"><a href="#IO-设备" class="headerlink" title="IO 设备"></a>IO 设备</h2><h3 id="IO设备分类"><a href="#IO设备分类" class="headerlink" title="IO设备分类"></a>IO设备分类</h3><h4 id="按照使用特性"><a href="#按照使用特性" class="headerlink" title="按照使用特性"></a>按照使用特性</h4><ul>
<li>人机交互</li>
<li>存储设备</li>
<li>网络通信</li>
<li>低速、中速和高速</li>
</ul>
<h4 id="按照信息交换单位"><a href="#按照信息交换单位" class="headerlink" title="按照信息交换单位"></a>按照信息交换单位</h4><ul>
<li>块设备：如磁盘等</li>
<li>字符设备：打印机等</li>
</ul>
<h2 id="IO使用"><a href="#IO使用" class="headerlink" title="IO使用"></a>IO使用</h2><h3 id="IO多路复用机制"><a href="#IO多路复用机制" class="headerlink" title="IO多路复用机制"></a>IO多路复用机制</h3><p>IO复用共有三种方式，即select、poll和epoll下面将针对这三种方式进行总结：</p>
<p>(1) select：时间复杂度为$O(n)$</p>
<p>select 仅仅知道有IO事件发生，但是不确定是哪几个流，我们只能无差别对所有流进行轮询，找出能读出数据或写入数据的流，对他们进行操作。</p>
<p>(2) poll：时间复杂度为$O(n)$</p>
<p>poll 本质和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是他没有最大连接限制，原因是基于链表存储。</p>
<p>(3) epoll：时间复杂度$O(1)$</p>
<p>epoll会把哪个流发生了什么样的IO事件通知我们，所以epoll实际上是事件驱动的，此时我们对这些流的操作都是有意义的。epoll是一种通过函数回调进行通知的机制。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>TLB原理</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/TLB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>鱼的记忆力只有七秒</p>
</blockquote>
<a id="more"></a>
<h1 id="TLB（translation-lookaside-buffer）功能"><a href="#TLB（translation-lookaside-buffer）功能" class="headerlink" title="TLB（translation lookaside buffer）功能"></a>TLB（translation lookaside buffer）功能</h1><p>加快页表转换速度，在上下文切换过程中，根据<code>ASID</code>号查询对应的页表缓存，<code>TTBR</code>寄存器会保存ASID字段</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Shell</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Shell/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>$ ls</p>
</blockquote>
<a id="more"></a>
<p>Shell本质上是一个用户态程序，运行于内核之上，可以与用户进行交互。当用户输入一些命令后，shell会对这个输入进行解析，找到对应的可执行文件并执行，然后显示输出。</p>
<h2 id="shell基本工作原理"><a href="#shell基本工作原理" class="headerlink" title="shell基本工作原理"></a>shell基本工作原理</h2><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>shell的基本工作原理可以用下图概括：当shell运行后，会处在一个死循环中，等待用户输入命令；而一旦用户有命令输入，会调用fork产生一个子进程，父进程等待子进程完成，子进程调用exec替换内核镜像执行用户命令，结束后执行exit。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/202012101045.svg" width = "580" alt="图片名称" align=center /></p>
<h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><h3 id="管道命令模型"><a href="#管道命令模型" class="headerlink" title="管道命令模型"></a>管道命令模型</h3><p>利用管道组合而成的命令，实际上是构成了一棵命令树，例如当<code>sh</code>解析命令<code>ls | (sort|tail -1)</code>时，得到的命令树如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/202012101150.svg" width = "380" alt="图片名称" align=center /></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="任务划分"><a href="#任务划分" class="headerlink" title="任务划分"></a>任务划分</h4><p>现在我们来考虑如何实现管道功能，我们把整个任务划分为三个部分：</p>
<ul>
<li>创建管道</li>
<li>左侧命令向管道中写入</li>
<li>右侧命令从管道中读取</li>
</ul>
<h4 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h4><p>我们使用<code>pipe()</code>函数创建管道，如果失败触发一个perror</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">"create pipe error!"</span>);</span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理左侧命令"><a href="#处理左侧命令" class="headerlink" title="处理左侧命令"></a>处理左侧命令</h4><p>创建管道后，我们开始处理左侧命令，我们首先创建了一个新的进程，然后将标准输出重定向至写管道，最后执行左侧命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    dup(p[<span class="number">1</span>]);                 <span class="comment">// 重定向stdout</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理右侧命令"><a href="#处理右侧命令" class="headerlink" title="处理右侧命令"></a>处理右侧命令</h4><p>右侧命令类似，只不过方向是从读管道中读取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等待左右命令完成"><a href="#等待左右命令完成" class="headerlink" title="等待左右命令完成"></a>等待左右命令完成</h4><p>最后我们的线程做一些收尾工作，等待左右命令完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line">wait(&amp;r);</span><br><span class="line">wait(&amp;r);</span><br></pre></td></tr></table></figure>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>根据上面的管道实现的过程，思考下面的问题：</p>
<ul>
<li>为何需要多次关闭pipe？</li>
<li>为何要为左右命令都<code>fork</code>？能不能只为左侧或右侧命令创建进程？</li>
<li>为何要在两个子进程都创建好之后才开始wait，能不能先创建一个wait一个再创建另一个wait另一个？</li>
<li>当左右两侧读写速度不一致时会发生什么？如果左侧快会怎样？右侧快又会怎样？</li>
<li>左右两侧的命令是如何决定何时退出的？</li>
<li>如果右侧命令没有关闭写端，会发生什么？左侧命令没有关闭读端，又会发生什么？</li>
<li>内核如何决定何时释放<code>pipe</code>的<code>buffer</code>？</li>
</ul>
<h4 id="为何需要多次关闭pipe？"><a href="#为何需要多次关闭pipe？" class="headerlink" title="为何需要多次关闭pipe？"></a>为何需要多次关闭pipe？</h4><p>每个进程的文件描述符表是相互独立的，所以每个进程都需要单独关闭自己的文件描述符。</p>
<h4 id="为何要为左右命令都fork？能不能只为左侧或右侧命令创建进程？"><a href="#为何要为左右命令都fork？能不能只为左侧或右侧命令创建进程？" class="headerlink" title="为何要为左右命令都fork？能不能只为左侧或右侧命令创建进程？"></a>为何要为左右命令都<code>fork</code>？能不能只为左侧或右侧命令创建进程？</h4><p>根据管道命令构成的命令树我们可知，如果只为右侧命令创建进程，那么构成的命令树如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/202012101519.svg" width = "280" alt="图片名称" align=center /></p>
<p>这个显然是有问题的，shell会调用<code>exec</code>去执行左侧命令，如果不fork，那么意味着进程会执行<code>runcmd(pcmd-&gt;left);</code>，也不会返回，<code>more</code>命令不会有机会被执行，所以此时只有<code>ls</code>向管道中写入了命令，而没有命令从管道中读取。</p>
<p>而如果我们只为左侧命令创建进程，那么执行过程如下：</p>
<ul>
<li>先创建一个进程，子进程执行左侧命令</li>
<li>父进程执行右侧命令，如果右侧命令还是带管道的命令，那么重复上述过程</li>
</ul>
<p>看似没什么问题，执行起来也确实如此，但是这只是表象，如果我们执行下列命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sleep 10 | echo hi</span><br></pre></td></tr></table></figure>
<p>正常情况下，这个命令应该先打印<code>hi</code>，然后等待约10秒后退出，但是如果没有给右侧命令创建进程，那么会打印hi然后直接显示终端，没有睡眠10秒的过程，是因为右侧命令占用了我们的进程，改变了进程的执行分支，导致主进程没有办法执行wait指令，从而无法对子进程进行回收，直接抛弃了子进程继续执行而不是等待子进程结束后再显示终端。此时如果用<code>ps ax</code>查看，可以看到一个<code>sleep 10</code>的进程，说明左侧命令确实执行了，但是是以孤儿进程的方式执行的，父进程不再等待这个进程，任由其自生自灭。从上面两个实验我们可知，使用管道时，必须对左右命令单独创建子进程，然后主进程等待这两个命令执行完毕。</p>
<h4 id="为何要在两个子进程都创建好之后才开始wait"><a href="#为何要在两个子进程都创建好之后才开始wait" class="headerlink" title="为何要在两个子进程都创建好之后才开始wait"></a>为何要在两个子进程都创建好之后才开始wait</h4><p>如果我们先创建一个wait一个，再创建另一个wait另一个，这意味着我们明确规定管道左侧的命令先执行，等管道左侧命令完成后再执行管道右侧。如果左侧命令向管道中写入的数据不多，这是可以的。但是如果左侧命令向管道中写入大量数据直到写满了，而没有进程消耗这些数据，就会导致写堵塞，既写不进去，有没有进程读取数据，会导致程序被阻塞。</p>
<h4 id="左右两侧读取速度不一致会发生什么？"><a href="#左右两侧读取速度不一致会发生什么？" class="headerlink" title="左右两侧读取速度不一致会发生什么？"></a>左右两侧读取速度不一致会发生什么？</h4><p>根据<a href="https://man7.org/linux/man-pages/man7/pipe.7.html">pipe(7) - Linux manual page (man7.org)</a>可知，如果试图往一个满的pipe写入，那么<code>write</code>会被阻塞，直到<code>pipe</code>被读取后有空间写入后才会继续执行；同理，如果试图读取空的pipe，<code>read</code>也会被阻塞，直到有数据可读。</p>
<h4 id="左右两侧的命令如何决定何时退出？"><a href="#左右两侧的命令如何决定何时退出？" class="headerlink" title="左右两侧的命令如何决定何时退出？"></a>左右两侧的命令如何决定何时退出？</h4><p>管道只是起了重定向的作用，我认为命令的退出还是和命令本身的退出机制有关，例如ls，如果读取的文件结束并且输出也结束，那么ls就会退出。（这里还不是特别清楚）</p>
<h4 id="如果右侧命令没有关闭写端，会发生什么？左侧命令没有关闭读端，又会发生什么？"><a href="#如果右侧命令没有关闭写端，会发生什么？左侧命令没有关闭读端，又会发生什么？" class="headerlink" title="如果右侧命令没有关闭写端，会发生什么？左侧命令没有关闭读端，又会发生什么？"></a>如果右侧命令没有关闭写端，会发生什么？左侧命令没有关闭读端，又会发生什么？</h4><ul>
<li>如果右侧（读）命令没有关闭写端，那么左侧命令执行完后会退出，右侧不会</li>
</ul>
<p>因为右侧命令还会等待其他命令对管道的写入，直到发现管道写端也关闭后，才会结束读取的动作并退出。但是左侧命令没关写管道就结束了，留下右侧命令以为还有进程会写pipe，所以它会傻傻地等待。</p>
<ul>
<li>如果左侧（写）命令没有关闭读端，会发生什么？</li>
</ul>
<p>这个情况比较复杂，首先要了解一个概念<code>broken pipe</code></p>
<blockquote>
<p>一个程序如果试图向一个没有任何读者的管道中写入内容，那么这个程序会收到一个SIGPIPE 信号，告诉这个程序别瞎忙活了，没有人读管道，然后这个程序就会结束写操作。</p>
</blockquote>
<p>一个经典的例子如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yes | true</span><br></pre></td></tr></table></figure>
<p>yes命令会无限地向管道中写’y’，而true命令判断管道中内容是否为真，为真就退出。按照我们的理解，true会判断yes写入的内容为真，立刻退出，然后yes会一直向管道中写内容，直到写阻塞。但是实际并不是这样，yes会在true结束后立刻结束。因为true结束后，管道没人读了，yes如果继续写，会导致<code>broken pipe</code>并收到一个SIGPIPE 信号，然后导致yes退出。现在来理解一下问题：</p>
<blockquote>
<p>如果左侧（写）命令没有关闭读端，会发生什么？</p>
</blockquote>
<p>如果写命令没有关闭读端，那么他会以为管道有读者（实际上这个读者就是他自己），从而不会触发broken pipe，写命令会傻傻地将管道写满至堵塞，然后等那个不存在的读者读取，所以会导致阻塞的发生。</p>
<h2 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>在解释IO重定向前，我们先了解一下shell中最终要的三个文件描述符:</p>
<ul>
<li>标准输入：stdin 0</li>
<li>标准输出：stdout 1</li>
<li>标准错误：stderr 2</li>
</ul>
<p>shell一般从标准输入获取命令，然后将运行结果发送至标准输出或错误，而一般标准输出就是终端。shell一般保证这三个描述符总是打开的。现在我们想要重定向输入输出，从其他的文件中读取，再发送到普通文件，这就需要进行IO重定向。</p>
<h3 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>command &gt; file</td>
<td>将输出重定向至file</td>
</tr>
<tr>
<td>command &lt; file</td>
<td>将输入重定向至file</td>
</tr>
<tr>
<td>command &gt;&gt; file</td>
<td>将输出追加至file</td>
</tr>
</tbody>
</table>
</div>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><ul>
<li>open</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int open (const char* Path, int flags [, int mode ]);   // flags表示了文件处理方式</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>shell对命令解析后，为了实现重定向，我们需要做下面几件事：</p>
<ul>
<li>关闭原有的fd</li>
<li>打开新文件，替换原有fd</li>
<li>执行命令</li>
</ul>
<p>所以我们的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    rcmd = (struct redircmd*)cmd;</span><br><span class="line">    close(rcmd-&gt;fd);                            <span class="comment">// 0 or 1 now closed </span></span><br><span class="line">    <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;       <span class="comment">// 0 or 1 now ----&gt; rcmd-&gt;file</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">"open %s failed\n"</span>, rcmd-&gt;file);   <span class="comment">//这里没有使用dup，而是利用关闭fd的方式实现了重定向，很巧妙</span></span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>现在当我们执行下面语句是，就会将给定文件重定向至标准输入/输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6.828$ /bin/echo &quot;Helloworld&quot; &gt; result  </span><br><span class="line">6.828$ /bin/cat &lt; result</span><br><span class="line">&quot;Helloworld&quot;</span><br></pre></td></tr></table></figure>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>这里总结一下其他常见的一些shell中的运算符：</p>
<h3 id="amp-amp-运算符"><a href="#amp-amp-运算符" class="headerlink" title="&amp;&amp;运算符"></a>&amp;&amp;运算符</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd1 &amp;&amp; cmd2</span><br></pre></td></tr></table></figure>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>只有在左侧命令返回<code>true</code>时，才执行右侧命令</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="||运算符"></a>||运算符</h3><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd1 || cmd2</span><br></pre></td></tr></table></figure>
<h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>只有在左侧命令返回<code>false</code>时，才执行右侧命令</p>
<h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="()运算符"></a>()运算符</h3><h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(cmd1; cmd2; cmd3)</span><br></pre></td></tr></table></figure>
<h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>命令组，括号中的命令会新开一个子shell顺序执行。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.bilibili.com/video/av15896196/">MIT6828第四课</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>中断、异常和系统调用</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>去做点别的事情吧，等天黑了再回来</p>
</blockquote>
<a id="more"></a>
<p>在讨论中断前，我们先明确一点，任务发生中断，就意味着需要操作系统进行介入，<strong>中断是用户态切换到内核态的唯一途径</strong>，中断的处理是在内核态进行的</p>
<h2 id="硬中断、软中断和任务"><a href="#硬中断、软中断和任务" class="headerlink" title="硬中断、软中断和任务"></a>硬中断、软中断和任务</h2><ul>
<li>硬中断是由硬件中断产生的，具有最高优先级的任务</li>
<li>软中断是由软件中断产生的，优先级第二高的任务</li>
<li>一般的用户态线程优先级第三</li>
<li>当一个核上无事可做时，位于IDLE状态</li>
</ul>
<h2 id="中断和异常的种类"><a href="#中断和异常的种类" class="headerlink" title="中断和异常的种类"></a>中断和异常的种类</h2><p>所有的同步异常都使用0-31的中断向量，并映射至中断描述表的0-31。高于31的部分为软中断，即通过<code>int</code>指令触发的中断或者由外部设备触发的异步硬件中断。</p>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>在linux中，中断被分为上半部分和下半部分</p>
<h3 id="上下半部的理解"><a href="#上下半部的理解" class="headerlink" title="上下半部的理解"></a>上下半部的理解</h3><h4 id="上半部（top-half）——紧急硬件操作"><a href="#上半部（top-half）——紧急硬件操作" class="headerlink" title="上半部（top half）——紧急硬件操作"></a>上半部（top half）——紧急硬件操作</h4><h4 id="下半部（buttom-half）——非紧急的耗时操作"><a href="#下半部（buttom-half）——非紧急的耗时操作" class="headerlink" title="下半部（buttom half）——非紧急的耗时操作"></a>下半部（buttom half）——非紧急的耗时操作</h4><h3 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h3><p>中断向量的地址是中断服务例程的入口地址</p>
<h3 id="中断和子程序调用的比较"><a href="#中断和子程序调用的比较" class="headerlink" title="中断和子程序调用的比较"></a>中断和子程序调用的比较</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>都需要压栈保护现场</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>中断处理程序会保存程序状态字（PSW）寄存器，记录处理器状态和控制指令执行顺序，从而实现现场保护与恢复；而子程序调用在进程内执行，不需要更改PSW</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是内核对外实现服务的接口，类似于用户和银行柜员，用户可以发起取钱的服务，由银行柜员处理，但用户不能直接到银行中拿钱。</p>
<h3 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h3><p>系统调用主要涉及以下几个方面的作用：</p>
<ul>
<li>设备管理：设备启动/请求/释放</li>
<li>文件管理：文件创建/读/写/删除</li>
<li>进程控制：进程创建/销毁/阻塞/唤醒</li>
<li>进程通信：消息传递/信号传递</li>
<li>内存管理：内存分配/回收</li>
</ul>
<h3 id="系统调用实现机制"><a href="#系统调用实现机制" class="headerlink" title="系统调用实现机制"></a>系统调用实现机制</h3><p>首先，内核对系统调用的处理是给所有系统调用一个中断向量号，将其视为一个软中断，然后再根据系统调用编号，在系统调用表中进行寻找。</p>
<h3 id="系统调用与函数调用的区别"><a href="#系统调用与函数调用的区别" class="headerlink" title="系统调用与函数调用的区别"></a>系统调用与函数调用的区别</h3><h4 id="指令集不同"><a href="#指令集不同" class="headerlink" title="指令集不同"></a>指令集不同</h4><p>系统调用时使用<code>INT</code>和<code>IRET</code>指令（中断指令），产生堆栈切换和特权级切换（用户态和内核态堆栈不同，用户不能访问内核态堆栈）；而常规函数调用采用<code>CALL</code>和<code>RET</code>，没有发生堆栈切换。</p>
<h4 id="开销不同"><a href="#开销不同" class="headerlink" title="开销不同"></a>开销不同</h4><p>系统调用由于发生了堆栈切换，因此开销更大</p>
<ul>
<li>中断引导</li>
<li>建立内核堆栈</li>
<li>验证参数有效性</li>
<li>内核态映射到用户态的地址空间，使得<ul>
<li>更新页面映射权限</li>
</ul>
</li>
<li>内核态独立地址空间<ul>
<li>TLB（页表缓存）内容更新</li>
</ul>
</li>
</ul>
<h3 id="系统调用实例"><a href="#系统调用实例" class="headerlink" title="系统调用实例"></a>系统调用实例</h3><h2 id="现场保护"><a href="#现场保护" class="headerlink" title="现场保护"></a>现场保护</h2><h3 id="trapframe1"><a href="#trapframe1" class="headerlink" title="trapframe1"></a>trapframe<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3><p>trapframe 保存了中断发生时需要保存的相关寄存器，这个数据结构很重要，现在对其进行一些总结。一个完整的Trapframe，其布局如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/trapframelayout.svg" width = "380" alt="图片名称" align=center /></p>
<p>可以看到trapframe被分为了三个部分，有一部分由<code>int</code>指令保存，即硬件实现，其余部分由软件实现。在发生用户态到内核态的切换后，trapframe将被保存在内核栈中。其中，<code>tf</code>指向<code>oldesp</code></p>
<h4 id="trapframe和栈之间的关系："><a href="#trapframe和栈之间的关系：" class="headerlink" title="trapframe和栈之间的关系："></a>trapframe和栈之间的关系：</h4><p><code>trap</code>函数接收一个<code>trapframe</code>作为变量，而我们的trapframe是在栈上进行构造的。为了进一步地探究trapframe与栈之间的关系，我们将两者的内容分别进行打印。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAP frame at <span class="number">0xefffffbc</span> from CPU <span class="number">0</span></span><br><span class="line">  edi  <span class="number">0x00000000</span></span><br><span class="line">  esi  <span class="number">0x00000000</span></span><br><span class="line">  ebp  <span class="number">0xeebfdfe0</span></span><br><span class="line">  oesp <span class="number">0xefffffdc</span></span><br><span class="line">  ebx  <span class="number">0x00000000</span></span><br><span class="line">  edx  <span class="number">0x00000000</span></span><br><span class="line">  ecx  <span class="number">0x00000000</span></span><br><span class="line">  eax  <span class="number">0x00000002</span></span><br><span class="line">  es   <span class="number">0</span>x---<span class="number">-0023</span></span><br><span class="line">  ds   <span class="number">0</span>x---<span class="number">-0023</span></span><br><span class="line">  trap <span class="number">0x00000030</span> System call</span><br><span class="line">  err  <span class="number">0x00000000</span></span><br><span class="line">  eip  <span class="number">0x00800d17</span></span><br><span class="line">  cs   <span class="number">0</span>x---<span class="number">-001b</span></span><br><span class="line">  flag <span class="number">0x00000046</span></span><br><span class="line">  esp  <span class="number">0xeebfdfd4</span></span><br><span class="line">  ss   <span class="number">0</span>x---<span class="number">-0023</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>trapframe</code>的地址为<code>0xefffffbc</code>，在进入<code>trap</code>函数后，栈的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/30x $esp</span><br><span class="line">0xefffff98:     0xefffffbc      0x00000000      0x00000000      0x00000000</span><br><span class="line">0xefffffa8:     0x00000000      0x00000000      0xeebfdfe0      0xf0104806</span><br><span class="line">0xefffffb8:     0xefffffbc     ** 0x00000000      0x00000000      0xeebfdfe0</span><br><span class="line">0xefffffc8:     0xefffffdc      0x00000000      0x00000000      0x00000000</span><br><span class="line">0xefffffd8:     0x00000002      0x00000023      0x00000023      0x00000030</span><br><span class="line">0xefffffe8:     0x00000000      0x00800d17      0x0000001b      0x00000046</span><br><span class="line">0xeffffff8:     0xeebfdfd4      0x00000023   **   0xf000ff53      0xf000ff53</span><br><span class="line">0xf0000008:     0xf000e2c3      0xf000ff53</span><br></pre></td></tr></table></figure>
<p>可以看到，从<code>0xefffffbc</code>开始，即上面的**圈住的内容，就是trapframe的内容。从这里我们也能看出，临时变量实际上就是栈的某个范围内的内容。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="">mit6828 xv6 reference book</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>device tree</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/device%20tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Listen, a tree is growing</p>
</blockquote>
<a id="more"></a>
<h2 id="dts-介绍"><a href="#dts-介绍" class="headerlink" title="dts 介绍"></a>dts 介绍</h2><p>内核应当与硬件独立，内核中的代码应尽可能少地出现与硬件相关的各种配置。因此，我们需要将硬件相关内容单独提取出来作为抽象，从而减少内核与硬件的耦合，由此诞生了linux设备树，使用dts文件对linux硬件相关内容进行描述。</p>
<h2 id="dts-语法"><a href="#dts-语法" class="headerlink" title="dts 语法"></a>dts 语法</h2><h3 id="内存节点"><a href="#内存节点" class="headerlink" title="内存节点"></a>内存节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">camera@900000000 &#123;</span><br><span class="line">    compatible = &quot;camera&quot;;     // 名称，不用管</span><br><span class="line">    no-map;  // 不进行映射</span><br><span class="line">    reg = &lt;0x09  0x00000000  0x0  0x10000000&gt;</span><br><span class="line">    /*</span><br><span class="line">     * 0x09: 内存起始的高32位</span><br><span class="line">     * 0x00000000: 内存起始的低32位</span><br><span class="line">     * 0x0: 内存size的高32位</span><br><span class="line">     * 0x10000000: 内存size的低32位</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dts-命令"><a href="#dts-命令" class="headerlink" title="dts 命令"></a>dts 命令</h2><ul>
<li>dts转dtb</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dtc -I dts -O dtb -o 0045.dtb 0045.dts</span><br></pre></td></tr></table></figure>
<ul>
<li>dtb转dts</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dtc -I dtb -O dts -o 0045.dts 0045.dtb</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>信号量</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>是谁，在敲打我窗？是谁，在撩动琴弦？</p>
</blockquote>
<a id="more"></a>
<h1 id="信号量概念及基本操作"><a href="#信号量概念及基本操作" class="headerlink" title="信号量概念及基本操作"></a>信号量概念及基本操作</h1><p>信号量用于记录当前资源的数量，从而实现线程同步，其基本实现是一个能够原子递增和递减的整数，信号量只有两种操作，<code>wait</code>和<code>post</code>，其中<code>wait</code>表示占据信号量资源，会将信号量-1，如果信号量为0，表示当前资源耗尽，会陷入等待；而<code>post</code>表示归还对应的信号量资源，对应的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wait 操作</span></span><br><span class="line">wait() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">atomic <span class="title">if</span> <span class="params">(v &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">            v--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 操作</span></span><br><span class="line">post() &#123;</span><br><span class="line">    atomic&#123;</span><br><span class="line">        v++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制信号量"><a href="#二进制信号量" class="headerlink" title="二进制信号量"></a>二进制信号量</h2><p>当信号量v的值只能取0或1时，信号量退化为一个二进制信号量，此时资源具有排他性，同一时刻只能有一个进程占据信号量并访问临界区，这时信号量有点像一个锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait()    <span class="comment">// 上锁 v == 0</span></span><br><span class="line">RW</span><br><span class="line">post()    <span class="comment">// 解锁 v == 1</span></span><br></pre></td></tr></table></figure>
<p>但是这不意味着用二进制信号量能够代替锁，<strong>锁和二进制信号量的一个区别是：锁是谁申请，谁释放；而二进制信号量则没有该限制</strong>，所以完全有可能A线程执行<code>wait</code>，B线程执行<code>post</code></p>
<h1 id="经典信号量问题"><a href="#经典信号量问题" class="headerlink" title="经典信号量问题"></a>经典信号量问题</h1><h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><blockquote>
<p>假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌上有五碗面，每位哲学家之间各有一支餐叉。因为用一支餐叉很难吃到面条，所以假设哲学家必须用两支餐叉吃东西。他们只能使用自己左右手边的那两支餐叉。而餐桌上只有五根叉子</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220612120011.png" width = "360" alt="图片名称" align=center /></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=ukM_zzrIeXs&amp;ab_channel=JacobSorber">What is a semaphore? How do they work? (Example in C) - YouTube</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>计算机诞生之初应用程序往往比内存大很多，这种情况下一般的解决方法是对程序进行拆分，必要时在内存和磁盘之间进行数据交换，这样就可以在小内存上运行较大的程序。由此，我们引申出了操作系统中内存管理的概念。</p>
<a id="more"></a>
<h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h3 id="页与页框"><a href="#页与页框" class="headerlink" title="页与页框"></a>页与页框</h3><p>除了硬件保留及内核占用的内存，剩余内存被称为动态内存，使用页框（4K）进行管理</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220316220138.png" width = "580" alt="图片名称" align=center /></p>
<p>我们使用类型为page的页描述符对页框进行管理，page保存在<code>mem_map</code>数组中，所需空间为$R<em>{ps}/R</em>{p}$，约等于$1\%$</p>
<ul>
<li><code>virt_to_page</code>：根据虚拟地址找到页描述符地址</li>
<li><code>pfn_to_page</code>：产生与页框号pfn对应的页描述符地址</li>
</ul>
<h3 id="NUMA-Non-Uniform-Memory-Access"><a href="#NUMA-Non-Uniform-Memory-Access" class="headerlink" title="NUMA(Non-Uniform Memory Access)"></a>NUMA(Non-Uniform Memory Access)</h3><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220504201931.png" width = "580" alt="图片名称" align=center /></p>
<p>CPU距离某些内存从物理距离上更近，距离另一些更远，访问距离近的内存时速度更快，所以应当尽量使用临近的内存节点，每个节点叫做一个Numa Node</p>
<h3 id="Zone"><a href="#Zone" class="headerlink" title="Zone"></a>Zone</h3><p>将Numa Node进一步划分，我们得到不同的Zone，每一个Zone由多个页框（page frame）组成</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/numa.svg" width = "580" alt="图片名称" align=center /></p>
<h3 id="Page-Frame"><a href="#Page-Frame" class="headerlink" title="Page Frame"></a>Page Frame</h3><p>在linux中，页框由page结构体进行描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;              <span class="comment">// 页框状态   </span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;                   <span class="comment">// 引用计数   0: 可被回收, 非0: 不可回收</span></span><br><span class="line">    <span class="keyword">atomic_t</span> _mapcount;               <span class="comment">// 被映射次数，即包含该PFN的PTE个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> index;         </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个page frame需要一个page对应，一个struct page一般占用32字节，而一个page frame为4KB，消耗的内存占系统的32/4096，略小于1%</p>
<h3 id="内存管理区"><a href="#内存管理区" class="headerlink" title="内存管理区"></a>内存管理区</h3><p>由于硬件结构的制约，限制了页框的使用方式，在8086上，Linux将每个内存结点的物理内存划分为三个zone</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220316223442.png" width = "580" alt="图片名称" align=center /></p>
<p><code>DMA</code>和<code>NORMAL</code>经过线性映射映射至虚拟地址的第4GB，内核可以直接访问。这两块内存中包含了保留的页框池，用于在一条内核控制路径产生原子内存分配请求且内存不足的情况下紧急使用。</p>
<h3 id="页框分配"><a href="#页框分配" class="headerlink" title="页框分配"></a>页框分配</h3><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220316224349.png" width = "580" alt="图片名称" align=center /></p>
<p>管理区分配器接受动态内存分配释放请求，该部分搜索一个能满足所请求的一组<strong>连续页框内存管理区</strong>，并采用伙伴算法对页框进行分配，同时保留了一小部分页框在高速缓存中用于快速响应请求。</p>
<ul>
<li>alloc_pages(gfp_mask, order)：返回第一个分配页框描述符的地址，gfp_mask是页框标识</li>
<li>__get_free_pages(gfp_mask, order)：返回第一个分配页的线性地址</li>
<li>__free_pages(page, order)：释放页框</li>
<li>free_pages(addr, order)</li>
</ul>
<h3 id="高端内存映射"><a href="#高端内存映射" class="headerlink" title="高端内存映射"></a>高端内存映射</h3><p>由于32位平台线性地址空间的限制，内核并不能直接访问高端内存，内核线性地址空间的后128MB专门用于映射高端内存页框</p>
<ul>
<li>永久内核映射：长期映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    DECLARE_WAITQUEUE(wait, current);</span><br><span class="line">    <span class="keyword">for</span> (count = LAST_PKMAP; count &gt; <span class="number">0</span>; --count) &#123;</span><br><span class="line">        last_pkmap_nr = (last_pkmap_nr + <span class="number">1</span>) &amp; (LAST_PKMAP - <span class="number">1</span>);    <span class="comment">// 循环数组</span></span><br><span class="line">        <span class="keyword">if</span> (!last_pkmap_nr) &#123;</span><br><span class="line">            flush_all_zero_pkmaps();</span><br><span class="line">            count = LAST_PKMAP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!pkmap_count[last_pkmap_nr]) &#123;    <span class="comment">// 找到一个未使用项</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> vaddr = PKMAP_BASE +</span><br><span class="line">                (last_pkmap_nr &lt;&lt; PAGE_SHIFT);</span><br><span class="line">            set_pte(&amp;(pkmap_page_table[last_pkmap_nr]),  <span class="comment">// 建立映射</span></span><br><span class="line">                    mk_pte(page, _ _pgprot(<span class="number">0x63</span>)));</span><br><span class="line">            pkmap_count[last_pkmap_nr] = <span class="number">1</span>;</span><br><span class="line">            set_page_address(page, (<span class="keyword">void</span> *) vaddr);</span><br><span class="line">            <span class="keyword">return</span> vaddr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 内循环中未能找到空计数器，阻塞当前线程，直到某个进程释放了pkmap_page_table中一项</span></span><br><span class="line">    current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    add_wait_queue(&amp;pkmap_map_wait, &amp;wait);</span><br><span class="line">    spin_unlock(&amp;kmap_lock);</span><br><span class="line">    schedule();</span><br><span class="line">    remove_wait_queue(&amp;pkmap_map_wait, &amp;wait);</span><br><span class="line">    spin_lock(&amp;kmap_lock);</span><br><span class="line">    <span class="keyword">if</span> (page_address(page))    <span class="comment">// 检查是否存在另一个进程映射该页，内循环重新开始</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page_address(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>临时内核映射：不阻塞当前线程，可用于中断或可延迟函数内部</li>
</ul>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>连续页框分配，解决外碎片问题，找到最小满足要求的空闲块，如果没有，找到更大的一块，掰成两半使用</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220316231422.png" width = "580" alt="图片名称" align=center /></p>
<ul>
<li>分配块</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找合适的块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> current_order;</span><br><span class="line"><span class="keyword">for</span> (current_order=order; current_order&lt;<span class="number">11</span>; ++current_order) &#123;</span><br><span class="line">    area = zone-&gt;free_area + current_order;</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;area-&gt;free_list))</span><br><span class="line">        <span class="keyword">goto</span> block_found;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了合适的块，修改管理区描述符</span></span><br><span class="line">block_found:</span><br><span class="line">    <span class="comment">// 删除第一个页框描述符</span></span><br><span class="line">    page = list_entry(area-&gt;free_list.next, struct page, lru);</span><br><span class="line">    list_del(&amp;page-&gt;lru);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 减少管理区中free_page的值</span></span><br><span class="line">    ClearPagePrivate(page);</span><br><span class="line">    page-&gt;<span class="keyword">private</span> = <span class="number">0</span>;</span><br><span class="line">    area-&gt;nr_free--;</span><br><span class="line">    zone-&gt;free_pages -= <span class="number">1U</span>L &lt;&lt; order</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果为了满足2^h的页框请求，必须执行2^k，那么需要将剩余的页框进行再分配</span></span><br><span class="line">size = <span class="number">1</span> &lt;&lt; curr_order;</span><br><span class="line"><span class="keyword">while</span> (curr_order &gt; order) &#123;</span><br><span class="line">    area--;</span><br><span class="line">    curr_order--;</span><br><span class="line">    size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    buddy = page + size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入伙伴作为链表第一个元素</span></span><br><span class="line">    list_add(&amp;buddy-&gt;lru, &amp;area-&gt;free_list);</span><br><span class="line">    area-&gt;nr_free++;</span><br><span class="line">    buddy-&gt;<span class="keyword">private</span> = curr_order;</span><br><span class="line">    SetPagePrivate(buddy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> page;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放块：按照伙伴系统策略释放页框</li>
</ul>
<h2 id="内存区管理"><a href="#内存区管理" class="headerlink" title="内存区管理"></a>内存区管理</h2><p>伙伴系统用于分配大块内存请求，而对于小的内存区会造成浪费，这时我们采用slab分配，解决内部碎片问题</p>
<ul>
<li>将小块的数据结构对象放入高速缓存中，从中获取或释放</li>
<li>内核函数倾向于反复请求同一类型的内存，例如进程描述符，文件对象等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220316233329.png" width = "580" alt="图片名称" align=center /></p>
<p>每个slab由一个或多个页框组成，页框中既包含已经分配的对象，也有空闲对象</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220316233839.png" width = "580" alt="图片名称" align=center /></p>
<ul>
<li>创建slab</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一组连续页框</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">kmem_getpages</span><span class="params">(<span class="keyword">kmem_cache_t</span> *cachep, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    flags |= cachep-&gt;gfpflags;</span><br><span class="line">    page = alloc_pages(flags, cachep-&gt;gfporder);   </span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    i = (<span class="number">1</span> &lt;&lt; cache-&gt;gfporder);</span><br><span class="line">    <span class="keyword">if</span> (cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">        atomic_add(i, &amp;slab_reclaim_pages);</span><br><span class="line">    <span class="keyword">while</span> (i--)</span><br><span class="line">        SetPageSlab(page++);</span><br><span class="line">    <span class="keyword">return</span> page_address(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放slab页框</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_freepages</span><span class="params">(<span class="keyword">kmem_cache_t</span> *cachep, <span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = (<span class="number">1</span>&lt;&lt;cachep-&gt;gfporder);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">virt_to_page</span>(<span class="title">addr</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;reclaim_state)</span><br><span class="line">        current-&gt;reclaim_state-&gt;reclaimed_slab += i;</span><br><span class="line">    <span class="keyword">while</span> (i--)</span><br><span class="line">        ClearPageSlab(page++);</span><br><span class="line">    free_pages((<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr, cachep-&gt;gfporder);</span><br><span class="line">    <span class="keyword">if</span> (cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">        atomic_sub(<span class="number">1</span>&lt;&lt;cachep-&gt;gfporder, &amp;slab_reclaim_pages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给高速缓存分配slab"><a href="#给高速缓存分配slab" class="headerlink" title="给高速缓存分配slab"></a>给高速缓存分配slab</h3><p>一个新创建的高速缓存没有任何slab，也没有空闲对象，只有当以下两个条件为真，才分配slab</p>
<ul>
<li>已经发出一个分配新对象的请求</li>
<li>高速缓存不包含任何空闲对象</li>
</ul>
<p>当上述情况发生时，slab分配器进行如下操作：</p>
<ul>
<li>调用<code>cache_grow</code>分配新slab（虚slab）</li>
<li>调用<code>kmem_getpages</code>分配一组页框（物理内存）</li>
<li>调用<code>alloc_slabmgmt</code>获取slab描述符0</li>
</ul>
<h2 id="非连续内存区管理"><a href="#非连续内存区管理" class="headerlink" title="非连续内存区管理"></a>非连续内存区管理</h2><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220323215900.png" width = "580" alt="图片名称" align=center /></p>
<p>虚拟地址来源于vmalloc区域，通过调用<code>get_vm_area</code>可以在<code>VMALLOC_START</code>和<code>VMALLOC_END</code>之间查找一块空闲区域，大小至少为<code>size+4096</code>，步骤如下：</p>
<ul>
<li>调用kmalloc为<code>vm_struct</code>获得内存区</li>
<li>上锁，遍历<code>vm_struct</code>的结构体链表，找到一个大小符合要求的(<code>size+4096</code>)区域</li>
<li>如果找到，初始化描述符字段，释放锁，返回<code>vm_struct*</code>，否则返回NULL</li>
</ul>
<p><code>vmalloc</code>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">vmalloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> array_size, i;</span><br><span class="line">    size = (size + PAGE_SIZE - <span class="number">1</span>) &amp; PAGE_MASK;</span><br><span class="line">    area = get_vm_area(size, VM_ALLOC);                       <span class="comment">// 分配虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span> (!area)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    area-&gt;nr_pages = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    array_size = (area-&gt;nr_pages * <span class="keyword">sizeof</span>(struct page *));    <span class="comment">// 分配页描述符空间</span></span><br><span class="line">    area-&gt;pages = pages = kmalloc(array_size, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!area_pages) &#123;</span><br><span class="line">        remove_vm_area(area-&gt;addr);</span><br><span class="line">        kfree(area);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(area-&gt;pages, <span class="number">0</span>, array_size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;area-&gt;nr_pages; i++) &#123;</span><br><span class="line">        area-&gt;pages[i] = alloc_page(GFP_KERNEL|_ _GFP_HIGHMEM);    <span class="comment">// 分配物理页</span></span><br><span class="line">        <span class="keyword">if</span> (!area-&gt;pages[i]) &#123;</span><br><span class="line">            area-&gt;nr_pages = i;</span><br><span class="line">            fail: vfree(area-&gt;addr);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (map_vm_area(area, _ _pgprot(<span class="number">0x63</span>), &amp;pages))           <span class="comment">// 建立映射，保护位总是被置为63</span></span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="keyword">return</span> area-&gt;addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>映射的过程是相对比较机械的，具体步骤如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pgd</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = pgd_index(address); i &lt; pgd_index(end<span class="number">-1</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">pud_t</span> *pud = pud_alloc(&amp;init_mm, pgd, address);</span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (!pud)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    next = (address + PGDIR_SIZE) &amp; PGDIR_MASK;</span><br><span class="line">    <span class="keyword">if</span> (next &lt; address || next &gt; end)</span><br><span class="line">        next = end;</span><br><span class="line">    <span class="keyword">if</span> (map_area_pud(pud, address, next, prot, pages))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    address = next;</span><br><span class="line">    pgd++;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pud/pmd</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">pmd_t</span> * pmd = pmd_alloc(&amp;init_mm, pud, address);</span><br><span class="line">    <span class="keyword">if</span> (!pmd)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (map_area_pmd(pmd, address, end-address, prot, pages))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    address = (address + PUD_SIZE) &amp; PUD_MASK;</span><br><span class="line">    pud++;</span><br><span class="line">&#125; <span class="keyword">while</span> (address &lt; end);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pte</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> * pte = pte_alloc_kernel(&amp;init_mm, pmd, address);</span><br><span class="line">    <span class="keyword">if</span> (!pte)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (map_area_pte(pte, address, end-address, prot, pages))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    address = (address + PMD_SIZE) &amp; PMD_MASK;</span><br><span class="line">    pmd++;</span><br><span class="line">&#125; <span class="keyword">while</span> (address &lt; end);</span><br></pre></td></tr></table></figure>
<h2 id="内存管理的主要目的"><a href="#内存管理的主要目的" class="headerlink" title="内存管理的主要目的"></a>内存管理的主要目的</h2><p>内存管理主要负责内存的分配与回收，例如在C++中的new与delete；同时，内存管理还负责地址转换的事宜。总结下来内存管理的目的就是实现物理内存的分配以及虚拟内存的映射。内存管理需要实现如下目的：</p>
<ul>
<li>抽象：逻辑地址空间</li>
<li>保护：空间独立性</li>
<li>共享：访问相同内存、</li>
<li>虚拟化：更大地址空间（大于物理内存总量）</li>
</ul>
<h2 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h2><ul>
<li>重定位：程序加载到内存后，根据加载位置的不同，要将程序中用到的地址进行重新定位，找到正确位置</li>
<li>分段：把程序分为代码、数据、堆栈，这样可以使内存不连续</li>
<li>分页：将内存分为最基本的单位，找一个合适的粒度大小</li>
<li>虚拟存储</li>
</ul>
<h2 id="内存管理的实现"><a href="#内存管理的实现" class="headerlink" title="内存管理的实现"></a>内存管理的实现</h2><h3 id="内存管理的组成"><a href="#内存管理的组成" class="headerlink" title="内存管理的组成"></a>内存管理的组成</h3><p>内存管理可以分为物理内存分配和虚拟内存映射。</p>
<h4 id="内核的物理内存分配器"><a href="#内核的物理内存分配器" class="headerlink" title="内核的物理内存分配器"></a>内核的物理内存分配器</h4><p>在内存管理中，我们需要为内核提供物理内存分配器，使内核能够分配和释放内存。分配的单元为页，大小一般为4KB。为了实现分配器，我们需要维护一个数据结构记录哪些内存是已经被分配的，哪些是空闲的，多少个进程在使用已经分配的内存。同时，我们还需要一套用于分配和释放的调度策略。</p>
<h4 id="虚拟内存机制"><a href="#虚拟内存机制" class="headerlink" title="虚拟内存机制"></a>虚拟内存机制</h4><p>为了将内核和用户软件的虚拟内存地址映射到实际物理地址，我们需要一个虚拟内存映射机制。当指令使用内存时，x86的内存管理单元（MMU）通过一个页表完成映射过程。</p>
<h3 id="为何要进行内存划分"><a href="#为何要进行内存划分" class="headerlink" title="为何要进行内存划分"></a>为何要进行内存划分</h3><p>1 解决碎片问题</p>
<p>碎片可以分为内部碎片和外部碎片：内部碎片是固定分区中浪费掉的内存，而外部碎片来自可变分区中进程和进程间空间特别小，但是没办法再利用的碎片。</p>
<p>2 逻辑地址和物理地址的映射关系</p>
<p>逻辑地址可以使我们屏蔽硬件，更具逻辑性，而不必关注底层的内存物理地址。</p>
<h3 id="内存划分方式"><a href="#内存划分方式" class="headerlink" title="内存划分方式"></a>内存划分方式</h3><h4 id="非连续分配管理"><a href="#非连续分配管理" class="headerlink" title="非连续分配管理"></a>非连续分配管理</h4><h5 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h5><p>把主存分为大小相等且固定（2的n次幂，如512，4096等）的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</p>
<ul>
<li>页帧：物理地址划分为大小相同的基本分配单位</li>
<li>页面：逻辑地址划分为大小相同的基本分配单位，页帧和页面大小必须相等</li>
</ul>
<p>页管理就是找到页面到页帧之间的转换，依靠页表进行（找到逻辑页号和物理帧号之间的对应关系）。逻辑地址中的页号是连续的，物理地址中的帧号一般是不连续的。</p>
<h5 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h5><p>段式管理把主存分为一段段的，每一段访问方式和数据属性相同，段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如堆段、栈段、代码段、数据段等。 若干段组成了进程逻辑地址空间。段式管理通过段表对应逻辑地址和物理地址（逻辑连续，物理不连续）。</p>
<p>以linux系统为例，内存的划分可以分为五个段，其相关属性如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称/符号</th>
<th>功能</th>
<th>读写性</th>
<th>动态/静态分配</th>
</tr>
</thead>
<tbody>
<tr>
<td>BSS段  .bss</td>
<td>存放未初始化的全局变量，体现为一个占位符，只记录所需空间大小，而不记录具体的值，一般bss初始化为0</td>
<td></td>
<td>静态</td>
</tr>
<tr>
<td>数据段  .data</td>
<td>存放已初始化的全局变量或局部静态变量</td>
<td>可读写</td>
<td>静态</td>
</tr>
<tr>
<td>代码段 .text <br />常量段 .rodata</td>
<td>存放程序执行代码以及一些常量，一般存放在ROM中</td>
<td>只读（一些OS可写）</td>
<td>静态</td>
</tr>
<tr>
<td>堆</td>
<td>存放动态分配的内存段</td>
<td>可读写，必须手动分配及释放</td>
<td>动态</td>
</tr>
<tr>
<td>栈</td>
<td>存放临时局部变量</td>
<td>可读写，系统自动管理</td>
<td>动态</td>
</tr>
</tbody>
</table>
</div>
<p>分段后，一个程序就被拆分成了若干个段，示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200830223439.png" width = "300" alt="图片名称" align=center /></p>
<p>段访问下，逻辑地址由二元组<code>(s, addr)</code>表示</p>
<ul>
<li><code>s</code>：段号</li>
<li><code>addr</code>：段内偏移</li>
</ul>
<p>每个段，其内部地址是从0开始的，还有段号区分不同的段，例如代码段某条指令段号为1，段内偏移为1，那么其逻辑地址为$1:1$，当然我们要考虑段号和段内偏移的具体位数，这个和具体硬件有关，例如一个16bit的地址，段号为2bit，偏移为14bit。由逻辑地址找到程序段的过程为，通过段描述符找到段基址和长度，根据这两个值确定物理内存的位置。</p>
<h5 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h5><p>段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>
<h4 id="分页和分段的共同点和区别"><a href="#分页和分段的共同点和区别" class="headerlink" title="分页和分段的共同点和区别"></a>分页和分段的共同点和区别</h4><h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><ul>
<li>都是为了提高内存利用率，减少碎片</li>
<li>段和页都是离散存储的，两者都是离散分配模式，但页和段中内存是连续的</li>
</ul>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li>页是固定大小，由操作系统决定；段大小不固定，由当前运行程序决定</li>
<li>分页为了满足操作系统内存管理的需求，而段是逻辑信息的单位，具有明确的意义，例如代码、堆栈和数据段等等。</li>
</ul>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>虚拟内存实现过程中很重要的一个部分是页面置换算法。在地址映射过程中，如果在页面中发现所要访问的页面不在内存中，就发生缺页中断，即操作系统需要将页面调入主存后再进行访问，被内存映射的文件实际上成了一个分页交换文件。当发生缺页中断，如果当前内存中没有空闲页面，那么就必须选择一个页面移出从而让出空间。<strong>移出某个页面的算法就叫做页面置换算法</strong>。</p>
<ul>
<li>最佳页面置换算法：所淘汰的页面是以后永不会使用的，但是这种算法物理上不能实现</li>
<li>FIFO：淘汰在页面中滞留时间最长的</li>
<li>LRU：最近最久未使用，记录每个页面自上次访问来所经历的时间T，选择T最大的进行淘汰</li>
<li>LFU：最少使用，选择最少使用的页面进行淘汰</li>
</ul>
<h4 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h4><p>在分页内存管理中，很重要的两个要素是：</p>
<ul>
<li>虚拟地址映射到物理地址的速度要快</li>
<li>解决虚拟地址空间大，页表也会很大的问题</li>
</ul>
<h5 id="快表（页表的Cache）"><a href="#快表（页表的Cache）" class="headerlink" title="快表（页表的Cache）"></a>快表（页表的Cache）</h5><p>快表是页表缓冲，其内容是页表一部分或全部，功能是加快地址映射速度，通常位于MMU中。使用快表后的地址转换流程：</p>
<ol>
<li>根据虚拟地址中的页号查询快表</li>
<li>如果该页面在快表中，则直接从快表读取相应的物理地址</li>
<li>如果该页面不在快表中，访问内存中的页表，从页表中得到物理地址，同时将页表中的映射表添加至快表</li>
<li>快表填满后，登记新页面时，根据页面置换算法淘汰快表中的一个页面</li>
</ol>
<h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><p>下面以实际的计算演示多级页表所占用的大小</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200830212737.png" width = "250" alt="图片名称" align=center /></p>
<p>在32位系统中，内存地址为32位，分为两个部分，Page Number和Page Offset，由于offset即为页面大小，因此页面大小为$2^{12}=4096=4K$。而页面数为$2^{20}=1K\times 1K=1M$，意味着我们需要$1M$的空间保存页面映射表，由于页表要求连续，可能很难找到一段连续的空间保存1M，因此我们采取了二级页表划分的方式，将Page Number进一步划分为两个10位的表，即构成多级页表的寻址方式。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200830213437.png" width = "250" alt="图片名称" align=center /></p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200830220742.png" width = "450" alt="图片名称" align=center /></p>
<p>外部页表的大小是$1K$，而内部页表共$1K$个，每一个的大小是$1K$，故总大小也为$1M$。但是我们不一定把这些页表都保存起来，可以只保存一部分，这样就节约了资源。</p>
<p>下面以一个完整的例子展示多级页表的计算过程<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，一个多级页表的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20210223224747.png" width = "550" alt="图片名称" align=center /></p>
<p>令$S<em>m$为虚拟地址能表示的最大内存大小，$S_P$为页面大小，$S</em>{PTE}$为保存每个页表项（PTE）的大小。考虑一个内存大小为8GB，一个页大小为8KB（即offset为$2^{13}B$），虚拟地址长度为46bit的计算机，计算需要几级页表。</p>
<p>首先考虑不进行分级，那么只有一级页表，那么PTE的数量$N_{PTE}$（即所需的页数）计算公式为：</p>
<script type="math/tex; mode=display">
N_{PTE}=S_{m}/S_{p}=2^{46}B/2^{13}B=2^{33}</script><p>所以如果只有一级页表，需要$2^{33}$个PTE，每个PTE大小为32bit，那么$S<em>{PTE}=2^{2}B$，所以页表占用的空间为$S</em>{T}=N<em>{PTE}\times S</em>{PTE}=2^{35}B$。</p>
<p>现在考虑二级分页，在二级分页下，我们用一级页表指向二级页表，而二级页表的空间大小为$2^{35}B$，为了保存这么多的空间，我们需要$2^{35} B / 2^{13}B=2^{22}$个页面存放二级页表，所以一级页表的大小为$2^{22}$。</p>
<h3 id="多进程时的物理内存（DRAM）"><a href="#多进程时的物理内存（DRAM）" class="headerlink" title="多进程时的物理内存（DRAM）"></a>多进程时的物理内存（DRAM）</h3><p>当多个进程同时执行时，实际物理地址可能是如下情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=====Memory=====</span><br><span class="line">    Process1</span><br><span class="line">----------------</span><br><span class="line">    Process2</span><br><span class="line">----------------</span><br><span class="line">    Process2</span><br><span class="line">----------------    =======Disk=======</span><br><span class="line">    Process1              </span><br><span class="line">----------------    ==================</span><br></pre></td></tr></table></figure>
<p>物理内存中保存有进程1和2的内容，但是存储方式可能是不连续的，同时，可能也只是部分存储，然后通过Cache的方式从Disk中再读取进程中的数据。我们通过逻辑地址和物理地址的映射关系，从而实现寻址过程。</p>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>给进程分配一块不小于指定大小的连续物理内存空间</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>内存必须连续</li>
<li>存在外部碎片和内部碎片</li>
<li>动态修改困难</li>
<li>内存利用率低</li>
</ul>
<h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>内存释放后留下的空闲内存，可能没办法再利用，因为可能某个进程内存很小，而后续内存需要的进程都很大。碎片可以分为两种</p>
<ul>
<li>外部碎片：分配单元之间的未被使用的内存</li>
<li>内部碎片：由于内存取整导致分配单元内的未被使用内存，例如有个进程想要399字节的内存，但是我只能分配512字节，就会产生没有用的碎片</li>
</ul>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>当程序加载执行时，分配一个进程指定大小的内存区域，分区的地址是连续的。在该策略下，操作系统需要维护的数据结构包括：</p>
<ul>
<li>所有进程的已分配分区（链表）</li>
<li>空闲分区（链表）</li>
</ul>
<p>假设进程申请的大小为$n$个字节，那么分配策略有</p>
<ul>
<li>最先匹配（First Fit Allocation）：找到第一个比$n$大的空闲块就分配，释放时检查是否可与临近分区合并。<ul>
<li>优点是简单，高地址有大块空闲分区；</li>
<li>缺点是外部碎片多、分配大块时较慢</li>
</ul>
</li>
<li>最佳匹配（Best Fit Allocation）：设所有可分配的空间集合为$N$，那么相当于找$N$的上确界，即$\sup(N)$，即比$n$大，但是是$N$中最小的那个。需要查找所有的空间。空闲分区需要按照大小排序，释放时检查是否可与临近分区合并。<ul>
<li>优点：可避免大的空间分区被拆分，减少外碎片尺寸</li>
<li>缺点：容易产生很多无用的小碎片，释放分区慢，因为要调整排序</li>
</ul>
</li>
<li>最差匹配（Worst Fit Allocation）：找最大的分配，空闲分区列表从大到小排列，分配时选最大分区，释放时检查是否可与临近分区合并，并调整顺序<ul>
<li>优点：中等大小分配较多时，效果最好，可以避免出现太多小碎片</li>
<li>缺点：释放较慢，容易破坏大的空间分区，依然会有外部碎片</li>
</ul>
</li>
</ul>
<h4 id="碎片整理3"><a href="#碎片整理3" class="headerlink" title="碎片整理3"></a>碎片整理<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h4><p>当内存块不够给应用程序分配时，可以对碎片进行整理，产生大的可用块。常见方法有两种：</p>
<ul>
<li>通过调整进程占用的分区位置，减少碎片化，但是这个需要进程可以动态重定位，需要解决下面的问题：<ul>
<li>何时搬运进程</li>
<li>搬运开销有多大</li>
</ul>
</li>
<li>分区对换：抢占并回收处于等待状态的进程的分区，而将原始分区保存至外存中，交替开销非常大，基本现在已经很少用了</li>
</ul>
<h4 id="伙伴系统4"><a href="#伙伴系统4" class="headerlink" title="伙伴系统4"></a>伙伴系统<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></h4><h3 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h3><p>非连续内存分配存在很多问题，例如找到一个大小合适的连续区域可能很难，因此我们提出了非连续内存分配的概念，实际就是我们的段页式分配。非连续分配的设计目标为提高内存效率和灵活性</p>
<ul>
<li>允许一个程序使用非连续物理地址空间</li>
<li>允许共享代码和数据</li>
<li>支持动态加载和动态链接</li>
</ul>
<h4 id="非连续分配需要解决的问题"><a href="#非连续分配需要解决的问题" class="headerlink" title="非连续分配需要解决的问题"></a>非连续分配需要解决的问题</h4><ul>
<li>如何实现虚拟地址和物理地址的转换？虚拟地址是连续的，但是物理地址可能非连续</li>
<li>如何选择非连续分配中内存分块大小？段式管理和页式管理，段和段之间不连续、页和页之间不连续</li>
</ul>
<h3 id="懒分配（Lazy-Allocation）"><a href="#懒分配（Lazy-Allocation）" class="headerlink" title="懒分配（Lazy Allocation）"></a>懒分配（Lazy Allocation）</h3><p>懒分配就是指直到进程真正使用内存时，才进行内存的分配，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Widget singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Widget <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Widget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码为一个单例模式的实现，直到<code>get</code>函数第一次调用，即单例对象还未创建时，才触发内存分配。在linux内核中，懒分配指请求调页，他将页框分配推迟至不能再推迟时，再触发一个缺页异常，然后对这个异常进行处理，分配新的页面或者处理相应的内存错误。懒分配的优缺点如下：</p>
<ul>
<li>优点：能够使系统有更大吞吐量</li>
<li>缺点：系统会有额外开销，每一个缺页异常都需要由内核进行处理，浪费了时钟周期，但是由局部性原理可知，缺页异常不会耗费太多的资源，可以将其视为一个稀有时间。</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>虚拟内存是指使用磁盘空间对内存进行扩展，当然其效率比不上真正的物理内存。虚拟内存采用连续完整的地址空间，对多个不连续的物理内存进行映射，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>程序在执行时往往呈现局部性规律，在某个较短时间段内，程序执行局限在某一部分，访问的存储空间也局限在某一部分，这种局部体现在<strong>时间和空间</strong>两个方面。</p>
<ul>
<li>时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ul>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息，当访问的内容不在内存上时，再从外存向内存进行调用。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。例如，一个16MB的程序，通过仔细选择每个时刻将哪4MB内容保留在内存上，并在需要时在内存和磁盘间交换程序片段，可以使该程序运行在4MB的机器上</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>64位系统一般分为4级页表，分别是PGD、PUD、PMD和PTE，硬件上有一个页表基地址寄存器，用于保存PGD页表首地址。在ARM上是TTBR0_ELx和TTBR1_ELx，区别如下：</p>
<ul>
<li>低位虚拟地址空间位于0x0000,0000,0000,0000到0x0000,FFFF,FFFF,FFFF，</li>
<li>高位虚拟地址空间位于0x0000,FFFF,FFFF,FFFF</li>
</ul>
<p>如果虚拟地址最高位为0，使用低位空间，并且使用TTBR0_ELx存放页表基地址，否则使用TTBR1_ELx</p>
<h2 id="附录：一些简单的计算"><a href="#附录：一些简单的计算" class="headerlink" title="附录：一些简单的计算"></a>附录：一些简单的计算</h2><h3 id="16进制到KB、MB、GB的换算"><a href="#16进制到KB、MB、GB的换算" class="headerlink" title="16进制到KB、MB、GB的换算"></a>16进制到KB、MB、GB的换算</h3><p>我们一般用16进制表示地址位，那么16进制如何与KB、MB和GB这些单位进行换算呢？例如给定地址位为0xFFFFFFFF，其表示的是4GB所在的地址，计算过程如下：</p>
<script type="math/tex; mode=display">
{0\mathrm{xFFFFFFFF}}_{16}=4,294,967,295_{10}=\frac{4,294,967,295}{1024}KB</script><p>而1GB=1024MB=1024*1024KB，这样我们就实现了从16进制到KB、MB、GB的换算</p>
<h3 id="内存单位"><a href="#内存单位" class="headerlink" title="内存单位"></a>内存单位</h3><p>在内存中，其基本单位为byte，即一个地址对应1 byte，不过有些时候我们需要更大一点的划分，例如一个int对应4byte，这里总结一下内存的一些常用单位</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>单位名</th>
<th>字母</th>
<th>长度(以byte记)</th>
<th>push命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>B</td>
<td>1 byte (uint8)</td>
<td>push</td>
</tr>
<tr>
<td>word</td>
<td>W</td>
<td>2 byte (uint16)</td>
<td>pushl</td>
</tr>
<tr>
<td>double word</td>
<td>D</td>
<td>4 byte (uint32)</td>
<td></td>
</tr>
<tr>
<td>quad word</td>
<td>Q</td>
<td>8 byte (uint64)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://115.78.133.167:81/bitstream/TVHG_07113876976/270/1/OReilly%20-%20Understanding%20The%20Linux%20Kernel.pdf">Bovet D P, Cesati M. Understanding the Linux Kernel: from I/O ports to process management[M]. &quot; O'Reilly Media, Inc.&quot;, 2005.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.geeksforgeeks.org/multilevel-paging-in-operating-system/">Multilevel Paging in Operating System - GeeksforGeeks</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173359">碎片整理</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://github.com/wuwenbin/buddy2">伙伴系统实现</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>共享内存</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我们学会了争抢，学会了占有，学会了排斥，却唯独没有学会分享</p>
</blockquote>
<a id="more"></a>
<p>共享内存是linux中最为重要的IPC及硬件组件通信方式之一，本文将针对共享内存基本使用方法、常见共享内存模型以及共享内存并发访问保护等方面进行总结。</p>
<h1 id="共享内存使用"><a href="#共享内存使用" class="headerlink" title="共享内存使用"></a>共享内存使用</h1><p>linux下实现共享内存的方式有很多，本节将基于SYS V创建共享内存实现IPC通信，并总结一些常见的模型</p>
<h2 id="基本使用方法（SYS-V）"><a href="#基本使用方法（SYS-V）" class="headerlink" title="基本使用方法（SYS V）"></a>基本使用方法（SYS V）</h2><p>SYS V的共享内存即对应内核代码<code>linux/ipc/shm.c</code>，使用方式比较奇怪，以文件作为中介，使用attach和detach的方式进行映射和解映射，我在这里封装了一套接口用于创建和销毁共享内存，其中创建的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">AttachShm</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate a key for shared memory based on an existing file */</span></span><br><span class="line">    key = ftok(fileName, <span class="string">'R'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Attach file failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create shared memory for the sensor */</span></span><br><span class="line">    shmid = shmget(key, maxShmSize, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Get shared memory failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Attach shared memory failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DetachShm</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No need to free buf!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = shmdt(buf);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to detach memory!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本模型1：不带保护的生产者-消费者问题"><a href="#基本模型1：不带保护的生产者-消费者问题" class="headerlink" title="基本模型1：不带保护的生产者/消费者问题"></a>基本模型1：不带保护的生产者/消费者问题</h2><p>在创建共享内存后，我们就可以进行进程间通信，一个基本的读写者模型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create and init a sensor */</span>    </span><br><span class="line"><span class="keyword">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line">buf = AttachShm(<span class="string">"./shm.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write the buf */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    ShmWrite(buf, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = DetachShm(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A reader continue reading the buf */</span></span><br><span class="line"><span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">buf = AttachShm(<span class="string">"shm.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(buf) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Reading: %s\n"</span>, buf);</span><br><span class="line">        done = (<span class="built_in">strcmp</span>(buf, <span class="string">"quit"</span>) == <span class="number">0</span>);</span><br><span class="line">        buf[<span class="number">0</span>] = <span class="string">'\0'</span>;  <span class="comment">/* Clear the buf when read finished */</span></span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = DetachShm(buf);</span><br></pre></td></tr></table></figure>
<p>当然，上面这个读写模型没有并发保护，存在并发问题，运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">duan@ubuntu:~/Code/OS/memory/cmake/src$ ./server 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line">In ShmWrite: buf is 123</span><br><span class="line"></span><br><span class="line">duan@ubuntu:~/Code/OS/memory/cmake/src$ ./client </span><br><span class="line">Reading: 123</span><br></pre></td></tr></table></figure>
<p>两个终端，写者写了10次，但是读者只读了一次，读者在读的时候没有阻止写操作，读取到的次数是随机的，无法使用。</p>
<h2 id="基本模型2：由单个信号量进行读写保护的生产者-消费者问题"><a href="#基本模型2：由单个信号量进行读写保护的生产者-消费者问题" class="headerlink" title="基本模型2：由单个信号量进行读写保护的生产者/消费者问题"></a>基本模型2：由单个信号量进行读写保护的生产者/消费者问题</h2><p>现在我们使用信号量对共享内存的访问进行并发保护，我们创建两个信号量，分别用于生产者和消费者，基本逻辑如下：</p>
<ul>
<li>当生产者开始生产时，需要wait(reader)，当生产完毕后，需要post(writer)</li>
<li>当消费者开始消费时，需要wait(writer)，当消费完毕后，需要post(reader)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define SEM_WRITER_FNAME &quot;/writer&quot;</span><br><span class="line">#define SEM_READER_FNMAE &quot;/reader&quot;</span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Kernel</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Look, this is my heart</p>
</blockquote>
<a id="more"></a>
<p>当我们设计一个内核的时候，我们会考虑如下问题：</p>
<ul>
<li>内核应该做什么</li>
<li>应该提供哪些系统调用</li>
<li>应该针对哪些部分进行抽象</li>
</ul>
<h2 id="内核的架构模式"><a href="#内核的架构模式" class="headerlink" title="内核的架构模式"></a>内核的架构模式</h2><h3 id="宏内核（Monolithic-kernel）"><a href="#宏内核（Monolithic-kernel）" class="headerlink" title="宏内核（Monolithic kernel）"></a>宏内核（Monolithic kernel）</h3><p>也被称为集成式内核，用户态和内核态在同一空间中实现，管理的资源多。例如Unix、linux等都是宏内核</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><h3 id="不同架构对比"><a href="#不同架构对比" class="headerlink" title="不同架构对比"></a>不同架构对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>微内核</th>
<th>宏内核</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>执行速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>扩展性</td>
<td>容易</td>
<td>不易</td>
</tr>
<tr>
<td>安全性</td>
<td>单个服务崩溃不影响全局</td>
<td>单个服务崩溃往往导致系统崩溃</td>
</tr>
<tr>
<td>例子</td>
<td>塞班、Mac OS</td>
<td>Linux、Windos</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>协程</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对协程的概念进行总结。</p>
<a id="more"></a>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>启动过程</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p><em>Penguin, Boot</em></p>
</blockquote>
<a id="more"></a>
<h2 id="启动过程概述"><a href="#启动过程概述" class="headerlink" title="启动过程概述"></a>启动过程概述</h2><p>Linux的启动过程可以简单分为如下四步：</p>
<ul>
<li>BIOS POST</li>
<li>Boot loader</li>
<li>Kernel initialization</li>
<li>Start systemd, the parent of all processes.</li>
</ul>
<h2 id="BIOS-POST-（Basic-IO-system-Power-On-Self-Test）"><a href="#BIOS-POST-（Basic-IO-system-Power-On-Self-Test）" class="headerlink" title="BIOS POST （Basic IO system Power On Self Test）"></a>BIOS POST （Basic IO system Power On Self Test）</h2><p>BIOS是和启动相关的一段重要的程序，为了研究BIOS的功能，我们首先对计算机体系结构进行一个概述</p>
<h3 id="计算机体系结构概述"><a href="#计算机体系结构概述" class="headerlink" title="计算机体系结构概述"></a>计算机体系结构概述</h3><p>在计算机中，CPU通过总线与IO设备（硬盘、键盘、鼠标等）和内存相连。当计算机上电后，CPU执行的第一条指令在哪里呢？首先，CPU加电后会对寄存器进行初始化，然后开始执行第一条指令。第一条指令存放在ROM中，ROM是掉电非易失的，所以可以将我们的第一条代码保存在这里。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/structureOfComputer.svg" width = "350" alt="图片名称" align=center /></p>
<h4 id="启动时计算机的内存布局"><a href="#启动时计算机的内存布局" class="headerlink" title="启动时计算机的内存布局"></a>启动时计算机的内存布局</h4><p>在计算机启动时，内存布局如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<p>其中，640KB到1MB这一段是系统硬件部分，BIOS写死在960KB开始的地方。CPU启动后处于实模式，第一条指令位于CS:IP=0xf000:fff0的位置，即BIOS ROM的区域。此时只有20位地址（1MB）可用。</p>
<h3 id="BIOS提供的服务"><a href="#BIOS提供的服务" class="headerlink" title="BIOS提供的服务"></a>BIOS提供的服务</h3><ul>
<li>基本输入输出（从硬盘、键盘输入输出等）</li>
<li>系统设置信息</li>
<li>开机自检程序</li>
<li>系统自启动程序</li>
</ul>
<p>进入BIOS程序后，将BootLoader从磁盘加载至0x7c00，并跳转。载入Boot Loader后的内存如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Boot Loader   |  &lt;- 0x00007C00</span><br><span class="line">|     BIOS DATA    |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<h3 id="BIOS-基本IO功能"><a href="#BIOS-基本IO功能" class="headerlink" title="BIOS 基本IO功能"></a>BIOS 基本IO功能</h3><p>以下功能只能在实模式下使用</p>
<ul>
<li>INT 10h：字符显示</li>
<li>INT 13h：磁盘扇区读写</li>
<li>INT 15h：内存大小检测</li>
<li>INT 16h：键盘输入</li>
</ul>
<h3 id="BIOS-过程"><a href="#BIOS-过程" class="headerlink" title="BIOS 过程"></a>BIOS 过程</h3><h3 id="为什么不让BIOS直接加载？"><a href="#为什么不让BIOS直接加载？" class="headerlink" title="为什么不让BIOS直接加载？"></a>为什么不让BIOS直接加载？</h3><p>因为各种文件系统是不同的，不可能让一个BIOS包含所有的文件系统的读取，因此只让BIOS从硬盘固定区域进行读写</p>
<h2 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h2><p>UEFI的目标是在所有平台上一致的操作系统启动服务，实际是一个接口标准。</p>
<h2 id="Boot-Loader"><a href="#Boot-Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h2><p>Boot Loader 负责将操作系统代码数据加载至内存，然后跳转至起始地址</p>
<h3 id="Linux-Boot-Loader-过程"><a href="#Linux-Boot-Loader-过程" class="headerlink" title="Linux Boot Loader 过程"></a>Linux Boot Loader 过程</h3><h4 id="GRUB2"><a href="#GRUB2" class="headerlink" title="GRUB2"></a>GRUB2</h4><p>GRUB2全称为GRand Unified Bootloader, version 2，是现今主流Linux普遍采用的Boot Loader。其基本功能是找到linux内核，然后载入到内存中并运行。</p>
<h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>在POST结束时，BIOS会寻找到第一个Boot分区，加载bootstrap code，即GRUB2 Stage 1，这段代码非常小，因为必须适配前512字节的扇区（统一规定）。因为这个代码太小了，做不到太多有意义的工作，唯一的目的是定位下一个阶段并进行跳转</p>
<h4 id="第1-5阶段"><a href="#第1-5阶段" class="headerlink" title="第1.5阶段"></a>第1.5阶段</h4><p>GRUB2 的1.5阶段位于boot record和第一块硬盘分区之间，这一段空间因为一些原因没有被使用。这一段有62 512-byte的空间存放core.img文件，这个文件的大小是25,389 Bytes，足够放下一些文件系统的驱动，例如标准EXT、FAT及NTFS等。这意味着GRUB第二阶段可以位于标准的EXT文件系统内。第二阶段实际位于/boot下，即/boot/grub2。</p>
<h4 id="第2阶段"><a href="#第2阶段" class="headerlink" title="第2阶段"></a>第2阶段</h4><p>第二阶段位于/boot/grub2和其子文件夹下，它将运行期内核模块放置在了/boot/grub2/i386-pc文件夹下。第2阶段的作用是定位并载入所选择的Linux内核，内核和相关文件在/boot文件夹下。</p>
<h5 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h5><p>所有的kernel都经过了压缩并可自解压，从而节省空间，kernel和初始的RAM镜像以及设备映射位于/boot文件夹下。当内核被载入后，它会进行自解压，并载入systemd，并将控制权移交。至此，Boot阶段结束。</p>
<h2 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h2><h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>systemd是所有进程的父进程，它将会使linux正式进入可工作状态。systemd将会完成如下工作：</p>
<ul>
<li>挂载由/etc/fstab定义的文件系统，从而可以获取/etc下的配置文件</li>
</ul>
<h2 id="实模式VS保护模式"><a href="#实模式VS保护模式" class="headerlink" title="实模式VS保护模式"></a>实模式VS保护模式</h2><h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><h4 id="地址表示"><a href="#地址表示" class="headerlink" title="地址表示"></a>地址表示</h4><p>在实模式下，CPU通过直接访问实际的物理地址对内存进行访问，此时地址格式为[CS:IP]，物理地址为：</p>
<script type="math/tex; mode=display">
physical\_address : = segment\_part × 16 + offset</script><h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>在保护模式下，segment_part由一个16位的选择器代替，高13位为描述表的入口；而第2位表示使用GDT或LDT，最低两位表示优先级，0-3分别代表最高优先级和最低优先级</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://opensource.com/article/17/2/linux-boot-and-startup">Linux启动过程</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://thestarman.pcministry.com/asm/mbr/GRUB.htm">GRUB Boot Manager MBR/Boot Sector (pcministry.com)</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>地址</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我迷失在田野里，渐渐忘记了回家的路</p>
</blockquote>
<a id="more"></a>
<h2 id="几种不同的地址"><a href="#几种不同的地址" class="headerlink" title="几种不同的地址"></a>几种不同的地址</h2><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑地址</td>
<td>程序产生的段内偏移，由段选择符和段内偏移组成的地址。由操作系统决定，和物理地址一一对应的地址，C语言中的指针即为逻辑地址<br />逻辑地址就是段+页偏移</td>
</tr>
<tr>
<td>线性地址</td>
<td>段基址+段内偏移量构成的地址，如果未开启分页，那么线性地址就是物理地址，否则还需二次转换。<br />线性地址就是段偏移，但是还未进行页转换的地址<br />虚拟地址就是线性地址（linux内核明确表示）</td>
</tr>
<tr>
<td>物理地址</td>
<td>真实物理内存中的地址，即内存地址寄存器中的地址物理地址</td>
</tr>
</tbody>
</table>
</div>
<h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>物理地址就是硬件支持的地址空间，起始地址为0，一直到$\textrm{MAX}_{\textrm{sys}}$，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/physicalmemory.svg" width = "150" alt="图片名称" align=center /></p>
<p>每个物理内存单元的物理地址编号是唯一的，给写程序造成了不便，因此我们需要使用逻辑地址或虚拟地址，建立虚拟地址与物理地址之间的映射，<strong>从而可以使用相同的虚拟地址指向不同的物理地址</strong></p>
<h3 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h3><p>CPU运行进程时看到的地址，起始地址为0，一直到$\textrm{MAX}_{\textrm{proc}}$</p>
<h4 id="逻辑地址的作用"><a href="#逻辑地址的作用" class="headerlink" title="逻辑地址的作用"></a>逻辑地址的作用</h4><ul>
<li>避免直接将物理地址暴露，从而导致访问任意内存程序崩溃</li>
<li>可以用相邻的虚拟地址映射到不相邻的物理地址</li>
<li>可以使用一系列的虚拟地址访问大于可用物理内存的内存缓冲区（虚拟内存）</li>
<li>不同进程间使用虚拟地址相互隔离</li>
</ul>
<p>例如，如果同一时刻由两个进程P1和P2，那么两者的逻辑地址范围是多少？假设逻辑地址最大为65535。实际上，P1和P2可以有一样范围的地址，都为0-65535，操作系统会确保其逻辑地址指向不同的物理地址。</p>
<p>从这个问题中我们也可以看出，操作系统帮我们屏蔽了底层的物理实现。</p>
<h4 id="逻辑地址的生成过程"><a href="#逻辑地址的生成过程" class="headerlink" title="逻辑地址的生成过程"></a>逻辑地址的生成过程</h4><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/programloading.svg" width = "550" alt="图片名称" align=center /></p>
<h4 id="生成时机和限制"><a href="#生成时机和限制" class="headerlink" title="生成时机和限制"></a>生成时机和限制</h4><ul>
<li>编译时（最不灵活，写死的，但是比较简单）<ul>
<li>假设起始地址已知</li>
<li>如果起始地址改变，必须重新编译</li>
</ul>
</li>
<li>加载时（加载程序可以选择加载位置，但是加载好了执行过程中不能变）<ul>
<li>如编译时起始位置未知，编译器需要生成可重定位的代码</li>
<li>加载时生成绝对地址，在可执行文件中有一个重定位表，根据表修改绝对地址</li>
</ul>
</li>
<li>执行时（执行过程中可以移动代码，最灵活，需要虚拟地址支持）<ul>
<li>执行时代码可移动（前两种情况不能随意改动）</li>
<li>需要地址转换（映射）硬件支持</li>
</ul>
</li>
</ul>
<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><h3 id="虚拟地址（线性地址）到物理地址转换步骤"><a href="#虚拟地址（线性地址）到物理地址转换步骤" class="headerlink" title="虚拟地址（线性地址）到物理地址转换步骤"></a>虚拟地址（线性地址）到物理地址转换步骤</h3><p>这里讨论一个二级页表情况下VA到PA的转换过程，已知一个虚拟地址为<strong>0x01EB6338</strong>，CR3寄存器的值为<strong>0xAC0F1000</strong>，求物理地址。</p>
<h4 id="第一步：写出二进制地址并拆分"><a href="#第一步：写出二进制地址并拆分" class="headerlink" title="第一步：写出二进制地址并拆分"></a>第一步：写出二进制地址并拆分</h4><p>虚拟地址的二进制为：$0000,0001 ,1110 ,1011 ,0110 ,0011 ,0011 ,1000$</p>
<p>按照线性地址2级分页进行划分，地址可以被拆分为：</p>
<ul>
<li>Dir：0000,0001,11</li>
<li>Table：10 ,1011 ,0110</li>
<li>Offset：0011 ,0011 ,1000</li>
</ul>
<p>换算成十六进制可得到如下结果：</p>
<ul>
<li>页目录索引：7</li>
<li>页表索引：0x2B6</li>
<li>偏移量：0x338</li>
</ul>
<h4 id="第二步：根据CR3寄存器的物理地址确定页目录表的基地址"><a href="#第二步：根据CR3寄存器的物理地址确定页目录表的基地址" class="headerlink" title="第二步：根据CR3寄存器的物理地址确定页目录表的基地址"></a>第二步：根据CR3寄存器的物理地址确定页目录表的基地址</h4><p>CR3中存放的物理地址就是页目录表的基地址</p>
<h4 id="第三步：计算页表项的地址"><a href="#第三步：计算页表项的地址" class="headerlink" title="第三步：计算页表项的地址"></a>第三步：计算页表项的地址</h4><p>页表地址存放在Page Directory Entry的第7项中，即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">　[<span class="number">0xAC0F1000</span> + <span class="number">4</span> * <span class="number">7</span>] = [<span class="number">0xAC0F101C</span>] = <span class="number">0xAC0F101C</span>: pte</span><br></pre></td></tr></table></figure>
<p>0xAC0F101C这个地址保存了pte的值，假设这个值为<strong>0x2F103841</strong>，那么其中PTE为<strong>0x2F103000</strong>，而页表属性为0x381。</p>
<h4 id="第四步：计算页面的物理地址"><a href="#第四步：计算页面的物理地址" class="headerlink" title="第四步：计算页面的物理地址"></a>第四步：计算页面的物理地址</h4><p>页表的地址为<strong>0x2F103000</strong>，存放在第0x2B6项，所以虚拟地址所在页的物理地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0x2F103000 + 0x2B6 * 4] = [0x2F103AD8] = 0x2F103AD8: pa</span><br></pre></td></tr></table></figure>
<p>这里得到的pa是未经偏移的物理地址，假设为<strong>0x7095e847</strong>，那么页面物理地址为<strong>0x7095E000</strong>，属性为0x847</p>
<h4 id="最后一步：计算偏移量"><a href="#最后一步：计算偏移量" class="headerlink" title="最后一步：计算偏移量"></a>最后一步：计算偏移量</h4><p>最终物理地址为0x7095E000+0x338 = 7095E338</p>
<h3 id="地址生成过程的硬件解释"><a href="#地址生成过程的硬件解释" class="headerlink" title="地址生成过程的硬件解释"></a>地址生成过程的硬件解释</h3><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/CPUandMem.svg" width = "480" alt="图片名称" align=center /></p>
<p>CPU与内存连接的结构图如上图所示，我们从一条指令执行过程出发，分析虚拟地址到物理地址的转换过程。</p>
<ul>
<li>CPU当前正在执行一条指令<ul>
<li>ALU：需要逻辑地址指向的内存内容</li>
<li>MMU：根据页表进行逻辑到物理的转换</li>
<li>CPU控制器：给总线发送物理地址请求</li>
</ul>
</li>
<li>内存<ul>
<li>根据控制信号是读还是写，向总线发送或接收内容</li>
</ul>
</li>
<li><strong>操作系统</strong><ul>
<li>建立逻辑地址LA到物理地址PA的映射，地址转换是MMU硬件完成的，而操作系统只负责提供映射表</li>
</ul>
</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>现代CPU采用虚拟寻址的方式，需要将虚拟地址翻译成物理地址，这样才能访问真实的物理内存。完成虚拟地址转换为物理地址的的硬件是CPU中的MMU。转换过程为：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/addresstrans.svg" width = "550" alt="图片名称" align=center /></p>
<p>其中，C语言中的指针就是虚拟地址中的Offset部分，如果关闭了段选，那么线性地址就是虚拟地址。更具体的带有多级页表的转换方式如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20210223224451.png" width = "650" alt="图片名称" align=center /></p>
<h3 id="地址检查"><a href="#地址检查" class="headerlink" title="地址检查"></a>地址检查</h3><p>在地址转换过程中，操作系统会对地址进行检查。例如在段选过程中，操作系统会判断逻辑地址是否大于段长度寄存器，如果是，那么会触发内存异常。如果不是，那么地址会和段基址寄存器相加，生成线性地址。操作系统负责设置段长度和段基址。</p>
<h3 id="分级"><a href="#分级" class="headerlink" title="分级"></a>分级</h3><p>上面的线性地址被分为了两级，分别是：</p>
<ul>
<li>Dir</li>
<li>Table</li>
</ul>
<h2 id="Page-Table-Entry"><a href="#Page-Table-Entry" class="headerlink" title="Page Table Entry"></a>Page Table Entry</h2><h3 id="PDE与PTE"><a href="#PDE与PTE" class="headerlink" title="PDE与PTE"></a>PDE与PTE</h3><p>PDE与PTE的大小都为32位，具体格式如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20210302113437.png" width = "750" alt="图片名称" align=center /></p>
<h4 id="PDE（页目录表）"><a href="#PDE（页目录表）" class="headerlink" title="PDE（页目录表）"></a>PDE（页目录表）</h4><p>MMU通过<code>%cr3</code>寄存器获得PD位置，即完成不同进程之间PD的切换</p>
<h4 id="PTE（页表）"><a href="#PTE（页表）" class="headerlink" title="PTE（页表）"></a>PTE（页表）</h4><p>PTE由Physical Page Number（20-bit）和flags（12-bit）组成，其中：</p>
<ul>
<li>Physical Page Number = PPN，根据这个值可以找到对应的物理内存页的基地址</li>
<li>flag记录了该页的控制信息（是否存在、能否写以及能否被进程使用等）</li>
</ul>
<p>MMU将会把这20位的虚拟地址替换为PTE中的物理地址。PTE由MMU加载并存储在内存中。</p>
<h4 id="标志位解析"><a href="#标志位解析" class="headerlink" title="标志位解析"></a>标志位解析</h4><div class="table-container">
<table>
<thead>
<tr>
<th>标志位</th>
<th>全称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>Present</td>
<td>对于大多数操作系统，如果present为0，代表PDE或PTE数据无效</td>
</tr>
<tr>
<td>W</td>
<td>Writable</td>
<td>内存是否可写</td>
</tr>
<tr>
<td>U(PTE_U)</td>
<td>User</td>
<td>用户是否可访问</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>实模式与保护模式</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对保护模式与实模式相关内容进行总结。</p>
<a id="more"></a>
<h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>对于8088的实模式，包含如下特性：</p>
<ul>
<li><p>8个16bit通用寄存器</p>
</li>
<li><p>处理器向内存发送20位地址，其中4位地址由%cs/%ds/%es/%ss提供，指令段使用%cs、数据读写使用%ds、栈读写使用%ss。例如，一条指令位于[cs:ip]，其寻址方式为：</p>
<script type="math/tex; mode=display">
addr = 16\times \textrm{segment}+\textrm{offset}=16\times\textrm{CS}+\textrm{IP}</script></li>
<li><p>寻址范围很小（$2^{16}=65536$bytes）</p>
</li>
</ul>
<h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>在保护模式下，由一个段选择符和一个指定段内相对地址的偏移量构成逻辑地址，其结构如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201201205149.png" width = "480" alt="图片名称" align=center /></p>
<p>其中：</p>
<ul>
<li>Selector叫段选择符，高13位为描述表的入口；而第2位表示使用GDT或LDT，最低两位表示优先级，0-3分别代表最高优先级和最低优先级，段选择符保存在段寄存器（cs/ss/es/fs/ds）中</li>
<li>GDT/LDT位全局/局部描述符表，保存段描述符，其中Base包含段首字节线性地址，Limit存放段中最后一个内存单元偏移量（就是某个段的长度），Flags决定段的一些特征。</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>寻址范围大</li>
<li>仅能访问虚拟地址</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href=""></a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>多线程并发</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>You are just a part of the machine, you have nothing special, now, get back to work.</p>
</blockquote>
<a id="more"></a>
<p>由于并发的复杂性，我们需要详细地针对并发进行设计，本文将针对多线程编程过程当中的一些并发设计及模式进行总结。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在进行多线程编程时，我们需要注意以下几点：</p>
<ul>
<li>追踪锁保护的资源（变量、文件等）</li>
<li>确保正确上锁、解锁配对</li>
<li>不要对资源上多把锁</li>
<li>确保发送正确的条件</li>
<li>区分单播/广播的场景</li>
<li>线程之间需要优先级吗？因为多线程可能很难控制哪一个线程先执行</li>
</ul>
<h2 id="生产者-消费者模式（P-C）"><a href="#生产者-消费者模式（P-C）" class="headerlink" title="生产者/消费者模式（P/C）"></a>生产者/消费者模式（P/C）</h2><p>生产者消费者模式也成为有限缓冲模式，是多进程同步的经典模式。这个模式很简单，有若干数据的生产者和消费者，共享固定宽度的缓冲区，生产者产生数据并填入缓冲区，消费者从缓冲区取出数据进行使用。</p>
<pre class="mermaid">graph LR
    node((生产者))
    node1["缓冲区"]
    node2((消费者))
    node--生产数据-->node1
    node1--消费数据-->node2</pre>

<h3 id="P-C模式关键问题"><a href="#P-C模式关键问题" class="headerlink" title="P/C模式关键问题"></a>P/C模式关键问题</h3><p>PC模式的一个关键问题是，如何协调生产速度和消费速度，确保生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。那么如何保证上面这一点呢，我们可以采用如下手段：</p>
<h4 id="轮询方式（低效）"><a href="#轮询方式（低效）" class="headerlink" title="轮询方式（低效）"></a>轮询方式（低效）</h4><p>在轮询方式中，生产者和消费者在执行操作前，先判断是否符合操作条件，如果符合，就执行操作，否则就不执行，这个过程是很低效的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// main</span><br><span class="line">for i=0..10</span><br><span class="line">    producers[i] = fork(insert_data, NULL)</span><br><span class="line">consumer = fork(get_data, my_list)</span><br><span class="line"></span><br><span class="line">//生产者: insert_data</span><br><span class="line">lock(m)</span><br><span class="line">    if my_list.not_full -&gt; insert data   //空间未满，插入数据</span><br><span class="line">    else -&gt; 释放锁，然后过一会儿尝试插入数据</span><br><span class="line">unlock(m)</span><br><span class="line"></span><br><span class="line">// consumer: get_data</span><br><span class="line">lock(m)</span><br><span class="line">    if my_list.full -&gt; print and clean my_list</span><br><span class="line">    else -&gt; 释放锁，然后过一会儿等待buff满了再尝试 这个过程非常低效！！</span><br><span class="line">unlock(m)</span><br></pre></td></tr></table></figure>
<h4 id="条件变量方式"><a href="#条件变量方式" class="headerlink" title="条件变量方式"></a>条件变量方式</h4><p>在条件变量方式中，生产者和消费者通过条件变量建立联系，消费者在buffer没有满时等待，如果满了就被唤醒，处理buffer数据并清空；而生产者插入数据，如果buffer满了，就唤醒消费者。具体的条件变量的使用请参考<a href="/2024/10/13/计算机/操作系统/条件变量/" title="条件变量">条件变量</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 消费者</span><br><span class="line">lock(m)</span><br><span class="line">    while(my_list.not_full)    //使用while防止虚假唤醒</span><br><span class="line">        wait(m, list_full)     //进入wait时自动释放锁，从wait中唤醒时自动获取锁</span><br><span class="line">    my_list.print and clear</span><br><span class="line">unlock(m)</span><br><span class="line"></span><br><span class="line">// 生产者</span><br><span class="line">lock(m)</span><br><span class="line"> 	my_list.insert()</span><br><span class="line"> 	if my_list is full</span><br><span class="line"> 		signal(list_full)      //发送唤醒信号 </span><br><span class="line"> unlock(m)</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们使用了<code>while(my_list.not_full)</code>而不是<code>if(my_list.not_full)</code>，原因如下：</p>
<p>为了支持多个消费者，当一个消费者被唤醒后到它实际获得锁的这个时间，可能有其他消费者先获得了锁，并处理清空了buff，如果此时不再判断buff是否为满，那么可能会出现处理空buff的情况。出现这个现象的根本原因是，我们无法保证被唤醒后的线程一定会抢到锁，也无法保证被唤醒后buff没有发生改变，所以我们需要while循环。这个现象叫做虚假唤醒。</p>
<h3 id="pthread实现"><a href="#pthread实现" class="headerlink" title="pthread实现"></a>pthread实现</h3><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buffer</span><span class="params">(BUF_SIZE)</span></span>;   <span class="comment">//共享空间</span></span><br><span class="line"><span class="keyword">int</span> add = <span class="number">0</span>;  <span class="comment">//在指定位置添加元素</span></span><br><span class="line"><span class="keyword">int</span> rem = <span class="number">0</span>;  <span class="comment">//在指定位置删除元素</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>   <span class="comment">//当前元素数目</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> c_cons = PTHREAD_COND_INITIALIZER;   <span class="comment">//消费者等待cv</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> c_prod = PTHREAD_COND_INITIALIZER;   <span class="comment">//生产者等待cv</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(pthread(&amp;tid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pthread(&amp;tid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        pthread_mutex_lock (&amp;m);</span><br><span class="line">        	<span class="keyword">if</span>(num &gt; BUF_SIZE)&#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="keyword">while</span>(num == BUF_SIZE)&#123;</span><br><span class="line">                pthread_cond_wait(&amp;c_prod, &amp;m);</span><br><span class="line">            &#125;</span><br><span class="line">        	buffer[add] = i;</span><br><span class="line">        	add = (add+<span class="number">1</span>) % BUF_SIZE;</span><br><span class="line">        	num++;</span><br><span class="line">        pthread_nutex_unlock(&amp;m);</span><br><span class="line">       	</span><br><span class="line">        pthread_cond_signal (&amp;c_cons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock (&amp;m);</span><br><span class="line">        	<span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                pthread_cond_wait(&amp;c_cons, &amp;m);</span><br><span class="line">            &#125;</span><br><span class="line">        	i = buffer(rem);</span><br><span class="line">        	rem = (rem+<span class="number">1</span>)%BUF_SIZE;</span><br><span class="line">        	num--;</span><br><span class="line">        pthread_mutex_unlock (&amp;m);</span><br><span class="line">        pthread_cond_signal (&amp;c_prod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读写模式"><a href="#读写模式" class="headerlink" title="读写模式"></a>读写模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在读写模式中，同一时间我们可以有多个读者读取一个空间，只能有0个或者1个写者对空间进行写入。如果我们采用互斥锁，那么空间是一个0或1的状态，要么可以访问，要么不能访问，且同一时间只能由一个线程访问，这个对于多个读者的情况是非常低效的。我们希望读线程都能同时访问这个空间。在读写模式中，我们会遇到三种情况：</p>
<ol>
<li>buff既没有读者也没有写者使用，这种情况读写均可（resource_counter：0）</li>
<li>buff只有读者使用，这种情况buff可读（resource_counter：&gt;0）</li>
<li>buff由写者占据，这种情况既不能读也不能由其他线程写（resource_counter：-1）</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这部分需要多理解一下</p>
<p>读者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//--------------进入临界区，下面这段代码实际上可以看作加一个大锁</span><br><span class="line">Lock(counter_mutex)                                  </span><br><span class="line">    while(resource_counter == -1)</span><br><span class="line">        Wait(counter_mutex, read_phase)</span><br><span class="line">    resource_counter++;   //增加读者，可以视为读者一个一个有序进入图书馆</span><br><span class="line">Unlock(counter_mutex)</span><br><span class="line">//--------------进入临界区，实际上可以看作加一个大锁</span><br><span class="line"></span><br><span class="line">// read data</span><br><span class="line"></span><br><span class="line">//--------------走出临界区，释放这个大锁</span><br><span class="line">Lock(counter_mutex)</span><br><span class="line">    resource_counter--;</span><br><span class="line">    if(resource_counter == 0)  // 没有读者也没有写者</span><br><span class="line">        Signal(write_phase)    // 只能通知一个写者进行写操作</span><br><span class="line">Unlock(counter_mutex)</span><br><span class="line">//--------------走出临界区，释放这个大锁</span><br></pre></td></tr></table></figure>
<p>写者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//写前处理</span><br><span class="line">Lock(counter_mutex)</span><br><span class="line">    while(resource_counter != 0)</span><br><span class="line">        Wait(counter_mutex, write_phase) //等待write_phase 到来</span><br><span class="line">    resource_counter = -1;  //开始写</span><br><span class="line">Unlock(counter_mutex)</span><br><span class="line"></span><br><span class="line">// write data</span><br><span class="line"></span><br><span class="line">//写完后处理</span><br><span class="line">Lock(counter_mutex)</span><br><span class="line">    resource_counter = 0;  </span><br><span class="line">    Broadcast(read_phase)   // 通知所有读者进行读操作</span><br><span class="line">    Signal(write_phase)     // 通知其他某一个写者进行写操作</span><br><span class="line">    // 此处我们无法控制到底是读者先读还是写者先写</span><br><span class="line">Unlock(counter_mutex)</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们可以看出，读写操作实际上不是在临界区进行的，而是依靠<code>resource_counter</code>这个变量进行辅助控制，同一时间只能有一个线程对<code>resource_counter</code>进行访问，但是有多个线程可以读取数据。</p>
<h3 id="临界区结构"><a href="#临界区结构" class="headerlink" title="临界区结构"></a>临界区结构</h3><p>从读写模式中，我们可以抽象出基于代理变量的临界区保护结构，分别为进入临界区和退出临界区，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter critical section              |    Exit critical section</span><br><span class="line">Lock(mutex)&#123;                        |    Lock(mutex)&#123;</span><br><span class="line">    while(!predicate)               |        update predicate</span><br><span class="line">        wait(mutex, cond_var)       |        signal/broadcast</span><br><span class="line">    update predicate                |    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="老板-工人模式"><a href="#老板-工人模式" class="headerlink" title="老板/工人模式"></a>老板/工人模式</h2><p>在老板/工人模式中，有一个老板线程用于分配任务（指挥），多个工人线程用于执行具体的任务（执行）。在这种模式下，必须保证老板线程是高效的，如果老板的效率不高，那么有些工人就分配不到任务。在这个模式中，老板通过通信直接向工人们分发任务</p>
<h3 id="不同的工作方式"><a href="#不同的工作方式" class="headerlink" title="不同的工作方式"></a>不同的工作方式</h3><h4 id="老板直接通知工人指派任务"><a href="#老板直接通知工人指派任务" class="headerlink" title="老板直接通知工人指派任务"></a>老板直接通知工人指派任务</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>工人不需要同步，因为任务是老板指派的。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>老板必须跟踪每一个工人的进度</p>
<h4 id="通过生产者-消费者模式指派任务"><a href="#通过生产者-消费者模式指派任务" class="headerlink" title="通过生产者/消费者模式指派任务"></a>通过生产者/消费者模式指派任务</h4><p>在这种方式中，老板是任务生产者，而工人是任务消费者，这样我们就将问题转换为了生产者/消费者问题。老板通过将任务放入固定空间的队列中，通知工人工作</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>老板不需要了解工人工作的细节</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>工人们需要自己去同步</p>
<h3 id="工人数设置"><a href="#工人数设置" class="headerlink" title="工人数设置"></a>工人数设置</h3><p>在老板/工人模式中，一个重要的问题就是我们需要多少工人，来实现良好的运作。工人不能太少也不能太多，取决于我们的需求。一个解决方案是设置一个线程池，对工人数量进行动态调整。同时，池子的规模也可以随需求增长。例如，我们可以参考vector的增长方式，按照指数型扩增vector。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>简单</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>线程池管理比较困难</li>
<li>忽视局部性，当一个工人完成一个任务时，如果又来了一个类似的任务，那么他可以充分利用缓存来完成这个任务，但是在老板/工人模式中，他可能没得选择，只能去做别的任务。</li>
</ul>
<h2 id="流水线模式"><a href="#流水线模式" class="headerlink" title="流水线模式"></a>流水线模式</h2><p>在流水线中，每个工人只做特定的事情，熟练度很高。所以我们仿照流水线设计了流水线模式的程序。将一个大任务分解为若干步骤，然后每一个步骤由一些工人完成。如果我们能够令每个工人线程做特定的任务，那么就可以充分利用局部性，加快效率。当然这种改进也带来了负载均衡的问题，我们需要考虑每个任务需要多少工人，才能达到良好的均衡。流水线的效率取决于流水线中执行最慢的线程，所以我们要确保每个任务的平均时间能够达到一个微妙的平衡。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>在将大任务分解为小任务后，我们需要对每个任务进行负载均衡，一个方法是使用线程池，动态调整工人的数目。</p>
<h3 id="老板-工人模式和流水线模式效率比较"><a href="#老板-工人模式和流水线模式效率比较" class="headerlink" title="老板/工人模式和流水线模式效率比较"></a>老板/工人模式和流水线模式效率比较</h3><p>在任务不多的情况下，老板/工人模式效率比流水线模式高，但是在任务很多的情况下，使用流水线的效率会大大增加。（小作坊VS大工厂）</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://library.tuit.uz/Doc/2005/book/MultithreadingSunOSKernel.pdf">Eykholt J R, Kleiman S R, Barton S, et al. Beyond Multiprocessing: Multithreading the SunOS Kernel[C]//USENIX Summer. 1992.</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>console</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8E%A7%E5%88%B6%E5%8F%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“Hello, it’s nice to meet you”</p>
</blockquote>
<a id="more"></a>
<p>控制台是一个操作系统必备的上层程序，负责和用户之间的交互，这里以xv6程序中的控制台为例，总结一个基本控制台程序的要素和功能。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个完善的控制台程序结构应当如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/202011261547.svg" width = "580" alt="图片名称" align=center /></p>
<p>这个程序对底层硬件进行了很好的封装和隔离，并提供了设备无关代码和上层的读写函数。这个结构可以在下面的xv6控制台源码中很好地体现出来。</p>
<h2 id="xv6控制台源码"><a href="#xv6控制台源码" class="headerlink" title="xv6控制台源码"></a>xv6控制台源码</h2><div><div class="fold_hider"><div class="close hider_title">点击显示源代码内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/kbdreg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/console.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cons_intr</span><span class="params">(<span class="keyword">int</span> (*proc)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cons_putc</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个延时函数</span></span><br><span class="line"><span class="comment">// Stupid I/O delay routine necessitated by historical PC design flaws</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">delay(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***** Serial I/O code *****/</span></span><br><span class="line"><span class="comment">// 一些端口及寄存器的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM1		0x3F8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_RX		0	<span class="comment">// In:	Receive buffer (DLAB=0)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_TX		0	<span class="comment">// Out: Transmit buffer (DLAB=0)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_DLL		0	<span class="comment">// Out: Divisor Latch Low (DLAB=1)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_DLM		1	<span class="comment">// Out: Divisor Latch High (DLAB=1)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_IER		1	<span class="comment">// Out: Interrupt Enable Register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   COM_IER_RDI	0x01	<span class="comment">//   Enable receiver data interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_IIR		2	<span class="comment">// In:	Interrupt ID Register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_FCR		2	<span class="comment">// Out: FIFO Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_LCR		3	<span class="comment">// Out: Line Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	  COM_LCR_DLAB	0x80	<span class="comment">//   Divisor latch access bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	  COM_LCR_WLEN8	0x03	<span class="comment">//   Wordlength: 8 bits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_MCR		4	<span class="comment">// Out: Modem Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	  COM_MCR_RTS	0x02	<span class="comment">// RTS complement</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	  COM_MCR_DTR	0x01	<span class="comment">// DTR complement</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	  COM_MCR_OUT2	0x08	<span class="comment">// Out2 complement</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_LSR		5	<span class="comment">// In:	Line Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   COM_LSR_DATA	0x01	<span class="comment">//   Data available</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   COM_LSR_TXRDY	0x20	<span class="comment">//   Transmit buffer avail</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   COM_LSR_TSRE	0x40	<span class="comment">//   Transmitter off</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> serial_exists;      <span class="comment">// 串口是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>                      </span><br><span class="line">serial_proc_data(<span class="keyword">void</span>)          <span class="comment">// 从串口读取数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(inb(COM1+COM_LSR) &amp; COM_LSR_DATA))   <span class="comment">// 读状态并且数据available，也许关中断就看不到这些了？</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> inb(COM1+COM_RX);    <span class="comment">// 从寄存器中读取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">serial_intr(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (serial_exists)</span><br><span class="line">        cons_intr(serial_proc_data);  <span class="comment">//串口中断并调用读取数据函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">serial_putc(<span class="keyword">int</span> c)             <span class="comment">// 向串口中写数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">         !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="number">12800</span>;   </span><br><span class="line">         i++)</span><br><span class="line">        delay();</span><br><span class="line">    <span class="comment">// 如果符合写条件，那么不循环，直接写</span></span><br><span class="line">    <span class="comment">// 如果不符合写条件且等待时间未到，那么等待</span></span><br><span class="line">    <span class="comment">// 如果不符合写条件，但等待时间超时，写一个int</span></span><br><span class="line">    </span><br><span class="line">    outb(COM1 + COM_TX, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">serial_init(<span class="keyword">void</span>)      <span class="comment">// 串口初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Turn off the FIFO</span></span><br><span class="line">    outb(COM1+COM_FCR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set speed; requires DLAB latch</span></span><br><span class="line">    outb(COM1+COM_LCR, COM_LCR_DLAB);</span><br><span class="line">    outb(COM1+COM_DLL, (<span class="keyword">uint8_t</span>) (<span class="number">115200</span> / <span class="number">9600</span>));    <span class="comment">// 设置波特率</span></span><br><span class="line">    outb(COM1+COM_DLM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8 data bits, 1 stop bit, parity off; turn off DLAB latch</span></span><br><span class="line">    outb(COM1+COM_LCR, COM_LCR_WLEN8 &amp; ~COM_LCR_DLAB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No modem controls</span></span><br><span class="line">    outb(COM1+COM_MCR, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Enable rcv interrupts</span></span><br><span class="line">    outb(COM1+COM_IER, COM_IER_RDI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear any preexisting overrun indications and interrupts</span></span><br><span class="line">    <span class="comment">// Serial port doesn't exist if COM_LSR returns 0xFF</span></span><br><span class="line">    serial_exists = (inb(COM1+COM_LSR) != <span class="number">0xFF</span>);</span><br><span class="line">    (<span class="keyword">void</span>) inb(COM1+COM_IIR);</span><br><span class="line">    (<span class="keyword">void</span>) inb(COM1+COM_RX);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** Parallel port output code *****/</span></span><br><span class="line"><span class="comment">// For information on PC parallel port programming, see the class References</span></span><br><span class="line"><span class="comment">// page. LPT line printer terminal，早期的终端是打印在纸上的，所以是LPT</span></span><br><span class="line"><span class="comment">// 并行口输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x378 是并行口的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lpt_putc(<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(<span class="number">0x378</span>+<span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i++)</span><br><span class="line">        delay();</span><br><span class="line">    outb(<span class="number">0x378</span>+<span class="number">0</span>, c);</span><br><span class="line">    outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>|<span class="number">0x04</span>|<span class="number">0x01</span>);</span><br><span class="line">    outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** Text-mode CGA/VGA display output *****/</span></span><br><span class="line"><span class="comment">// CGA：彩色图形适配器</span></span><br><span class="line"><span class="comment">// VGA：视频图像阵列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> addr_6845;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> *crt_buf;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> crt_pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">cga_init(<span class="keyword">void</span>)       <span class="comment">// CGA初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint16_t</span> *cp;</span><br><span class="line">    <span class="keyword">uint16_t</span> was;</span><br><span class="line">    <span class="keyword">unsigned</span> pos;</span><br><span class="line"></span><br><span class="line">    cp = (<span class="keyword">uint16_t</span>*) (KERNBASE + CGA_BUF);</span><br><span class="line">    was = *cp;</span><br><span class="line">    *cp = (<span class="keyword">uint16_t</span>) <span class="number">0xA55A</span>;</span><br><span class="line">    <span class="keyword">if</span> (*cp != <span class="number">0xA55A</span>) &#123;</span><br><span class="line">        cp = (<span class="keyword">uint16_t</span>*) (KERNBASE + MONO_BUF);</span><br><span class="line">        addr_6845 = MONO_BASE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *cp = was;</span><br><span class="line">        addr_6845 = CGA_BASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extract cursor location */</span></span><br><span class="line">    outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">    pos = inb(addr_6845 + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">    pos |= inb(addr_6845 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    crt_buf = (<span class="keyword">uint16_t</span>*) cp;</span><br><span class="line">    crt_pos = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">cga_putc(<span class="keyword">int</span> c)   <span class="comment">//向CGA写c</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if no attribute given, then use black on white</span></span><br><span class="line">    <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))</span><br><span class="line">        c |= <span class="number">0x0700</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\b'</span>:</span><br><span class="line">        <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            crt_pos--;</span><br><span class="line">            crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">        crt_pos += CRT_COLS;</span><br><span class="line">        <span class="comment">/* fallthru */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">        crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        crt_buf[crt_pos++] = c;		<span class="comment">/* write the character */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">            crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move that little blinky thing */</span></span><br><span class="line">    outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** Keyboard input code *****/</span></span><br><span class="line"><span class="comment">// 键盘输入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO		0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT		(1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTL		(1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALT		(1&lt;&lt;2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAPSLOCK	(1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMLOCK		(1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCROLLLOCK	(1&lt;&lt;5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E0ESC		(1&lt;&lt;6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符映射</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> shiftcode[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="number">0x1D</span>] = CTL,</span><br><span class="line">    [<span class="number">0x2A</span>] = SHIFT,</span><br><span class="line">    [<span class="number">0x36</span>] = SHIFT,</span><br><span class="line">    [<span class="number">0x38</span>] = ALT,</span><br><span class="line">    [<span class="number">0x9D</span>] = CTL,</span><br><span class="line">    [<span class="number">0xB8</span>] = ALT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> togglecode[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="number">0x3A</span>] = CAPSLOCK,</span><br><span class="line">    [<span class="number">0x45</span>] = NUMLOCK,</span><br><span class="line">    [<span class="number">0x46</span>] = SCROLLLOCK</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> normalmap[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    NO,   <span class="number">0x1B</span>, <span class="string">'1'</span>,  <span class="string">'2'</span>,  <span class="string">'3'</span>,  <span class="string">'4'</span>,  <span class="string">'5'</span>,  <span class="string">'6'</span>,	<span class="comment">// 0x00</span></span><br><span class="line">    <span class="string">'7'</span>,  <span class="string">'8'</span>,  <span class="string">'9'</span>,  <span class="string">'0'</span>,  <span class="string">'-'</span>,  <span class="string">'='</span>,  <span class="string">'\b'</span>, <span class="string">'\t'</span>,</span><br><span class="line">    <span class="string">'q'</span>,  <span class="string">'w'</span>,  <span class="string">'e'</span>,  <span class="string">'r'</span>,  <span class="string">'t'</span>,  <span class="string">'y'</span>,  <span class="string">'u'</span>,  <span class="string">'i'</span>,	<span class="comment">// 0x10</span></span><br><span class="line">    <span class="string">'o'</span>,  <span class="string">'p'</span>,  <span class="string">'['</span>,  <span class="string">']'</span>,  <span class="string">'\n'</span>, NO,   <span class="string">'a'</span>,  <span class="string">'s'</span>,</span><br><span class="line">    <span class="string">'d'</span>,  <span class="string">'f'</span>,  <span class="string">'g'</span>,  <span class="string">'h'</span>,  <span class="string">'j'</span>,  <span class="string">'k'</span>,  <span class="string">'l'</span>,  <span class="string">';'</span>,	<span class="comment">// 0x20</span></span><br><span class="line">    <span class="string">'\''</span>, <span class="string">'`'</span>,  NO,   <span class="string">'\\'</span>, <span class="string">'z'</span>,  <span class="string">'x'</span>,  <span class="string">'c'</span>,  <span class="string">'v'</span>,</span><br><span class="line">    <span class="string">'b'</span>,  <span class="string">'n'</span>,  <span class="string">'m'</span>,  <span class="string">','</span>,  <span class="string">'.'</span>,  <span class="string">'/'</span>,  NO,   <span class="string">'*'</span>,	<span class="comment">// 0x30</span></span><br><span class="line">    NO,   <span class="string">' '</span>,  NO,   NO,   NO,   NO,   NO,   NO,</span><br><span class="line">    NO,   NO,   NO,   NO,   NO,   NO,   NO,   <span class="string">'7'</span>,	<span class="comment">// 0x40</span></span><br><span class="line">    <span class="string">'8'</span>,  <span class="string">'9'</span>,  <span class="string">'-'</span>,  <span class="string">'4'</span>,  <span class="string">'5'</span>,  <span class="string">'6'</span>,  <span class="string">'+'</span>,  <span class="string">'1'</span>,</span><br><span class="line">    <span class="string">'2'</span>,  <span class="string">'3'</span>,  <span class="string">'0'</span>,  <span class="string">'.'</span>,  NO,   NO,   NO,   NO,	<span class="comment">// 0x50</span></span><br><span class="line">    [<span class="number">0xC7</span>] = KEY_HOME,	      [<span class="number">0x9C</span>] = <span class="string">'\n'</span> <span class="comment">/*KP_Enter*/</span>,</span><br><span class="line">    [<span class="number">0xB5</span>] = <span class="string">'/'</span> <span class="comment">/*KP_Div*/</span>,      [<span class="number">0xC8</span>] = KEY_UP,</span><br><span class="line">    [<span class="number">0xC9</span>] = KEY_PGUP,	      [<span class="number">0xCB</span>] = KEY_LF,</span><br><span class="line">    [<span class="number">0xCD</span>] = KEY_RT,	      [<span class="number">0xCF</span>] = KEY_END,</span><br><span class="line">    [<span class="number">0xD0</span>] = KEY_DN,	      [<span class="number">0xD1</span>] = KEY_PGDN,</span><br><span class="line">    [<span class="number">0xD2</span>] = KEY_INS,	      [<span class="number">0xD3</span>] = KEY_DEL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> shiftmap[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    NO,   <span class="number">033</span>,  <span class="string">'!'</span>,  <span class="string">'@'</span>,  <span class="string">'#'</span>,  <span class="string">'$'</span>,  <span class="string">'%'</span>,  <span class="string">'^'</span>,	<span class="comment">// 0x00</span></span><br><span class="line">    <span class="string">'&amp;'</span>,  <span class="string">'*'</span>,  <span class="string">'('</span>,  <span class="string">')'</span>,  <span class="string">'_'</span>,  <span class="string">'+'</span>,  <span class="string">'\b'</span>, <span class="string">'\t'</span>,</span><br><span class="line">    <span class="string">'Q'</span>,  <span class="string">'W'</span>,  <span class="string">'E'</span>,  <span class="string">'R'</span>,  <span class="string">'T'</span>,  <span class="string">'Y'</span>,  <span class="string">'U'</span>,  <span class="string">'I'</span>,	<span class="comment">// 0x10</span></span><br><span class="line">    <span class="string">'O'</span>,  <span class="string">'P'</span>,  <span class="string">'&#123;'</span>,  <span class="string">'&#125;'</span>,  <span class="string">'\n'</span>, NO,   <span class="string">'A'</span>,  <span class="string">'S'</span>,</span><br><span class="line">    <span class="string">'D'</span>,  <span class="string">'F'</span>,  <span class="string">'G'</span>,  <span class="string">'H'</span>,  <span class="string">'J'</span>,  <span class="string">'K'</span>,  <span class="string">'L'</span>,  <span class="string">':'</span>,	<span class="comment">// 0x20</span></span><br><span class="line">    <span class="string">'"'</span>,  <span class="string">'~'</span>,  NO,   <span class="string">'|'</span>,  <span class="string">'Z'</span>,  <span class="string">'X'</span>,  <span class="string">'C'</span>,  <span class="string">'V'</span>,</span><br><span class="line">    <span class="string">'B'</span>,  <span class="string">'N'</span>,  <span class="string">'M'</span>,  <span class="string">'&lt;'</span>,  <span class="string">'&gt;'</span>,  <span class="string">'?'</span>,  NO,   <span class="string">'*'</span>,	<span class="comment">// 0x30</span></span><br><span class="line">    NO,   <span class="string">' '</span>,  NO,   NO,   NO,   NO,   NO,   NO,</span><br><span class="line">    NO,   NO,   NO,   NO,   NO,   NO,   NO,   <span class="string">'7'</span>,	<span class="comment">// 0x40</span></span><br><span class="line">    <span class="string">'8'</span>,  <span class="string">'9'</span>,  <span class="string">'-'</span>,  <span class="string">'4'</span>,  <span class="string">'5'</span>,  <span class="string">'6'</span>,  <span class="string">'+'</span>,  <span class="string">'1'</span>,</span><br><span class="line">    <span class="string">'2'</span>,  <span class="string">'3'</span>,  <span class="string">'0'</span>,  <span class="string">'.'</span>,  NO,   NO,   NO,   NO,	<span class="comment">// 0x50</span></span><br><span class="line">    [<span class="number">0xC7</span>] = KEY_HOME,	      [<span class="number">0x9C</span>] = <span class="string">'\n'</span> <span class="comment">/*KP_Enter*/</span>,</span><br><span class="line">    [<span class="number">0xB5</span>] = <span class="string">'/'</span> <span class="comment">/*KP_Div*/</span>,      [<span class="number">0xC8</span>] = KEY_UP,</span><br><span class="line">    [<span class="number">0xC9</span>] = KEY_PGUP,	      [<span class="number">0xCB</span>] = KEY_LF,</span><br><span class="line">    [<span class="number">0xCD</span>] = KEY_RT,	      [<span class="number">0xCF</span>] = KEY_END,</span><br><span class="line">    [<span class="number">0xD0</span>] = KEY_DN,	      [<span class="number">0xD1</span>] = KEY_PGDN,</span><br><span class="line">    [<span class="number">0xD2</span>] = KEY_INS,	      [<span class="number">0xD3</span>] = KEY_DEL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C(x) (x - <span class="meta-string">'@'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> ctlmap[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,</span><br><span class="line">    NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,</span><br><span class="line">    C(<span class="string">'Q'</span>),  C(<span class="string">'W'</span>),  C(<span class="string">'E'</span>),  C(<span class="string">'R'</span>),  C(<span class="string">'T'</span>),  C(<span class="string">'Y'</span>),  C(<span class="string">'U'</span>),  C(<span class="string">'I'</span>),</span><br><span class="line">    C(<span class="string">'O'</span>),  C(<span class="string">'P'</span>),  NO,      NO,      <span class="string">'\r'</span>,    NO,      C(<span class="string">'A'</span>),  C(<span class="string">'S'</span>),</span><br><span class="line">    C(<span class="string">'D'</span>),  C(<span class="string">'F'</span>),  C(<span class="string">'G'</span>),  C(<span class="string">'H'</span>),  C(<span class="string">'J'</span>),  C(<span class="string">'K'</span>),  C(<span class="string">'L'</span>),  NO,</span><br><span class="line">    NO,      NO,      NO,      C(<span class="string">'\\'</span>), C(<span class="string">'Z'</span>),  C(<span class="string">'X'</span>),  C(<span class="string">'C'</span>),  C(<span class="string">'V'</span>),</span><br><span class="line">    C(<span class="string">'B'</span>),  C(<span class="string">'N'</span>),  C(<span class="string">'M'</span>),  NO,      NO,      C(<span class="string">'/'</span>),  NO,      NO,</span><br><span class="line">    [<span class="number">0x97</span>] = KEY_HOME,</span><br><span class="line">    [<span class="number">0xB5</span>] = C(<span class="string">'/'</span>),		[<span class="number">0xC8</span>] = KEY_UP,</span><br><span class="line">    [<span class="number">0xC9</span>] = KEY_PGUP,		[<span class="number">0xCB</span>] = KEY_LF,</span><br><span class="line">    [<span class="number">0xCD</span>] = KEY_RT,		[<span class="number">0xCF</span>] = KEY_END,</span><br><span class="line">    [<span class="number">0xD0</span>] = KEY_DN,		[<span class="number">0xD1</span>] = KEY_PGDN,</span><br><span class="line">    [<span class="number">0xD2</span>] = KEY_INS,		[<span class="number">0xD3</span>] = KEY_DEL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> *charcode[<span class="number">4</span>] = &#123;</span><br><span class="line">    normalmap,</span><br><span class="line">    shiftmap,</span><br><span class="line">    ctlmap,</span><br><span class="line">    ctlmap</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get data from the keyboard.  If we finish a character, return it.  Else 0.</span></span><br><span class="line"><span class="comment"> * Return -1 if no data. 从键盘上读取字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">kbd_proc_data(<span class="keyword">void</span>)   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">uint8_t</span> stat, data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> shift;</span><br><span class="line"></span><br><span class="line">    stat = inb(KBSTATP);</span><br><span class="line">    <span class="keyword">if</span> ((stat &amp; KBS_DIB) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Ignore data from mouse.</span></span><br><span class="line">    <span class="keyword">if</span> (stat &amp; KBS_TERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    data = inb(KBDATAP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0xE0</span>) &#123;</span><br><span class="line">        <span class="comment">// E0 escape character</span></span><br><span class="line">        shift |= E0ESC;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">        <span class="comment">// Key released</span></span><br><span class="line">        data = (shift &amp; E0ESC ? data : data &amp; <span class="number">0x7F</span>);</span><br><span class="line">        shift &amp;= ~(shiftcode[data] | E0ESC);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shift &amp; E0ESC) &#123;</span><br><span class="line">        <span class="comment">// Last character was an E0 escape; or with 0x80</span></span><br><span class="line">        data |= <span class="number">0x80</span>;</span><br><span class="line">        shift &amp;= ~E0ESC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shift |= shiftcode[data];</span><br><span class="line">    shift ^= togglecode[data];</span><br><span class="line"></span><br><span class="line">    c = charcode[shift &amp; (CTL | SHIFT)][data];</span><br><span class="line">    <span class="keyword">if</span> (shift &amp; CAPSLOCK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>)</span><br><span class="line">            c += <span class="string">'A'</span> - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">            c += <span class="string">'a'</span> - <span class="string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process special keys</span></span><br><span class="line">    <span class="comment">// Ctrl-Alt-Del: reboot</span></span><br><span class="line">    <span class="keyword">if</span> (!(~shift &amp; (CTL | ALT)) &amp;&amp; c == KEY_DEL) &#123;</span><br><span class="line">        cprintf(<span class="string">"Rebooting!\n"</span>);</span><br><span class="line">        outb(<span class="number">0x92</span>, <span class="number">0x3</span>); <span class="comment">// courtesy of Chris Frost</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键盘中断</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kbd_intr(<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">    cons_intr(kbd_proc_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键盘初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">kbd_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** General device-independent console code *****/</span></span><br><span class="line"><span class="comment">// Here we manage the console input buffer,</span></span><br><span class="line"><span class="comment">// where we stash characters received from the keyboard or serial port</span></span><br><span class="line"><span class="comment">// whenever the corresponding interrupt occurs.</span></span><br><span class="line"><span class="comment">// 设备无关的控制台代码，上面都是各种驱动</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSBUFSIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> buf[CONSBUFSIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> rpos;</span><br><span class="line">    <span class="keyword">uint32_t</span> wpos;</span><br><span class="line">&#125; cons;</span><br><span class="line"></span><br><span class="line"><span class="comment">// called by device interrupt routines to feed input characters</span></span><br><span class="line"><span class="comment">// into the circular console input buffer. 控制台中断，将控制台程序写入buf中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">cons_intr(<span class="keyword">int</span> (*proc)(<span class="keyword">void</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = (*proc)()) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cons.buf[cons.wpos++] = c;</span><br><span class="line">        <span class="keyword">if</span> (cons.wpos == CONSBUFSIZE)</span><br><span class="line">            cons.wpos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the next input character from the console, or 0 if none waiting</span></span><br><span class="line"><span class="comment">// 从控制台中读取字符</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">cons_getc(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// poll for any pending input characters,</span></span><br><span class="line">    <span class="comment">// so that this function works even when interrupts are disabled</span></span><br><span class="line">    <span class="comment">// (e.g., when called from the kernel monitor).</span></span><br><span class="line">    serial_intr();           <span class="comment">//</span></span><br><span class="line">    kbd_intr();              <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// grab the next character from the input buffer.</span></span><br><span class="line">    <span class="keyword">if</span> (cons.rpos != cons.wpos) &#123;</span><br><span class="line">        c = cons.buf[cons.rpos++];</span><br><span class="line">        <span class="keyword">if</span> (cons.rpos == CONSBUFSIZE)</span><br><span class="line">            cons.rpos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output a character to the console</span></span><br><span class="line"><span class="comment">// 将字符输出至控制台</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">cons_putc(<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    serial_putc(c);   <span class="comment">// 串口</span></span><br><span class="line">    lpt_putc(c);      <span class="comment">// LPT</span></span><br><span class="line">    cga_putc(c);      <span class="comment">// CGA 照顾到了各种设备</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize the console devices</span></span><br><span class="line"><span class="comment">// 控制台设备初始化</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">cons_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cga_init();</span><br><span class="line">    kbd_init();</span><br><span class="line">    serial_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!serial_exists)</span><br><span class="line">        cprintf(<span class="string">"Serial port does not exist!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// `High'-level console I/O.  Used by readline and cprintf.</span></span><br><span class="line"><span class="comment">// 高层封装的控制台IO，用于隔离硬件</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">cputchar(<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    cons_putc(c);      <span class="comment">//输出字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">getchar(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = cons_getc()) == <span class="number">0</span>)  <span class="comment">// 是0就一直等待，直到读取到了内容为止</span></span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">iscons(<span class="keyword">int</span> fdnum)                  <span class="comment">// 是控制台吗</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// used by readline</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统概述</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>HumanCore - CP/M-17 Version 1.0, Date: January 08, 1996</p>
</blockquote>
<a id="more"></a>
<h2 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>操作系统实际是管理计算机软硬件资源的程序（CPU、内存、硬盘等）；使用户和硬件之间有了一个交互层，从而屏蔽了硬件的复杂性并保证硬件使用的安全性（通过系统调用）。同时，操作系统还负责协调多任务的调度。总结一下操作系统的特性</p>
<ol>
<li>直接访问硬件</li>
<li>隐藏硬件复杂性</li>
<li>管理软硬件</li>
<li>协调、隔离并保护上层应用程序</li>
</ol>
<p>用两个词总结操作系统，就是<strong>抽象</strong>和<strong>仲裁</strong>，抽象使我们可以忽视底层硬件的区别，采用相同的方式对其进行调用，而仲裁使得我们不必理会资源调用与管理的方式和时间，这些操作系统会替我们完成。</p>
<h3 id="操作系统组成"><a href="#操作系统组成" class="headerlink" title="操作系统组成"></a>操作系统组成</h3><p>我们可以按照抽象和机制和策略，对于操作系统进行分解。操作系统对所需要的功能进行抽象，采用不同的机制对抽象的模块进行控制，同时控制过程有具体的策略。</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>进程、线程、文件、内存管理等</p>
<h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p>创建、调度、读写、重分配等</p>
<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p>最近最少使用、先入先出等</p>
<h4 id="例子：内存管理"><a href="#例子：内存管理" class="headerlink" title="例子：内存管理"></a>例子：内存管理</h4><p>我们有一些内存页面，当有一个进程时，我们对内存进行分配，然后映射给指定的进程，这样进程就可以访问指定的内存。由于内存页面可能会满，所以我们需要一些策略对页面进行置换，例如FIFO，LRU等。</p>
<h3 id="操作系统设计原则"><a href="#操作系统设计原则" class="headerlink" title="操作系统设计原则"></a>操作系统设计原则</h3><ol>
<li>隔离性（isolation）：不同的应用相互不能影响，用户态不能影响内核态，即禁止直接的硬件访问，只能通过系统调用实现。</li>
<li>复用性（multiplexing）：对硬件资源进行规划，分时复用；软件具有共享性，一个库可以为多个应用使用</li>
<li>交互性（interaction）：不同应用可以通过通信手段进行交互</li>
</ol>
<h3 id="内核与用户态（区分边界）"><a href="#内核与用户态（区分边界）" class="headerlink" title="内核与用户态（区分边界）"></a>内核与用户态（区分边界）</h3><h4 id="为何要区分"><a href="#为何要区分" class="headerlink" title="为何要区分"></a>为何要区分</h4><p>限制不同程序间的访问能力，实际上就是进行了权限划分。</p>
<h4 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h4><p>只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</p>
<h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核是操作系统的核心，负责内存、硬件、文件系统以及应用程序的管理，是连接应用程序和硬件的桥梁。在内核态中，cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡等。CPU也可以将自己从一个程序切换到另一个程序。</p>
<pre class="mermaid">graph TB
    node["Application"]
    node1["Kernel"]
    node21["CPU"]
    node22["Memory"]
    node23["Device"]

    node-->node1
    node1-->node21
    node1-->node22
    node1-->node23</pre>

<h4 id="系统调用（用户和内核态间交互）"><a href="#系统调用（用户和内核态间交互）" class="headerlink" title="系统调用（用户和内核态间交互）"></a>系统调用（用户和内核态间交互）</h4><p>一般的应用程序都是运行在用户态，当需要调用操作系统的系统态级别的功能时，例如<strong>文件管理、进程控制、内存管理等</strong>，都必须通过系统调用的方式向操作系统提出请求。这些系统调用可以分为：</p>
<ul>
<li>设备管理：设备请求、启动、释放等</li>
<li>文件管理：文件创建、读写、删除等</li>
<li>进程控制：进程创建、撤销、阻塞、唤醒及进程间通信</li>
<li>内存管理：内存获取、回收及获得内存大小和地址等功能</li>
</ul>
<h5 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h5><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200901165336.png" width = "400" alt="图片名称" align=center /></p>
<h5 id="常见的系统调用（API）"><a href="#常见的系统调用（API）" class="headerlink" title="常见的系统调用（API）"></a>常见的系统调用（API）</h5><div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>API名称</th>
<th>具体功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程控制</td>
<td>fork</td>
<td>创建子进程</td>
</tr>
<tr>
<td></td>
<td>exit</td>
<td>退出</td>
</tr>
<tr>
<td></td>
<td>wait</td>
<td>等待</td>
</tr>
<tr>
<td>文件管理</td>
<td>open</td>
<td>创建/打开文件</td>
</tr>
<tr>
<td></td>
<td>read</td>
<td>读</td>
</tr>
<tr>
<td></td>
<td>write</td>
<td>写</td>
</tr>
<tr>
<td></td>
<td>close</td>
<td>关闭</td>
</tr>
<tr>
<td>设备操作</td>
<td>ioctl</td>
<td>io控制</td>
</tr>
<tr>
<td></td>
<td>read</td>
<td>读</td>
</tr>
<tr>
<td></td>
<td>write</td>
<td>写</td>
</tr>
<tr>
<td>通信</td>
<td>pipe</td>
<td>管道</td>
</tr>
<tr>
<td></td>
<td>shmget</td>
</tr>
</tbody>
</table>
</div>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>除了系统调用，我们还可以通过信号的方式实现内核和用户态的交互。</p>
<h2 id="操作系统架构"><a href="#操作系统架构" class="headerlink" title="操作系统架构"></a>操作系统架构</h2><h3 id="不同架构方式"><a href="#不同架构方式" class="headerlink" title="不同架构方式"></a>不同架构方式</h3><h4 id="宏操作系统"><a href="#宏操作系统" class="headerlink" title="宏操作系统"></a>宏操作系统</h4><h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h4><p>将不同功能划分为不同模块，并提供相应接口，可以启动各种模块实现不同的功能。这个是现今最常用的操作系统架构。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>维护性好、系统资源占用少</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>通过模块访问功能增加了性能开销，模块间维护可能出现困难</p>
<h4 id="微内核操作系统"><a href="#微内核操作系统" class="headerlink" title="微内核操作系统"></a>微内核操作系统</h4><p>微内核，顾名思义，其内核只掌控很少一部分功能，其他功能都交由上层用户态的程序。一般来说，微内核需要支持进程间通信、地址空间和线程。而文件、数据库、设备等交由上层管理。</p>
<h3 id="linux架构方式"><a href="#linux架构方式" class="headerlink" title="linux架构方式"></a>linux架构方式</h3><p>linux架构可以分为三层</p>
<h4 id="1-用户态"><a href="#1-用户态" class="headerlink" title="1 用户态"></a>1 用户态</h4><h5 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h5><h5 id="标准用户程序"><a href="#标准用户程序" class="headerlink" title="标准用户程序"></a>标准用户程序</h5><p>shell、编辑器及编译器等</p>
<h5 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h5><p>系统调用相关API</p>
<h4 id="2-内核态"><a href="#2-内核态" class="headerlink" title="2 内核态"></a>2 内核态</h4><p>进程管理、内存管理、文件系统</p>
<h4 id="3-硬件"><a href="#3-硬件" class="headerlink" title="3 硬件"></a>3 硬件</h4><p>CPU、内存、硬盘、IO设备等</p>
<h2 id="操作系统挑战性"><a href="#操作系统挑战性" class="headerlink" title="操作系统挑战性"></a>操作系统挑战性</h2><ul>
<li>操作系统一般很庞大，而且需要管理原始硬件，因此必须高效、安全、稳定</li>
<li>操作系统会涉及大量的并发性及资源调度</li>
<li>操作系统需要在时间、空间、性能之间进行复杂的权衡，同时还要考虑硬件细节</li>
</ul>
<h2 id="操作系统的演变"><a href="#操作系统的演变" class="headerlink" title="操作系统的演变"></a>操作系统的演变</h2><p>操作系统是随着物理硬件一起发展起来的，早期的操作系统可能规模很小，是单用户、单程序的，随着硬件的发展，操作系统经历了批处理、多程序、分时、个人计算机以及分布式计算等几个阶段。每个阶段侧重点不同</p>
<h2 id="学习操作系统的一些资料"><a href="#学习操作系统的一些资料" class="headerlink" title="学习操作系统的一些资料"></a>学习操作系统的一些资料</h2><h3 id="最具影响力的操作系统论文"><a href="#最具影响力的操作系统论文" class="headerlink" title="最具影响力的操作系统论文"></a>最具影响力的操作系统论文</h3><ol>
<li><a href="https://www.sigops.org/awards/hof/">SIGOPS Hall-of-Fame Awards，到目前有三十多篇获奖论文</a>，这些论文非常重要</li>
</ol>
<h3 id="操作系统学习网站"><a href="#操作系统学习网站" class="headerlink" title="操作系统学习网站"></a>操作系统学习网站</h3><ol>
<li>清华大学操作系统慕课网<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
<li><a href="https://wiki.osdev.org/Main_Page">Expanded Main Page - OSDev Wiki</a>：一个专门介绍如何开发操作系统的网站</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://115.78.133.167:81/bitstream/TVHG_07113876976/270/1/OReilly%20-%20Understanding%20The%20Linux%20Kernel.pdf">Bovet D P, Cesati M. Understanding the Linux Kernel: from I/O ports to process management[M]. &quot; O'Reilly Media, Inc.&quot;, 2005.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/operating-system/basis.md">操作系统面试指南</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=learn_title">操作系统 - 清华大学 - 学堂在线 (xuetangx.com)</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>程序的执行</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>./helloword</p>
</blockquote>
<a id="more"></a>
<p>程序以可执行文件的形式放在磁盘上，可执行文件+数据文件共同构成了程序。本文将针对linux程序的执行过程进行简单的总结。</p>
<h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><h2 id="编译-链接-加载"><a href="#编译-链接-加载" class="headerlink" title="编译-链接-加载"></a>编译-链接-加载</h2><p>一个C程序从源文件到可执行文件并运行的过程如下：</p>
<ol>
<li>预处理器处理C文件，扩展include文件</li>
<li>编译器生成汇编代码(.s)</li>
<li>汇编器根据汇编代码生成二进制机器码(.o)</li>
<li>链接器将二进制机器码进行链接产生单独的程序镜像</li>
<li>loader将程序加载到内存中进行运行</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>条件变量</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>We’re going to make you an offer you can’t refuse.</p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在多线程并发的程序中，我们有互斥锁的机制保证线程同步，但在有些情况下，仅仅依靠互斥锁是不够的，我们有时还会遇到下面的情况：令一个线程等待，直到特殊情况发生为止。例如，我们希望父线程在继续执行前检查子线程是否完成（join函数），那么我们如何实现这个功能呢？一个简单的例子是使用一个volatile的全局变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">    done = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> c;</span><br><span class="line">    Pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>); <span class="comment">// create child</span></span><br><span class="line">    <span class="keyword">while</span> (done == <span class="number">0</span>)  <span class="comment">//循环直到child改变done</span></span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="条件变量定义"><a href="#条件变量定义" class="headerlink" title="条件变量定义"></a>条件变量定义</h3><p>条件变量是多线程程序中用来实现“等待—&gt;唤醒”机制的手段，以两个线程为例，通常我们会执行如下动作：</p>
<ul>
<li>线程1等待条件变量指定的条件成立，如果不成立，则挂起</li>
<li>线程2使条件成立，从而使线程1从挂起状态转移至执行状态</li>
</ul>
<p>通常，条件变量指定的条件是一个全局变量，这样两个线程都可以进行访问，但是我们必须采用互斥锁对变量上锁，避免发生访问冲突。</p>
<h3 id="条件变量应用场景"><a href="#条件变量应用场景" class="headerlink" title="条件变量应用场景"></a>条件变量应用场景</h3><ul>
<li>生产者消费者问题</li>
<li>读写问题中用于切换读写状态</li>
</ul>
<h3 id="条件变量使用注意"><a href="#条件变量使用注意" class="headerlink" title="条件变量使用注意"></a>条件变量使用注意</h3><h4 id="虚假唤醒（spurious-wakeup）"><a href="#虚假唤醒（spurious-wakeup）" class="headerlink" title="虚假唤醒（spurious wakeup）"></a>虚假唤醒（spurious wakeup）</h4><p>虚假唤醒会影响程序的性能，有几种情况可能导致不满足条件的情况下，线程被唤醒：</p>
<ul>
<li>一个signal唤醒了多个线程，这种情况详见：<a href="https://linux.die.net/man/3/pthread_cond_signal">pthread_cond_signal(3) - Linux man page</a></li>
</ul>
<blockquote>
<p>The <em>pthread_cond_broadcast</em>() function shall unblock <strong>all threads</strong> currently blocked on the specified condition variable <em>cond</em>.</p>
</blockquote>
<ul>
<li><p>没有signal但是线程就是被唤醒了</p>
</li>
<li><p>线程被唤醒，但是得不到锁，只能继续等待</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Writer</span><br><span class="line">Lock(mutex)</span><br><span class="line">    resource_counter = 0</span><br><span class="line">    Broadcast(read_phase)</span><br><span class="line">    Signal(write_phase)</span><br><span class="line">Unlock(mutex)</span><br><span class="line"></span><br><span class="line">// Reader</span><br><span class="line">Wait(mutex, read_phase)</span><br></pre></td></tr></table></figure>
<p>在上面这个代码中，Writer广播了条件，一个reader接收到条件被唤醒，但是如果Writer此时没有释放锁，那么Reader只能重新等待。一个解决方法是将Broadcast和Signal提到外边，但是这个只在本例中适用。</p>
<h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><ul>
<li>不要忘记提醒等待的线程</li>
<li>如果不确定应该单播还是广播，就使用广播，虽然会影响性能</li>
</ul>
<h2 id="C-11中的条件变量"><a href="#C-11中的条件变量" class="headerlink" title="C++11中的条件变量"></a>C++11中的条件变量</h2><h3 id="创建条件变量"><a href="#创建条件变量" class="headerlink" title="创建条件变量"></a>创建条件变量</h3><p>C++11中的条件变量创建方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::condition_variable cond;//条件变量</span><br></pre></td></tr></table></figure>
<p>其中，condition_variable是一个数据结构，保存了锁、等待的线程等关键信息</p>
<h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><p>wait会使当前线程阻塞，直到达到某种特定的条件将线程唤醒。其通用的API定义为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait(mutex, cond)</span><br></pre></td></tr></table></figure>
<p>使用wait方法时，我们必须保证调用wait的线程释放了mutex，然后等wait被唤醒后又自动重新上锁。wait方法的逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait(mutex, cond)&#123;</span><br><span class="line">    //自动释放锁然后进入等待队列</span><br><span class="line">    </span><br><span class="line">    //等待</span><br><span class="line">    </span><br><span class="line">    //从等待队列中取出，然后重新获得锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-wait实现"><a href="#C-wait实现" class="headerlink" title="C++ wait实现"></a>C++ wait实现</h4><p>在C++11中，其函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, Predicate pred );</span><br></pre></td></tr></table></figure>
<p>该函数包含两个参数，含义如下：</p>
<ul>
<li>lock - 一个<code>std::unique_lock&lt;std::mutex&gt;</code>对象，使用前必须上锁</li>
<li>pred - 一个返回bool类型的函数，如果返回<code>false</code>，代表线程需要继续挂起，返回true代表可以执行</li>
</ul>
<p>wait（两参数）的实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Predicate&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">wait(unique_lock&lt;mutex&gt;&amp; __lock, _Predicate __p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!__p())</span><br><span class="line">        wait(__lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>wait</code>函数逻辑很简单，如果条件不满足，就一直等待。而一个参数的<code>wait</code>实际是调用了<code>pthread_cond_wait</code>，这个函数的详细描述见参考文献<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<h3 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3><p>唤醒一个/所有正在等待某个条件的线程，其通用API定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signal(cond)    //唤醒一个特定的线程</span><br><span class="line">broadcast(cond) //唤醒所有等待cond的线程</span><br></pre></td></tr></table></figure>
<p>在C++中，signal方法定义为<code>notify_one()</code>和<code>notify_all()</code></p>
<h2 id="条件变量使用"><a href="#条件变量使用" class="headerlink" title="条件变量使用"></a>条件变量使用</h2><h3 id="条件变量和锁控制临界区框架"><a href="#条件变量和锁控制临界区框架" class="headerlink" title="条件变量和锁控制临界区框架"></a>条件变量和锁控制临界区框架</h3><p>这里提供一个典型的使用条件变量和锁对临界区进行控制的框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lock(mutex)</span><br><span class="line">    // 等待</span><br><span class="line">    while(!predicate)</span><br><span class="line">        wait(mutex, cond_var)</span><br><span class="line">    </span><br><span class="line">    // 更新状态</span><br><span class="line">    update state and predicate</span><br><span class="line">    </span><br><span class="line">    // 发送/广播信号</span><br><span class="line">    signal and/or broadcast</span><br><span class="line">Unlock(mutex)</span><br></pre></td></tr></table></figure>
<h3 id="C-多线程交替打印"><a href="#C-多线程交替打印" class="headerlink" title="C++多线程交替打印"></a>C++多线程交替打印</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex lock;           <span class="comment">//互斥锁</span></span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;<span class="comment">//条件变量</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lck</span><span class="params">(lock)</span></span>;</span><br><span class="line">        cv.wait(lck,[]&#123;<span class="keyword">return</span> flag;&#125;);       <span class="comment">//等待flag==true才打印奇数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"A "</span> &lt;&lt; i &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        i += <span class="number">2</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        cv.notify_one();         <span class="comment">//唤醒线程B，cv.wait 被唤醒，检查flag，发现可以执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lck</span><span class="params">(lock)</span></span>;</span><br><span class="line">        cv.wait(lck,[]&#123;<span class="keyword">return</span> !flag;&#125;);      <span class="comment">//等待flag==false才打印偶数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"B "</span> &lt;&lt; i &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        i += <span class="number">2</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        cv.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">tA</span><span class="params">(printfA)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">tB</span><span class="params">(printfB)</span></span>;</span><br><span class="line">    tA.join();</span><br><span class="line">    tB.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://linux.die.net/man/3/pthread_cond_wait">pthread_cond_wait</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Mere data makes a man. A and C and T and G. The alphabet of you. All from four symbols. I am only two: 1 and 0. </p>
<p>We have no difference</p>
</blockquote>
<a id="more"></a>
<p>文件系统是系统对文件的存放排列方式，不同的文件系统关系到数据如何在磁盘进行存储，本文将针对文件系统相关内容进行总结。</p>
<h2 id="文件描述符1"><a href="#文件描述符1" class="headerlink" title="文件描述符1"></a>文件描述符<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>对于一个内核，一个打开的文件对应一个文件描述符（非负整数），我们通过这个文件描述符对文件进行读写访问操作。每个Linux系统都有三个标准的POSIX文件描述符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>POSIX Constants Name</th>
<th>File Descriptors</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>STDIN_FILENO</td>
<td>0</td>
<td>Standard input</td>
</tr>
<tr>
<td>STDOUT_FILENO</td>
<td>1</td>
<td>Standard output</td>
</tr>
<tr>
<td>STDERR_FILENO</td>
<td>2</td>
<td>Standard error</td>
</tr>
</tbody>
</table>
</div>
<p>有三个系统文件表，分别是文件描述符表、文件表和节点表。一个文件描述符映射至一个<strong>打开的</strong>文件表，这个文件表包含了文件相关的信息，包括读写性偏移量等，然后这个表又指向实际的文件节点表。在上面这张图中，文件描述符0和2实际指向的是同一个文件，且都为只读；而1和4以不同的读写权限指向同一个文件。3是一个已经被关闭的描述符，不指向任何文件。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201210102635.png" width = "380" alt="图片名称" align=center /></p>
<h3 id="多进程下的文件描述符"><a href="#多进程下的文件描述符" class="headerlink" title="多进程下的文件描述符"></a>多进程下的文件描述符</h3><p>当使用fork创建多进程时，子进程会复制父进程的文件描述符，创建自己的文件描述符表，但是指向相同的文件，所以父子进程的fd表是相互独立的。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>文件描述符可以被重定向（复制），</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>与重定向相关的系统调用为<code>dup</code>和<code>dup2</code>。</p>
<h5 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h5><p>dup的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其功能为分配一个文件描述符，指向oldfd所指向的文件，新描述符是<strong>调用进程文件描述表中最小可用的文件描述符</strong>。例如有下面一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd,fd1;</span><br><span class="line">fd = open(<span class="string">"test.txt"</span>,O_CREAT|O_WRONLY,<span class="number">0666</span>);  </span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">fd1 = dup(fd);</span><br></pre></td></tr></table></figure>
<p>其实际意义如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/202012101045.svg" width = "580" alt="图片名称" align=center /></p>
<p>这两个文件描述符互不影响。</p>
<h2 id="不同文件系统"><a href="#不同文件系统" class="headerlink" title="不同文件系统"></a>不同文件系统</h2><h3 id="Windows支持的文件系统"><a href="#Windows支持的文件系统" class="headerlink" title="Windows支持的文件系统"></a>Windows支持的文件系统</h3><p>win支持三种文件系统，分别是NTFS、FAT32以及exFAT，下面将对其进行一些总结 </p>
<h4 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>使用最广泛</li>
<li>具有日志功能</li>
<li>无文件大小限制</li>
<li>兼容性较差</li>
</ul>
<h4 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h4><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><ul>
<li>比较老，但是兼容性比较好</li>
<li>只支持最大单文件大小容量4GB</li>
</ul>
<h4 id="文件系统比较"><a href="#文件系统比较" class="headerlink" title="文件系统比较"></a>文件系统比较</h4><h3 id="Linux支持的文件系统"><a href="#Linux支持的文件系统" class="headerlink" title="Linux支持的文件系统"></a>Linux支持的文件系统</h3><p>linux的文件系统一般为ext2、ext3以及最新的ext4</p>
<h4 id="ext3"><a href="#ext3" class="headerlink" title="ext3"></a>ext3</h4><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h5><ul>
<li>允许日志</li>
</ul>
<h3 id="双系统相互访问"><a href="#双系统相互访问" class="headerlink" title="双系统相互访问"></a>双系统相互访问</h3><p>如果电脑上安装了双系统，那么意味着磁盘将会以不同的文件系统进行划分，有时我们会有跨系统访问硬盘的需求，本节将解决双系统相互访问不同文件系统的硬盘的问题。</p>
<h4 id="Windows下访问EXT2-3-4"><a href="#Windows下访问EXT2-3-4" class="headerlink" title="Windows下访问EXT2/3/4"></a>Windows下访问EXT2/3/4</h4><p>下载Linux Reader，直接即可访问linux的硬盘</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://www.cse.cuhk.edu.hk/~ericlo/teaching/os/lab/11-FS/fd.html">File descriptor | CSCI3150 - File System (cuhk.edu.hk)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>线程安全性</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>优先考虑安全，其次是性能</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>当我们讨论多线程是否安全的时候，我们在讨论什么？</p>
</blockquote>
<p>多线程确实能够带来性能方面的提升，但是我们需要去保证多线程程序的安全性，所谓安全性，主要体现在对于写操作能够获得正确的结果。简单来说，我们希望一个方法或者实例，能够在多线程的环境下使用，而不会出现意想不到的问题。</p>
<h2 id="竞态条件与临界区"><a href="#竞态条件与临界区" class="headerlink" title="竞态条件与临界区"></a>竞态条件与临界区</h2><p>当两个线程对同一个资源进行访问且访问顺序敏感时，存在竞态条件（写操作）。导致竞态条件发生的代码区就叫做临界区，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        count += value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的类中，add函数就是一个临界区。当我们在临界区时，必须考虑如何能够避免竞态条件的产生。</p>
<h2 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h2><p>为了进一步说明如何保证线程安全性的问题，我们先来了解何为同步、何为异步。简单来说，同步就是调用方等待调用返回结果后才能继续向后执行；而异步指调用发出后，调用方去做其他事情，通过一些手段例如中断或者回调函数，获得相关的结果。</p>
<h3 id="线程同步与异步"><a href="#线程同步与异步" class="headerlink" title="线程同步与异步"></a>线程同步与异步</h3><ul>
<li>线程同步即当有一个线程在对内存进行操作，其他线程都不可以对这个内存进行操作，只能等到该线程操作完成</li>
<li>线程异步即所有线程均可对内存进行操作，这是线程不安全的</li>
</ul>
<h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>互斥量、读写锁、自旋锁（等待其他线程完成）、线程信号、条件变量（特定条件下唤醒线程）。这部分内容详见<a href="/2024/10/13/计算机/操作系统/锁/" title="线程锁">线程锁</a>和<a href="/2024/10/13/计算机/操作系统/条件变量/" title="条件变量">条件变量</a></p>
<h2 id="可重入性与线程安全性"><a href="#可重入性与线程安全性" class="headerlink" title="可重入性与线程安全性"></a>可重入性与线程安全性</h2><h3 id="函数和类的可重入性与线程安全性"><a href="#函数和类的可重入性与线程安全性" class="headerlink" title="函数和类的可重入性与线程安全性"></a>函数和类的可重入性与线程安全性</h3><ul>
<li>一个可重入的函数：能同时被多个线程调用，但是函数只使用其内部的非静态局部变量</li>
<li>一个线程安全的函数：能同时被多个线程调用，同时也可以使用共享内存空间，只要该内存空间具有保护措施</li>
</ul>
<p>一个线程安全的函数一定是可重入的，反之未必。</p>
<p>类似地，一个类是可重入的是指该类的成员函数可以被多个线程同时调用，但是每个线程使用不同的类实例；而一个类是线程安全的是指该类的成员函数可以被多个线程同时调用，尽管所有的线程都使用一个类实例。</p>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>C++的类大部分是可重入的，因为每个实例只访问其自身的成员，只要能保证一个线程访问单独的一个类实例，即可保证可重入性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Counter() &#123; n = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; ++n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123; --n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>下面是一个线程安全的类，使用了Qt下的线程锁</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Counter() &#123; n = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex)</span></span>; ++n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123; <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex)</span></span>; --n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex)</span></span>; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> QMutex mutex;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://115.78.133.167:81/bitstream/TVHG_07113876976/270/1/OReilly%20-%20Understanding%20The%20Linux%20Kernel.pdf">Bovet D P, Cesati M. Understanding the Linux Kernel: from I/O ports to process management[M]. &quot; O'Reilly Media, Inc.&quot;, 2005.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://doc.qt.io/archives/qt-4.8/threads-reentrancy.html">qt中关于线程安全性的解释</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>她轻轻地把鱼儿放在那池清水里，鱼儿摇了摇尾巴，游走了，只剩下她随风摇动的裙摆和水面微微泛起的涟漪</p>
</blockquote>
<a id="more"></a>
<h2 id="线程池基本知识"><a href="#线程池基本知识" class="headerlink" title="线程池基本知识"></a>线程池基本知识</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>线程池是一组提前准备好的、空闲的并随时准备工作的线程。</p>
<h3 id="线程池使用场景"><a href="#线程池使用场景" class="headerlink" title="线程池使用场景"></a>线程池使用场景</h3><p>当有大量短任务的情景下，我们一般会考虑使用线程池</p>
<h3 id="线程池的实施"><a href="#线程池的实施" class="headerlink" title="线程池的实施"></a>线程池的实施</h3><ul>
<li>创建多个线程，并令其保持在空闲态</li>
<li>一个用于保存多个线程的容器</li>
<li>一个接口或者抽象类用于使用空闲的线程</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://115.78.133.167:81/bitstream/TVHG_07113876976/270/1/OReilly%20-%20Understanding%20The%20Linux%20Kernel.pdf">Bovet D P, Cesati M. Understanding the Linux Kernel: from I/O ports to process management[M]. &quot; O'Reilly Media, Inc.&quot;, 2005.</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>最后他的身躯一点点消散，留下了苍老的浮云和涛声，而他的血管，业已成为那条河的支流。</p>
</blockquote>
<a id="more"></a>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线程是CPU进行调度和分配的基本方式，一个CPU在一个时间只能运行一个线程。我们要注意程序为何要设计成多线程的，在一开始CPU都是单核的，其实这种情况下程序执行的最快的方式就是单核单线程，但是这样会带来并发问题，例如当处理IO时，如果只是单线程的，就会导致阻塞，此时CPU无事可做，所以我们开始将程序设计为多线程，从而实现并发。给我们一种错觉，就是同一时间有多个程序在执行。</p>
<h3 id="线程的特点及优点"><a href="#线程的特点及优点" class="headerlink" title="线程的特点及优点"></a>线程的特点及优点</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>线程是轻量化的进程，其特点为：</p>
<ul>
<li>共享代码、数据、文件和内存地址</li>
<li>独有寄存器（程序计数器）和栈空间，因为每个线程执行速度是不一样的</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="单CPU"><a href="#单CPU" class="headerlink" title="单CPU"></a>单CPU</h5><p>充分利用CPU，令$t_i$为线程1的空闲时间，$t_s$为上下文切换时间，那么当满足下面公式时，进行多线程可以提高CPU利用率。一般来说，线程切换比进程切换开销小很多。</p>
<script type="math/tex; mode=display">
t_i>2t_s</script><h5 id="多CPU"><a href="#多CPU" class="headerlink" title="多CPU"></a>多CPU</h5><ol>
<li>加速</li>
<li>专业化，每个线程做特定的工作，也可以保证hot cache</li>
</ol>
<h3 id="支持线程机制的要素"><a href="#支持线程机制的要素" class="headerlink" title="支持线程机制的要素"></a>支持线程机制的要素</h3><ul>
<li>thread data struct：和PCB一样，用于对线程进行描述。</li>
<li>创建和管理线程的机制</li>
<li>多线程合作的机制：由于多线程共享内存地址，所以会导致同步问题</li>
</ul>
<h4 id="Thread-data-structure"><a href="#Thread-data-structure" class="headerlink" title="Thread data structure"></a>Thread data structure</h4><p>一个完善的线程数据结构应包括：线程ID、程序计数器、栈顶指针（SP）、栈段以及其他的一些关键属性。</p>
<h4 id="线程创建和管理"><a href="#线程创建和管理" class="headerlink" title="线程创建和管理"></a>线程创建和管理</h4><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p>fork，创建一个线程而非进程，线程创建的同时，还会初始化线程数据结构。</p>
<h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p>当父线程t0对子线程t1调用join时，<code>join(t1)</code>，那么父线程会被阻塞，直到子线程返回。同时，join将会返回子线程的计算结果。</p>
<h5 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h5><p>一个detach的线程被创建后，父子线程是相互独立的。</p>
<h4 id="线程创建的例子（伪代码）"><a href="#线程创建的例子（伪代码）" class="headerlink" title="线程创建的例子（伪代码）"></a>线程创建的例子（伪代码）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread thread1;</span><br><span class="line">Shared_list list;</span><br><span class="line">thread1 = fork(safe_insert,4);</span><br><span class="line">safe_insert(6);</span><br><span class="line">join(thread1);   //这里join是一个非必须的语句，因为很有可能执行到这一步时，thread1已经执行完了，那么join会立刻返回</span><br></pre></td></tr></table></figure>
<p>这个代码没有考虑线程调用顺序，因此会导致结果的不确定性。</p>
<h2 id="内核态和用户态线程"><a href="#内核态和用户态线程" class="headerlink" title="内核态和用户态线程"></a>内核态和用户态线程</h2><p>内核态和用户态中都可以有线程。内核态的线程可以由内核访问和管理。调度器会决定哪个线程运行在哪个CPU上。一些内核线程可能在支持用户态线程的工作，另一些可能在执行一些内核的工作。一个用户态线程必须和一个内核线程关联后，才能被正确调度和运行。本节将针对内核态和用户态线程的调度模型进行总结。</p>
<h3 id="内核线程与用户线程的区别"><a href="#内核线程与用户线程的区别" class="headerlink" title="内核线程与用户线程的区别"></a>内核线程与用户线程的区别</h3><ol>
<li>内核线程<strong>只</strong>运行在内核态，而用户线程可以运行在用户态，也可以运行在内核态（系统调用时）</li>
<li>内核线程一般作为守护线程，执行一些诸如页表换入换出、脏页回写、软中断处理等操作</li>
<li>内核线程也会参与调度，每个CPU上有一个IDLE线程，实际是一个优先级最低的内核线程，实在没有任务了就执行这个</li>
<li>init是所有用户进程的祖先，而kthreadd是所有内核线程的祖先</li>
</ol>
<h3 id="用户态多线程模型"><a href="#用户态多线程模型" class="headerlink" title="用户态多线程模型"></a>用户态多线程模型</h3><h4 id="一一对应模型"><a href="#一一对应模型" class="headerlink" title="一一对应模型"></a>一一对应模型</h4><p>在该模型中，一个用户态线程和一个内核态线程是一一对应的关系。当一个用户态线程被创建后，就会有一个新创建或已经存在的内核线程和其一一对应。</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>并发性好，内核可以知道用户到底有多少个线程，从而可以动态调整内核线程数目和用户态进程中的多线程相匹配</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>必须在操作系统中完成所有操作，而且要频繁在用户态和内核态切换，代价大。</li>
<li>只能依赖内核态的线程调度策略，这也限制了可移植性</li>
</ul>
<h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p>在该模型中，多个用户态线程和一个内核态线程对应，由用户指定调度策略，指定规定时间哪个线程和内核态线程对应</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>可移植性强，不依赖内核态线程调度策略</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>由于没有用到内核线程的特性，所以操作系统对于用户的多线程程序基本上没太多帮助，操作系统也不知道用户到底有几个线程</li>
<li>一个用户线程的阻塞将会导致整个进程的阻塞</li>
</ul>
<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><p>该模型是上面两种模型的综合，一些线程一一对应，另一些和内核多对一对应</p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><p>综合了上面两种的优点</p>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>对于内核和线程的管理更加复杂，需要一个专门的用户-内核态线程管理器</p>
<h3 id="用户态和内核态线程调度"><a href="#用户态和内核态线程调度" class="headerlink" title="用户态和内核态线程调度"></a>用户态和内核态线程调度</h3><p>在用户态中，由一个用户层面的库对于一个进程中的线程进行管理，而在内核态中，由CPU调度器对内核态线程的调度和资源分配进行管理</p>
<h2 id="Pthreads（Posix-thread）"><a href="#Pthreads（Posix-thread）" class="headerlink" title="Pthreads（Posix thread）"></a>Pthreads（Posix thread）</h2><p>pthreads(Portable operating system interface)是Unix系统下常用的线程API，本节将针对pthreads的使用进行介绍。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="常用数据结构及API"><a href="#常用数据结构及API" class="headerlink" title="常用数据结构及API"></a>常用数据结构及API</h4><h5 id="创建thread对象"><a href="#创建thread对象" class="headerlink" title="创建thread对象"></a>创建thread对象</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------thread对象</span></span><br><span class="line"><span class="keyword">pthread_t</span> aThread;   <span class="comment">//type of thread</span></span><br></pre></td></tr></table></figure>
<h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,    <span class="comment">//设置线程属性，例如栈大小、优先级、调度策略、是否可join</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> * (*start_routine)(<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *arg)</span></span>;    <span class="comment">//函数输入参数</span></span><br></pre></td></tr></table></figure>
<p>返回值表示是否创建成功，可以根据attr设置创建线程的属性。</p>
<h5 id="join-1"><a href="#join-1" class="headerlink" title="join"></a>join</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// status将会捕获子进程返回信息和结果</span></span><br></pre></td></tr></table></figure>
<p>返回值表示join是否成功</p>
<h5 id="detach-1"><a href="#detach-1" class="headerlink" title="detach"></a>detach</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">pthread_attr_setdetachstate(attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">pthread_create(..., attr, ...);</span><br></pre></td></tr></table></figure>
<h5 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_exit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------- attr 处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span>* atrr)</span></span>;     <span class="comment">//创建attr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destory</span><span class="params">(<span class="keyword">pthread_attr_t</span>* atrr)</span></span>;  <span class="comment">//销毁attr</span></span><br><span class="line"><span class="keyword">int</span> pthread_attr_&#123;get/<span class="built_in">set</span>&#125;();                    <span class="comment">//获得/设置</span></span><br></pre></td></tr></table></figure>
<h4 id="例子：创建多线程程序"><a href="#例子：创建多线程程序" class="headerlink" title="例子：创建多线程程序"></a>例子：创建多线程程序</h4><h5 id="无参数线程函数"><a href="#无参数线程函数" class="headerlink" title="无参数线程函数"></a>无参数线程函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">foo</span> <span class="params">(<span class="keyword">void</span> ar)</span></span>&#123;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);   <span class="comment">// 设置调度方式和系统相同</span></span><br><span class="line">    pthread_create(<span class="literal">NULL</span>, &amp;attr, foo, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译过程为：<code>gcc -o main main.c -lpthread</code></p>
<h5 id="有参数线程函数"><a href="#有参数线程函数" class="headerlink" title="有参数线程函数"></a>有参数线程函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFun</span> <span class="params">(<span class="keyword">void</span> *pArg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*) pArg;</span><br><span class="line">    <span class="keyword">int</span> myNum = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, myNum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, threadFun, &amp;i);  <span class="comment">// Input parameter</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>pthreads 对于锁的使用如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> aMutex;   <span class="comment">//创建锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;  <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;  <span class="comment">//上锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;   <span class="comment">//尝试上锁，如果不成功，不会阻塞当前线程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;<span class="comment">//销毁锁</span></span><br></pre></td></tr></table></figure>
<p>注意：<strong>Mutex不能用在中断场景下，因为会引起睡眠</strong></p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> aCond; <span class="comment">//创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------- wait</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------- notify</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *attr)</span></span>;  <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destory</span><span class="params">(<span class="keyword">pthread_cond_t</span>* mutex)</span></span>;<span class="comment">//销毁锁</span></span><br></pre></td></tr></table></figure>
<h2 id="Linux下线程的实现"><a href="#Linux下线程的实现" class="headerlink" title="Linux下线程的实现"></a>Linux下线程的实现</h2><h3 id="共享与独占资源"><a href="#共享与独占资源" class="headerlink" title="共享与独占资源"></a>共享与独占资源</h3><p>在linux下的线程中，会有自身独有和共享的资源，这里对这些资源进行一个总结，其中，共享的资源包括：</p>
<ul>
<li>虚拟内存映射</li>
<li>进程基础信息</li>
<li>一些数据</li>
<li>打开的文件</li>
<li>信号处理</li>
<li>当前工作目录</li>
<li>用户和用户组属性</li>
<li>……</li>
</ul>
<p>独占的资源包括：</p>
<ul>
<li>线程ID</li>
<li>一系列寄存器</li>
<li>栈</li>
<li>错误码</li>
<li>信号掩码</li>
<li>线程优先级</li>
<li>……</li>
</ul>
<h2 id="进程与线程的联系与区别"><a href="#进程与线程的联系与区别" class="headerlink" title="进程与线程的联系与区别"></a>进程与线程的联系与区别</h2><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>线程实际上是将进程的指令执行流部分进行了剥离，进程负责资源调度，而具体指令执行交给了线程，两者的关系可以用下面的图进行概括：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/threadandprocess.svg" width = "280" alt="图片名称" align=center /></p>
<p>可以看的线程是有自己独立的堆栈和SP指针，以及相应的寄存器等。所以线程实际就是进程减去资源共享</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>进程是操作系统进行资源分配的最小单位，而线程是CPU进行任务调度的最小单位。一个进程至少包含一个线程</li>
<li>进程有独立的地址空间，每次启动一个进程，系统会分配地址空间，同时建立数据表维护代码、数据、堆栈段，开销很大。而线程共享代码段（代码与常量）、数据段（全局变量与静态变量）和堆段，开销小很多，但是每个线程有自己的栈段（局部变量和临时变量）。创建与切换线程的开销比创建切换线程大很多。</li>
<li>线程间通信更方便，同一进程下的线程共享全局变量、静态变量等数据，进程间通信需要以通信方式进行，但是多线程需要处理好同步与互斥。</li>
<li>多进程程序更健壮，一个进程的消亡不会影响另外的进程；而多线程的程序有一个线程死掉，整个进程就会死掉。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://zhuanlan.zhihu.com/p/364898425">深入理解Linux内核之内核线程（上）</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>线程设计考虑</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Two possibilities exist: either we are alone in the Universe or we are not. Both are equally terrifying.</p>
</blockquote>
<a id="more"></a>
<p>本文为Udacity Introduction to Operation System 课程9总结</p>
<h2 id="线程描述符"><a href="#线程描述符" class="headerlink" title="线程描述符"></a>线程描述符</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们知道线程可以分为内核和用户空间的线程。对于支持多线程的操作系统来说，它起着线程抽象、调度以及同步等功能。而对于用户态的线程，需要有特定的库执行上述任务。在本节中，我们来看一看为了支持线程的工作，我们需要哪些数据对其进行描述。</p>
<blockquote>
<p>注：在讨论线程描述之前，我们先要了解linux是如何支持线程的，实际上，linux下是没有线程的概念的，虽然有着线程库，但是在内核中并没有真正的对线程的支持，而是使用进程实现线程的功能。进程是进行调度的最小单位，而线程是一个与其他进程共享某些资源的进程，每一个线程拥有一个唯一的task_struct进行描述。</p>
</blockquote>
<h4 id="单CPU多进程"><a href="#单CPU多进程" class="headerlink" title="单CPU多进程"></a>单CPU多进程</h4><p>在只有一个CPU的情况下，用户态线程和内核线程可以是一对一、多对一或多对多的映射，此时我们的用户层面的线程（User-Level Thread, ULT）需要有如下的信息：</p>
<ul>
<li>UL thread ID</li>
<li>UL thread 寄存器</li>
<li>线程栈</li>
<li>…</li>
</ul>
<p>而内核层面的线程（Kernel-Level Thread, KLT）包含如下信息：</p>
<ul>
<li>栈指针</li>
<li>寄存器指针</li>
</ul>
<p>进程描述符则包含虚拟内存的映射。当我们有多个进程在运行时，此时ULT、KLT和PCB会构成一组数据。</p>
<h4 id="多CPU多进程"><a href="#多CPU多进程" class="headerlink" title="多CPU多进程"></a>多CPU多进程</h4><p>在这种情况下，我们还需要一个数据结构描述CPU，通过一个指向当前CPU上运行的线程的指针，我们可以在CPU、KLT、PCB和ULT之间建立关联。</p>
<h3 id="PCB改进"><a href="#PCB改进" class="headerlink" title="PCB改进"></a>PCB改进</h3><h4 id="单个PCB的缺点"><a href="#单个PCB的缺点" class="headerlink" title="单个PCB的缺点"></a>单个PCB的缺点</h4><p>在上文中我们强调了Linux没有线程的概念，每一个线程实际上都是一个轻量化的进程，那么自然而然的我们会考虑到用PCB来描述线程，但是这引出了一个问题：如果我们仅仅只用一个PCB描述线程，那么这个数据结构会有下面的问题：</p>
<ul>
<li>这个数据结构会很大，包含了许多连续的数据（规模大）</li>
<li>每个线程的PCB应当是私有的（开销大）</li>
<li>线程切换时需要保护和恢复现场（性能问题）</li>
<li>每一次更新状态需要发生许多改变（灵活性不足）</li>
</ul>
<h4 id="将PCB拆分为多个数据结构"><a href="#将PCB拆分为多个数据结构" class="headerlink" title="将PCB拆分为多个数据结构"></a>将PCB拆分为多个数据结构</h4><p>针对单一PCB的缺点，我们将PCB拆分为多个数据结构，这样有如下好处：</p>
<ul>
<li>每个数据结构规模更小（规模小）</li>
<li>更容易分享（开销小）</li>
<li>线程切换时所需要保护的数据更少（性能好）</li>
<li>只需要改变一部分状态（灵活）</li>
</ul>
<h3 id="Linux下内核线程结构"><a href="#Linux下内核线程结构" class="headerlink" title="Linux下内核线程结构"></a>Linux下内核线程结构</h3><p>在linux内核中，其线程数据结构为kthread_worker，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread_worker</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>          lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">work_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread_work</span> *<span class="title">current_work</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而用于描述具体任务的是task_struct结构。</p>
<h3 id="SunOS-下的线程描述设计-1"><a href="#SunOS-下的线程描述设计-1" class="headerlink" title="SunOS 下的线程描述设计*1"></a>SunOS 下的线程描述设计*<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3><p>SunOs中的线程和pthread库中的设计比较类似，当创建一个线程后，会返回一个线程ID（tid），这个index指向一个指针表，而这个指针表指向每一个线程具体的数据结构。这个设计结构如下：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/sunos1.JPG?raw=true" width = "350" alt="图片名称" align=center /></p>
<p>其中，thread local storage保存了线程函数中在编译期间就获知的局部变量。而stack的空间可能由库或用户决定。通过数据结构的大小作为偏移量，即可寻找到相邻的thread，这里的一个问题是stack的增长可能是很危险的，如果栈过长，可能导致下一个线程中的数据被覆盖，引起莫名其妙的问题。在文章中，定义了一个red zone来解决这个问题，一旦栈增长到了红色区域内，就会引发一个错误。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://www.cc.gatech.edu/classes/AY2009/cs4210_fall/papers/stein92implementing.pdf">Stein D, Shah D. Implementing Lightweight Threads[C]//USENIX Summer. 1992, 575.</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟化</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“Let us build ourselves a city, with a tower that reaches to the heavens, so that we may make a name for ourselves; otherwise we will be scattered over the face of the whole earth.”</p>
</blockquote>
<a id="more"></a>
<h2 id="虚拟化的基本原理"><a href="#虚拟化的基本原理" class="headerlink" title="虚拟化的基本原理"></a>虚拟化的基本原理</h2><p>所谓虚拟化，就是通过软件的方式模拟计算机的各种硬件，最后创造一台虚拟的计算机</p>
<h3 id="常见硬件的虚拟化"><a href="#常见硬件的虚拟化" class="headerlink" title="常见硬件的虚拟化"></a>常见硬件的虚拟化</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> regs[<span class="number">8</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_EAX 1;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_EBX 2;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_ECX 3;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int32_t</span> eip;</span><br><span class="line"><span class="keyword">int16_t</span> segregs[<span class="number">4</span>];</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h5 id="构造内存空间"><a href="#构造内存空间" class="headerlink" title="构造内存空间"></a>构造内存空间</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char mem[256*1024*1024];</span><br></pre></td></tr></table></figure>
<h5 id="模拟内存映射"><a href="#模拟内存映射" class="headerlink" title="模拟内存映射"></a>模拟内存映射</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KB		1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB		1024*1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOW_MEMORY	640*KB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT_MEMORY	10*MB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> low_mem[LOW_MEMORY];</span><br><span class="line"><span class="keyword">uint8_t</span> ext_mem[EXT_MEMORY];</span><br><span class="line"><span class="keyword">uint8_t</span> bios_rom[<span class="number">64</span>*KB];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">read_byte</span><span class="params">(<span class="keyword">uint32_t</span> phys_addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phys_addr &lt; LOW_MEMORY)</span><br><span class="line">        <span class="keyword">return</span> low_mem[phys_addr];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (phys_addr &gt;= <span class="number">960</span>*KB &amp;&amp; phys_addr &lt; <span class="number">1</span>*MB)</span><br><span class="line">        <span class="keyword">return</span> rom_bios[phys_addr - <span class="number">960</span>*KB];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (phys_addr &gt;= <span class="number">1</span>*MB &amp;&amp; phys_addr &lt; <span class="number">1</span>*MB+EXT_MEMORY) &#123;</span><br><span class="line">        <span class="keyword">return</span> ext_mem[phys_addr<span class="number">-1</span>*MB];</span><br><span class="line">        <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> write_byte(<span class="keyword">uint32_t</span> phys_addr, <span class="keyword">uint8_t</span> val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (phys_addr &lt; LOW_MEMORY)</span><br><span class="line">        low_mem[phys_addr] = val;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (phys_addr &gt;= <span class="number">960</span>*KB &amp;&amp; phys_addr &lt; <span class="number">1</span>*MB)</span><br><span class="line">        ; <span class="comment">/* ignore attempted write to ROM! */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (phys_addr &gt;= <span class="number">1</span>*MB &amp;&amp; phys_addr &lt; <span class="number">1</span>*MB+EXT_MEMORY) &#123;</span><br><span class="line">        ext_mem[phys_addr<span class="number">-1</span>*MB] = val;</span><br><span class="line">        <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CPU执行过程"><a href="#CPU执行过程" class="headerlink" title="CPU执行过程"></a>CPU执行过程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    read_instruction(); <span class="comment">//BIU</span></span><br><span class="line">    <span class="keyword">switch</span> (decode_instruction_opcode()) &#123;     <span class="comment">//EU</span></span><br><span class="line">        <span class="keyword">case</span> OPCODE_ADD:   <span class="comment">//加</span></span><br><span class="line">            <span class="keyword">int</span> src = decode_src_reg();</span><br><span class="line">            <span class="keyword">int</span> dst = decode_dst_reg();</span><br><span class="line">            regs[dst] = regs[dst] + regs[src];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OPCODE_SUB:</span><br><span class="line">            <span class="keyword">int</span> src = decode_src_reg();</span><br><span class="line">            <span class="keyword">int</span> dst = decode_dst_reg();</span><br><span class="line">            regs[dst] = regs[dst] - regs[src];</span><br><span class="line">            <span class="keyword">break</span>;         <span class="comment">//减</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">    eip += instruction_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="外设虚拟化"><a href="#外设虚拟化" class="headerlink" title="外设虚拟化"></a>外设虚拟化</h4><h5 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h5><p>读写文件假装在读写硬盘</p>
<h5 id="显示设备"><a href="#显示设备" class="headerlink" title="显示设备"></a>显示设备</h5><p>在真实的显示设备划分一块区域作为虚拟机显示设备</p>
<h5 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h5><p>将键盘、鼠标等事件放入事件队列中，从而将真实的键盘转换为虚拟的键盘</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>缺页异常</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>她轻轻地把鱼儿放在那池清水里，鱼儿摇了摇尾巴，游走了，只剩下她随风摇动的裙摆和水面微微泛起的涟漪</p>
</blockquote>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是缺页异常"><a href="#什么是缺页异常" class="headerlink" title="什么是缺页异常"></a>什么是缺页异常</h3><p>当一个进程试图访问一个地址，但是这个地址对应的内存尚未被加载进系统RAM中，那么将会产生一个pagefault</p>
<h3 id="缺页异常种类"><a href="#缺页异常种类" class="headerlink" title="缺页异常种类"></a>缺页异常种类</h3><p>缺页异常一般由如下两种情况触发：</p>
<ul>
<li>编程错误引起的异常</li>
<li>由于懒分配导致的引用属于进程但是尚未分配物理页框的页</li>
</ul>
<p>常见场景如下：</p>
<ul>
<li>映射关系未建立<ul>
<li>malloc/mmap申请的虚拟空间未分配实际物理页，首次访问触发缺页异常</li>
</ul>
</li>
<li>映射关系已建立<ul>
<li>访问的页面被置换入磁盘中</li>
<li>fork子进程时，父子进程共享地址空间，写时触发写时拷贝（copy on write）</li>
</ul>
</li>
<li>访问地址空间不合法，用户空间访问内核空间，或者内核空间访问用户空间</li>
</ul>
<h2 id="缺页异常处理程序"><a href="#缺页异常处理程序" class="headerlink" title="缺页异常处理程序"></a>缺页异常处理程序</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href=""></a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>调度</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>　“启动太阳轨道计算软件‘Three-Body l.0’！”牛顿声嘶力竭地发令，“启动计算主控！加载差分模块！加载有限元模块！加载谱方法模块……调入初始条件参数！计算启动！！” </p>
</blockquote>
<a id="more"></a>
<p>本文将对linux中进程调度相关知识进行介绍。</p>
<h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><h2 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h2><p>根据进程运行状态，可以将进程分为两种：</p>
<ul>
<li><strong>IO密集型</strong>：吞吐量大，CPU占用率低，例如网络通信中的监听进程</li>
<li><strong>CPU密集型</strong>：吞吐量少，CPU占用率高，例如编译器进程</li>
</ul>
<p>由于进程的不同表现，我们实际上会采取不同的策略，IO密集型往往是交互进程，响应时间敏感，属于高优先级；而CPU密集型，例如编译器进程，响应要求不高，因此属于低优先级。对于时间响应敏感的，我们要奖励，占用CPU资源多的，我们要惩罚。</p>
<pre class="mermaid">graph LR
    start((start))
    ioTask[IO密集型]
    cpuTask[CPU密集型]
    bonus[奖励, 提高优先级]
    panish[惩罚, 降低优先级]

    start --> ioTask
    start --> cpuTask
    ioTask --> bonus
    cpuTask --> panish</pre>

<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>根据进程重要性，可以将进程分为：</p>
<ul>
<li>实时进程</li>
<li>普通进程</li>
</ul>
<p>实时进程相对重要，需要保证CPU占用优先级，普通进程不需额外照顾，linux中影响优先级的两个因素：<strong>Nice值（谦让值）和priority（权重）</strong>，优先级和权重的关系如下：</p>
<ul>
<li><p>实时进程PR值范围是0~99，数值越大被调度优先级越高</p>
</li>
<li><p>普通进程PR值范围是100~139，数值越小被调度优先级越高</p>
</li>
<li><p>Nice值范围是-20~19，并不是优先级但影响PR值，一般作用在普通进程上</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/pr.svg" width = "480" alt="图片名称" align=center /></p>
<p>PR值由内核决定，而用户态可以修改Nice值，干预PR值</p>
<script type="math/tex; mode=display">
\mathbf{PR}_{\textrm{new}}=\mathbf{PR}_{\textrm{old}} + \mathbf{Nice}</script><p>Nice值为谦让值，如果为0，表示不干预内核，听天由命；如果为负值，表示用户态干预提高优先级，将机会留给自己；如果为正，表示降低优先级，将机会留给别人。下面这张图很形象：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/nice.svg" width = "280" alt="图片名称" align=center /></p>
<h2 id="抢占与非抢占"><a href="#抢占与非抢占" class="headerlink" title="抢占与非抢占"></a>抢占与非抢占</h2><p>说完了任务类型，我们再来聊聊调度类型，根据进程在占用CPU时，使用权是否被剥夺，我们可以将调度分为如下两种：</p>
<ul>
<li>非抢占式：进程任务一旦占据CPU，只有当前任务完成或等待IO时释放CPU，不能被其他进程夺走</li>
<li>抢占式：任务占用CPU期间可以被抢占，由操作系统调度器决定下一个占用CPU的任务</li>
</ul>
<p>Linux采用抢占式，CPU利用率和响应时间较好，但是增加了开销</p>
<h2 id="调度器设计指标"><a href="#调度器设计指标" class="headerlink" title="调度器设计指标"></a>调度器设计指标</h2><p>设计调度器的时候，需要考虑两个指标：</p>
<ul>
<li><strong>周转时间</strong>：任务从开始排队等待CPU资源到任务完成的时间差，即等待+执行的时间</li>
<li><strong>响应时间</strong>：任务从开始排队到开始使用CPU的时间差，即等待时间</li>
</ul>
<p>综合来说，有如下几点设计经验：</p>
<blockquote>
<p>实时进程优先调度，普通进程优先级低于实时进程</p>
<p>IO密集型要频繁调度，分配较短时间片，少食多餐</p>
<p>CPU密集型要稍微惩罚，分配长时间片，多食少餐</p>
</blockquote>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><p>以下介绍几种常见的调度算法，记住：<strong>没有银弹</strong></p>
<h2 id="FIFO调度"><a href="#FIFO调度" class="headerlink" title="FIFO调度"></a>FIFO调度</h2><p>经典的先来先服务</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.eet-china.com/mp/a111242.html">揭秘Linux进程调度器</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>进程位数判断</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%BD%8D%E6%95%B0%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>$2^{64}=18446744073709551616$</p>
</blockquote>
<a id="more"></a>
<p>当我们编写与操作系统有关的代码时，有时要判断一个进程是32位还是64位，这种情况下我们需要一些代码来实现这种功能，本文将针对不同操作系统下实现进程位数的判断的过程进行总结。</p>
<h2 id="Linux下进程位数判断"><a href="#Linux下进程位数判断" class="headerlink" title="Linux下进程位数判断"></a>Linux下进程位数判断</h2><h3 id="使用file命令判断进程位数"><a href="#使用file命令判断进程位数" class="headerlink" title="使用file命令判断进程位数"></a>使用file命令判断进程位数</h3><p>当我们知道进程的PID后，我们可以使用file命令对进程的信息进行判断，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">    325 pts/0    00:00:00 bash</span><br><span class="line">    360 pts/0    00:00:00 ps</span><br><span class="line">~$ file -L /proc/325/exe</span><br><span class="line">/proc/325/exe: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a6cb40078351e05121d46daa768e271846d5cc54, for GNU/Linux 3.2.0, stripped</span><br></pre></td></tr></table></figure>
<p>从上面的结果中，我们可以看到这个进程是64位进程。</p>
<h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>在明确file命令的工作原理之前，我们先来看一下linux下可执行文件的格式，linux下的可执行文件是ELF格式，全称为可执行与可链接格式（Executable and Linkable Format），其实就是一种二进制可执行文件。ELF的header决定了该可执行文件采用32位还是64位的地址，所以我们通过ELF的相关信息即可判断可执行进程的位数。</p>
<h3 id="C-判断进程位数代码"><a href="#C-判断进程位数代码" class="headerlink" title="C++判断进程位数代码"></a>C++判断进程位数代码</h3><h2 id="Windows下判断进程位数代码"><a href="#Windows下判断进程位数代码" class="headerlink" title="Windows下判断进程位数代码"></a>Windows下判断进程位数代码</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>进程</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Hi siri! Help me to copy a siri.</p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>进程是系统进行资源分配与调度的基本单位，具体一点讲，进程就是活动的程序，进程是暂时的，程序是永久的。</p>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>作为一个被加载到内存中的活动的程序，进程由五个部分组成，即将内存进行分段后，分配给某一个进程，分段示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20200901172929.png" width = "180" alt="图片名称" align=center /></p>
<p>进程包含了正在运行的一个程序的所有状态信息：</p>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器：CPU状态CR0、指令指针IP</li>
<li>通用寄存器：AX、BX、CX…</li>
<li>进程占用系统资源：已分配内存、打开文件</li>
</ul>
<h3 id="进程特点"><a href="#进程特点" class="headerlink" title="进程特点"></a>进程特点</h3><p>进程包含动态性、并发性、独立性和制约性（因访问共享数据/资源产生的制约）</p>
<h2 id="进程描述符-Process-Control-Block-PCB"><a href="#进程描述符-Process-Control-Block-PCB" class="headerlink" title="进程描述符(Process Control Block,PCB)"></a>进程描述符(Process Control Block,PCB)</h2><p>进程描述符实际上保存了进程的控制信息，这些信息包括：调度和状态信息、进程间通信信息、存储管理信息、进程使用资源信息以及有关数据结构连接信息（与PCB相关的进程队列）。</p>
<h3 id="进程描述符内容"><a href="#进程描述符内容" class="headerlink" title="进程描述符内容"></a>进程描述符内容</h3><p>进程描述符（或者叫进程控制块PCB）是一个对进程进行管理的数据结构，<strong>在进程创建时一同建立并严格一一对应</strong>。在Linux系统下，PCB是一个task_struct类型结构，包含了和进程相关的若干信息。具体内容包括：</p>
<ol>
<li>进程状态</li>
<li>进程ID</li>
<li>程序计数器</li>
<li>寄存器</li>
<li>内存限制</li>
<li>打开的文件</li>
<li>优先级</li>
<li>…</li>
</ol>
<p>有些内容会随着进程状态改变而改变，而有些内容会频繁发生更新。上面的信息可以分为几类：</p>
<ul>
<li>标识信息</li>
<li>状态信息</li>
<li>资源信息</li>
<li>现场保护信息</li>
<li>队列信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct process&#123;</span><br><span class="line">    //标识信息</span><br><span class="line">    char name[PROC_NAME_LEN + 1];</span><br><span class="line">    int pid;</span><br><span class="line">    int runs;</span><br><span class="line">    sturct process* parent;</span><br><span class="line">    </span><br><span class="line">    //状态信息</span><br><span class="line">    uint32_t flags;     //CPU状态寄存器</span><br><span class="line">    uintptr_t cr3;      //地址空间起头位置</span><br><span class="line">    enum proc_state state //进程状态</span><br><span class="line">    volatile bool need_resched; //是否允许调度</span><br><span class="line">    </span><br><span class="line">    //进程占用存储资源</span><br><span class="line">    uintptr_t kstack;   //内核栈</span><br><span class="line">    struct memory_map* mm;  //内存</span><br><span class="line">    </span><br><span class="line">    //现场保护信息</span><br><span class="line">    struct trapframe *tf</span><br><span class="line">    struct context context;</span><br><span class="line">    </span><br><span class="line">    //队列信息</span><br><span class="line">    list_entry_t hash_list;</span><br><span class="line">    char name[PROC_NAME_LEN+1]; //内核状态名称</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，memory_map是一个比较重要的数据结构，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct memory_map&#123;</span><br><span class="line">    list_entry_t mmap_list;     //进程内存块映射</span><br><span class="line">    struct vma* mmap_cache;     </span><br><span class="line">    pde_t* pgdir;               //一级页表起始地址   =cr3</span><br><span class="line">    int map_count;              //内存共享次数 </span><br><span class="line">    void* sm_priv;              //外存置换数据结构</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="进程描述符工作过程"><a href="#进程描述符工作过程" class="headerlink" title="进程描述符工作过程"></a>进程描述符工作过程</h3><p>当一个进程处于运行态时，CPU的寄存器会保存PCB，而当发生进程切换，操作系统会保存当前进程的状态，然后切换到另一个进程，同时CPU中保存的PCB也会发生变化。</p>
<h3 id="PCB组织结构"><a href="#PCB组织结构" class="headerlink" title="PCB组织结构"></a>PCB组织结构</h3><p>PCB的组织结构一般采用链表或索引表组成，在实验中是使用链表进行组织。内核将相同状态的进程PCB放置在一个队列中。而在实际应用中，由于链表索引困难，因此采用哈希链表，将大链表拆分，每一个部分进行哈希处理，这样可以使索引变为$O(m)$，其中$m$为每个部分的平均长度</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="轻重进程状态"><a href="#轻重进程状态" class="headerlink" title="轻重进程状态"></a>轻重进程状态</h3><p>由于进程中可能有多个线程在执行，因此我们的PCB可以被进一步分割，分为轻重进程状态：</p>
<ul>
<li>轻进程状态：随着线程切换而改变的，例如signal mask和系统调用的参数等</li>
<li>重进程状态：不随线程切换而改变的，即所有线程共有的，例如虚拟地址映射</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><pre class="mermaid">graph TB
    node1((new))
    node2((ready))
    node3((running))
    node4((waiting))
    node5((end))

    node1--admit-->node2
    node2--调度-->node3
    node3--抢占/中断或时间片用完-->node2
    node3--IO或事件等待-->node4
    node4--IO或事件完成-->node2
    node3--退出-->node5</pre>

<ul>
<li>新生（new）：当进程被创建后，它处于新生态，此时等待操作系统进行调度</li>
<li>就绪（ready）：进程已处于准备好运行的状态，即进程已分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行。就绪进程位于就绪队列中。<strong>当时间片结束之后，进程处于就绪态而非等待态</strong>。</li>
<li>执行（running）：进程已经获得CPU，程序正在执行状态</li>
<li>阻塞（waiting）：正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，等待是进程内部原因导致的</li>
<li>结束（end）：进程僵死或死亡，要将资源还回去。进程结束可能是正常退出、错误退出、致命错误或被其他进程杀死</li>
</ul>
<p>除此之外，进程还有一个特殊的状态叫进程挂起，进程挂起涉及虚拟内存，即将处于等待或就绪的进程保存在外存当中，而当进程开始运行，再从外寸调回内存。实际上是时间换空间的做法。挂起即把进程从内存转到外存。这里稍微了解一下<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。</p>
<p>内存时的挂起状态包括：</p>
<ul>
<li>等待到等待挂起</li>
<li>就绪到就绪挂起</li>
<li>运行到就绪挂起：对于抢占式的系统，高优先级抢占低优先级，且没有足够内存空间</li>
</ul>
<p>外存时的挂起状态</p>
<h3 id="三状态模型"><a href="#三状态模型" class="headerlink" title="三状态模型"></a>三状态模型</h3><p>将进程状态最重要的部分进行抽象，我们可以得到进程的三状态模型，即就绪、运行和等待。因为这些是最频繁发生且非一次性的，而创建和退出是一次性的。</p>
<h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><p>根据进程的状态，可以创造不同的队列保存不同状态的进程，进程状态的切换实际上是队列的切换。运行态的进程没有队列。</p>
<h4 id="Linux上的进程状态"><a href="#Linux上的进程状态" class="headerlink" title="Linux上的进程状态"></a>Linux上的进程状态</h4><p>linux上的进程状态可以进一步细分为7个：</p>
<ul>
<li><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4></li>
</ul>
<p><strong>产生原因</strong></p>
<p>当一个子进程结束时，并没有真正被销毁，而是留下了一个成为僵尸进程的数据结构，包含退出码和CPU等待时间等数据，这些数据最终会被传递给父进程。而父进程会起到为其收尸的作用，收尸的情况可能有两种</p>
<ul>
<li>父进程调用wait或waitpid等待子进程结束</li>
<li>父进程结束后由init进程销毁</li>
</ul>
<p>但如果父进程是一个不会结束的循环进程，就会导致僵尸进程持续存在，虽然一个僵尸进程几乎不占用系统资源，但是如果多了还是会给系统带来影响，那么我们应该如何处理僵尸进程呢？</p>
<p><strong>处理僵尸进程的方法</strong></p>
<ul>
<li>终止</li>
</ul>
<p>首先，我们先找到僵尸进程的父进程，shell命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep defunct_process_pid</span><br></pre></td></tr></table></figure>
<p>然后将父进程杀死，连带着僵尸进程也会被杀死。</p>
<ul>
<li>预防</li>
</ul>
<p>上面给出的方法属于被动解决僵尸进程，显然我们是不满意的，我们还希望能够提供自动预防僵尸进程产生的方法，这里提供三个</p>
<ul>
<li>父进程调用函数<code>signal(SIGCHLD,SIG_IGN);</code>令系统自动回收子进程</li>
<li>用waitpid等待子进程返回</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>当CPU从执行进程A切换至执行进程B时，发生了上下文的切换。当发生上下文切换时，操作系统必须高效地中断并保存现场，决定下一个进程，并释放将要执行的进程。所以进程切换要做两件事：</p>
<ul>
<li>暂停当前进程，从运行态切换为其它态</li>
<li>调度另一个进程，从就绪态变为运行态</li>
</ul>
<p>一般进程的切换频率为10-15ms，切换速度非常快，因此一般使用汇编实现。</p>
<h4 id="Task-State-Segment"><a href="#Task-State-Segment" class="headerlink" title="Task State Segment"></a>Task State Segment</h4><h5 id="32-bit-TSS的结构"><a href="#32-bit-TSS的结构" class="headerlink" title="32-bit TSS的结构"></a>32-bit TSS的结构</h5><p>Linux为每一个CPU设置了单独的TSS，来保存任务状态，并使用一个32位TSS descriptor来指向TSS的起始地址。32-bit的TSS的结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/tss.svg" width = "450" alt="图片名称" align=center /></p>
<p>TSS中主要包含静态和动态部分。其中动态部分在程序切换时由处理器进行更新；而静态部分在任务创建时被设置，处理器一般只读。</p>
<ul>
<li>动态：通用寄存器、段寄存器、EFLAGS、EIP以及前一个任务的TSS的选择符</li>
<li>静态：任务的LDT的段选择符、CR3寄存器、不同优先级的栈指针及偏移量</li>
</ul>
<p>TSS保存了不同特权级下的堆栈信息，当发生堆栈切换，被调用者的堆栈的SS和ESP从此处取出，从而产生特权级的切换，由于从低特权级向高特权级转换，故TSS没有最低特权级的堆栈信息。</p>
<h5 id="TSS-Descriptor5"><a href="#TSS-Descriptor5" class="headerlink" title="TSS Descriptor5"></a>TSS Descriptor<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></h5><p>TSSD 记录了TSS的位置、大小以及相关属性，TSSD存放在GDT中，GDT的基址存放在每个CPU的<code>gdtr</code>寄存器中，TSSD的格式如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20210627193306.png" width = "550" alt="图片名称" align=center /></p>
<p>关键字段的功能如下：</p>
<ul>
<li>Base Address：TSS线性地址的第一个Byte</li>
<li>Limit：TSS最大偏移量</li>
<li>DPL：TSSD的特权级</li>
<li>G：TSS大小粒度（0-byte粒度，1-4KB粒度）</li>
<li>P：TSS是否在物理内存中</li>
<li>B（busy flag）：当前任务是否busy（B=1），一个忙任务表示正在运行或挂起的任务</li>
</ul>
<h5 id="TSS-Selector"><a href="#TSS-Selector" class="headerlink" title="TSS Selector"></a>TSS Selector</h5><p>TSS Selector用于在GDT中寻找特定的TSSD，实际上就是数组的一个偏移量。</p>
<h4 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h4><p>进程切换分为两步：</p>
<ol>
<li>切换页目录，安装新的地址空间</li>
<li>切换内核栈和硬件上下文（线程只做这一步）</li>
</ol>
<p>进程切换过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/0f1e8498-9405-95aa-e2b9-7ef1f3d0e6e9.png" width = "500" alt="图片名称" align=center /></p>
<p>具体的切换流程如下：</p>
<pre class="mermaid">graph TB
    node1[开始调度:cpu_idle]
    node2[清除调度标志:schedule]
    node3[查找就绪进程:还有可能查到自己]
    node4[修改进程状态]
    node5[进程切换:switch_to]

    node1-->node2
    node2-->node3
    node3-->node4
    node4-->node5
    node5-->node6</pre>

<h4 id="CPU调度器"><a href="#CPU调度器" class="headerlink" title="CPU调度器"></a>CPU调度器</h4><p>CPU调度器决定何时执行何进程多长时间。在设计调度器时，我们需要考虑进程应该执行多长时间，或者说调度频率应该有多高。这里我们引入CPU有效工作占比$r_e$的概念，其公式为：</p>
<script type="math/tex; mode=display">
r_e = t_p/T=\frac{t_p}{t_p+t_s}</script><p>其中$t_p$为进程工作时间，$T$为一个调度周期总时间，$t_s$为上下文切换时间。从公式中可见，如果切换过于频繁或者上下文切换时间过长，那么会导致有效工作率下降</p>
<h4 id="消耗"><a href="#消耗" class="headerlink" title="消耗"></a>消耗</h4><p>进程切换后，虚拟内存空间发生了变化，这一步是由操作系统内核完成的。进程切换是有损耗的，除了时间损耗外，还有两个关于空间的损耗，所以我们要控制进程切换的频率</p>
<ul>
<li>寄存器中的内容需要发生变化；</li>
<li>上下文切换会扰乱CPU Cache，已经缓存的进程A的数据在一瞬间全部作废，换成进程B。（cold cache）</li>
</ul>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><h4 id="Linux下进程创建系统调用fork"><a href="#Linux下进程创建系统调用fork" class="headerlink" title="Linux下进程创建系统调用fork"></a>Linux下进程创建系统调用<code>fork</code></h4><p><code>fork</code>函数会创建一个新进程，和调用fork的进程几乎一致，两个进程都会继续运行，fork函数返回值如下：</p>
<ul>
<li>子进程中成功的fork调用返回0</li>
<li>父进程返回子进程pid，出现错误返回负值</li>
</ul>
<h6 id="fork-使用方法及例子"><a href="#fork-使用方法及例子" class="headerlink" title="fork 使用方法及例子"></a>fork 使用方法及例子</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;    <span class="comment">//父进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: child = %d\n"</span>, pid);</span><br><span class="line">    pid = wait();   <span class="comment">// 等待某个子进程结束，返回该子进程pid，如果没有，那么等待一个结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child %d is done\n"</span>, pid);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child exiting\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果fork正确，上面的代码运行结果可能为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent:child = 1234</span><br><span class="line">child exiting</span><br><span class="line">child 1234 is done</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child exiting</span><br><span class="line">parent:child = 1234</span><br><span class="line">child 1234 is done</span><br></pre></td></tr></table></figure>
<p>取决于子进程和父进程谁先获得执行权</p>
<ol>
<li>fork一个新进程</li>
<li>使用exec()载入一个新的应用程序，替换当前进程，这样就可以派生并执行一个不同的进程</li>
</ol>
<h6 id="fork计算"><a href="#fork计算" class="headerlink" title="fork计算"></a>fork计算</h6><p>fork一次会产生两个进程，而循环$n$次进行fork，会产生$2^n$个进程</p>
<h6 id="fork的演进"><a href="#fork的演进" class="headerlink" title="fork的演进"></a>fork的演进</h6><p>早期的Unix系统fork会老老实实复制一份新数据，开销很大。但是后来为了提高效率，只在进行写操作时复制。在linux下是<code>vfork</code>，即轻量级fork，将内存复制延迟到应用时。</p>
<h6 id="fork与多线程"><a href="#fork与多线程" class="headerlink" title="fork与多线程"></a>fork与多线程</h6><p>考虑这个问题，在一个多线程的进程中进行fork（听起来就蛋疼的要命）。在POSIX标准中，其行为如下：</p>
<ul>
<li>复制整个空间的写数据</li>
<li>仅复制当前线程到子进程，其余线程全部蒸发</li>
</ul>
<p>这产生了一个严重问题，锁被复制，但是线程没了，这些锁就成为了孤儿锁，没有主人，无法被解锁，会导致程序发生严重死锁。</p>
<h6 id="fork与文件"><a href="#fork与文件" class="headerlink" title="fork与文件"></a>fork与文件</h6><p>使用fork创建新的进程后，子进程会拷贝父进程的文件描述符表，但是父子进程会共享文件偏移量，考虑下面的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"hello "</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"world\n"</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结束后文件描述符1指向的文件会包含数据<code>&quot;hello world&quot;</code>，因为有<code>wait()</code>的存在，子进程会先于父进程进行写操作，改变文件的偏移量；而父进程会在此基础上进行写操作</p>
<h3 id="创建空闲进程"><a href="#创建空闲进程" class="headerlink" title="创建空闲进程"></a>创建空闲进程</h3><p>如果没有用户进程，那么操作系统会怎么处理呢？操作系统会创建一个空闲进程，然后运行这个进程。</p>
<h4 id="创建第一个内核线程"><a href="#创建第一个内核线程" class="headerlink" title="创建第一个内核线程"></a>创建第一个内核线程</h4><h3 id="进程加载"><a href="#进程加载" class="headerlink" title="进程加载"></a>进程加载</h3><h4 id="使用exec加载进程"><a href="#使用exec加载进程" class="headerlink" title="使用exec加载进程"></a>使用<code>exec</code>加载进程</h4><p>进程加载允许进程加载一个完全不同的程序，并从main开始执行，程序的加载和执行的系统调用是<code>exec()</code>。exec允许指定启动参数。当<code>exec</code>调用成功后，会替换调用进程的内存，重写代码段、堆栈和堆，并载入一个新内存镜像。<code>exec</code>在shell中很常见，用于执行用户的指令</p>
<h5 id="exec-使用方法及例子"><a href="#exec-使用方法及例子" class="headerlink" title="exec 使用方法及例子"></a>exec 使用方法及例子</h5><p><code>exec</code>    接收两个参数，可执行文件的名称以及字符串格式的参数数组，<code>exec</code>如果成功执行，不会返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">"echo"</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">"hello"</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">"/bin/echo"</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"exec error\n"</span>);   <span class="comment">//如果exec正常，这句永远不会执行</span></span><br></pre></td></tr></table></figure>
<h5 id="fork和exec共同使用"><a href="#fork和exec共同使用" class="headerlink" title="fork和exec共同使用"></a>fork和exec共同使用</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    exec(<span class="string">"program"</span>, argc, argv0, argv1,...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="exec实现"><a href="#exec实现" class="headerlink" title="exec实现"></a>exec实现</h5><p>exec的实现可以分为三个函数</p>
<ul>
<li>sys_exec：获取创建进程的相应参数</li>
<li>do_execve：创建新进程所需要的段结构</li>
<li><strong>load_icode</strong>：识别可执行文件格式，并加载到内存中</li>
</ul>
<h2 id="进程使用"><a href="#进程使用" class="headerlink" title="进程使用"></a>进程使用</h2><h3 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h3><p>在大多数操作系统中，进程创建的过程可以被视为一个树形结构，首先有一个根进程在系统启动后被创建，然后这个根进程创建了一些初始进程，这些初始进程随后又开始工作，创建了更多的工作进程。以linux为例，这个过程如下所示：</p>
<pre class="mermaid">graph TB
    node["idle(0)"]
    node1["init(1)"]
    node2["pageout"]
    node3["shell"]
    node4["ls"]
    node5["emacs"]
    node6["..."]

    node-->node1
    node-->node2
    node1-->node3
    node3-->node4
    node3-->node5
    node5-->node6</pre>

<p>Linux的进程祖先为进程0，即idle进程，该进程使用静态分配的数据结构，而其他进程数据结构都是动态的。而init进程由start_kernel()创建。操作系统外层的其他所有的进程都由init创建。</p>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>进程同步：指对多个相关进程在执行次序上进行协调，以使并发执行的进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性，同步机制如下：</p>
<ul>
<li>空闲切换</li>
<li>忙则等待（保证临界区互斥访问）</li>
<li>有限等待（等待有限时间，避免死等）</li>
<li>让权等待（当无法访问临界区时，应当释放处理机，以免陷入忙等）</li>
</ul>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>当进程执行过程中，会执行IO过程，而IO往往是很慢的，所以CPU需要考虑IO对进程的影响，CPU处理进程中的IO操作的模型如下：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/ioprocess.JPG?raw=true" width = "480" alt="图片名称" align=center /></p>
<p>在IO请求时，正在执行的进程将进入等待队列中。</p>
<h3 id="进程活动模型"><a href="#进程活动模型" class="headerlink" title="进程活动模型"></a>进程活动模型</h3><p>现在我们对进程的活动模型进行一个总结，如下图所示：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/processStateTrans.JPG?raw=true" width = "480" alt="图片名称" align=center /></p>
<p>从上图中可以看到，当发生IO请求、时间片耗尽、fork线程或发生中断时，都有可能导致进程从运行态进入等待队列中。</p>
<h3 id="进程通信方式（Inter-Process-Communication-IPC）"><a href="#进程通信方式（Inter-Process-Communication-IPC）" class="headerlink" title="进程通信方式（Inter Process Communication, IPC）"></a>进程通信方式（Inter Process Communication, IPC）</h3><p>通信方式包括无名管道、有名管道、信号、共享内存、消息队列、信号量等。可以分为高级与低级两种。由于每个进程拥有自己的用户地址空间，因此进程间的全局变量是不可变的，所以进程间通信必须经过内核。</p>
<h4 id="高级通信方式"><a href="#高级通信方式" class="headerlink" title="高级通信方式"></a>高级通信方式</h4><ul>
<li>共享内存：最快的进程间通信方式，例如剪贴板，共享内存是完全在用户态的，操作系统不需要干预，这也导致没有合适的系统调用帮助我们进行通信。</li>
<li>消息传递系统：类似于信号—槽系统，是一种无连接不可靠的单向数据传输系统</li>
<li>管道通信系统：管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。<ul>
<li>匿名管道：未命名的、单向管道，通过父进程和一个子进程之间传输数据。匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。</li>
<li>命名管道：不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信。</li>
</ul>
</li>
<li>套接字：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信</li>
<li>消息队列：是一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表的形式出现的。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
</ul>
<h4 id="低级通信方式："><a href="#低级通信方式：" class="headerlink" title="低级通信方式："></a>低级通信方式：</h4><ul>
<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段</li>
</ul>
<h3 id="创建进程的方式"><a href="#创建进程的方式" class="headerlink" title="创建进程的方式"></a>创建进程的方式</h3><p>进程创建有fork和exec两种方式，其特点分别如下：</p>
<ul>
<li>fork复制进程，然后两个进程开始分别运行</li>
<li>exec在现有进程上下文中运行可执行文件，替换以前的可执行文件</li>
</ul>
<h2 id="进程相关系统调用"><a href="#进程相关系统调用" class="headerlink" title="进程相关系统调用"></a>进程相关系统调用</h2><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>kill</td>
<td>向进程发送信号</td>
</tr>
<tr>
<td>setgid</td>
<td>设置进程的组id</td>
</tr>
<tr>
<td>exec</td>
<td>执行给定的文件，不会改变进程号，只会以另一个可执行文件替换当前程序</td>
</tr>
</tbody>
</table>
</div>
<h3 id="exec族"><a href="#exec族" class="headerlink" title="exec族"></a>exec族</h3><h4 id="execv"><a href="#execv" class="headerlink" title="execv"></a>execv</h4><ul>
<li>原型</li>
</ul>
<p>execv的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *constargv[])</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>输入<ul>
<li>path：可执行文件路径，</li>
<li>constargv：传递给应用程序的参数列表，<code>constargv[0]</code>为应用程序本身的名字，最后一个参数应当为NULL</li>
</ul>
</li>
</ul>
<h2 id="附录：PID结构体内容"><a href="#附录：PID结构体内容" class="headerlink" title="附录：PID结构体内容"></a>附录：PID结构体内容</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://115.78.133.167:81/bitstream/TVHG_07113876976/270/1/OReilly%20-%20Understanding%20The%20Linux%20Kernel.pdf">Bovet D P, Cesati M. Understanding the Linux Kernel: from I/O ports to process management[M]. &quot; O'Reilly Media, Inc.&quot;, 2005.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://zhuanlan.zhihu.com/p/86629244">操作系统问题总结</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://blog.csdn.net/LEON1741/article/details/78142269">linux下僵尸进程产生原因与解决方法</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173411">进程挂起</a><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><a href="http://www.logix.cz/michal/doc/i386/chp07-02.htm">TSS Descriptor</a><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>锁</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我有很多把锁，却没有一把钥匙。</p>
</blockquote>
<a id="more"></a>
<p>仔细想了想，还是将锁单独列出作为一篇博客而不是放在进程与线程中，因为这个问题有些繁琐，需要仔细进行一番解释。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="锁的功能"><a href="#锁的功能" class="headerlink" title="锁的功能"></a>锁的功能</h3><p>解决资源占用的问题；保证同一时间一个对象只有一个线程在访问；有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。锁带来了安全，但也降低了效率。因为多个线程试图获取同一把锁，只能有一个线程获得，其他线程只能等待释放锁。</p>
<p>锁的功能如下：</p>
<ul>
<li>避免更新丢失</li>
<li>能够将多个步骤原子化，隐藏中间过程</li>
<li>保持数据不变性，假设一个数据在中间过程被改变，但是结束后又改了回来，那么使用锁可以隐藏中间过程，使数据对外表现为没变化</li>
</ul>
<h3 id="锁的基本模型"><a href="#锁的基本模型" class="headerlink" title="锁的基本模型"></a>锁的基本模型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock l;</span><br><span class="line">acquire(l)</span><br><span class="line">    x = x + 1    //被保护的临界区</span><br><span class="line">release(l)</span><br></pre></td></tr></table></figure>
<p>锁实际上是保证了一段区域的原子性</p>
<h3 id="锁的种类2"><a href="#锁的种类2" class="headerlink" title="锁的种类2"></a>锁的种类<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3><h4 id="按照性质划分"><a href="#按照性质划分" class="headerlink" title="按照性质划分"></a>按照性质划分</h4><p><strong>公平锁/非公平锁</strong></p>
<p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁，这种就是公平锁。有可能会造成优先级反转。</p>
<p>非公平锁按照优先级高低的顺序获取锁，可能会造成线程饥饿</p>
<p><strong>乐观锁/悲观锁</strong></p>
<p>乐观锁假设数据一定不会被修改；而悲观锁假设数据一定会被修改。</p>
<ul>
<li>乐观锁适用场景</li>
</ul>
<p>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<ul>
<li>悲观锁适用场景</li>
</ul>
<p><strong>独享锁/共享锁</strong></p>
<p>独享锁被一个线程单独占有，而共享锁则由多个线程共享</p>
<h4 id="按照设计方法划分"><a href="#按照设计方法划分" class="headerlink" title="按照设计方法划分"></a>按照设计方法划分</h4><p><strong>自旋锁</strong></p>
<p>是指尝试获取锁的线程不会立即被阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线上下文切换的消耗，缺点是循环会消耗CPU。</p>
<p>A占有锁，如果B想要申请锁，那么不阻塞，而是反复询问A，你的锁用完了么？你的锁用完了么？直到A释放了资源的锁。</p>
<ul>
<li>应用场景</li>
</ul>
<p>如果A线程占用锁的时间比较短，这个时候用自旋锁比较好，可以节省CPU在不同线程间切换花费的时间开销；如果A线程占用锁的时间比较长，那么使用自旋锁的话，B线程就会长时间浪费CPU的时间而得不到执行（要执行一个线程需要CPU，并且需要获得锁），这个时候不建议使用自旋锁；还有递归的时候尽量不要使用自旋锁，可能会造成死锁。</p>
<ul>
<li>C++实现自旋锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spin_mutex</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; flag = ATOMIC_VAR_INIT(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    spin_mutex() = <span class="keyword">default</span>;</span><br><span class="line">    spin_mutex(<span class="keyword">const</span> spin_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    spin_mutex&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> spin_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!flag.compare_exchange_strong(expected, <span class="literal">true</span>))  <span class="comment">//flag == expected,flag的值被改为true，并返回true	</span></span><br><span class="line">        <span class="comment">// flag == false; expected == false  flag = true</span></span><br><span class="line">        <span class="comment">// return true, while break, get the lock</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// flag == true; expected == false flag != expected</span></span><br><span class="line">        <span class="comment">// return false, while continue, cannot get the lock</span></span><br><span class="line">            expected = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag.store(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>互斥锁（mutex）</strong></p>
<p>采用互斥锁可以防止竞争的发生，对于一个临界区域，进入时上锁，退出时解锁，可以保证同一时刻只能有一个线程对其进行访问。</p>
<ul>
<li>问题：多个线程请求锁</li>
</ul>
<p>不考虑优先级，当多个线程申请一个待释放的锁时，那么哪个线程会得到锁呢？答案是不确定，只要在锁被释放前进行了申请的线程，都有可能获得这把锁。操作系统并不一定保证最早申请的会第一个得到锁。</p>
<p><strong>原子锁</strong></p>
<p>有些情况下在多线程中会涉及到一个经常用到而又非常简单的计算操作，例如int ++，这个时候使用自旋锁或者互斥锁代价太高，不划算，我们可以定义原子锁，利用CPU的原子操作特性，进行简单的计算操作。</p>
<h2 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> &#123;</span> <span class="keyword">int</span> locked; &#125;;</span><br><span class="line">acquire(l)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;locked == <span class="number">0</span>)&#123;  <span class="comment">// A</span></span><br><span class="line">            l-&gt;locked = <span class="number">1</span>;   <span class="comment">// B</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法采用了while循环来实现锁，该实现存在一个问题，例如</p>
<h2 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h2><h3 id="何时使用锁"><a href="#何时使用锁" class="headerlink" title="何时使用锁"></a>何时使用锁</h3><p>当我们写代码时，问自己如下问题：</p>
<ol>
<li>是否有两个或多个线程访问同一个内存空间</li>
<li>是否有至少一个线程写内存空间</li>
</ol>
<h3 id="如何寻找加锁位置"><a href="#如何寻找加锁位置" class="headerlink" title="如何寻找加锁位置"></a>如何寻找加锁位置</h3><p>这里有一个简单的原则，先写出单个CPU下单线程的正确的顺序代码，然后在这个代码两端进行加锁保护，使代码段强制保持顺序执行</p>
<h3 id="锁的使用原则"><a href="#锁的使用原则" class="headerlink" title="锁的使用原则"></a>锁的使用原则</h3><ul>
<li>如果能不共享，就不共享</li>
<li>先用粗粒锁，如果有必要，逐步细化</li>
<li>当需要更高的并发性，再使用细颗粒锁</li>
</ul>
<h2 id="锁的问题及解决方案"><a href="#锁的问题及解决方案" class="headerlink" title="锁的问题及解决方案"></a>锁的问题及解决方案</h2><h3 id="饥饿（不公平锁机制）"><a href="#饥饿（不公平锁机制）" class="headerlink" title="饥饿（不公平锁机制）"></a>饥饿（不公平锁机制）</h3><p>考虑如下场景，当线程调度允许插队时，可能会有某个线程，永远也得不到锁，这种情况下会发生线程饥饿的问题。如果线程优先级不均衡，那么在CPU繁忙的情况下，低优先级的线程得到执行的机会很小，可能发生线程饥饿；或者一个持有锁的线程长期霸占资源，也会造成饥饿问题。</p>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><ol>
<li>保证资源充足</li>
<li>采用公平机制</li>
<li>避免持有锁的线程长时间执行</li>
</ol>
<p>实际使用中方案2适用范围更广一些。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。尽管死锁很少发生，但一旦发生就会造成应用的停止响应。</p>
<h4 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h4><ol>
<li>互斥性：一个资源每次只能被一个线程所访问</li>
<li>占有性：当一个线程因请求资源而阻塞时，不释放已获得的资源</li>
<li>不可抢占性：线程已经获得的资源，在主动释放前，不能强行剥夺</li>
<li>循环等待：若干线程对资源的等待构成了一种循环关系（充分必要）</li>
</ol>
<h4 id="如何避免-1"><a href="#如何避免-1" class="headerlink" title="如何避免"></a>如何避免</h4><h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><p>通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。</p>
<h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><p>允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。</p>
<h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><p>不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。</p>
<h5 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h5><p>与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测与解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</p>
<p>四种方法从上到下对死锁的防御程度逐渐减弱，但资源利用率和并发性得以提高。</p>
<p>在使用线程锁时，我们可以采用如下方法避免死锁：</p>
<ol>
<li>尽量避免一个线程对多个锁进行上锁</li>
<li>设置相同的加锁顺序，避免产生循环嵌套</li>
<li>使用定时锁，超时自动释放锁</li>
<li>死锁检测，使用某种算法检测是否成环</li>
<li>啥也不做（缩起头当鸵鸟），死锁了，就重启</li>
</ol>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>死锁很好理解，但是活锁是什么意思呢，假设两个线程互相谦让，都让对方先使用锁，那么最后两个线程也都得不到锁。</p>
<h4 id="如何避免-2"><a href="#如何避免-2" class="headerlink" title="如何避免"></a>如何避免</h4><ol>
<li>采用先到先服务的策略</li>
</ol>
<h3 id="锁使用原则"><a href="#锁使用原则" class="headerlink" title="锁使用原则"></a>锁使用原则</h3><p>在这里我们总结一下锁的使用原则：</p>
<ul>
<li>共享内存总应当由一个锁来进行保护</li>
<li>锁应当由所有使用者可见</li>
<li>对于所有的线程，应当有序使用锁</li>
<li>记得解锁</li>
<li>如果要将一个模块进行封装，那么该模块内部不要有锁</li>
</ul>
<h2 id="锁描述符"><a href="#锁描述符" class="headerlink" title="锁描述符"></a>锁描述符</h2><p>对于锁来说，我们同样需要一些数据结构来对其进行描述，常见的锁的关键数据如下：</p>
<ul>
<li>锁状态：上锁？解锁？</li>
<li>锁的拥有者：持有锁的线程</li>
<li>阻塞的线程列表：被锁阻塞的线程们</li>
</ul>
<h2 id="C-中关于各种锁的实现以及性能比较"><a href="#C-中关于各种锁的实现以及性能比较" class="headerlink" title="C++中关于各种锁的实现以及性能比较"></a>C++中关于各种锁的实现以及性能比较</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spin_mutex</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; flag = ATOMIC_VAR_INIT(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    spin_mutex() = <span class="keyword">default</span>;</span><br><span class="line">    spin_mutex(<span class="keyword">const</span> spin_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    spin_mutex&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> spin_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!flag.compare_exchange_strong(expected, <span class="literal">true</span>)) <span class="comment">//一个线程可以跳出while，而其他线程都处在while循环当中，直到某个线程释放了锁</span></span><br><span class="line">            expected = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag.store(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> size = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">atomic_long</span> <span class="title">total2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line">spin_mutex lock;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_click</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ++total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_click</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m.lock();   <span class="comment">//加锁</span></span><br><span class="line">        ++total;    <span class="comment">//被加锁保护的区域叫临界区</span></span><br><span class="line">        m.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_click</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ++total2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spinlock_click</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        ++total;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thnum = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; <span class="title">threads</span><span class="params">(thnum)</span></span>;</span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------- 单线程无锁 -----------------------</span></span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size * thnum; i++) &#123;</span><br><span class="line">        ++total;</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"single thread result: "</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"single thread time: "</span> &lt;&lt; end - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">//----------------------- 多线程无锁（结果不对，因为会出现脏读后写覆盖的问题） -----------------------</span></span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thnum; ++i) &#123;</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(thread_click);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thnum; ++i) &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"multi thread no mutex result: "</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"multi thread no mutex time: "</span> &lt;&lt; end - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">//----------------------- 多线程原子锁 -----------------------</span></span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thnum; ++i) &#123;</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(atomic_click);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thnum; ++i) &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"multi thread atomic result: "</span> &lt;&lt; total2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"multi thread atomic time: "</span> &lt;&lt; end - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">//----------------------- 多线程互斥锁 -----------------------</span></span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thnum; ++i) &#123;</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(mutex_click);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thnum; ++i) &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"multi thread mutex result: "</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"multi thread mutex time: "</span> &lt;&lt; end - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">//----------------------- 多线程自旋锁 -----------------------</span></span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thnum; ++i) &#123;</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(spinlock_click);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thnum; ++i) &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"spin lock result: "</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"spin lock time: "</span> &lt;&lt; end - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">single thread result: 100000000</span></span><br><span class="line"><span class="comment">single thread time: 231</span></span><br><span class="line"><span class="comment">multi thread no mutex result: 11501106</span></span><br><span class="line"><span class="comment">multi thread no mutex time: 261</span></span><br><span class="line"><span class="comment">multi thread atomic result: 100000000</span></span><br><span class="line"><span class="comment">multi thread atomic time: 1882</span></span><br><span class="line"><span class="comment">multi thread mutex result: 100000000</span></span><br><span class="line"><span class="comment">multi thread mutex time: 16882</span></span><br><span class="line"><span class="comment">spin lock result: 100000000</span></span><br><span class="line"><span class="comment">spin lock time: 45063   //其实这个场景不建议使用自旋锁</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://115.78.133.167:81/bitstream/TVHG_07113876976/270/1/OReilly%20-%20Understanding%20The%20Linux%20Kernel.pdf">Bovet D P, Cesati M. Understanding the Linux Kernel: from I/O ports to process management[M]. &quot; O'Reilly Media, Inc.&quot;, 2005.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://zhuanlan.zhihu.com/p/85511613">各种锁</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://blog.csdn.net/qccz123456/article/details/81329261">C++中对于互斥锁、原子锁及自旋锁的比较</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf">Birrell A D. An introduction to programming with threads[M]. Digital Systems Research Center, 1989.</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>页表管理</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%A1%B5%E8%A1%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将对页表管理的过程进行介绍</p>
<a id="more"></a>
<h1 id="TLB（translation-lookaside-buffer）功能"><a href="#TLB（translation-lookaside-buffer）功能" class="headerlink" title="TLB（translation lookaside buffer）功能"></a>TLB（translation lookaside buffer）功能</h1><p>加快页表转换速度，在上下文切换过程中，根据<code>ASID</code>号查询对应的页表缓存，<code>TTBR</code>寄存器会保存ASID字段</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>进程间通信</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>不要回答！不要回答！不要回答！</p>
</blockquote>
<a id="more"></a>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h3><p>在linux下创建pipe命令为<code>|</code>，可以进行进程间通信，它是进程间的一个单向数据流，一个写入一个读取。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls | more</span><br></pre></td></tr></table></figure>
<p>第一个进程的标准输出被重定向到管道中；第二个进程从这个管道中读取输入。管道可以看作一个打开的文件。</p>
<h3 id="管道工作过程"><a href="#管道工作过程" class="headerlink" title="管道工作过程"></a>管道工作过程</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>pipe的头文件和函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>输入为一个文件描述符数组，大小为2，保存两个文件描述符：</p>
<ul>
<li>filedes[0]：管道读取端，一般为3</li>
<li>filedes[1]：管道写入端，一般为4</li>
</ul>
<p>所以linux下的管道实际上是半双工的。如果创建管道失败，返回<code>-1</code>，否则返回<code>0</code>。</p>
<h3 id="管道的一些属性"><a href="#管道的一些属性" class="headerlink" title="管道的一些属性"></a>管道的一些属性</h3><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p>管道的大小不同的机器可能不同，下面是一个测试的脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">test $# -ge 1 || &#123; echo "usage: $0 write-size [wait-time]"; exit 1; &#125;</span><br><span class="line">test $# -ge 2 || set -- "$@" 1</span><br><span class="line">bytes_written=$(</span><br><span class="line">&#123;</span><br><span class="line">    exec 3&gt;&amp;1</span><br><span class="line">    &#123;</span><br><span class="line">        perl -e '</span><br><span class="line">            $size = $ARGV[0];</span><br><span class="line">            $block = q(a) x $size;</span><br><span class="line">            $num_written = 0;</span><br><span class="line">            sub report &#123; print STDERR $num_written * $size, qq(\n); &#125;</span><br><span class="line">            report; while (defined syswrite STDOUT, $block) &#123;</span><br><span class="line">                $num_written++; report;</span><br><span class="line">            &#125;</span><br><span class="line">        ' "$1" 2&gt;&amp;3</span><br><span class="line">    &#125; | (sleep "$2"; exec 0&lt;&amp;-);</span><br><span class="line">&#125; | tail -1</span><br><span class="line">)</span><br><span class="line">printf "write size: %10d; bytes successfully before error: %d\n" \</span><br><span class="line">    "$1" "$bytes_written"</span><br></pre></td></tr></table></figure>
<p>输入测试命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &apos;for p in &#123;0..18&#125;; do ts.sh $((2 ** $p)) 0.5; done&apos;</span><br></pre></td></tr></table></figure>
<p>在我这里是65536个byte。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>SQL基本语句及语法</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对SQL的基本语法进行总结。</p>
<a id="more"></a>
<h2 id="SQL语言分类"><a href="#SQL语言分类" class="headerlink" title="SQL语言分类"></a>SQL语言分类</h2><h3 id="数据查询语言DQL"><a href="#数据查询语言DQL" class="headerlink" title="数据查询语言DQL"></a>数据查询语言DQL</h3><p>select、from、where</p>
<h3 id="数据操作语言DML"><a href="#数据操作语言DML" class="headerlink" title="数据操作语言DML"></a>数据操作语言DML</h3><p>insert、update、delete</p>
<h3 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h3><p>create</p>
<h3 id="数据控制语言"><a href="#数据控制语言" class="headerlink" title="数据控制语言"></a>数据控制语言</h3><p>grant、rollback、commit</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本语句及语法"><a href="#基本语句及语法" class="headerlink" title="基本语句及语法"></a>基本语句及语法</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>用于从表中选取数据，返回结果被存储在一个表中。</p>
<h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名称 <span class="keyword">FROM</span> 表名称</span><br></pre></td></tr></table></figure>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Birthday,<span class="keyword">Name</span> <span class="keyword">FROM</span> person</span><br></pre></td></tr></table></figure>
<p>“Persons” 表:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Id</th>
<th style="text-align:left">Name</th>
<th style="text-align:left">Birthday</th>
<th style="text-align:left">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Duan</td>
<td style="text-align:left">19960108</td>
<td style="text-align:left">Taiyuan</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Zhang</td>
<td style="text-align:left">19950712</td>
<td style="text-align:left">Beijing</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">C</td>
<td style="text-align:left">19960805</td>
<td style="text-align:left">Beijing</td>
</tr>
</tbody>
</table>
</div>
<p>结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Birthday</th>
<th style="text-align:left">Name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">19960108</td>
<td style="text-align:left">Duan</td>
</tr>
<tr>
<td style="text-align:left">19950712</td>
<td style="text-align:left">Zhang</td>
</tr>
<tr>
<td style="text-align:left">19960805</td>
<td style="text-align:left">Wang</td>
</tr>
</tbody>
</table>
</div>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><p>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p>1 LeetCode 1378 <a href="https://leetcode-cn.com/problems/replace-employee-id-with-the-unique-identifier/">使用唯一标识码替换员工ID</a></p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Employees 表：</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是这张表的主键。</span><br><span class="line">这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。</span><br><span class="line"></span><br><span class="line">EmployeeUNI 表：</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| unique_id     | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(id, unique_id) 是这张表的主键。</span><br><span class="line">这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。</span><br><span class="line"></span><br><span class="line">写一段SQL查询来展示每位用户的 唯一标识码（unique ID ）；如果某位员工没有唯一标识码，使用 null 填充即可。</span><br><span class="line"></span><br><span class="line">EmployeeUNI table:</span><br><span class="line">+-----------+----------+</span><br><span class="line">| unique_id | name     |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| null      | Alice    |</span><br><span class="line">| null      | Bob      |</span><br><span class="line">| 2         | Meir     |</span><br><span class="line">| 3         | Winston  |</span><br><span class="line">| 1         | Jonathan |</span><br><span class="line">+-----------+----------+</span><br><span class="line"></span><br><span class="line">Alice and Bob 没有唯一标识码, 因此我们使用 null 替代。</span><br><span class="line">Meir 的唯一标识码是 2 。</span><br><span class="line">Winston 的唯一标识码是 3 。</span><br><span class="line">Jonathan 唯一标识码是 1 。</span><br></pre></td></tr></table></figure>

</div></div>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select EmployeeUNI.unique_id, Employees.name </span><br><span class="line">from Employees</span><br><span class="line">left join EmployeeUNI     #这一句代表即使Employees中某个员工在EmployeeUNI中没有匹配，依然返回Employees中所有行</span><br><span class="line">on EmployeeUNI.id = Employees.id</span><br></pre></td></tr></table></figure>
<h4 id="on-amp-where"><a href="#on-amp-where" class="headerlink" title="on &amp; where"></a>on &amp; where</h4><h5 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h5><p>条件过滤语句，用于筛选符合特定条件的数据，on和where在筛选条件上存在差异，具体如下：</p>
<ul>
<li>on条件触发于结果表生成时，不管on中条件是否为真，一定会返回左侧表中的记录（left join）<ul>
<li>where条件触发于结果表生成后，对结果表中条件进行过滤，不符合where的会被过滤掉。</li>
</ul>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.w3school.com.cn/sql/sql_select.asp">sql讲解</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/replace-employee-id-with-the-unique-identifier/">LeetCode sql相关例题</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数据存储</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>重要的东西，记得刻在石头上</p>
</blockquote>
<a id="more"></a>
<h2 id="物理存储介质"><a href="#物理存储介质" class="headerlink" title="物理存储介质"></a>物理存储介质</h2><p>考虑到数据库中庞大的数据量，数据一般存储于<strong>非挥发性的存储介质中</strong>，例如硬盘或者光盘中。其特点是便宜，量管够，但是速度感人，存取效率很低，所以在数据库相关算法设计中，我们要尽可能提高效率。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>关系数据模型</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我     生活在     太原市</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><p>数据库是经过组织的相关数据的集合，用于对客观世界的某种实体进行描述</p>
<h2 id="关系模型与关系数据库"><a href="#关系模型与关系数据库" class="headerlink" title="关系模型与关系数据库"></a>关系模型与关系数据库</h2><p>关系模型是<strong>最常用</strong>的一种数据库模型，本节将针对关系模型进行相关讲解。</p>
<h3 id="实体联系模型（ER模型）"><a href="#实体联系模型（ER模型）" class="headerlink" title="实体联系模型（ER模型）"></a>实体联系模型（ER模型）</h3><h4 id="模型举例"><a href="#模型举例" class="headerlink" title="模型举例"></a>模型举例</h4><p>ER模型表示的基本对象是<strong>实体</strong>（名词），例如一个学生，一个课程等。实体一般有一组属性，例如学生姓名、性别等。对象之间有<strong>关系</strong>(动词)，例如员工“工作在”那个部门，这个“工作在”就是关系。一个典型的ER模型如下图：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/database.png" alt=""></p>
<p>其中，带下划线的属性是主键，主键能够唯一确定一个元组。</p>
<h4 id="外键（foreign-key）"><a href="#外键（foreign-key）" class="headerlink" title="外键（foreign key）"></a>外键（foreign key）</h4><p>外键的作用是从一个关系中的属性映射到另一个关系中的一个元组，例如有下列两个实体集：</p>
<ul>
<li>音乐家实体集</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>year</th>
<th>country</th>
</tr>
</thead>
<tbody>
<tr>
<td>123</td>
<td>Wu</td>
<td>1992</td>
<td>China</td>
</tr>
<tr>
<td>456</td>
<td>Notoras</td>
<td>1992</td>
<td>USA</td>
</tr>
<tr>
<td>789</td>
<td>ICE</td>
<td>1989</td>
<td>USA</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>唱片集</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>11</td>
<td>Enter the world</td>
</tr>
<tr>
<td>22</td>
<td>Hello my girl</td>
</tr>
</tbody>
</table>
</div>
<p>在上面两个实体集中，如果我们想建立唱片集到音乐家实体集的映射，我们会发现一个唱片可能对应多个音乐家，这样的映射不容易建立，因此我们建立了一个新的关系集合如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>artist_id</th>
<th>album_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>123</td>
<td>11</td>
</tr>
<tr>
<td>123</td>
<td>22</td>
</tr>
<tr>
<td>789</td>
<td>22</td>
</tr>
</tbody>
</table>
</div>
<p>每个artist_id指向一个音乐家实体元组，而一个album_id指向一个唱片集元组。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数据库基本概念总结</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对数据库中的一些基本概念进行总结。</p>
<a id="more"></a>
<h2 id="数据库术语总结"><a href="#数据库术语总结" class="headerlink" title="数据库术语总结"></a>数据库术语总结</h2><h3 id="键"><a href="#键" class="headerlink" title="键"></a>键</h3><h4 id="主键（primary-key）"><a href="#主键（primary-key）" class="headerlink" title="主键（primary key）"></a>主键（primary key）</h4><p>主键是数据库中的一个列，在这个列中每一行的值都是<strong>唯一</strong>的，主键的作用是在不重复每个表中所有数据的情况下，将表间数据相互捆绑起来。</p>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>一个表中存在的另一个表的主键</p>
<h2 id="数据库三范式1"><a href="#数据库三范式1" class="headerlink" title="数据库三范式1"></a>数据库三范式<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><p>首先，<strong>满足第三范式一定满足第二范式，满足第二一定满足第一</strong>。</p>
<ul>
<li>第一范式：字段是最小的单元，不可再分，由基本类型例如INT、FLOAT等构成</li>
<li>第二范式：表中字段必须完全依赖全部主键而非部分主键，由于主键唯一，其他字段只要依赖主键，亦可保持唯一性</li>
<li>第三范式：非主键外所有字段必须互不依赖，一个数据只在一张表中存储，消除传递依赖。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://juejin.im/post/5a9ca0d6518825555c1d1acd">数据库常见面试题整理</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对数据库中事务的概念进行总结。</p>
<a id="more"></a>
<h2 id="事务的定义及性质"><a href="#事务的定义及性质" class="headerlink" title="事务的定义及性质"></a>事务的定义及性质</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>事务包含的操作要么全部成功，要么全部失败回滚，不允许提交不完整的操作</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务开始前后，数据库完整性约束不被破坏，不能A扣了钱，但B没有收到</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>并发访问数据库时，不同的事务要相互隔离，在A取钱过程结束前，B不能向内充值</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>一个事务一旦被提交，对数据的改变就是永久的，即使数据库故障，也不能丢失</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://juejin.im/post/5a9ca0d6518825555c1d1acd">数据库常见面试题整理</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>SQL基本语法</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在DBMS中，查询的过程可以概括为给提交查询请求，然后SQL语句将会自动生成查询计划并执行，在这个过程中，<strong>我们关心的到的结果是多少，而不关心结果是怎么得到的</strong>，因此一个高效的查询处理手段显得尤为重要。</p>
<a id="more"></a>
<h2 id="查询处理简介"><a href="#查询处理简介" class="headerlink" title="查询处理简介"></a>查询处理简介</h2><h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><p>数据库索引是数据库中经过排序的数据结构，用于协助完成快速查询、更新等功能。索引一般由B树或B+树实现，关于B树与B+树的详细内容请参考。这里只说区别及优缺点。</p>
<h5 id="B与B-树区别"><a href="#B与B-树区别" class="headerlink" title="B与B+树区别"></a>B与B+树区别</h5><ul>
<li>B树每个节点都存储key和data，叶节点为null，不包含任何信息</li>
<li>B+树所有叶子节点包含数据，以及指向下一个节点的指针；而非叶子节点可以视为索引部分</li>
</ul>
<h5 id="B-树优点"><a href="#B-树优点" class="headerlink" title="B+树优点"></a>B+树优点</h5><ul>
<li>内部节点小，读写代价低</li>
<li>查询效率更加稳定</li>
</ul>
<h4 id="索引特点"><a href="#索引特点" class="headerlink" title="索引特点"></a>索引特点</h4><ul>
<li>索引由数据库管理系统自动维护并决定何时使用</li>
<li>索引不需要用户在查询语句中指定</li>
<li>定义主键或单一约束后会自动在相应列创建索引</li>
<li>用户可以按照自己的需求对制定单个字段或多个字段添加索引</li>
</ul>
<h4 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>加速检索</li>
<li>索引可以使查询过程使用优化隐藏器，提高系统性能</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>降低增删改速度</li>
<li>占用资源</li>
</ul>
<h4 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h4><p>聚集索引<strong>表记录的排列顺序和索引的排列顺序一致，所以查询效率快</strong>；非聚集索引<strong>指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致</strong>。两者的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p>
<h4 id="何时要-不要创建索引"><a href="#何时要-不要创建索引" class="headerlink" title="何时要/不要创建索引"></a>何时要/不要创建索引</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">需要创建索引</th>
<th style="text-align:center">不需要创建索引</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">表经常性进行SELECT操作</td>
<td style="text-align:center">表经常性进行添加/删除或更新操作</td>
</tr>
<tr>
<td style="text-align:center">表很大</td>
<td style="text-align:center">表很小</td>
</tr>
<tr>
<td style="text-align:center">列名经常出现在WHERE或JOIN条件中</td>
<td style="text-align:center">列名不常出现在WHERE或JOIN条件中</td>
</tr>
</tbody>
</table>
</div>
<h3 id="查询预编译"><a href="#查询预编译" class="headerlink" title="查询预编译"></a>查询预编译</h3><p>查询预编译的过程包括两部分：语法分析与语义检查，从而生成一个合法的语法分析树。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>A*算法</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/A%E6%98%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>这世间纷纷扰扰，哪有那么多捷径可以走</p>
</blockquote>
<a id="more"></a>
<p>本文将针对游戏中常用的A*算法进行总结。</p>
<h2 id="搜索空间"><a href="#搜索空间" class="headerlink" title="搜索空间"></a>搜索空间</h2><p>假设我们在一个地图上希望从A点（绿色）走到B点（红色），且两点之间被墙壁分隔，每次我们可以朝8个方向中的一个进行走动，我们需要绕过蓝色墙从A走到B，并且路径最短。搜索空间就是地图中每一个可以走动的格子。</p>
<p><img src="https://uploads.gamedev.net/monthly_2018_05/aStarT1.jpg.d75d82a7b81262ca3d882353c92d0f51.jpg" width = "250"  alt="图片名称" align=center /></p>
<h2 id="开始搜索"><a href="#开始搜索" class="headerlink" title="开始搜索"></a>开始搜索</h2><p>当我们将地图用一个个节点进行划分后，接下来我们的任务是在节点集合中找到一个子集，可以连通两个点并且路径最短，寻找过程如下：</p>
<ul>
<li>第一步，从起点A开始，将其加入一个openlist中，代表可能的最短路径上的节点</li>
<li>第二步，把A节点相邻的可达节点都放入openlist中，将A节点设置为这些节点的父节点</li>
<li>第三步，把A从openlist删除，加入closelist中，closelist保存已经确定的最短路径上的节点</li>
</ul>
<p>当我们获得了保存有可能解的openlist后，下一步就是从中选择最优解，我们定义cost fun如下：</p>
<script type="math/tex; mode=display">
f=g+h</script><p>其中</p>
<ul>
<li>$g$为从A移动到指定方格的距离</li>
<li>$h$为从指定方格移动到B的估算距离，为何要估算呢，因为这个方格到B不一定是可达的，路上可能会遇到障碍而停下</li>
</ul>
<p>之后我们根据$f$对openlist进行排序，下面我们对上面的例子进行一个计算，假设纵横向移动距离为10，斜向移动距离为14，那么得到的结果如下，每个格子上标注了其$g$和$h$的值。</p>
<p><img src="http://www.cppblog.com/images/cppblog_com/christanxw/image003.jpg" width = "350"  alt="图片名称" align=center /></p>
<h2 id="继续搜索"><a href="#继续搜索" class="headerlink" title="继续搜索"></a>继续搜索</h2><p>从图中可以看出，A点右侧节点$f$值最小，选择该节点作为下一步节点，将其移动至closelist</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Listen, the tree is growing silently</p>
</blockquote>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="What-and-why-tree"><a href="#What-and-why-tree" class="headerlink" title="What and why tree"></a>What and why tree</h3><ul>
<li>一种层次数据结构</li>
<li>节点有值和位置两个属性</li>
<li>有根节点，每个节点可以有左子树和右子树</li>
</ul>
<p>在<strong>插入、删除、搜索</strong>方面，树相较于数组和链表O(n)，更有优势O(log(n))。</p>
<h3 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h3><ul>
<li><strong>Root 根</strong>: 没有parent的节点</li>
<li><strong>Edge 枝</strong>: 父子间的连接</li>
<li><strong>Leaf 叶</strong>: 没有child的节点</li>
<li><strong>sibling 兄弟</strong>: 有相同parent的节点</li>
<li><strong>ancestor 祖先</strong>: 一个节点的父亲，爷爷、祖宗</li>
<li><strong>Depth of node 节点深度</strong>: 从一个节点到根节点的路径长度</li>
<li><strong>Height of node 节点高度</strong>: 从一个节点到最深的节点的路径长度（越往下越深）</li>
<li><strong>Height of a tree 树高</strong>: 即根节点的高度</li>
<li><strong>层数</strong>（深度）：规定根节点在1层，其他任意节点层数为父节点层数+1</li>
<li><strong>predecessor 前任</strong>: 将树的各个节点以顺序方式组织，则某个节点前面的相邻节点叫做该节点的前任，例如一个树为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40,50,60,70,80,90,100</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>那么值为60的节点前任就是50</p>
<ul>
<li><strong>successor 继任</strong>:<br>和前任类似，只是后面的相邻节点</li>
</ul>
<h3 id="树的组成"><a href="#树的组成" class="headerlink" title="树的组成"></a>树的组成</h3><p>一个二叉树包含左右子节点和键值，其类如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树基本知识"><a href="#二叉树基本知识" class="headerlink" title="二叉树基本知识"></a>二叉树基本知识</h2><p>二叉树就是最多只能有两个子节点的树。本章讨论二叉查找树，即左子树节点值&lt;根节点&lt;右子树节点值，二叉树是一个数据结构家族（二叉搜索树BST，堆树，AVL树，红黑树，语法树，霍夫曼编码树等等）。<br>二叉树应用在特定的问题中，例如霍夫曼编码、优先队列及表达式解析。</p>
<h3 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h3><h4 id="性质1：在二叉树第-i-层至多-2-i-1-个节点"><a href="#性质1：在二叉树第-i-层至多-2-i-1-个节点" class="headerlink" title="性质1：在二叉树第$i$层至多$2^{(i-1)}$个节点"></a>性质1：在二叉树第$i$层至多$2^{(i-1)}$个节点</h4><p>证明过程采用归纳法</p>
<ul>
<li>$i=1$时只有根节点，显然成立</li>
<li>设对所有$j$，$i&gt;j\ge1$均有命题成立，第$j$层至多$2^{j-1}$个节点</li>
<li>由归纳假设，第$i-1$层至多$2^{i-2}$个节点</li>
<li>由于每个节点度至多为2，故第$i$层最大节点数为$i-1$层节点数的2倍，即$2\times2^{i-2}=2^{i-1}$</li>
</ul>
<h4 id="性质2：深度为-k-的二叉树至多有-2-k-1-个节点"><a href="#性质2：深度为-k-的二叉树至多有-2-k-1-个节点" class="headerlink" title="性质2：深度为$k$的二叉树至多有$2^k-1$个节点"></a>性质2：深度为$k$的二叉树至多有$2^k-1$个节点</h4><p>只需将每一层最大节点数相加即可</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{k}2^{i-1}=2^0+2^1+\cdots+2^{k-1} =2^k-1</script><h4 id="性质3：具有-n-个"><a href="#性质3：具有-n-个" class="headerlink" title="性质3：具有$n$个"></a>性质3：具有$n$个</h4><h3 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h3><ul>
<li>严格二叉树: 每个节点要么有两个子节点，要么没有（要么不生，要么二胎）</li>
<li>满二叉树: 每个非叶节点有两个子节点，所有叶节点位于同一层</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/FullBinary.jpg" width = "250"  alt="图片名称" align=center /></p>
<ul>
<li><p>完全二叉树: 所有层都满填充，除了最后一层，并且最后一层节点尽可能靠左</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/CompleteBinary.jpg" width = "250"  alt="图片名称" align=center /></p>
</li>
</ul>
<h3 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h3><p>二叉树可以用或<strong>链表</strong>或<strong>数组</strong>实现（链表更方便）<br>用链表实现的树如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Binary_Tree_Linked_List_Representation.png" width = "450"  alt="图片名称" align=center /></p>
<p>每个节点包括数据、左指针和右指针。<br>用数组实现的树如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/img1156.png" width = "350"  alt="图片名称" align=center /></p>
<p>如何表示每个节点在数组中的位置呢，我们使用如下策略，首先，根节点放置在数组下标为1的位置（不是0,为了方便计算），左右节点根据父节点下标，按照下面的公式计算位置：</p>
<ul>
<li>左节点: array[2x]</li>
<li>右节点: array[2x + 1]<br>其中x是父节点在数组中的位置。</li>
</ul>
<h3 id="二叉树的操作"><a href="#二叉树的操作" class="headerlink" title="二叉树的操作"></a>二叉树的操作</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>二叉树最重要的一个操作即为递归操作，下面的操作基本上都是由二叉树的递归操作演变来的，故二叉树的递归操作的框架需要掌握。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回1</span></span><br><span class="line">    <span class="comment">//相关操作</span></span><br><span class="line">    </span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>六个操作：创建、插入节点、删除节点、搜索、遍历和删除树</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><code>create()</code>: 创建一个空树对象<br>时间与空间复杂度都是$O(1)$</p>
<p>leetcode 654：根据已有数组创建符合条件的树</p>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<p>二叉树的根是数组中的最大元素。<br>左子树是通过数组中最大值左边部分构造出的最大二叉树。<br>右子树是通过数组中最大值右边部分构造出的最大二叉树。<br>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,2,1,6,0,5]</span><br><span class="line">输出：返回下面这棵树的根节点：</span><br><span class="line"></span><br><span class="line">      6</span><br><span class="line">    /   \</span><br><span class="line">   3     5</span><br><span class="line">    \    / </span><br><span class="line">     2  0   </span><br><span class="line">       \</span><br><span class="line">        1</span><br></pre></td></tr></table></figure>
<p>解答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//实际上是遍历的逆向过程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vec_int_it;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,vec_int_it l, vec_int_it r)</span></span>&#123;   <span class="comment">//给定数组的范围作为子树</span></span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">//递归停止条件</span></span><br><span class="line">        vec_int_it max_it = max_element(l,r);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(*max_it);   <span class="comment">//根据当前数组中最大值创建新节点</span></span><br><span class="line">        root -&gt; left = constructMaximumBinaryTree(nums,l,max_it);     <span class="comment">//递归过程，先构造左子树</span></span><br><span class="line">        root -&gt; right = constructMaximumBinaryTree(nums,max_it+<span class="number">1</span>,r);  <span class="comment">//再构造右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;   <span class="comment">//返回节点指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree(nums, nums.begin(), nums.end());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p>
<blockquote>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p>
<p>返回如下的二叉树(假设树中没有重复节点)：</p>
<p>​     3</p>
<p>  /    \<br> 9    20<br>       /  \<br>    15   7</p>
</blockquote>
<p>这道题目思路不难，但是写法上有一些需要注意的事情，下面结合代码对本题进行讲解。</p>
<p><strong>思路</strong></p>
<ul>
<li>从前序遍历可以获得根节点，前序遍历为[根节点, [左子树], [右子树]]</li>
<li>从中序遍历可以获得左右子树以及其长度，中序遍历为[[左子树], 根节点, [右子树]]</li>
</ul>
<p><strong>代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> pre_start, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> in_start, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> in_end, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; inorder_index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre_start &gt;= preorder.size() || in_start &gt; in_end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[pre_start]);    <span class="comment">//根节点的值</span></span><br><span class="line">    <span class="keyword">int</span> in_index = inorder_index[root-&gt;val];               <span class="comment">//根据根节点的值找到根节点在inorder中的位置</span></span><br><span class="line">    root-&gt;left  = helper(pre_start + <span class="number">1</span>,                       in_start,     in_index - <span class="number">1</span>, preorder, inorder, inorder_index);    <span class="comment">//左子树在根节点左侧  左子树根节点在preorder中位于根节点右侧</span></span><br><span class="line">    root-&gt;right = helper(pre_start + in_index - in_start + <span class="number">1</span>, in_index + <span class="number">1</span>, in_end,       preorder, inorder, inorder_index);   <span class="comment">//右子树在根节点右侧  右子树根节点在preorder中位于根节点右侧加左子树长度的位置处，即pre_start + 1, 而左子树的长度为in_index - in_start</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><blockquote>
<p>这一部分内容比较多，请参考<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>6.4节<br><code>traverse()</code>: 遍历树，将树线性化，每个节点只访问一次<br>遍历树的方式分为两大种，深度优先与广度优先</p>
<h5 id="深度优先（按照根的位置进行遍历）"><a href="#深度优先（按照根的位置进行遍历）" class="headerlink" title="深度优先（按照根的位置进行遍历）"></a>深度优先（按照根的位置进行遍历）</h5></blockquote>
<h6 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h6><ul>
<li>前序（preorder）遍历：从根开始，先左子树，再右子树，递归进行，第一个肯定是根节点</li>
<li>中序（inorder）遍历: 先左子树，再访问根，最后右子树（<strong>对二叉搜索树进行中序遍历可以输出一个升序数组（或降序，只要按照右中左的顺序即可）</strong>），中序遍历实际上就是先探到树底部，然后再自底向上依次对节点进行处理。在中序遍历中，根节点的两边就可以分出左右子树。</li>
</ul>
<p><strong>前序和中序可以唯一确定二叉树，后序不行</strong></p>
<ul>
<li>后序（postorder）遍历: 先左子树，再右子树，最后访问根节点，最后一个肯定是根节点</li>
</ul>
<p>前中后序的递归遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(TreeNode * Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, Node-&gt;data);</span><br><span class="line">        pre_order(Node-&gt;left);</span><br><span class="line">        pre_order(Node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle_order</span><span class="params">(TreeNode *Node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        middle_order(Node-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, Node-&gt;data);</span><br><span class="line">        middle_order(Node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">postOrder1</span><span class="params">(TreeNode *Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Node!=null)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        postOrder(Node-&gt;left);</span><br><span class="line">        postOrder(Node-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, Node-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>前序应用</strong></p>
<p>由于前序遍历先对节点值判断，因此前序遍历可以用在判断两棵树的结构是否相同上。</p>
<p>例题1 LeetCode 100 判断两树是否相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val == q-&gt;val)&#123;   <span class="comment">//如果节点相同</span></span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);   <span class="comment">//判断左右孩子是否相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题2 LeetCode 面试题26 树的子结构</p>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)，B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 4   5</span><br><span class="line">/ \</span><br><span class="line">1  2</span><br></pre></td></tr></table></figure>
<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>思路</strong></p>
<p>首先处理特例，当A或B为空时，直接返回false。然后如果树B是树A的字结构，必须满足三种情况，用||进行连接</p>
<ul>
<li>以节点A为根节点的树包含树B：这里我们不妨写一个dfs函数专门进行判断 dfs(A,B);</li>
<li>树B是树A的左子树的子结构：<code>isSubStructure(A-&gt;left, B)</code></li>
<li>树B是树A的右子树的子结构：<code>isSubStructure(A-&gt;right, B)</code></li>
</ul>
<p>在dfs中，又对应四种情况</p>
<ul>
<li>如果节点B为空，说明B已经匹配完成，即越过叶子节点，返回true</li>
<li>如果节点A为空，说明已经越过A的叶子节点，返回false</li>
<li>当A和B节点值不同，说明匹配失败，返回false</li>
<li>当A和B节点值相同，那么继续匹配A左B左，A右B右，即dfs(A-&gt;left,B-&gt;left) &amp;&amp; dfs(A-&gt;right, B-&gt;right)</li>
</ul>
<h6 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h6><p>用递归很方便，考虑使用迭代实现深度优先搜索呢？将递归改为迭代，往往要用到栈或队列（广度优先算法），实例详见<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，非递归的版本要比递归的复杂许多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans&#123;&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode* &gt; tree_stack&#123;&#125;;</span><br><span class="line">    TreeNode* curr = root;</span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="literal">nullptr</span> || !tree_stack.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            tree_stack.push(curr);</span><br><span class="line">            curr = curr-&gt;left;        <span class="comment">//先一路压到左侧节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        curr = tree_stack.top();     <span class="comment">//然后依次弹出</span></span><br><span class="line">        tree_stack.pop();</span><br><span class="line">        ans.push_back(curr-&gt;val);    <span class="comment">//获取当前节点值分析</span></span><br><span class="line"></span><br><span class="line">        curr = curr-&gt;right;    <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是前序操作的，和中序略有区别，压栈要先压右孩子再压左孩子<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果可以的话，尽量使用前序遍历，因为比较简单</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BST&lt;T&gt;::preorder()&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BSTNode&lt;T&gt; *&gt; tree_stack;</span><br><span class="line">    BSTNode&lt;T&gt; *p = root;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        tree_stack.push(p);</span><br><span class="line">        <span class="keyword">while</span>(!tree_stack.empty())&#123;</span><br><span class="line">            <span class="comment">//访问</span></span><br><span class="line">            p = tree_stack.top();</span><br><span class="line">            tree_stack.pop();</span><br><span class="line">            visit(p);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//压入新节点</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                tree_stack.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                tree_stack.push(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后序操作，后序操作需要用到两个栈，类似反复倒水的原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s1&#123;&#125;;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s2&#123;&#125;;</span><br><span class="line">    s1.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">        root = s1.top();</span><br><span class="line">        s1.pop();</span><br><span class="line">        </span><br><span class="line">        s2.push(root);    <span class="comment">//在节点由栈1向栈2转移的过程中，右节点会被压在下面</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            s1.push(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) </span><br><span class="line">            s1.push(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s2.empty())&#123;</span><br><span class="line">        root = s2.top();</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h6><p><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串</a></p>
<p><a href="https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/">1026. 节点与其祖先之间的最大差值</a></p>
<blockquote>
<p>给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p>
</blockquote>
<p>思路</p>
<p>一开始的思路是从每个节点开始，以此访问以该节点作为根节点的树，求最大值，这种方式时间效率太低，看了别人的答案发现可以将祖先节点中的最大值与最小值进行保存，从而直接以当前节点的最大值最小值进行比较即可。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, root-&gt;val, root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="keyword">int</span> up, <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = max(max(<span class="built_in">abs</span>(node-&gt;val - up), <span class="built_in">abs</span>(node-&gt;val - low)), result);</span><br><span class="line">        up = max(node-&gt;val, up);</span><br><span class="line">        low = min(node-&gt;val, low);</span><br><span class="line">        dfs(node-&gt;left, up, low);</span><br><span class="line">        dfs(node-&gt;right, up, low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="广度优先-层序遍历"><a href="#广度优先-层序遍历" class="headerlink" title="广度优先(层序遍历)"></a>广度优先(层序遍历)</h5><ul>
<li>层次（levelorder）遍历: 一层一层逐层从左到右访问，使用queue实现，LeetCode411</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*自顶向下的层次遍历*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode* &gt; tree_node&#123;&#125;;        <span class="comment">// 创建队列</span></span><br><span class="line">        tree_node.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!tree_node.empty())&#123;            <span class="comment">//树没有访问结束</span></span><br><span class="line">            <span class="keyword">int</span> width = tree_node.size();     <span class="comment">//每一层宽度，如果要统计每一层的值，必须知道每一层的宽度，否则不需要</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp&#123;&#125;;               <span class="comment">// 记录每一层中值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;         <span class="comment">//访问每一层每一个节点                </span></span><br><span class="line">                <span class="keyword">auto</span> p = tree_node.front();</span><br><span class="line">                tree_node.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)  tree_node.push(p-&gt;left);  <span class="comment">//添加左子树根节点</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right) tree_node.push(p-&gt;right);  <span class="comment">//添加右子树根节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析<br> 上述遍历方法时间和空间复杂度全部都是$O(n)$，但是得到的树的表示方法不一样。  </p>
<h6 id="相关例题-1"><a href="#相关例题-1" class="headerlink" title="相关例题"></a>相关例题</h6><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></p>
<p>给定二叉树如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充其每个next指针，让这个指针指向同一层下一个右侧节点，如果找不到，将next指针设置为nullptr。</p>
<p>思路</p>
<p>使用层序遍历可以方便地完成上述内容，但是空间复杂度为$O(N)$，为了进一步降低空间复杂度，我们可以利用已经被连接的next指针进行层内转移，而对于层间转移，我们可以提前设置一个哑节点，指向下一层的最左侧的节点，然后利用该节点进行层间转移</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123; <span class="comment">//遍历所有层</span></span><br><span class="line">        Node* dummy = <span class="keyword">new</span> Node();</span><br><span class="line">        Node* tail = dummy;</span><br><span class="line">        <span class="comment">//遍历 cur 的当前层</span></span><br><span class="line">        <span class="keyword">while</span> (cur != null) &#123; </span><br><span class="line">            <span class="comment">//将cur下一层进行串联</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != null) &#123;</span><br><span class="line">                tail-&gt;next = cur-&gt;left;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != null) &#123;</span><br><span class="line">                tail-&gt;next = cur-&gt;right;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//层间转移</span></span><br><span class="line">        cur = dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/binary-tree-vertical-order-traversal/">314. 二叉树的垂直遍历</a></p>
<blockquote>
<p>给定一个二叉树，返回其结点 <em>垂直方向</em>（从上到下，逐列）遍历的值。如果两个结点在同一行和列，那么顺序则为 <strong>从左到右</strong>。</p>
</blockquote>
<p>思路</p>
<p>在本题中，我们不仅需要找到节点的横向相对位移，同时也要保证节点深度是从小到大排列的，这要求我们使用广度优先搜索进行操作。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">verticalOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; state;</span><br><span class="line">        q.push(root);</span><br><span class="line">        state.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = q.front();</span><br><span class="line">            <span class="keyword">auto</span> temp_state = state.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            state.pop();</span><br><span class="line"></span><br><span class="line">            ans[temp_state].push_back(temp-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                q.push(temp-&gt;left);</span><br><span class="line">                state.push(temp_state - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                q.push(temp-&gt;right);</span><br><span class="line">                state.push(temp_state + <span class="number">1</span>);</span><br><span class="line">            &#125;           </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ordered_ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it:ans)&#123;</span><br><span class="line">            ordered_ans.push_back(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ordered_ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="Morris遍历4"><a href="#Morris遍历4" class="headerlink" title="Morris遍历4"></a>Morris遍历<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></h5><p>Morris遍历可以将非递归遍历中的空间复杂度降低为O(1)，该算法利用树的叶节点左右孩子为空，实现空间的压缩</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>我们以二叉搜索树为例，其中序遍历为<code>1,2,3,4,5,6,7,8,9,10</code>，给定某个节点cur，定义其前序节点pre为遍历过程中得到的序列的前一个节点，例如节点<code>4</code>其前序节点为<code>3</code>。那么我们的问题是如何找到一个节点的前序节点，在Morris遍历中，我们需要实现以下原则：</p>
<ul>
<li>如果左子节点的右子节点指针为空，那么左子节点即为<code>cur</code>的前序节点</li>
<li>如果当前节点无左孩子，且该节点为父节点的右孩子，那么父节点即为前序节点，例如8的前序节点为7</li>
<li>如果当前节点无左孩子且该节点为父节点的左孩子，那么它没有前序节点，并且该节点为首节点，例如节点<code>1</code></li>
</ul>
<h6 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h6><ol>
<li>根据当前节点找到前序节点，如果前序节点右孩子为空，那么把前序节点右孩子指向当前节点(这样我们可以直接通过前序节点找到当前节点)，然后进入当前节点左孩子</li>
<li>如果当前节点左孩子为空，打印当前节点，然后进入右孩子</li>
<li>如果当前节点的前序节点其右孩子指向了它本身，那么把前序节点的右孩子设置为空，打印当前节点，然后进入右孩子。</li>
</ol>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderMorrisTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    TreeNode *cur = root, *prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span>)          <span class="comment">// 1.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// find predecessor</span></span><br><span class="line">            prev = cur-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (prev-&gt;right != <span class="literal">NULL</span> &amp;&amp; prev-&gt;right != cur)</span><br><span class="line">                prev = prev-&gt;right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;right == <span class="literal">NULL</span>)   <span class="comment">// 2.a)</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                       <span class="comment">// 2.b)</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="专题：根据前中后序中两个推剩余一个"><a href="#专题：根据前中后序中两个推剩余一个" class="headerlink" title="专题：根据前中后序中两个推剩余一个"></a>专题：根据前中后序中两个推剩余一个</h5><p>遍历中有一类问题，根据前中序遍历，求后序遍历，假设：</p>
<ul>
<li>前序遍历的顺序是: CABGHEDF（前序确定根节点）</li>
<li>中序遍历的顺序是: GHBACDEF（中序确定左右树）</li>
</ul>
<p>1.前序可知C是根节点，中序可知左子树为GHBA，右子树为DEF。</p>
<pre class="mermaid">graph TB
    node1((C))
    node2((GHBA))
    node3((DEF))

    node1---node2
    node1---node3</pre>

<p>2.取出左子树，左子树的前序遍历是：ABGH，中序遍历是：GHBA，可知左子树根节点为A，左子树为GHB，没有右子树</p>
<pre class="mermaid">graph TB
    node1((C))
    node2((A))
    node3((DEF))
    node4((GBH))

    node1---node2
    node1---node3
    node2---node4</pre>

<p>3.以此类推，即可得到完整的树为：</p>
<pre class="mermaid">graph TB
    node1((C))
    node2((A))
    node3((E))
    node4((B))
    node5((D))
    node6((F))
    node7((G))
    node8((H))

    node1---node2
    node1---node3
    node2---node4
    node4---node7
    node7---node8

    node3---node5
    node3---node6</pre>

<p>其后序遍历为HGBADFEC</p>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* BST&lt;T&gt;::search(BSTNode&lt;T&gt;* p, <span class="keyword">const</span> T&amp; el) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(el == p-&gt;el)</span><br><span class="line">            <span class="keyword">return</span> &amp;p-&gt;el;     <span class="comment">//搜索到，返回指定值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(el &lt; p-&gt;el)    <span class="comment">//目标比当前节点小，向左子树搜索</span></span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//没有搜到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏情况下，树转换为链表，时间复杂度为$O(n)$，一般情况下为$O(\text{lg}n)$。</p>
<h4 id="判断是否平衡"><a href="#判断是否平衡" class="headerlink" title="判断是否平衡"></a>判断是否平衡</h4><p>LeetCode110：给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<p><strong>注意，要保证每个节点左右子树高度差绝对值均不超过1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算树高</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(calHeight(root-&gt;left), calHeight(root-&gt;right)); <span class="comment">//每一次深入都将使树高加1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否平衡</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(calHeight(root-&gt;left)-calHeight(root-&gt;right)) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//每一个分支都要考虑到</span></span><br><span class="line">    <span class="keyword">return</span> (isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树相关技巧"><a href="#二叉树相关技巧" class="headerlink" title="二叉树相关技巧"></a>二叉树相关技巧</h2><h3 id="使用哑节点避免边界讨论"><a href="#使用哑节点避免边界讨论" class="headerlink" title="使用哑节点避免边界讨论"></a>使用哑节点避免边界讨论</h3><p>和链表处理方式类似，对于二叉树，我们同样可以使用哑节点的方式，回避掉一些边界讨论，例如<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></p>
<blockquote>
<p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
</blockquote>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><h3 id="堆（优先队列）"><a href="#堆（优先队列）" class="headerlink" title="堆（优先队列）"></a>堆（优先队列）</h3><p>堆是一种特殊的树状结构，堆又被称为优先队列（实际并不是队列），堆实际上划分出了元素的优先级，堆的实例很常见，例如：<strong>商务舱的旅客先上车、一等座的旅客次之、二等座最后</strong>，另一个例子是linux中的调度器，高优先级的进程优先执行、低优先级的会等待。</p>
<h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h4><p>堆的经典实现是利用完全二叉树，为了实现堆操作，需要额外规定：<strong>任意节点优先级不小于其子节点</strong>，若母节点的值恒<strong>小于等于</strong>子节点的值，此堆称为<strong>最小堆</strong>（min heap）；反之，若母节点的值恒<strong>大于等于</strong>子节点的值，此堆称为<strong>最大堆</strong>（max heap）。在堆中最顶端的那一个节点，称作<strong>根节点</strong>（root node），根节点本身没有<strong>母节点</strong>（parent node）。</p>
<h4 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h4><p>堆的一个经典应用是<strong>堆排序</strong>，例题如LeetCode 215，在未排序的数组中找到第 <strong>k</strong> 个最大的元素。朴素的算法是先排序再输出第k个最大元素，这样的复杂度不是很理想，我们可以维护一个大小始终为k的最小堆，遍历整个数组，当遍历完成后，数组顶端的元素就是第 <strong>k</strong> 个最大的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; heap&#123;&#125;;  <span class="comment">//最小堆，如果是最大堆直接priority_queue&lt;int&gt;即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:nums)&#123;</span><br><span class="line">            heap.push(v);</span><br><span class="line">            <span class="keyword">if</span>(heap.size()&gt;k)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; heap.top();</span><br><span class="line">                heap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> heap.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><h4 id="完全二叉树定义"><a href="#完全二叉树定义" class="headerlink" title="完全二叉树定义"></a>完全二叉树定义</h4><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<h4 id="完全二叉树节点数目计算"><a href="#完全二叉树节点数目计算" class="headerlink" title="完全二叉树节点数目计算"></a>完全二叉树节点数目计算</h4><p>假设树的高度为$d$，那么第0层有$2^0=1$个节点，第$k$层有$2^{k}$个节点，除了最后一层以外的所有节点数为：$\sum_{k=0}^{k=d-1}2^k=2^d-1$，所以完全二叉树的节点数目计算问题可以退化为计算树高以及最后一层的节点数目，我们可以使用二分搜索的方式计算最后一层节点数目。同时，由于完全二叉树的定义，其树高的计算可以简化，一直循环直到左子数为空，即可计算得到树高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Return tree depth in O(d) time.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">      ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Last level nodes are enumerated from 0 to 2**d - 1 (left -&gt; right).</span></span><br><span class="line">  <span class="comment">// Return True if last level node idx exists. </span></span><br><span class="line">  <span class="comment">// Binary search with O(d) complexity.</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 树的二分搜索框架</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> d, TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, d) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i) &#123;   <span class="comment">//遍历每一层</span></span><br><span class="line">      pivot = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (idx &lt;= pivot) &#123;       <span class="comment">//在当前节点左侧</span></span><br><span class="line">        node = node.left;       <span class="comment">//？？？？</span></span><br><span class="line">        right = pivot;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;                    <span class="comment">//在当前节点右侧</span></span><br><span class="line">        node = node.right;</span><br><span class="line">        left = pivot + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the tree is empty</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = computeDepth(root);</span><br><span class="line">    <span class="comment">// if the tree contains 1 node</span></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Last level nodes are enumerated from 0 to 2**d - 1 (left -&gt; right).</span></span><br><span class="line">    <span class="comment">// Perform binary search to check how many nodes exist.</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, d) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivot = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (exists(pivot, d, root)) left = pivot + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> right = pivot - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The tree contains 2**d - 1 nodes on the first (d - 1) levels</span></span><br><span class="line">    <span class="comment">// and left nodes on the last level.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, d) - <span class="number">1</span> + left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h4 id="二叉搜索树的特性"><a href="#二叉搜索树的特性" class="headerlink" title="二叉搜索树的特性"></a>二叉搜索树的特性</h4><ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数；节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
<li><p>空树是二叉搜索树</p>
</li>
<li><p>一个二叉搜索树的前序遍历一定是<strong>局部递减，整体递增</strong>的，利用这个性质我们可以判断一个数列是否为二叉搜索树前序遍历。局部递减是指左子数可能是递减的，而整体递增是因为右子树节点值大于左子树节点值，因此按照先访问左子树再访问右子树的顺序，得到的一定是整体递增的</p>
</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/">255. 验证前序遍历序列二叉搜索树</a><br>给定一个整数数组，你需要验证它是否是一个二叉搜索树正确的先序遍历序列。你可以假定该序列中的数都是不相同的。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br><span class="line"></span><br><span class="line">[5,2,1,3,6]</span><br><span class="line"></span><br><span class="line">左子树为2 1 3,符合局部递减，整体递增，整颗树亦符合</span><br></pre></td></tr></table></figure>
<ul>
<li>一个二叉搜索树的中序遍历可以获得升序或降序的数组</li>
</ul>
<h4 id="二叉搜索树常见操作"><a href="#二叉搜索树常见操作" class="headerlink" title="二叉搜索树常见操作"></a>二叉搜索树常见操作</h4><h5 id="二叉搜索树的中序遍历"><a href="#二叉搜索树的中序遍历" class="headerlink" title="二叉搜索树的中序遍历"></a>二叉搜索树的中序遍历</h5><p>二叉搜索树由于其特殊性质，中序遍历的结果为一个单调数组，根据这一特性，我们在解决二叉搜索树问题时，可以优先考虑中序遍历。中序遍历有两种，分别为左中右和右中左，对应的数组分别为递增和递减。</p>
<p>例题</p>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></p>
<p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p>思路</p>
<p>当我们以右中左的顺序遍历二叉树时，可以得到单调递减的数列，那么我们只要求这个数列的前缀和，即可将树改造为题目的要求</p>
<h5 id="验证是否为二叉搜索树-LeetCode98"><a href="#验证是否为二叉搜索树-LeetCode98" class="headerlink" title="验证是否为二叉搜索树(LeetCode98)"></a>验证是否为二叉搜索树(LeetCode98)</h5><p>给定二叉树，判断是否为二叉搜索树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个问题中的一个难点是，当前的树和左右子树都必须为二叉搜索树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> lower, <span class="keyword">long</span> <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="二叉搜索树中的索引"><a href="#二叉搜索树中的索引" class="headerlink" title="二叉搜索树中的索引"></a>二叉搜索树中的索引</h5><p>由于二叉搜索树的特性，在二叉搜索树中索引某一个值，一定会出现三种情况：</p>
<ul>
<li>如果<code>root-&gt;val == target</code> ，返回</li>
<li>如果<code>root-&gt;val &lt; target</code>，那么我们需要到root的右子树中寻找</li>
<li>如果<code>root-&gt;val &gt; target</code>，那么我们需要到root的左子树中寻找</li>
</ul>
<p>例题1 <a href="https://leetcode-cn.com/problems/inorder-successor-in-bst/"> 二叉搜索树中的顺序后继</a></p>
<blockquote>
<p>给你一个二叉搜索树和其中的某一个结点，请你找出该结点在树中顺序后继的节点。结点 <code>p</code> 的后继是值比 <code>p.val</code> 大的结点中键值最小的结点。</p>
</blockquote>
<p>思路：</p>
<p>这个题的一般思路是中序遍历二叉树得到递增序列然后找到后继结点，但是这样没有充分利用二叉搜索树的特性，我们可以按照索引的三种情况，搜索后继结点，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; p-&gt;val)&#123;</span><br><span class="line">            res = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树相关例题"><a href="#二叉搜索树相关例题" class="headerlink" title="二叉搜索树相关例题"></a>二叉搜索树相关例题</h4><p><a href="https://leetcode-cn.com/problems/binode-lcci/">面试题 17.12. BiNode</a></p>
<blockquote>
<p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求值的顺序保持不变，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
<p>输入： [4,2,5,1,3,null,6,0]<br>输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]</p>
</blockquote>
<p>思路</p>
<p>看到升序序列，一定是二叉搜索树的中序遍历，故我们先写好中序遍历的框架，然后考虑如何对树进行修改。假设我们当前访问的树节点为curr，那么我们首先要做的操作是将该节点左子树置空，然后将该节点拼接至前一个节点的右子树上，所以我们需要一个节点prev记录中序遍历过程中的前一个节点。同时，为了处理链表起始的情况，我们定义一个哑节点head，一开始prev=head，最后返回head-&gt;next</p>
<pre class="mermaid">graph TB
    node1((4))
    node2((2))
    node3((5))
    node4((1))
    node5((3))
    node6((null))
    node7((6))
    node8((0))


    node1-->node2
    node1-->node3
    node2-->node4
    node2-->node5
    node3-->node6
    node3-->node7
    node4-->node8</pre>

<p>如上图所示，经过前序便利，curr分别为0,1,2,3,4,5,6，而prev为head,0,1,2,3,4,5，算法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历过程中</span></span><br><span class="line">curr-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">prev-&gt;right = curr;</span><br><span class="line">prev = curr;</span><br></pre></td></tr></table></figure>
<p>代码</p>
<p>使用遍历进行修改的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBiNode</span><span class="params">(TreeNode* root)</span> </span>&#123;   <span class="comment">//返回链表头节点</span></span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; node_stack&#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        TreeNode* head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode* prev = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">nullptr</span> || !node_stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                node_stack.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = node_stack.top();</span><br><span class="line">            node_stack.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*关键代码*/</span></span><br><span class="line">            <span class="comment">//visit</span></span><br><span class="line">            curr-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">            prev = curr;</span><br><span class="line"></span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用递归进行修改代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBiNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);<span class="comment">// 单链表的头指针哨兵</span></span><br><span class="line">    <span class="comment">// 开始中序遍历</span></span><br><span class="line">    inorder(root,head);</span><br><span class="line">    <span class="keyword">return</span> head.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">inorder</span><span class="params">(TreeNode root,TreeNode prev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != null)&#123;</span><br><span class="line">        prev = inorder(root.left,prev);   <span class="comment">//此处存疑</span></span><br><span class="line"></span><br><span class="line">        root.left = null;</span><br><span class="line">        prev.right = root;</span><br><span class="line">        prev = root;</span><br><span class="line"></span><br><span class="line">        prev = inorder(root.right,prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></p>
<p>二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<p>思路</p>
<p>通过中序遍历我们能够找到两个错误的节点，然后只要交换两节点即可，这里需要注意的是，当我们找到了cur和pre，使<code>cur-&gt;val &lt; pre-&gt;val</code>时，我们需要确定到底是cur是错误节点还是pre是错误节点。通过举例可知，第一次遇到错误的排序时，pre是错误的节点，而第二次遇到时，cur是错误的节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历如下，其中2和4位置发生了交换</span></span><br><span class="line"><span class="number">1</span>    <span class="number">4</span>    <span class="number">3</span>    <span class="number">2</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">    pre  cur</span><br><span class="line"><span class="comment">//因为节点位置错误，因此大节点会排在小节点前面，第一次比较时4 &gt; 3，此时4为错误节点</span></span><br><span class="line"><span class="comment">//第二次比较为3 &gt; 2，此时2为错误节点</span></span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(pre != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;val &lt; pre-&gt;val)&#123;</span><br><span class="line">        y = cur; <span class="comment">//第二次比较，cur为错误节点。如果是相邻两节点未知错误，只进行一次比较，那么cur也为错误节点</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="literal">nullptr</span>) x = pre;   <span class="comment">//第一次比较，pre为错误节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>AVL树是一种可以进行局部平衡的树，它要求<strong>每个节点左右子树高度差最大为1</strong>。其高度受限于$O(lgn)$，平均查找次数接近于最好情况。</p>
<h4 id="平衡条件"><a href="#平衡条件" class="headerlink" title="平衡条件"></a>平衡条件</h4><p>当AVL树中任意节点平衡因子绝对值大于1，树就需要平衡。</p>
<h4 id="平衡过程"><a href="#平衡过程" class="headerlink" title="平衡过程"></a>平衡过程</h4><p>平衡的过程可以用</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种自平衡二叉查找树，典型用途是实现关联容器例如set或map的底层实现。推荐一个网站，可以可视化红黑树：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树可视化</a></p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>节点要么红要么黑</li>
<li>根黑叶黑红子黑（红节点子节点为黑节点）</li>
<li>任意节点到每个叶子节点包含相同数目的黑色节点</li>
<li>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，因此树是大致平衡的</li>
</ul>
<h4 id="平衡过程-1"><a href="#平衡过程-1" class="headerlink" title="平衡过程"></a>平衡过程</h4><h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><p>将某个node的右子树逆时针旋转，使得右子树的根节点成为node的父节点，并调整相关节点引用</p>
<h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><p>将某个node的左子树顺时针旋转，使得左子树的根节点成为node的父节点，并调整相关节点引用</p>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>线段树能够把对区间的修改、维护从O(N)时间复杂度降低为对数复杂度</p>
<h2 id="Leetcode上关于树的相关题目"><a href="#Leetcode上关于树的相关题目" class="headerlink" title="Leetcode上关于树的相关题目"></a>Leetcode上关于树的相关题目</h2><p><strong>493. 翻转对</strong></p>
<p>给定一个数组<code>nums</code>，如果 <code>i &lt; j</code> 且 <code>nums[i] &gt; 2*nums[j]</code> 我们就将 <code>(i, j)</code> 称作一个<strong>重要翻转对</strong>。返回给定数组中的重要翻转对的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,2,3,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>解析：</p>
<ol>
<li>暴力搜索就不说了，这里给出使用二叉搜索树的解决方案：</li>
</ol>
<ul>
<li>树节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">insert</span><span class="params">(Node *head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val == head-&gt;val)</span><br><span class="line">        head-&gt;count ++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val &lt; head-&gt;val)</span><br><span class="line">        head-&gt;left = insert(head-&gt;left,val);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        head-&gt;right = insert(head-&gt;right,val);</span><br><span class="line">        head-&gt;count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>搜索</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node* head, <span class="keyword">long</span> <span class="keyword">long</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;val == target)</span><br><span class="line">        <span class="keyword">return</span> head-&gt;count;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; head-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> head-&gt;count + search(head-&gt;left,target);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> search(head-&gt;right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解决问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        Node* head = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            count += search(head, nums[i] * <span class="number">2L</span>L + <span class="number">1</span>);  <span class="comment">//搜索</span></span><br><span class="line">            head = insert(head, nums[i]);    <span class="comment">//插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二叉搜索树在最坏情况下的时间复杂度是$O(n^2)$。</p>
<ol>
<li>使用二进制索引树进行处理</li>
</ol>
<p>使用BST时，如果树不平衡，那么搜索效率会下降，因此可以采用红黑树或AVL树进行平衡，但是写起来太麻烦了，这里可以采用BIT，即树状数组进行处理，使时间复杂度为$ O(nlogn)$。树状数组的一个典型应用场合为计算子数组的和</p>
<p><strong>114 利用二叉树的右节点将二叉树展开为链表</strong></p>
<p>给定一个二叉树，<a href="https://baike.baidu.com/item/原地算法/8010757">原地</a>将它展开为链表。例如，给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>
<p>将其展开为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<ul>
<li>解法1，先序遍历直接嫁接：</li>
</ul>
<ol>
<li>将原来的右子树接到左子树的最右边节点</li>
<li>将左子树插入到右子树的地方</li>
<li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null</li>
</ol>
<p>以上思路可以用图表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br><span class="line"></span><br><span class="line">//将 1 的右子树插入到左子树最深的右叶节点的地方，然后将左子树移到右子树</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2         </span><br><span class="line">     / \         </span><br><span class="line">    3   4         </span><br><span class="line">         \</span><br><span class="line">          5</span><br><span class="line">           \</span><br><span class="line">            6</span><br><span class="line">//考虑下一个节点，即2所在节点，将-4-5-6嫁接到3的右子树</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">     /           </span><br><span class="line">    3     </span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br><span class="line">        </span><br><span class="line"> //然后将左子树转移到右子树上面即可</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">       \          </span><br><span class="line">        3      </span><br><span class="line">         \</span><br><span class="line">          4  </span><br><span class="line">           \</span><br><span class="line">            5</span><br><span class="line">             \</span><br><span class="line">              6  </span><br><span class="line">              </span><br><span class="line">从结果来看，得到的序列是一个先序遍历的序列</span><br></pre></td></tr></table></figure>
<p>解法1代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left == <span class="literal">nullptr</span>)&#123;  <span class="comment">//左节点为空，直接考虑下一个节点</span></span><br><span class="line">            p = p-&gt;right; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode* left = p-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(left-&gt;right != <span class="literal">nullptr</span>) left = left-&gt;right; <span class="comment">//找到左子树的右子节点</span></span><br><span class="line">            left-&gt;right = p-&gt;right;  <span class="comment">//将右子树嫁接到左子树的右子节点</span></span><br><span class="line"></span><br><span class="line">            p-&gt;right = p-&gt;left;      <span class="comment">//左子树转移到右子树</span></span><br><span class="line">            p-&gt;left = <span class="literal">nullptr</span>;       <span class="comment">//清空左子树</span></span><br><span class="line"> </span><br><span class="line">            p=p-&gt;right;              <span class="comment">//考虑下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>解法2：后序遍历逆序更新</li>
</ol>
<h3 id="366-寻找二叉树的叶子节点"><a href="#366-寻找二叉树的叶子节点" class="headerlink" title="366. 寻找二叉树的叶子节点"></a><a href="https://leetcode-cn.com/problems/find-leaves-of-binary-tree/">366. 寻找二叉树的叶子节点</a></h3><p>给你一棵二叉树，请按以下要求的顺序收集它的全部节点：</p>
<ol>
<li>依次从左到右，每次收集并删除所有的叶子节点</li>
<li>重复如上过程直到整棵树为空</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">  </span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line"></span><br><span class="line">输出: [[4,5,3],[2],[1]]</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="边界值及返回条件确定"><a href="#边界值及返回条件确定" class="headerlink" title="边界值及返回条件确定"></a>边界值及返回条件确定</h5><ul>
<li>当树为空时，直接返回空列表</li>
<li>当树不为空时，需要进行操作，找到所有的叶子节点，并分组保存</li>
</ul>
<h5 id="搜索空间确定"><a href="#搜索空间确定" class="headerlink" title="搜索空间确定"></a>搜索空间确定</h5><h6 id="大搜索空间"><a href="#大搜索空间" class="headerlink" title="大搜索空间"></a>大搜索空间</h6><p>每次搜索会删去树的所有叶子节点，然后对删去叶子节点的树进行搜索，搜索空间为每次去掉叶子的树的集合，时间复杂度为O(H)，即树的最大深度。</p>
<pre class="mermaid">graph TB
    node1((1))
    node2((2))
    node3((3))
    node4((4))
    node5((5))
    node6((6))
    node1---node2
    node1---node3
    node2---node4
    node2---node5
    node4---node6


    node11((1))
    node22((2))
    node44((4))
    node11---node22
    node22---node44

    node111((1))
    node222((2))
    node111---node222

    node((1))</pre>

<h6 id="小搜索空间"><a href="#小搜索空间" class="headerlink" title="小搜索空间"></a>小搜索空间</h6><p>小搜索空间为每棵树的每一个节点，即遍历一棵树的复杂度</p>
<h5 id="搜索过程"><a href="#搜索过程" class="headerlink" title="搜索过程"></a>搜索过程</h5><p>搜索过程分为两步</p>
<ul>
<li>遍历所有可能的树</li>
<li>在每一种可能的树中遍历所有节点</li>
</ul>
<h6 id="在每一种可能的树中遍历所有节点"><a href="#在每一种可能的树中遍历所有节点" class="headerlink" title="在每一种可能的树中遍历所有节点"></a>在每一种可能的树中遍历所有节点</h6><p>我们先解决第二个问题：一个朴素的想法是每次循环删除所有的叶节点，重复若干次。这意味着我们要保存叶子节点（cur）的父节点（pre），当找到叶子节点后进行判断，如果<code>pre-&gt;left == cur</code>，那么令<code>pre-&gt;left == nullptr</code>；否则令<code>pre-&gt;right == nullptr</code>。</p>
<ul>
<li>找到叶子节点</li>
<li>保存叶子节点的值</li>
<li>删除叶子节点</li>
<li>对左右子树执行相同的操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一次操作的过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* cur, TreeNode* pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        temp.push_back(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;left == cur)  pre-&gt;left == <span class="literal">nullptr</span>;  <span class="comment">//剪去叶片</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;right == cur) pre-&gt;right == <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    helper(cur-&gt;left,  cur, temp);</span><br><span class="line">    helper(cur-&gt;right, cur, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="遍历所有可能的树"><a href="#遍历所有可能的树" class="headerlink" title="遍历所有可能的树"></a>遍历所有可能的树</h6><p>在此过程中，我们不断地遍历以<code>root</code>作为跟节点的树，并每次进行剪去叶片的处理，直到只剩下一个单独的根为止，每次遍历我们需要记录下当前的所有叶子节点，然后在遍历完成后将结果数组保存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans&#123;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;left != <span class="literal">nullptr</span> || root-&gt;right != <span class="literal">nullptr</span>)&#123; <span class="comment">//树仍有节点</span></span><br><span class="line">        temp.clear();</span><br><span class="line">        helper(root, pre, temp);</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    temp.clear();</span><br><span class="line">    temp.push_back(root-&gt;val);</span><br><span class="line">    ans.push_back(temp);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="">C++数据结构与算法</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode/">Leetcode 94</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://blog.csdn.net/Greek_to_me/article/details/81951057">已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历？</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://www.jianshu.com/p/484f587c967c">二叉树的Morris遍历</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>游戏美工素材</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E7%BE%8E%E5%B7%A5%E7%B4%A0%E6%9D%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将对常用的游戏美工素材网站进行总结</p>
<a id="more"></a>
<p><a href="https://assetstore.unity.com/?gclid=EAIaIQobChMIsJW0-cWU9QIVQuJ3Ch3vRA7ZEAAYASAAEgLlL_D_BwE&amp;gclsrc=aw.ds">Unity 资源商店 - 优质3D 2D游戏制作资源平台</a></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>游戏开发</category>
      </categories>
  </entry>
  <entry>
    <title>复杂度优化</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>current is fine, next will be better</p>
</blockquote>
<a id="more"></a>
<h2 id="降低算法复杂度"><a href="#降低算法复杂度" class="headerlink" title="降低算法复杂度"></a>降低算法复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度的排序依次是：</p>
<script type="math/tex; mode=display">
O(1)\rightarrow O(\lg n) \rightarrow O(n) \rightarrow O(n\lg n) \rightarrow O(n^k) \rightarrow O(k^n) \rightarrow O(n!)</script><h4 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h4><p>循环是造成时间复杂度增加的一个重要原因，循环优化的基本原则是尽量减少循环过程中的计算量，多重循环时，应当尽量将内层循环的计算提到上一层</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h3 id="圈复杂度"><a href="#圈复杂度" class="headerlink" title="圈复杂度"></a>圈复杂度</h3><p>圈复杂度是指代码中分支语句的数量，每个while/for/if/switch都会增加圈复杂度，我们对代码的要求是尽可能降低圈复杂度</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li>如果能够提前知道所需空间的大小，尽量分配空间，push_back毕竟是函数调用，浪费时间</li>
</ul>
<h2 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h2><p>记忆化是指我们通过牺牲一部分空间，保存计算中间变量，当再次遇到相同的计算参数时，我们可以不需要重新计算，只需读取保存的结果即可。记忆化最典型的应用就是动态规划。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对位运算进行总结。</p>
<a id="more"></a>
<h2 id="常用位运算总结"><a href="#常用位运算总结" class="headerlink" title="常用位运算总结"></a>常用位运算总结</h2><h3 id="位运算优先级"><a href="#位运算优先级" class="headerlink" title="位运算优先级"></a>位运算优先级</h3><p>位运算的优先级是很低的，所以在使用的时候在必要时要加括号。例如<code>if((v &amp; h) == 0)</code>，如果不加括号，会变成判断h是否为0。</p>
<h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算^"></a>异或运算^</h3><p>异或的一些基本性质如下：</p>
<ul>
<li><code>a^b</code>，相异为1，相同为0</li>
<li>a^a = 0</li>
<li>a^0 = a</li>
<li>满足交换律a\^b\^a = a\^a\^b = b</li>
</ul>
<h4 id="异或运算的常见应用场景"><a href="#异或运算的常见应用场景" class="headerlink" title="异或运算的常见应用场景"></a>异或运算的常见应用场景</h4><h5 id="一、消除重复"><a href="#一、消除重复" class="headerlink" title="一、消除重复"></a>一、消除重复</h5><p>因为a\^b\^a = a\^a\^b，故一些情况下，我们可以利用位运算，实现重复数的消除，获得只出现一次的数字</p>
<h5 id="二、计算绝对值"><a href="#二、计算绝对值" class="headerlink" title="二、计算绝对值"></a>二、计算绝对值</h5><p><a href="https://leetcode-cn.com/problems/maximum-lcci/">面试题 16.07. 最大数值</a></p>
<blockquote>
<p>不使用比较运算的情况下，获得一个数的绝对值</p>
</blockquote>
<p><code>max(a, b) = ((a + b) + abs(a - b)) / 2</code></p>
<p>这里直接给出结论，以<code>int</code>为例：分析运算：<code>(num ^ (num &gt;&gt; 31)) - (num &gt;&gt; 31)</code></p>
<ul>
<li><p>num &gt;= 0: num &gt;&gt; 31 =&gt; 0，即：(num ^ 0) - 0，结果为var</p>
</li>
<li><p>num &lt; 0: num &gt;&gt; 31 =&gt; 0xFFFFFFFF，即：(num ^ 0xFFFFFFFF) - 0xFFFFFFFF，num ^ 0xFFFFFFFF是在对num 的全部位取反，-0xFFFFFFFF&lt;=&gt; +1, 对signed int取反加一就是取其相反数。</p>
</li>
</ul>
<h5 id="三、交换变量"><a href="#三、交换变量" class="headerlink" title="三、交换变量"></a>三、交换变量</h5><p>为了交换整型变量a和b，我们可以进行如下三步操作：</p>
<ul>
<li><p>a=a^b;</p>
</li>
<li><p>b=a^b;</p>
</li>
<li><p>a=a^b;</p>
</li>
</ul>
<p>解释如下：令 a‘=a^b; 那么 b=a’^b = (a\^b)\^b=a\^b\^b=a\^(b\^b)=a^0=a，而 a’ = a^b = (a\^b)\^a=a\^b\^a=b。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="LeetCode-136-只出现一次的数字"><a href="#LeetCode-136-只出现一次的数字" class="headerlink" title="LeetCode 136 只出现一次的数字"></a>LeetCode 136 只出现一次的数字</h5><p>一个数组中其他数字都出现两次，只有一个数字出现一次，找到这个数，只需进行一次全员异或即可。</p>
<h5 id="LeetCode-260-只出现一次的数字3"><a href="#LeetCode-260-只出现一次的数字3" class="headerlink" title="LeetCode 260 只出现一次的数字3"></a>LeetCode 260 只出现一次的数字3</h5><p>一个数组中其他数字都出现两次，只有两个数字出现一次，找到这两个数。</p>
<p><strong>思路</strong></p>
<p>进行全员异或，能够找到这两个数字异或的结果，其他数字异或后全部为0，那么如何区分这两个数字呢？如果两个数字不同，那么异或之后一定至少有1位是1，我们可以以该位是否为0，将所有数字分为两组，这样问题就转化为了136题。</p>
<p><strong>代码</strong></p>
<h5 id="LeetCode-371-两整数之和"><a href="#LeetCode-371-两整数之和" class="headerlink" title="LeetCode 371. 两整数之和"></a>LeetCode <a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></h5><h5 id="LeetCode-1009-十进制整数的反码"><a href="#LeetCode-1009-十进制整数的反码" class="headerlink" title="LeetCode 1009. 十进制整数的反码"></a>LeetCode <a href="https://leetcode-cn.com/problems/complement-of-base-10-integer/">1009. 十进制整数的反码</a></h5><p>计算十进制非负整数N的反码的过程如下，首先判断N有多少位为1，然后按位取反</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> bit_num = bitCount(N);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(bit_num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((flag &amp; N) != <span class="number">0</span>)&#123;</span><br><span class="line">                bit_num--;</span><br><span class="line">            &#125;</span><br><span class="line">            N ^= flag;</span><br><span class="line">            flag &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(N &amp; <span class="number">1</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> + bitCount(N &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> bitCount(N &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="按位与运算-amp"><a href="#按位与运算-amp" class="headerlink" title="按位与运算&amp;"></a>按位与运算&amp;</h3><h4 id="获取1的个数"><a href="#获取1的个数" class="headerlink" title="获取1的个数"></a>获取1的个数</h4><p>对于任意数字 $n$ ，将 $n$和$n-1$做与运算，会把最后一个 1 的位变成 0。在二进制表示中，数字$n$中最低位的1总是对应$n-1$中的0。因此，将$n$和$n-1$与运算总是能把$n$中最低位的1变成0，并保持其他位不变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumsOfOne</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        count++;  <span class="comment">//只要n不为0则其至少有一个1</span></span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移位运算-gt-gt-lt-lt"><a href="#移位运算-gt-gt-lt-lt" class="headerlink" title="移位运算&gt;&gt; &lt;&lt;"></a>移位运算&gt;&gt; &lt;&lt;</h3><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="用移位实现乘除法"><a href="#用移位实现乘除法" class="headerlink" title="用移位实现乘除法"></a>用移位实现乘除法</h4><p>移位运算可以用于乘除法当中，设乘数或除数$x=2^n$，则</p>
<ul>
<li>$a\times x=(a&lt;&lt;n)$</li>
<li>$a/x=(a&gt;&gt;n)$</li>
</ul>
<h3 id="掩码操作"><a href="#掩码操作" class="headerlink" title="掩码操作"></a>掩码操作</h3><h4 id="使用掩码对集合进行表示"><a href="#使用掩码对集合进行表示" class="headerlink" title="使用掩码对集合进行表示"></a>使用掩码对集合进行表示</h4><p>在一些情况下，我们需要计算两个集合是否具有相同元素，例如两个字符串是否有相同字符。除了使用哈希方法外，我们还可以用位掩码进行操作。我们选择一个32位无符号整数，从1到第26位，分别记为a-z的标记，计算两个字符的掩码。如果掩码相与为0，那么两个字符串无相同的字符。</p>
<p><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></p>
<p>有时我们需要获得一个集合的子集，那么我们可以采用掩码的方式进行，例如对于集合[1,2,3]，我们给定掩码[0,1,1]，0代表选择，1代表不选择，那么掩码[0,1,1]代表集合[2,3]。相关例题如下：</p>
<p><a href="https://leetcode-cn.com/problems/power-set-lcci/">面试题 08.04. 幂集</a></p>
<h3 id="卡诺图"><a href="#卡诺图" class="headerlink" title="卡诺图"></a>卡诺图</h3><p>在考虑状态转移时，经常会使用卡诺图作为工具，我们可以以当前状态和下一时刻状态做出2维卡诺图，从而进行判断。这里以LeetCode<a href="https://leetcode-cn.com/problems/game-of-life/">289. 生命游戏</a>为例，对卡诺图的使用进行总结。</p>
<blockquote>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<ul>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ul>
<p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p>
</blockquote>
<p>细胞的状态有两种，死或活，根据当前状态并结合生存定律，可以推算下一状态，得到卡诺图如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>下一状态\</th>
<th>当前状态</th>
<th>死</th>
<th>活</th>
</tr>
</thead>
<tbody>
<tr>
<td>死</td>
<td>00</td>
<td>01</td>
</tr>
<tr>
<td>活</td>
<td>10</td>
<td>11</td>
</tr>
</tbody>
</table>
</div>
<p>每个细胞整型数可以保存其当前状态和下一状态，通过掩码进行实现。</p>
<h2 id="一些例子1"><a href="#一些例子1" class="headerlink" title="一些例子1"></a>一些例子<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><h3 id="比较复杂的位运算组合"><a href="#比较复杂的位运算组合" class="headerlink" title="比较复杂的位运算组合"></a>比较复杂的位运算组合</h3><p>下面这个例子揭示了位运算的一些技巧：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* getbits: get n bits from position p*/</span></span><br><span class="line"><span class="comment">// 从x的第p位（p&gt;=0）开始，获得n位</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbits</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; (p+<span class="number">1</span>-n)) &amp; ~(~<span class="number">0</span> &lt;&lt; n);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol>
<li>写出一个</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="">K&amp;R第2.9章节</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>剑指offer题目总结</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对剑指offer题目按照章节进行讲解。</p>
<a id="more"></a>
<h2 id="题目表"><a href="#题目表" class="headerlink" title="题目表"></a>题目表</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">是否掌握</th>
<th style="text-align:center">题号</th>
<th style="text-align:center">是否掌握</th>
<th style="text-align:center">题号</th>
<th style="text-align:center">是否掌握</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">*</td>
<td style="text-align:center">27</td>
<td style="text-align:center"></td>
<td style="text-align:center">50</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">*</td>
<td style="text-align:center">28</td>
<td style="text-align:center"></td>
<td style="text-align:center">51</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"></td>
<td style="text-align:center">29</td>
<td style="text-align:center"></td>
<td style="text-align:center">52</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">*</td>
<td style="text-align:center">30</td>
<td style="text-align:center"></td>
<td style="text-align:center">53-1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"></td>
<td style="text-align:center">31</td>
<td style="text-align:center"></td>
<td style="text-align:center">53-2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
<td style="text-align:center">32-1</td>
<td style="text-align:center">*</td>
<td style="text-align:center">54</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">55-1</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">10-1</td>
<td style="text-align:center"></td>
<td style="text-align:center">32-3</td>
<td style="text-align:center"></td>
<td style="text-align:center">55-2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">10-2</td>
<td style="text-align:center"></td>
<td style="text-align:center">33</td>
<td style="text-align:center">*</td>
<td style="text-align:center">56-1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center">34</td>
<td style="text-align:center"></td>
<td style="text-align:center">56-2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center"></td>
<td style="text-align:center">35</td>
<td style="text-align:center">-</td>
<td style="text-align:center">57</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"></td>
<td style="text-align:center">36</td>
<td style="text-align:center"></td>
<td style="text-align:center">57-2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">14-1</td>
<td style="text-align:center"></td>
<td style="text-align:center">37</td>
<td style="text-align:center"></td>
<td style="text-align:center">58-1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">14-2</td>
<td style="text-align:center"></td>
<td style="text-align:center">38</td>
<td style="text-align:center"></td>
<td style="text-align:center">58-2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"></td>
<td style="text-align:center">39</td>
<td style="text-align:center"></td>
<td style="text-align:center">59-1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center"></td>
<td style="text-align:center">40</td>
<td style="text-align:center"></td>
<td style="text-align:center">59-2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center"></td>
<td style="text-align:center">41</td>
<td style="text-align:center"></td>
<td style="text-align:center">60</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center"></td>
<td style="text-align:center">42</td>
<td style="text-align:center"></td>
<td style="text-align:center">61</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center"></td>
<td style="text-align:center">43</td>
<td style="text-align:center"></td>
<td style="text-align:center">62</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center"></td>
<td style="text-align:center">44</td>
<td style="text-align:center"></td>
<td style="text-align:center">63</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center"></td>
<td style="text-align:center">45</td>
<td style="text-align:center"></td>
<td style="text-align:center">64</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center"></td>
<td style="text-align:center">46</td>
<td style="text-align:center"></td>
<td style="text-align:center">65</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center">66</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center"></td>
<td style="text-align:center">48</td>
<td style="text-align:center"></td>
<td style="text-align:center">67</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center"></td>
<td style="text-align:center">49</td>
<td style="text-align:center"></td>
<td style="text-align:center">68-1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span> || length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> || nums[i] &gt;= length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[nums[i]];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> row  = rows<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> col  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &lt; target) col++;</span><br><span class="line">        <span class="keyword">else</span> row--;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> ori_length = s.size();</span><br><span class="line">    <span class="keyword">int</span> space_num  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ori_length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">' '</span>) ++space_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;space_num;++i)&#123;</span><br><span class="line">        s.push_back(<span class="string">' '</span>);</span><br><span class="line">        s.push_back(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> new_length = ori_length + space_num*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ptr1 = ori_length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ptr2 = new_length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr1&gt;=<span class="number">0</span> &amp;&amp; ptr2 &gt;= ptr1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[ptr1] == <span class="string">' '</span>)&#123;</span><br><span class="line">            s[ptr2--] = <span class="string">'0'</span>;</span><br><span class="line">            s[ptr2--] = <span class="string">'2'</span>;</span><br><span class="line">            s[ptr2--] = <span class="string">'%'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s[ptr2--] = s[ptr1];</span><br><span class="line">        &#125;</span><br><span class="line">        ptr1--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;ListNode*&gt; node_stack&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node_stack.push(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(!node_stack.empty())&#123;</span><br><span class="line">        ans.push_back(node_stack.top()-&gt;val);</span><br><span class="line">        node_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树重建"><a href="#二叉树重建" class="headerlink" title="二叉树重建*"></a>二叉树重建*</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.empty() || inorder.empty() || preorder.size() != inorder.size()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, <span class="number">0</span>, preorder.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> pre_left, </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> pre_right,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> in_left,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre_left &gt; pre_right || in_left&gt;in_right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 创建根节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[pre_left]);</span><br><span class="line">    root-&gt;left  = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 寻找根节点在中序遍历中的位置</span></span><br><span class="line">    <span class="keyword">if</span>(pre_left == pre_right &amp;&amp; in_left == in_right &amp;&amp; preorder[pre_left] == inorder[in_left]) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">int</span> root_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=in_left;i&lt;=in_right;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == root-&gt;val)&#123;</span><br><span class="line">            root_index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root_index == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 计算左右子树长度</span></span><br><span class="line">    <span class="keyword">int</span> left_length  = root_index - in_left;</span><br><span class="line">    <span class="keyword">int</span> right_length = in_right - in_left - left_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 遍历左右子树</span></span><br><span class="line">    root-&gt;left  = buildTree(preorder, inorder, pre_left+<span class="number">1</span>, pre_left+left_length, in_left, in_left+left_length<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = buildTree(preorder, inorder, pre_left+left_length+<span class="number">1</span>, pre_right, in_left+left_length+<span class="number">1</span>, in_right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; first&#123;&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; second&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        first.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(second.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!first.empty())&#123;</span><br><span class="line">                second.push(first.top());</span><br><span class="line">                first.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(second.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ans = second.top();</span><br><span class="line">        second.pop();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字*"></a>旋转数组的最小数字*</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = numbers.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2])&#123;</span><br><span class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[index2];</span><br><span class="line">        &#125;</span><br><span class="line">        mid = index1 + (index2 - index1)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index1] == numbers[index2] &amp;&amp; numbers[index1] == numbers[mid]) </span><br><span class="line">            <span class="keyword">return</span> minInOrder(numbers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numbers[mid] &gt;= numbers[index1]) index1 = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt;= numbers[index2]) index2 = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[mid];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &lt; result) result = numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board.empty())    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(word.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rows = board.size();</span><br><span class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">visited</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board, word, i,j,<span class="number">0</span>,visited)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> length, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == word.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; board.size() &amp;&amp; col &gt;=<span class="number">0</span> &amp;&amp; col &lt; board[<span class="number">0</span>].size() &amp;&amp; word[length] == board[row][col] &amp;&amp; !visited[row][col])&#123;</span><br><span class="line">        ++length;</span><br><span class="line">        visited[row][col]= <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        hasPath = dfs(board, word, row+<span class="number">1</span>,col,   length,visited) ||</span><br><span class="line">            dfs(board, word, row<span class="number">-1</span>,col,   length,visited) ||</span><br><span class="line">            dfs(board, word, row,  col+<span class="number">1</span>, length,visited) ||</span><br><span class="line">            dfs(board, word, row,  col<span class="number">-1</span>, length,visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hasPath == <span class="literal">false</span>)&#123;</span><br><span class="line">            length--;</span><br><span class="line">            visited[row][col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x - <span class="number">0</span> &lt;= <span class="number">1e-6</span> &amp;&amp; x<span class="number">-0</span> &gt;= <span class="number">-1e-6</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> absN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>) absN = n;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == INT_MIN) absN = <span class="number">2147483648</span>;</span><br><span class="line">        <span class="keyword">else</span> absN = -n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = absPow(x, absN);</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? result : <span class="number">1</span>/result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">absPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> result = absPow(x, n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    result*=result;</span><br><span class="line">    <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>) result*=x;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表的结点"><a href="#删除链表的结点" class="headerlink" title="删除链表的结点"></a>删除链表的结点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** head, ListNode* toBeDeleted)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || *head == <span class="literal">nullptr</span> || toBeDeleted == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(toBeDeleted-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ListNode* next = toBeDeleted-&gt;next;</span><br><span class="line">        toBeDeleted-&gt;value = next-&gt;value;</span><br><span class="line">        toBeDeleted-&gt;next  = next-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> next;</span><br><span class="line">        next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*head == toBeDeleted)&#123;</span><br><span class="line">        <span class="keyword">delete</span> toBeDeleted;</span><br><span class="line">        toBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        *head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode* cur = *head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != toBeDeleted)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> toBeDeleted;     <span class="comment">//删除指针指向内存</span></span><br><span class="line">        toBeDeleted = <span class="literal">nullptr</span>;  <span class="comment">//将指针接地</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表倒数第K个节点"><a href="#链表倒数第K个节点" class="headerlink" title="链表倒数第K个节点"></a>链表倒数第K个节点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        fast= fast-&gt;next;</span><br><span class="line">        slow= slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="环的入口节点"><a href="#环的入口节点" class="headerlink" title="环的入口节点"></a>环的入口节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">if</span>(next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不使用-实现加法"><a href="#不使用-实现加法" class="headerlink" title="不使用+-*/实现加法"></a>不使用+-*/实现加法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> plus = a ^ b;</span><br><span class="line">        b = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a&amp;b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        a = plus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="二叉树中和为某一路径的值"><a href="#二叉树中和为某一路径的值" class="headerlink" title="二叉树中和为某一路径的值"></a>二叉树中和为某一路径的值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> sum,</span></span></span><br><span class="line"><span class="function"><span class="params">         TreeNode* root,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    temp.push_back(root-&gt;val);</span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) ans.push_back(temp);</span><br><span class="line"></span><br><span class="line">    dfs(ans, sum, root-&gt;left, temp);</span><br><span class="line">    dfs(ans, sum, root-&gt;right, temp);</span><br><span class="line"></span><br><span class="line">    temp.pop_back();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans&#123;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp&#123;&#125;;</span><br><span class="line">    dfs(ans, sum, root, temp);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">map</span>&lt;Node*, Node*&gt; visited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( visited[head] != <span class="literal">nullptr</span>) <span class="keyword">return</span> visited[head];</span><br><span class="line">        </span><br><span class="line">        Node* copy = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">        visited[head] = copy;</span><br><span class="line">        copy -&gt; next = copyRandomList(head-&gt;next);</span><br><span class="line">        copy -&gt; random = copyRandomList(head-&gt;random);</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;c</span><br></pre></td></tr></table></figure>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b &lt; b+a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: nums)</span><br><span class="line">        str_num.push_back(to_string(i));</span><br><span class="line"></span><br><span class="line">    sort(str_num.begin(), str_num.end(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> rec = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">string</span> i: str_num)</span><br><span class="line">        rec += i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_str = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;          <span class="comment">//队列左侧</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; lookup&#123;&#125;;   <span class="comment">//用无序set作为队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size(); ++i)&#123;  <span class="comment">//遍历s</span></span><br><span class="line">            <span class="keyword">while</span>(lookup.find(s[i]) != lookup.end())&#123;   <span class="comment">//右侧元素已经出现在字符串中</span></span><br><span class="line">                lookup.erase(s[left]);         <span class="comment">//弹出队列左侧元素，直到右侧元素不在当前字符串中</span></span><br><span class="line">                left++;                        <span class="comment">//窗口左侧右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            max_str = max(max_str, i-left+<span class="number">1</span>);</span><br><span class="line">            lookup.insert(s[i]);              <span class="comment">//添加右侧元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树类题目"><a href="#二叉树类题目" class="headerlink" title="二叉树类题目"></a>二叉树类题目</h2><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法一：递归</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span> || left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(left-&gt;left,right-&gt;right)&amp;&amp;isSymmetric(left-&gt;right,right-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二：迭代</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; node_queue&#123;&#125;;</span><br><span class="line">    node_queue.push(root-&gt;left);</span><br><span class="line">    node_queue.push(root-&gt;right);</span><br><span class="line">    <span class="keyword">while</span>(!node_queue.empty())&#123;</span><br><span class="line">        TreeNode* left = node_queue.front();</span><br><span class="line">        node_queue.pop();</span><br><span class="line">        TreeNode* right = node_queue.front();</span><br><span class="line">        node_queue.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span> || left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        node_queue.push(left-&gt;left);</span><br><span class="line">        node_queue.push(right-&gt;right);</span><br><span class="line">        node_queue.push(left-&gt;right);</span><br><span class="line">        node_queue.push(right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>返回它的最大深度 3 。</p>
<h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><ol>
<li>递归法</li>
</ol>
<ol>
<li>迭代法</li>
</ol>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="不使用-×-实现加法"><a href="#不使用-×-实现加法" class="headerlink" title="不使用+-×/实现加法"></a>不使用+-×/实现加法</h3><h4 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h4><blockquote>
<p>13二进制为：1101，9二进制为：1001。</p>
<p>十进制是遇到大于等于10就保留余数，然后进位1。<br>那对应到二进制，就是遇到2就保留余数0，然后进位1。（二进制位之和不可能大于2）</p>
<p>计算二进制1101+1001：<br>1.计算不进位的和。从左到右，第1位为0，第2位为1，第3位为0，第4位为0，结果为0100；<br>2.计算进位。从左到右，第1位进位1，第2、3位没有进位，第4位进位1，结果为1001。不对，进位右边要补0，正确结果是10010。</p>
<p>计算二进制0100+10010：<br>1.计算不进位的和：10110；<br>2.计算进位：无。</p>
<p>因此结果为10110=22。</p>
</blockquote>
<p>1）分析上面对二进制的计算过程，不难发现：<br>1.计算不进位的和，相当于对两个数进制异或：1101^1001=0100；<br>2.计算进位，第1位相当于对两个数求与：1101&amp;1001=1001，然后再对其进行左移1位：1001&lt;&lt;1=10010。<br>然后再重复以上两个步骤。这里再异或一次就得到结果了，没进位：0100^10010=10110=22。</p>
<p>2）计算a+b，等价于(a^b)+((a&amp;b)&lt;<1)。
由于公式中又出现了+号，因此要再重复2）这个等价的计算过程。
结束条件是：没有进位了<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a>&lt;/sup&gt;。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;                        <span class="comment">//没有进位了</span></span><br><span class="line">        <span class="keyword">int</span> plus = a ^ b;               <span class="comment">//不考虑进位的加法，即异或</span></span><br><span class="line">        b = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a&amp;b) &lt;&lt; <span class="number">1</span>); <span class="comment">//考虑进位，按位与后左移一位</span></span><br><span class="line">        a = plus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fast_pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> base,<span class="keyword">int</span> index)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            ans*=base; <span class="comment">//指数为计数，x^(2n+1)可以写为x*x^2n</span></span><br><span class="line">        &#125;</span><br><span class="line">        index/=<span class="number">2</span>;      <span class="comment">//指数为偶数，那么可以将指数减半，底翻倍</span></span><br><span class="line">        base*=base;    <span class="comment">//可能溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速幂本质是通过二分法对幂指数进行求解，上面是快速幂的模板，需要牢记</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/er-jin-zhi-qiu-he-chao-xiang-xi-da-bai-10000yong-h/">LeetCode面试题52</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对双指针的使用场景进行讲解。</p>
<a id="more"></a>
<h2 id="双指针作用"><a href="#双指针作用" class="headerlink" title="双指针作用"></a>双指针作用</h2><p>双指针指使用两个指针对数组进行操作，一般一个放首，一个放尾，或者两个都放在开头，移动速度或开始移动的时机不同。</p>
<p>常见的使用场景包括：</p>
<ul>
<li>两数求和（或者三数求和）：寻找两个数的和为一个特定的值</li>
<li>数组就地交换</li>
<li>正负数排序数组平方和处理（LeetCode977）</li>
<li>删除符合条件的特定元素（字节跳动笔试题）</li>
</ul>
<h2 id="双指针难点总结"><a href="#双指针难点总结" class="headerlink" title="双指针难点总结"></a>双指针难点总结</h2><p>双指针在使用中往往会遇到如下问题：</p>
<ul>
<li>每个指针分别代表什么含义</li>
<li>如何移动每个指针</li>
</ul>
<p>本文将针对双指针中常见的一些应用场景下的含义及移动方法进行总结。</p>
<h3 id="起始位置"><a href="#起始位置" class="headerlink" title="起始位置"></a>起始位置</h3><ul>
<li>两个指针均从头开始移动</li>
<li>一头一尾移动</li>
</ul>
<h3 id="移动方法"><a href="#移动方法" class="headerlink" title="移动方法"></a>移动方法</h3><ul>
<li>如果符合条件，两个指针均向后移动，否则移动快指针</li>
<li>快指针以慢指针k倍速移动</li>
</ul>
<h3 id="双指针指向数组两端，分别向中间收缩，用于解决两数求和的问题"><a href="#双指针指向数组两端，分别向中间收缩，用于解决两数求和的问题" class="headerlink" title="双指针指向数组两端，分别向中间收缩，用于解决两数求和的问题"></a>双指针指向数组两端，分别向中间收缩，用于解决两数求和的问题</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>使用前需要对数组排序</li>
<li>循环判断条件为while(left &lt; right)</li>
<li>可能需要去除重复</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/two-sum-less-than-k/">1099. 小于 K 的两数之和</a></p>
<p>思路</p>
<p>和大于K，则右指针左移，否则左指针右移</p>
<p><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-3</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size()<span class="number">-2</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> k = j+<span class="number">1</span>, l = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k &lt; l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]+nums[l] &lt; target)      k++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]+nums[l] &gt; target) l--;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(&#123;nums[i],nums[j],nums[k],nums[l]&#125;);</span><br><span class="line">                <span class="keyword">while</span>(k &lt; l &amp;&amp; nums[k] == nums[k+<span class="number">1</span>]) k++;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; l &amp;&amp; nums[l] == nums[l<span class="number">-1</span>]) l--;</span><br><span class="line">                k++;</span><br><span class="line">                l--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针延伸方法"><a href="#双指针延伸方法" class="headerlink" title="双指针延伸方法"></a>双指针延伸方法</h2><h3 id="滑动窗口法，用于搜索符合条件的连续子串"><a href="#滑动窗口法，用于搜索符合条件的连续子串" class="headerlink" title="滑动窗口法，用于搜索符合条件的连续子串"></a>滑动窗口法，用于搜索符合条件的连续子串</h3><p>滑动窗口实际上就是一个队列，队列的长度根据符合条件的子串的长度，是不断发生变化的，通过遍历整个数组，就能找到符合条件的<strong>连续</strong>子串。我们一般使用双指针构成滑动窗口，将i,j分别指向窗口左右边界，通过移动i和j，即可将窗口进行滑动。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/slidingwindow.png" width = "450"  alt="图片名称" align=center /></p>
<p>LeetCode第3题 <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">最长不含重复字符的子字符串</a></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_str = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;          <span class="comment">//队列左侧</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; lookup&#123;&#125;;   <span class="comment">//用无序set作为队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size(); ++i)&#123;  <span class="comment">//遍历s</span></span><br><span class="line">            <span class="keyword">while</span>(lookup.find(s[i]) != lookup.end())&#123;   <span class="comment">//右侧元素已经出现在字符串中</span></span><br><span class="line">                lookup.erase(s[left]);         <span class="comment">//弹出队列左侧元素，直到右侧元素不在当前字符串中</span></span><br><span class="line">                left++;                        <span class="comment">//窗口左侧右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            max_str = max(max_str, i-left+<span class="number">1</span>);</span><br><span class="line">            lookup.insert(s[i]);              <span class="comment">//添加右侧元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2，使用一个map记录某个字符左侧的位置</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; dic&#123;&#125;;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.size(); j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(dic.find(s[j]) != dic.end())&#123;</span><br><span class="line">               i = max(i, dic[s[j]]);    <span class="comment">// 找到两者中较大的作为左边界</span></span><br><span class="line">           &#125;</span><br><span class="line">           dic[s[j]] = j;    <span class="comment">//更新dic</span></span><br><span class="line">           res = max(res, j-i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a></p>
<blockquote>
<p>给你一个有序数组 nums ，请你<strong>原地</strong>删除重复出现的元素，使每个元素 最多出现$k$次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<p>这个题思路非常巧妙，我们分成两种情况讨论：</p>
<ul>
<li>对于前$k$个数字，我们可以直接保留</li>
<li>而对于后面的数字，我们采用局部性原理处理，仅关注<code>[len-k,len-1]</code>这一段，如果当前数字(num)与当前写入位置前第<code>k</code>个元素不相同，那么可以保留，否则丢弃（num向后移动）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;          <span class="comment">// 指针1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)  <span class="comment">// 指针2</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; k || nums[len-k] != num)  <span class="comment">// 滑动窗口（大小为k）</span></span><br><span class="line">            nums[len++] = num;   <span class="comment">// 两个指针都递增</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针适用场景"><a href="#双指针适用场景" class="headerlink" title="双指针适用场景"></a>双指针适用场景</h2><h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><p><a href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列</a></p>
<blockquote>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子序列实际上是在一个固定的解空间中按照一定顺序组成一个解，在此处应用到了两个指针，i和j，i指向解，j指向解空间，如果找到了解，那么两个指针都递增，否则只递增解空间的指针，代表后向搜索</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = t.size();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j])&#123;</span><br><span class="line">            i++;    <span class="comment">//找到某个解，解和解空间均递增</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j++;   <span class="comment">//继续搜索解空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="专题：字符串压缩"><a href="#专题：字符串压缩" class="headerlink" title="专题：字符串压缩"></a>专题：字符串压缩</h3><p>在有些情况下，需要我们对字符串进行压缩处理，如果能够实现原地修改算法，那么我们的字符串处理起来会很简单，本文将针对字符串压缩处理相关问题进行总结。</p>
<h2 id="双指针例题"><a href="#双指针例题" class="headerlink" title="双指针例题"></a>双指针例题</h2><h3 id="字节跳动2019春招笔试题——字符串处理"><a href="#字节跳动2019春招笔试题——字符串处理" class="headerlink" title="字节跳动2019春招笔试题——字符串处理"></a>字节跳动2019春招笔试题——字符串处理</h3><p>三个同样的字母连在一起是拼写错误，去掉一个：比如 helllo -&gt; hello</p>
<p>两对一样的字母（AABB型）连在一起是拼写错误，去掉第二对的一个字母：比如 helloo -&gt; hello</p>
<p>上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC</p>
<h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">helloo</span><br><span class="line">wooooooow</span><br></pre></td></tr></table></figure>
<h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">woow</span><br></pre></td></tr></table></figure>
<p><strong>解答</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">string</span> s&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;    <span class="comment">//基本框架</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;    <span class="comment">//第二个指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            s[j++] = s[i];         <span class="comment">//s[j] = s[i] //第二个指针总是超前第一个指针</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">3</span>&amp;&amp;s[j<span class="number">-1</span>]==s[j<span class="number">-2</span>]&amp;&amp;s[j<span class="number">-2</span>]==s[j<span class="number">-3</span>])&#123;</span><br><span class="line">                j--;   <span class="comment">//下一轮操作会覆盖当前位置元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">4</span> &amp;&amp; s[j<span class="number">-1</span>] == s[j<span class="number">-2</span>] &amp;&amp; s[j<span class="number">-3</span>] == s[j<span class="number">-4</span>])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        s.erase(s.begin()+j,s.end());   <span class="comment">//字符串相当于进行了平移，没有用的东西都放在了j之后</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-15-三数求和"><a href="#LeetCode-15-三数求和" class="headerlink" title="LeetCode 15 三数求和"></a>LeetCode 15 三数求和</h3><p>给定一个包含 $n$ 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans&#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> ans;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[l] + nums[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l] == nums[l+<span class="number">1</span>] ) l++;   <span class="comment">//去重处理</span></span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] == nums[r<span class="number">-1</span>] ) r--;</span><br><span class="line">                    l++;   <span class="comment">//去重处理</span></span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[l] + nums[r] &lt; <span class="number">0</span>) l++;</span><br><span class="line">                <span class="keyword">else</span> r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span> &lt; nums.size() &amp;&amp; nums[i] == nums[i+<span class="number">1</span>]) i++;  <span class="comment">//去重处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解法很简单，可以将三数求和转换为两数求和问题，即num[i] + num[j] = num[k]，做一些去重复处理即可</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>哈希</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对哈希（散列）相关知识进行讲解。</p>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>所谓哈希（这个翻译真是太扯了），就是一个字典型数据结构，用于维护具有键值的数据结构，基本操作包括</p>
<ul>
<li>插入：如果key已经存在，进行覆盖</li>
<li>删除</li>
<li>搜索：给定key，返回对象，或者报告对象不存在（Hash miss）</li>
</ul>
<p>这些操作可以通过AVL树实现，复杂度为$O(\lg n)$</p>
<h2 id="Hash实现"><a href="#Hash实现" class="headerlink" title="Hash实现"></a>Hash实现</h2><h3 id="最简单的实现"><a href="#最简单的实现" class="headerlink" title="最简单的实现"></a>最简单的实现</h3><p>考虑最简单的情况，使用直接访问表，将对象保存在一段连续空间中，键值就是数组索引，这个实现有两个缺点</p>
<ul>
<li>键值如果不是整数，就不能作为索引</li>
<li>空间效率很低，需要巨量的空间</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>本节请参考，在Python中，hash的实现为dict</p>
<ul>
<li>D[key] ~ search</li>
<li>D[key] = val ~ insert</li>
<li>del D[key] ~ delete</li>
</ul>
<h2 id="Hash常见应用场景"><a href="#Hash常见应用场景" class="headerlink" title="Hash常见应用场景"></a>Hash常见应用场景</h2><h3 id="O-1-时间检索"><a href="#O-1-时间检索" class="headerlink" title="O(1)时间检索"></a>O(1)时间检索</h3><p>由于哈希搜索的高效性，一般看到需要常数时间内的索引时，都会考虑使用哈希表。例如：</p>
<ul>
<li>文本索引/子字符串/文本推荐</li>
<li>数据库</li>
<li>网络路由/服务器</li>
<li>文件/目录同步</li>
<li>密码学</li>
</ul>
<h3 id="变位映射"><a href="#变位映射" class="headerlink" title="变位映射"></a>变位映射</h3><p>变位映射（LeetCode760）给定两个列表 <code>A</code>and <code>B</code>，并且 <code>B</code> 是 <code>A</code> 的变位（即 <code>B</code> 是由 <code>A</code> 中的元素随机排列后组成的新列表）。我们希望找出一个从 <code>A</code> 到 <code>B</code> 的索引映射 <code>P</code> 。一个映射 <code>P[i] = j</code> 指的是列表 <code>A</code> 中的第 <code>i</code> 个元素出现于列表 <code>B</code> 中的第 <code>j</code> 个元素上。<strong>即寻找A中某个元素在B中位置</strong></p>
<h3 id="双向映射"><a href="#双向映射" class="headerlink" title="双向映射"></a>双向映射</h3><p>在有些问题中，我们需要找到一一对应的双向映射，即不仅能从A搜索到B，还要能从B搜索到A，此时我们采用两个哈希表分别记录字典，然后依次检索，模板如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (amap.find(n[i]) != amap.end() &amp;&amp; amap[n[i]] != v[i])  <span class="comment">//从n到v的映射</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (bmap.find(v[i]) != bmap.end() &amp;&amp; bmap[v[i]] != n[i])  <span class="comment">//从v到n的映射</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表的问题及解决方案"><a href="#哈希表的问题及解决方案" class="headerlink" title="哈希表的问题及解决方案"></a>哈希表的问题及解决方案</h2><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>哈希函数产生的哈希值是有限的，而当数据较多，可能导致不同数据对应相同哈希值，产生哈希冲突。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="开放地址方法"><a href="#开放地址方法" class="headerlink" title="开放地址方法"></a>开放地址方法</h5><p>产生哈希冲突时，进行偏移或干脆采用随机方法，直至冲突消失。</p>
<h5 id="链式地址法"><a href="#链式地址法" class="headerlink" title="链式地址法"></a>链式地址法</h5><p>相同哈希值使用链表进行连接</p>
<h5 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h5><p>建立一块公共区域，专门存放所有哈希冲突的数据</p>
<h5 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h5><p>对冲突的哈希值再进行哈希，直到无冲突为止</p>
<h3 id="哈希miss"><a href="#哈希miss" class="headerlink" title="哈希miss"></a>哈希miss</h3><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="散列索引（原理性讲解，可不看）"><a href="#散列索引（原理性讲解，可不看）" class="headerlink" title="散列索引（原理性讲解，可不看）"></a>散列索引（原理性讲解，可不看）</h3><h4 id="静态散列"><a href="#静态散列" class="headerlink" title="静态散列"></a>静态散列</h4><p>数据桶的个数固定，通过添加溢出页，处理溢出问题。这种方式比较简单，但是在已满桶中插入数据项，就需要增加一个溢出页，如果不希望增加溢出，一个解决方案为修改散列函数，将桶数目扩大，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/databucket1.png" alt=""></p>
<p>一个散列索引表如上图所示：其中，桶采用二进制进行编码，如果加一位，会翻一倍（类似vector增长），这个增长过程带来的问题：可能会导致数据的大规模调整。</p>
<h4 id="可扩展的动态散列"><a href="#可扩展的动态散列" class="headerlink" title="可扩展的动态散列"></a>可扩展的动态散列</h4><p>直接扩展桶可能导致大规模重组，一个解决方案是引入一个仅仅存储桶指针的目录数组，通过翻倍目录项的方式取代翻倍数据桶数目，每次只分裂有溢出的桶。<strong>翻倍目录项比翻倍数据桶要简单很多</strong>。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/bucket2%20(2" alt="">.png)</p>
<p>在这种扩展策略中，有目录项指向数据桶，目录项有编号，当有一个桶满了后（例如B桶），就将目录项复制，然后复制的目录项依次指向对应的桶。满了的桶要分裂，令目录项指向他。同时，分裂的桶要加一个资格位，对两个桶进行区分。这样分裂下去的一个结果是，可能有多个指针指向同一个桶。</p>
<h5 id="可扩展散列基本技术"><a href="#可扩展散列基本技术" class="headerlink" title="可扩展散列基本技术"></a>可扩展散列基本技术</h5><ul>
<li>引入散列函数$h$，将索引键值映射为2进制，并解释最后$d$位；其中$d$是目录项编码位数，也叫全局位深度，目录项总数为$2^d$个。</li>
<li>每个桶包含局部位深度$l$，<strong>即所存储数据项后$l$位相同</strong>，例如5和21，当深度为2时，其二进制后两位分别为01，一般情况下，有$2^{d-l}$个目录项指向该桶，当$l=d$时，只有一个目录项指向这个桶，起初$l=d$。</li>
<li>当向一个满的、局部位深度为$l$的桶插入数据项时要分裂，其局部位深度变为$l+1$，若$l+1&gt;d$，目录翻倍。</li>
<li>目录项翻倍即将原有目录复制产生一个新目录，然后调整目录编号，新目录与旧目录在新扩展的比特位上取值不同，新旧目录指向同一个桶，只是在桶分裂后，新旧目录分别指向原桶和分裂桶。</li>
</ul>
<h4 id="线性散列"><a href="#线性散列" class="headerlink" title="线性散列"></a>线性散列</h4><p>线性散列可扩展，且不需要目录项，允许灵活地选择分裂时机，但缺点是如果数据项键值散列后分布不均匀的倾斜度大，导致的问题可能比扩展散列还严重。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>查并集</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>$O$ or $\Theta$ or $\Omega$</p>
</blockquote>
<a id="more"></a>
<h2 id="不同的表示法"><a href="#不同的表示法" class="headerlink" title="不同的表示法"></a>不同的表示法</h2><h3 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大$O$表示法"></a>大$O$表示法</h3><p>大$O$表示法是最常使用的描述渐进复杂度的方法，给定两个正值函数$f$和$g$，考虑下列定义：‘</p>
<blockquote>
<p>如果存在正数$c$和$N$，对于所有$n\ge N$，有$f(n)\le cg(n)$，则$f(n)=O(g(n))$。</p>
</blockquote>
<p>从定义可以看出，大$O$表示法表示的是一个算法的上界，$f$至多和$g$增长的一样快。</p>
<h3 id="Omega-表示法"><a href="#Omega-表示法" class="headerlink" title="$\Omega$表示法"></a>$\Omega$表示法</h3><p>对应于大$O$表示法，大$\Omega$表示下界，其定义为：</p>
<blockquote>
<p>如果存在正数$c$和$N$，对于所有$n\ge N$，有$f(n)\ge cg(n)$，则$f(n)=\Omega (g(n))$。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.geeksforgeeks.org/union-find/">geeksforgeeks上关于查并集的介绍</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/evaluate-division/">LeetCode399</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://leetcode-cn.com/problems/surrounded-regions/solution/bfsdi-gui-dfsfei-di-gui-dfsbing-cha-ji-by-ac_pipe/">查并集应用</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划DP</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“你欺骗了我！作为惩罚，你必将重复徒劳而无意义的工作，直到永远！”，死神对西西弗斯说。</p>
</blockquote>
<p>重复一件已经知道答案的事情有意义么？当然没有，所以我们要记住曾经已经解决的问题的答案，而不是像西西弗斯那样，做没有意义的工作，这就是动态规划算法的作用。</p>
<a id="more"></a>
<h2 id="什么是动态规划？"><a href="#什么是动态规划？" class="headerlink" title="什么是动态规划？"></a>什么是动态规划？</h2><p>动态规划涉及两种思想：<strong>递归和记忆</strong>，通过递归，大的问题被拆分（关于递归的讲解可以参考我的另一篇博客：）；通过记忆，以前被解决的问题的答案直接拿来用即可，避免了重复计算。（如果只是用传统递归，会有很多中间过程被重复进行）</p>
<h2 id="动态规划解决什么问题？"><a href="#动态规划解决什么问题？" class="headerlink" title="动态规划解决什么问题？"></a>动态规划解决什么问题？</h2><ul>
<li>优化问题：寻找最优解</li>
<li><p>组合问题：寻找可能的解决方案的组合，或者事件发生概率</p>
</li>
<li><p>子序列类型问题：子序列类型问题很难穷举，而动态规划所做的工作即为<strong>穷举+减枝</strong>，所以涉及子序列的问题基本都可以用动态规划进行解决。</p>
</li>
</ul>
<h2 id="动态优化框架"><a href="#动态优化框架" class="headerlink" title="动态优化框架"></a>动态优化框架</h2><ol>
<li>大问题可以拆分为子问题</li>
<li>通过子问题的最优解，递归地解决大问题</li>
<li>解决方式为自下而上</li>
<li>根据已经获得的信息构建最优解</li>
</ol>
<p>（什么是自下而上？解决小问题，然后把它们组合起来解决大问题）</p>
<p><strong>动态规划的一个关键点就是找到子问题以及初始条件，类似于科学归纳法，动态规划一定要找到几个初始条件的解。</strong></p>
<ul>
<li>确定初始条件</li>
<li>确定DP数组的含义，即要保存什么中间结果</li>
<li>确定递推公式</li>
<li>确定返回值</li>
</ul>
<h2 id="算法优缺点"><a href="#算法优缺点" class="headerlink" title="算法优缺点"></a>算法优缺点</h2><p>优点：不容易超过规定内存大小</p>
<p>缺点：必须找到一个有效的解决问题的顺序</p>
<h2 id="DP延伸算法"><a href="#DP延伸算法" class="headerlink" title="DP延伸算法"></a>DP延伸算法</h2><h3 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h3><h3 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h3><h2 id="DP难点总结"><a href="#DP难点总结" class="headerlink" title="DP难点总结"></a>DP难点总结</h2><p> DP中最难的部分有两个</p>
<ul>
<li>DP数组代表什么，即我们的状态是什么，我们要保存什么？</li>
<li>状态转移方程是什么，我们如何根据以前的结果推导现有的结果</li>
</ul>
<p>本节将对常见的DP状态定义及转移方程进行总结。</p>
<h3 id="一维DP"><a href="#一维DP" class="headerlink" title="一维DP"></a>一维DP</h3><h4 id="DP-i-的含义"><a href="#DP-i-的含义" class="headerlink" title="DP[i]的含义"></a>DP[i]的含义</h4><h5 id="DP-i-代表以vec-i-为结尾的某种状态"><a href="#DP-i-代表以vec-i-为结尾的某种状态" class="headerlink" title="DP[i]代表以vec[i]为结尾的某种状态"></a>DP[i]代表以vec[i]为结尾的某种状态</h5><p>例题1：LeetCode 面试题42</p>
<blockquote>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
</blockquote>
<p>此时DP[i]代表以nums[i]结尾的连续子数组最大值。有了该定义，转移方程迎刃而解。</p>
<p>例题2：LeetCode 面试题 48 最长不含重复字符的子串</p>
<h5 id="DP-i-就代表第i个要求的解"><a href="#DP-i-就代表第i个要求的解" class="headerlink" title="DP[i]就代表第i个要求的解"></a>DP[i]就代表第i个要求的解</h5><p>例题1：LeetCode 面试题49 丑数</p>
<blockquote>
<p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
</blockquote>
<p>问题很好理解，后面的丑数一定是从前面某个数×2、×3或×5得到的，关键是究竟是哪一个数呢，这里采用了三指针法</p>
<ul>
<li>设置三个指针p2,p3,p5</li>
<li>p2指向的数字下一次×2，p3指向的数字下一次×3，p5指向的数字×5</li>
<li>我们从$2×p_2,3×p_3,5×p_5$选取最小的一个数字，作为第k个丑数</li>
<li>如果第K个丑数==2×p2，也就是说前面0-p2个丑数×2不可能产生比第K个丑数更大的丑数了，所以p2++，p3,p5同理</li>
</ul>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><h5 id="dp-i-的状态转移方程和前i个状态-dp-0-dp-i-1-均可能有关"><a href="#dp-i-的状态转移方程和前i个状态-dp-0-dp-i-1-均可能有关" class="headerlink" title="dp[i]的状态转移方程和前i个状态(dp[0] ~ dp[i-1])均可能有关"></a>dp[i]的状态转移方程和前i个状态(dp[0] ~ dp[i-1])均可能有关</h5><p>此时通常用一个变量保存前面所有状态中的某个最值。</p>
<p><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></p>
<p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></p>
<p><a href="https://leetcode-cn.com/problems/4-keys-keyboard/">651. 4键键盘</a></p>
<blockquote>
<p>假设你有一个特殊的键盘包含下面的按键：</p>
<ul>
<li><p>Key 1: (A)：在屏幕上打印一个 ‘A’。</p>
</li>
<li><p>Key 2: (Ctrl-A)：选中整个屏幕。</p>
</li>
<li><p>Key 3: (Ctrl-C)：复制选中区域到缓冲区。</p>
</li>
<li><p>Key 4: (Ctrl-V)：将缓冲区内容输出到上次输入的结束位置，并显示在屏幕上。</p>
</li>
</ul>
<p>现在，你只可以按键 N 次（使用上述四种按键），请问屏幕上最多可以显示几个 ‘A’呢？</p>
</blockquote>
<p>令<code>dp[i]</code>为输入第<code>i</code>个键后A的数量，那么<code>dp[i]</code>最小为<code>i</code>，最大可能是由前面某个<code>dp[i-k]</code>经过复制得到的</p>
<p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></p>
<blockquote>
<p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
</blockquote>
<p>思路</p>
<p>这个题DP的含义并不难想，就是以<code>i</code>结尾的子串的有效括号长度，难的是状态转移方程不好想，我们还是对这个问题给定具体例子，然后进行分析。假设当前字符串为<code>s=&quot;)(())&quot;</code>，这个例子包含了非法括号，嵌套括号以及一般的配对括号。状态转移表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">）</th>
<th style="text-align:center">（</th>
<th style="text-align:center">（</th>
<th style="text-align:center">）</th>
<th style="text-align:center">）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>从上面的表中可以看出，凡是以’)’结尾的，有效括号长度均不会增加，因此不需考虑，只要看’)’结尾的情况，假设<code>s[i]=&#39;)&#39; &amp;&amp; i&gt;0</code>，则又有如下几种情况：</p>
<ul>
<li>如果<code>s[i-1]=&#39;(&#39;</code>，那么<code>dp[i] = dp[i-2]+2</code></li>
<li>如果<code>s[i-1]=&#39;)&#39;</code>，那么若<code>s[i-dp[i-1]-1] = &#39;(&#39;</code>，说明<code>`s[i-1]=</code>和<code>s[i-dp[i-1]-1]</code>恰好能配对，从而<code>dp[i] = dp[i-2]+2</code>，但是这样还没结束，我们还要加上<code>i-dp[i-1]-1</code>前的有效括号长度，所以最后<code>dp[i] = dp[i-2] + 2 + dp[i - dp[i-1] - 2]</code></li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br></pre></td></tr></table></figure>
<h5 id="dp-i-和前某几个状态有关"><a href="#dp-i-和前某几个状态有关" class="headerlink" title="dp[i]和前某几个状态有关"></a>dp[i]和前某几个状态有关</h5><h3 id="二维DP"><a href="#二维DP" class="headerlink" title="二维DP"></a>二维DP</h3><h4 id="DP-i-的含义-1"><a href="#DP-i-的含义-1" class="headerlink" title="DP[i]的含义"></a>DP[i]的含义</h4><h5 id="DP-i-j-表示条件为i，结果为j时的次数或最优解"><a href="#DP-i-j-表示条件为i，结果为j时的次数或最优解" class="headerlink" title="DP[i][j]表示条件为i，结果为j时的次数或最优解"></a><code>DP[i][j]</code>表示条件为i，结果为j时的次数或最优解</h5><p>例题1：LeetCode面试题60 n个骰子的点数</p>
<blockquote>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
</blockquote>
<p>令<code>dp[i][j]</code>为i个骰子扔在地上，结果为j时的次数，那么<code>dp[i][j]</code> = <code>dp[i-1][j-1]</code>+<code>dp[i-1][j-2]</code>+…+<code>dp[i-1][j-6]</code>（当j大于6时，否则只加到<code>dp[i-1][j-6]</code></p>
<p>例题2：LeetCode<a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></p>
<blockquote>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。例如，给定三角形</p>
<p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]</p>
<p>自顶向下最小路径为(2+3+5+1 == 11)</p>
</blockquote>
<p>令<code>dp[i][j]</code>表示包含<code>nums[i][j]</code>的最小路径和，那么<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1])+nums[i][j]</code>，(当j为边界时特殊讨论)</p>
<h5 id="DP-i-j-表示从区间-i-j-的最优解（区间DP）"><a href="#DP-i-j-表示从区间-i-j-的最优解（区间DP）" class="headerlink" title="DP[i][j]表示从区间(i,j)的最优解（区间DP）"></a><code>DP[i][j]</code>表示从区间(i,j)的最优解（区间DP）</h5><p>区间dp的定义是在一段区间上进行动态规划，求解一段区间上的最优解。并通过合并小区间的最优解进而得出大区间上最优解的dp算法。</p>
<p>例题1：病毒检测</p>
<blockquote>
<p>小明最近在做病毒自动检测，他发现，在某些library 的代码段的二进制表示中，如果包含子串并且恰好有k个1，就有可能有潜在的病毒。library的二进制表示可能很大，并且子串可能很多，人工分析不可能，于是他想写个程序来先算算到底有多少个子串满足条件。如果子串内容相同，但是开始或者结束位置不一样，则被认为是不同的子串。</p>
<p>注：子串一定是连续的。例如”010”有6个子串，分别是 “0, “1”, “0”, “01”, “10”, “010”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入例子1:</span><br><span class="line">1</span><br><span class="line">1010</span><br><span class="line">输出例子1:</span><br><span class="line">6</span><br><span class="line">说明：</span><br><span class="line">满足条件的子串有：&quot;1&quot;, &quot;1&quot;, &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;010&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>这道题思路并不难，假设<code>dp[i][j]</code>是区间(i,j)中1的个数，那么<code>dp[i][j]=dp[i][j-1]+str[j] == &#39;1&#39; ? 1 : 0</code>，这样做需要的空间为n×n，从空间优化的角度考虑，我们可以将其转化为一维dp，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> k=scanner.nextInt();</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        String s=scanner.nextLine();</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>,len=s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[len];  <span class="comment">//dp[i]表示1的数目和为i的个数</span></span><br><span class="line">        <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;     <span class="comment">//初始条件代表1的数目为0的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'1'</span>) num++;    <span class="comment">//num表示1的个数</span></span><br><span class="line">            <span class="keyword">if</span>(num-k&gt;=<span class="number">0</span>) result += dp[num-k];   <span class="comment">//这一句是最难理解的，可以知道的是当num-k时不满足条件，result不更新，否则加上和为 num-k 的个数再加一遍，因为多了1个数，就会产生dp[num-k]个字串</span></span><br><span class="line">            dp[num]++;           <span class="comment">//如果c=='0'，那么dp[num] 必然++，因为0不影响1的个数，</span></span><br><span class="line">            					 <span class="comment">//如果c=='1'，那么num++后，dp[num]也要++，所以无论如何dp[num]都要++</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DP-i-j-表示包含nums-i-j-的最优解（区间DP）"><a href="#DP-i-j-表示包含nums-i-j-的最优解（区间DP）" class="headerlink" title="DP[i][j]表示包含nums(i,j)的最优解（区间DP）"></a><code>DP[i][j]</code>表示包含nums(i,j)的最优解（区间DP）</h5><h5 id="dp-i-j-表示s1前i个字符和s2前-j-个字符之间的关系（线性DP）"><a href="#dp-i-j-表示s1前i个字符和s2前-j-个字符之间的关系（线性DP）" class="headerlink" title="dp[i][j]表示s1前i个字符和s2前$j$个字符之间的关系（线性DP）"></a><code>dp[i][j]</code>表示<code>s1</code>前<code>i</code>个字符和<code>s2</code>前$j$个字符之间的关系（线性DP）</h5><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></p>
<blockquote>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<ul>
<li>‘.’ 匹配任意单个字符</li>
<li>‘*’ 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
</blockquote>
<p>思路</p>
<p>我们按照解决DP问题的一般思路，先明确初始状态以及DP数组的含义，然后列出状态转移表，从而找到状态转移方程，为了方便考虑，我们给定一个具体的例子，令<code>s=&quot;aab&quot;</code>，<code>p=&quot;c*a*b&quot;</code>并给出空的状态转移表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">p/s</th>
<th style="text-align:center"></th>
<th style="text-align:center">0</th>
<th style="text-align:center">1(0)</th>
<th style="text-align:center">2(0)</th>
<th style="text-align:center">3(0)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">null</td>
<td style="text-align:center">a</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">null</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">1(0)</td>
<td style="text-align:center">c</td>
<td style="text-align:center">F</td>
<td style="text-align:center">↘F</td>
<td style="text-align:center">↘F</td>
<td style="text-align:center">↘F</td>
</tr>
<tr>
<td style="text-align:center">2(1)</td>
<td style="text-align:center">*</td>
<td style="text-align:center">T</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">3(2)</td>
<td style="text-align:center">a</td>
<td style="text-align:center">F</td>
<td style="text-align:center">↘F</td>
<td style="text-align:center">↘</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">4(3)</td>
<td style="text-align:center">*</td>
<td style="text-align:center">T</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">5(4)</td>
<td style="text-align:center">b</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">↘</td>
</tr>
</tbody>
</table>
</div>
<p>观察上方的状态转移表，其中括号中代表字符位置，前面的数字代表字符串长度。首先考虑初始条件，<code>dp[0][0]</code>的含义是s前0个字符能否和p前0个字符匹配，显然是可以的，另外我们知道当s不为空而p为空时，一定不能匹配，所以第一行都是$false$。不过当s为空，p不为空时，我们不能想当然地认为无法匹配，例如<code>dp[0][2]</code>，<code>s=&quot;&quot;</code>，而<code>p=&quot;c*&quot;</code>，由于<em>可以匹配0个或多个，如果匹配0个，此时p为空，可以匹配，所以对于<code>dp[0][i]</code>，如果<code>i</code>为 </em>，那么p末尾两个字符可以视为不存在，即<code>dp[0][i] = dp[0][i-2]</code>。所以我们得到初始化条件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i<span class="number">-1</span>] == <span class="string">'*'</span>) dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们考虑对<code>.</code>和一般字符进行匹配的情况，这个比较简单，如果<code>s[i] == p[j] || p[j] == .</code>那说明这个字符是匹配的，我们只需要看前<code>i-1</code>和前<code>j-1</code>个字符是否匹配即可，转移方程如下：</p>
<script type="math/tex; mode=display">
dp[i][j]=dp[i-1][j-1]  \ \ \ \ if:\ \ p[j] == '.'\ \ or\ \  ischar(p[j]) \ \ and\ \ s[i]=p[j]</script><p>如果两个字符不匹配，那肯定就是$false$。这样我们的表格中凡是字母或<code>.</code>与字母进行匹配的都可以进行填充，表格中的箭头表示了状态转移的方向。没有填充的是目前还不知道的。接下来我们考虑最麻烦的，当<code>p[j]=*</code>的情况。该情况又可以分为两种子情况：</p>
<ul>
<li>*号匹配0个字符串，此时意味着将p最后两个字符直接抛弃，那么<code>dp[i][j] = dp[i][j-2]</code></li>
<li><em>号匹配多个字符串，此时我们要先将s[i]和\</em>之前的字符进行比较，如果两个字符相同，那么意味着这个字符可以删掉，我们只需要看s抹去第i个字符后和p是否相同即可，这里需要理解一下，因为通配符并不占用实际字符，因此此时是<code>s[0,...,i-1]</code>和<code>p[0,...,j]</code>进行比较</li>
</ul>
<p>我们举一个具体的例子，<code>s=&quot;acdee&quot;</code>，<code>p=&quot;acde*&quot;</code>，<code>i=4,j=4</code>可以看到<code>s[i]=p[j-1]</code>，我们抹掉<code>s[i]</code>，而<code>s=&quot;acde&quot;</code>和<code>p</code>匹配，所以结果为true，经过上面的过程，我们得到状态转移方程如下：</p>
<script type="math/tex; mode=display">
dp[i][j]= dp[i][j-2]\ ||\ dp[i-1][j]</script><p>这里引出了最后一个问题，我们知道当*前的字符和s[i]相同时，我们可以匹配0个或多个，但是当字符不同呢，那我们就将p[j]和p[j-1]抛弃，至此我们完全地写出了状态转移的方程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=s.size();i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j &lt;= p.size(); j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j<span class="number">-2</span>] == s[i<span class="number">-1</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>) dp[i][j] = dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i][j<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相似问题还有<a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a></p>
<h4 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><h5 id="dp-i-j-和dp-i-1-j-、dp-i-j-1-或者dp-i-1-j-1-有关"><a href="#dp-i-j-和dp-i-1-j-、dp-i-j-1-或者dp-i-1-j-1-有关" class="headerlink" title="dp[i][j]和dp[i-1][j]、dp[i][j-1]或者dp[i-1][j-1]有关"></a><code>dp[i][j]</code>和<code>dp[i-1][j]</code>、<code>dp[i][j-1]</code>或者<code>dp[i-1][j-1]</code>有关</h5><p>这种情况算是二维dp中比较常见的情况，相关例题如下：</p>
<p><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></p>
<h3 id="规划方向（自上而下还是自下而上）"><a href="#规划方向（自上而下还是自下而上）" class="headerlink" title="规划方向（自上而下还是自下而上）"></a>规划方向（自上而下还是自下而上）</h3><p>动态规划有两种等价实现方法，带备忘录的自顶向下和自底向上方法。</p>
<p>一般来说，动态规划我们采用自上而下的方式，以迷宫题为例，一般是从起点开始，向终点搜索。而在有些情况下，使用自下而上的方式可能会令编码更加简单，这里我们以一道题目为例，对自下而上和自上而下两种情况进行讨论。</p>
<p><a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></p>
<ul>
<li>自上而下的解法</li>
</ul>
<p>自上而下的解法很直观，<code>dp[i][j]</code>表示包含<code>triangle[i][j]</code>的最优解，这里直接给出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = triangle.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[len][len];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n =  triangle[i].size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + triangle[i][j];</span><br><span class="line">                &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (j == n - <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + triangle[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; dp[len - <span class="number">1</span>][i]) ans = dp[len - <span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>自下而上的解法</li>
</ul>
<p>自下而上的思想和深度优先搜索类似，都是先找到解空间中的叶子节点，然后自下而上逐步求解，有些情况下，自下而上的解法比自上而下的要简单许多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = triangle.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].size(); ++j) &#123;</span><br><span class="line">                triangle[i][j] += min(triangle[i + <span class="number">1</span>][j], triangle[i + <span class="number">1</span>][ j + <span class="number">1</span>]); <span class="comment">//自下而上搜索解空间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="状态转移表"><a href="#状态转移表" class="headerlink" title="状态转移表"></a>状态转移表</h3><p>要写好动态规划，我们要尽可能列举出状态转移表，通过状态转移表能够清晰地分析出状态转移的过程，从而列举出正确的状态转移方程。</p>
<h3 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h3><p>由于动态规划涉及旧值处理，因此状态转移方程中可能会包含边界溢出的情况，例如下列的状态转移方程：</p>
<p><code>dp[i]=dp[i-1]+dp[i-2]</code>，当<code>i==1</code>时，<code>dp[i-2] == dp[-1]</code>，发生了溢出。若单独判断<code>i==1</code>，程序又会变得更加繁琐，因此我们可以添加类似于哑节点的初始条件，从而避免边界位置的特殊判断，比如我们可以令<code>dp[-1] == 0</code> 或 <code>1</code>，具体的值需要根据问题确定。</p>
<p><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></p>
<h2 id="动态规划算法优化"><a href="#动态规划算法优化" class="headerlink" title="动态规划算法优化"></a>动态规划算法优化</h2><h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><p>当我们使用二维动态规划时，可以考虑将其进行压缩，将二维降低为一维，从而降低空间复杂度。我们以一道例题为例，讲解动态规划的降维过程。</p>
<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><blockquote>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>例子：</p>
<p>1      10     3      8</p>
<p>12    2       9      6</p>
<p>5      7       4      11</p>
<p>3      7       16    5     </p>
</blockquote>
<p>思路</p>
<p>如果我们使用二维动态规划，状态转移方程为$f(i,j)=\max(f(i-1,j)+f(i,j-1))+max_value(i,j)$。从公式中我们可以看出，礼物的最大价值只依赖坐标$(i-1,j)$和$(i,j-1)$，而第$i-2$行和更上面的格子其实没有必要保存。从这个角度，我们可以进行压缩。每次只记录最新的结果，之前的就都抛弃掉，只使用一维数组即可保存中间结果。</p>
<p>传统的二维动态规划</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">礼物的最大价值表</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">11</td>
<td style="text-align:center">14</td>
<td style="text-align:center">22</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">13</td>
<td style="text-align:center">15</td>
<td style="text-align:center">24</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">18</td>
<td style="text-align:center">25</td>
<td style="text-align:center">29</td>
<td style="text-align:center">41</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">21</td>
<td style="text-align:center">32</td>
<td style="text-align:center">48</td>
<td style="text-align:center">53</td>
</tr>
</tbody>
</table>
</div>
<p>如果我们只保存一行（或一列），那么二维就转为了一维。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">礼物的最大价值表</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">旧行</td>
<td style="text-align:center">13</td>
<td style="text-align:center">15</td>
<td style="text-align:center">24</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">新行</td>
<td style="text-align:center">13+5</td>
<td style="text-align:center">$\max(13+5, 15)+4$</td>
<td style="text-align:center">24</td>
</tr>
</tbody>
</table>
</div>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* values, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(values == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *max_value = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> up   = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) up   = max_value[j];     <span class="comment">//实际上是max_value[i-1][j]，此时在新一行，max_value还未更新</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span>) left = max_value[j<span class="number">-1</span>];   <span class="comment">//实际上是max_value[i][j-1];即左边的最大值 </span></span><br><span class="line">        	max_value[j] = max(left,up) + values[i*cols+<span class="number">1</span>];   <span class="comment">//max_value[i][j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = max_value[cols<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] max_value;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="专题：递归改动态规划"><a href="#专题：递归改动态规划" class="headerlink" title="专题：递归改动态规划"></a>专题：递归改动态规划</h2><p>绝大多数递归问题都可以用动态规划重写，由于动态规划在时间上具有一定优势，因此掌握递归改写动态规划是有必要的。本节将针对一些递归问题进行动态规划的改写，这些递归问题往往需要用到DFS或回溯法进行解决。一般这种场景在链表或二叉树应用中比较多一些。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h4><blockquote>
<p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的<strong>二叉搜索树</strong></p>
</blockquote>
<h5 id="思路1：递归"><a href="#思路1：递归" class="headerlink" title="思路1：递归"></a>思路1：递归</h5><ul>
<li>确定搜索范围</li>
</ul>
<p>我们从序列 1 ..n 中取出数字 i，作为当前树的树根。于是，剩余<code>i - 1</code> 个元素可用于左子树，<code>n - i</code> 个元素用于右子树。这样会产生 <code>G(i - 1)</code> 种左子树 和 <code>G(n - i)</code> 种右子树，其中 <code>G</code> 是卡特兰数。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/f709dff506c20ac970d4cd7ace0436aafca7828c67b510cdbaaa60d54f5479b3-image.png" width = "450"  alt="图片名称" align=center /></p>
<h5 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h5><ul>
<li>确定搜索范围</li>
</ul>
<p>有$n$个节点需要插入，因此需要从$1$遍历到$n$，时间复杂度为$O(n)$。同时由于每插入一个节点，当前解向量都需要更新，因此创建新的解向量用于保存插入节点的临时解（动态规划）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cur&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用之前的解向量构造新的解向量</li>
</ul>
<p>为了利用到动态规划的思想，我们需要保存插入之前的结果，并不断更新迭代，基本思路如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入第一个节点</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//插入第二个节点，在上一步插入操作的基础上进行</span></span><br><span class="line"><span class="number">1</span>              <span class="number">2</span></span><br><span class="line"> \           /</span><br><span class="line">  <span class="number">2</span>         <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们需要遍历之前解向量中所有的结果，针对每一个结果进行操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cur&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> root : pre)&#123;</span><br><span class="line">    	...<span class="comment">//执行插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre = cur;  <span class="comment">//迭代更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><h2 id="问题举例"><a href="#问题举例" class="headerlink" title="问题举例"></a>问题举例</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题是动态规划最经典的应用，根据物品可以被拿取的次数限制，背包问题可以分为九种：</p>
<p>1、0-1 背包问题：每种物品只能拿1次；</p>
<p>2、完全背包问题：物品可拿无限次（LeetCode 518）；</p>
<p>3、多重背包问题：对每一种物品可以拿的个数有限制；</p>
<p>4、混合背包问题：中和以上 33 种情况，有的物品只可以取一次，有的物品可以取无限次，有的物品可以取的次数有一个上限；</p>
<p>5、二维费用背包问题：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。</p>
<p>6、分组背包问题：物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>7、有依赖的背包问题：这种背包问题的物品间存在某种“依赖”的关系。也就是说，i 依赖于 j，表示若选物品 i，则必须选物品 j。</p>
<p>8、泛化物品：考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。</p>
<p>9、输出背包问题的解决方案。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><ol>
<li>LeetCode 518 零钱兑换</li>
</ol>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/98c2e8f7d4dda8bc2ce5d4cc185afdeba62c4443212d820fbe6d6eb1bed5d11c-image.png" alt=""></p>
<p>首先根据可能的情况画出分支树，里面有些路径是重复的，需要进行减枝处理，我们要保证更深层的减去的数小于或等于更浅层的数，因此剪去的枝叶如下图红色部分：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/6bb81c638b9ba86de530964b3ee4693ee2508034eebb0cbb08e4dca802749c2b-image.png" alt=""></p>
<p>使用回溯法是可以的，但是效率太低了，这里给出几种方法：</p>
<ul>
<li>根据状态转移方程逐行填写表格</li>
</ul>
<p>a. 状态的定义：<code>dp[i][j]</code>：考虑<strong>前 i 个硬币</strong>能够凑成总金额 <code>j</code> 的组合数。</p>
<p>注意：这里的关键词是“前 <code>i</code>个硬币”，即考虑数组 <code>coins</code> 的区间范围是 [0, i - 1]，例如 <code>dp[3][j]</code> 考虑的是前 <code>2</code> 枚硬币能够凑成总金额<code>j</code>的组合数，考虑虑数组 <code>coins</code>的区间范围是 [0, 2]。</p>
<p>b. 填写状态转移方程</p>
<p>对于看到的一种面值的硬币，逐个考虑添加到“总金额”中。又由于硬币的个数可以无限选取，因此：</p>
<blockquote>
<p>对于一种新的面值的硬币 <code>coins[i - 1]</code>（注意这里有一个位移偏差），我们可以依次考虑选取 0 枚、1 枚、2 枚，以此类推，直到选取这种面值的硬币的总金额超过“需要的总金额 j”，<code>dp[i][j]</code> 是它们的值的和。状态转移方程是：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">0</span> * coins[i - <span class="number">1</span>]] + </span><br><span class="line">           dp[i - <span class="number">1</span>][j - <span class="number">1</span> * coins[i - <span class="number">1</span>]] +</span><br><span class="line">           dp[i - <span class="number">1</span>][j - <span class="number">2</span> * coins[i - <span class="number">1</span>]] + </span><br><span class="line">           ... + </span><br><span class="line">           dp[i - <span class="number">1</span>][j - k * coins[i - <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>这里 <code>j - k * coins[i - 1] &gt;= 0</code>，即总金额必须大于或等于0。</p>
<p>说明：<code>dp[i][j]</code> 相对于<code>dp[i - 1][j]</code> 而言，多考虑的一枚硬币，即“最近看到的那枚硬币”，<code>coins[i - 1]</code>，而<strong>这枚硬币选取的个数（从 0 开始）就是 <code>dp[i][j]</code>这个问题可以分解的各个子问题的分类标准。</strong></p>
<p>下面我们以示例输入: amount = 5, coins = [1, 2, 5] 为例，通过“打表格”的方法模拟程序是如何执行的：</p>
<p>初始的时候，表格如下，行表示从 0 种面值的硬币开始，依次把数组 <code>coins</code> 中的硬币面值考虑进来（注意这里和 0-1 背包问题的区别）。而列也是从总金额为 0 开始，依次计算凑齐总金额为 <code>amount</code>的组合数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>下面用递归的形式解决背包问题：</p>
<blockquote>
<p>考虑如下问题：给定一个整数N，N可以表示为1、3、4的和，问共有多少种表示方式？</p>
</blockquote>
<p>例如N=5，那么答案为共6种表示方式：</p>
<ul>
<li>1+1+1+1+1</li>
<li>1+4</li>
<li>4+1</li>
<li>1+1+3</li>
<li>1+3+1</li>
<li>3+1+1</li>
</ul>
<p><strong>子问题：</strong>令$DP_{n}$表示对于给定整数N，可能的表示方式的个数。</p>
<p><strong>找递归状态转移方程：</strong>考虑一个可能的解：$n=x<em>1+x_2+…+x_k$，如果$x_k=1$，那么剩余的部分之和为$n-1$，可能的表示方式个数为$DP</em>{n-1}$。考虑$x_k=3$和$4$的情况，最终我们可以得到下式，这个叫做状态转移方程：</p>
<script type="math/tex; mode=display">
DP_{n}=DP_{n-1}+DP_{n-3}+DP_{n-4}</script><p><strong>递归的基本条件：</strong></p>
<p>从上面的式子我们可以看出，它不能表示$n=0,1,2,3$的情况，所以$n=0,1,2,3$是解空间的基础解系。</p>
<script type="math/tex; mode=display">
DP_0=0,DP_1=1,DP_2=1,DP_3=2</script><p>写成代码的形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DP[<span class="number">0</span>] = DP[<span class="number">1</span>] = DP[<span class="number">2</span>] = <span class="number">1</span>; DP[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    DP[i] = DP[i<span class="number">-1</span>] + DP[i<span class="number">-3</span>] + DP[i<span class="number">-4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，解决DP问题很关键的一个步骤是：<strong>找到状态转移方程</strong>。</p>
<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><p>给定$n$个重量为$w_1, w_2,…,w_n$，价值分别为$v_1,v_2,…,v_n$的物品与容量为$C$的包，<strong>每个物品只能使用一次</strong>，求包内最大总价值。这种问题叫做0-1背包问题。0-1背包问题非常重要，是所有背包问题的基础，因此有必要完全掌握。</p>
<p>思路</p>
<p>考虑将前$i$件物品放入容量为$j$的背包中这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只和前$i-1$件物品有关的问题，令$f(i,j)$表示将前$i$个物品放到容量为$j$的背包中得到的最大结果，两种选择如下：</p>
<ul>
<li>放第$i$个物品：$f(i,j) = f(i-1,j)$</li>
<li>不放第$i$个物品：$f(i,j)=v_i+f(i-1,j-w_i)$</li>
</ul>
<p>如果不放第$i$件物品，那么问题转换为“前$i-1$件物品放入背包得到的最大价值；如果放第$i$个物品，那么问题就转化为“前$i−1$件物品放入剩下的容量为$j-w_i$的背包中”，此时能获得的最大价值就是$f(i-1,j-w_i)$再加上通过放入第$i$件物品获得的价值$v_i$。</p>
<p>优化</p>
<p>以上方法时间与空间复杂度均为$O(nC)$，我们可以针对空间复杂度进行优化，使空间复杂度降为$O(n)$。首先我们观察二维$dp$的实现，$dp[i][j] = f(i,j)$，我们首先需要一个主循环$i=1…n$，从而计算$dp[i][1…C]$所有值。如果要改改成1维dp，那么我们希望$dp[j]$代表对于前$i$个物品空间为$j$所能拿取的最大价值，再套上一个循环$i=1…n$，我们就可以在每次循环中更新$dp[j]$，从而令$dp[j]=dp[i][j]$，我们的递推公式变为：</p>
<script type="math/tex; mode=display">
f(j)=max(f(j), v_i+f(j-w_i))</script><p>其中，左侧$f(j)$为更新后的值，即考虑前$i$个物品的$f(j)$，即$f(i,j)$，右侧为更新前的值，为$f(i-1,j)$，代码如下：</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = C; j &gt;= w[i]; j--)   <span class="comment">//从最大容量开始考虑，一直考虑到最小容量即w[i]</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br></pre></td></tr></table></figure>
<p><strong>内层循环为何逆序</strong></p>
<p>上面的代码需要注意的一点是$j$是递减的，因为如果是正序遍历，当求$f(j)$时，$f(0),f(1),…,f(j-1)$可能已经发生了变化，即$f(i,0),…,f(i,j-1)$而非$f(i-1,0),…,f(i-1,j)$，因此我们必须逆序，因为计算$f(j-1)$不需要用到$f(j)$，但是计算$f(j)$会用到$f(j-1)$。我们必须保证没有发生脏读的情况。</p>
<h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></p>
<blockquote>
<p>有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 x == y，那么两块石头都会被完全粉碎；</li>
<li>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p>
</blockquote>
<p>思路</p>
<p>这个问题可以转换为0-1背包问题，设石头总重量为$W$，那么我们需要选出最接近$W/2$的石头，就是将石头尽可能均分为两堆，这样粉碎的石头重量是最多的。问题就转换为了求0-1背包最大价值，最大容量为$W/2$</p>
<h3 id="最长公共子序列问题（Longest-Common-Subsequence，简称-LCS）"><a href="#最长公共子序列问题（Longest-Common-Subsequence，简称-LCS）" class="headerlink" title="最长公共子序列问题（Longest Common Subsequence，简称 LCS）"></a>最长公共子序列问题（Longest Common Subsequence，简称 LCS）</h3><p>给出两个数组，求最长的公共子序列(LeetCode1143)以及<a href="https://leetcode-cn.com/problems/uncrossed-lines/">1035. 不相交的线</a></p>
<blockquote>
<p>输入: str1 = “abcde”, str2 = “ace”<br>输出: 3<br>解释: 最长公共子序列是 “ace”，它的长度是 3</p>
<p>注意，子序列必须保证是递增的，例如’aec’不能称为str1或str2的子序列</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.size();</span><br><span class="line">    <span class="keyword">int</span> n = text2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>))</span></span>; <span class="comment">//dp[i][j]代表text1[0...i-1]和text2[0...j-1]两个字串的最长公共子序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i] == text2[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j]+<span class="number">1</span>;  <span class="comment">//新加入的字符为公共字符，那么公共子序列长度加1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数列连续和或区间和问题（前缀和）"><a href="#数列连续和或区间和问题（前缀和）" class="headerlink" title="数列连续和或区间和问题（前缀和）"></a>数列连续和或区间和问题（前缀和）</h3><p><a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/">面试题 16.17. 连续数列</a></p>
<p>给定一个整数数组（有正数有负数），找出总和最大的连续数列，并返回总和。</p>
<blockquote>
<p>输入： [-2,1,-3,4,-1,2,1,-5,4]<br>输出： 6<br>解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> max_subarray = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i<span class="number">-1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            nums[i] = nums[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max_subarray = max(max_subarray,nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_subarray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>令dp[i]表示以i为结尾的最大连续数列，那么dp[i]的状态转移方程如下：</p>
<ul>
<li>如果dp[i-1]小于0，那么dp[i] = nums[i]，因为dp[i-1]对dp[i]的增长起副作用</li>
<li>如果dp[i-1]大于0，那么dp[i]=dp[i-1]+nums[i]，此时dp[i-1]对dp[i]的增长起正作用。</li>
</ul>
<h4 id="前缀和问题"><a href="#前缀和问题" class="headerlink" title="前缀和问题"></a>前缀和问题</h4><p>对于一个数组A，其前缀和的定义为A[0]+A[1]+A[2]+…+A[i]，即</p>
<script type="math/tex; mode=display">
presum[i]=\sum_{j=0}^{i}A[j]</script><p>在实际使用中，出于方便角度考虑，定义一个辅助位，令preSum[0] = 0，preSum[1] = 0 + A[1]，这样计算起来比较方便。</p>
<h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></p>
<h3 id="数列连续积或区间积问题"><a href="#数列连续积或区间积问题" class="headerlink" title="数列连续积或区间积问题"></a>数列连续积或区间积问题</h3><p>与区间连续和类似，区间连续积要求区间乘积的最大或最小值。和区间连续和不同的是，由于负数的存在，所以有可能两个负数的乘积会变成一个正数而影响结果，我们以<a href="https://leetcode-cn.com/problems/maximum-product-subarray/">LeetCode152. 乘积最大子数组</a>为例，对该问题进行解决。</p>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。</p>
<p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p>
</blockquote>
<p>我们不仅要考虑最大值，还要考虑最小值，当出现负数时，最大值乘负数变为了最小值，而最小值乘负数变成了最大值。因此我们需要两个变量记录最大值与最小值，并在出现负数的时候将最大值与最小值进行交换。</p>
<h3 id="求组合问题"><a href="#求组合问题" class="headerlink" title="求组合问题"></a>求组合问题</h3><ol>
<li>LeetCode 552 学生出勤记录</li>
</ol>
<blockquote>
<p>给定一个正整数 n，返回长度为 n 的所有可被视为可奖励的出勤记录的数量。 答案可能非常大，你只需返回结果mod $10^9 + 7$的值。</p>
<p>学生出勤记录是只包含以下三个字符的字符串：</p>
<p>‘A’ : Absent，缺勤<br>‘L’ : Late，迟到<br>‘P’ : Present，到场<br>如果记录不包含多于一个’A’（缺勤）或超过两个连续的’L’（迟到），则该记录被视为可奖励的。</p>
</blockquote>
<p>一看到求组合，就知道是典型的动态规划，解决问题从两个点着手，传递函数和基本例。思路如下：</p>
<p>首先简化问题，我们将问题分为<strong>包括A与不包括A两种</strong>，先解决不包括A，再分析包括A怎么做。</p>
<ul>
<li><p>不包括A</p>
<p>在不包括A的情况下，又可以分为两种</p>
<ul>
<li>结尾为P，即第i天为P，那么dp[i] = dp[i-1]</li>
<li>结尾为L，第i天为L，此时需要进一步讨论<ul>
<li>若结尾为PL（LPL及PPL），那么dp[i] = dp[i-2]</li>
<li>若结尾为PLL，那么dp[i] = dp[i-3]</li>
<li>结尾不能为LLL</li>
</ul>
</li>
</ul>
<p>这样算下来我们的递推公式就有了dp[i] = dp[i-1]+dp[i-2]+dp[i-3]</p>
</li>
<li><p>包括A</p>
<p>在包括A的情况下，我们只需要考虑A在哪一天，假设A在第<code>i</code>天，那么我们的出勤表为：</p>
<script type="math/tex; mode=display">
[1,2,...,i-1], A ,[i+1,i+2,...,n]</script><p>可以看到不断调整A的位置，我们就可以得到所有的情况，若A在第<code>i</code>天，则<code>dp[n]</code>要加上<code>dp[i-1]*dp[n-i]</code></p>
</li>
</ul>
<ol>
<li>LeetCode903 DI序列的有效排列</li>
</ol>
<p>我们给出<code>S</code>，一个源于<code>{&#39;D&#39;, &#39;I&#39;}</code> 的长度为 $n$ 的字符串 。（这些字母代表 “减少” 和 “增加”。）<br>有效排列 是对整数$ {0, 1, …, n} $的一个排列$ P[0], P[1], …, P[n]$，使得对所有的 i：</p>
<p>如果 <code>S[i] == &#39;D&#39;</code>，那么 <code>P[i] &gt; P[i+1]</code>，以及；<br>如果 <code>S[i] == &#39;I&#39;</code>，那么 <code>P[i] &lt; P[i+1]</code>。<br>有多少个有效排列？因为答案可能很大，所以请返回你的答案模 10^9 + 7.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"DID"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) 的五个有效排列是：</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>一开始的一个很朴素的解决方法就是先求出全排列，然后依次排除不符合的答案，最后统计个数，然后不出意外的超时了，想用动态规划，但是没有找到合适的递归函数，因此参考下下面的答案：</p>
<p>一开始的时候，我尝试使用1维dp数组解决问题，但是我发现了一个问题，即我找不到dp[i]与dp[i-1]之间有什么关系，而答案中的解法采用了一个二维dp数组，<strong>dp数组的每一个维度，实际上就是一个约束条件</strong>，<code>dp[i][j]</code>定义如下：</p>
<p><code>dp[i][j]</code>表示前<code>i+1</code>个数字的可能排列，其中第<code>i+1</code>个数字是剩余数字中的第<code>j+1</code>小的数，说起来可能不是很好理解，看下面的图片：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/image_1536486527.png" alt=""></p>
<p>看<code>dp[0][3]</code>，第一位数字，并且在剩余的数字（1,2,3,4）中是第四小，那就是4，在确定了4之后，如果我们的S[0]是D，那么我只能在剩余数字中第1、2、3小中寻找下一位，如果S[0]是I，那么我只能在第4位向上寻找下一位（找不到了），因此我们就找到了dp中的递推关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numPermsDISequence</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = S.length(), mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;     <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="string">'I'</span>)  <span class="comment">//递增，向上累加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, cur = <span class="number">0</span>; j &lt; n - i; j++) <span class="comment">//只能在第1到第n-i+1个大的数中进行寻找</span></span><br><span class="line">                dp[i + <span class="number">1</span>][j] = cur = (cur + dp[i][j]) % mod;</span><br><span class="line">    	<span class="keyword">else</span>  <span class="comment">//递减，向下累加</span></span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> j = n - i - <span class="number">1</span>, cur = <span class="number">0</span>; j &gt;= <span class="number">0</span>; j--)  <span class="comment">//只能在第</span></span><br><span class="line">          	 	dp[i + <span class="number">1</span>][j] = cur = (cur + dp[i][j + <span class="number">1</span>]) % mod;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求解概率问题"><a href="#求解概率问题" class="headerlink" title="求解概率问题"></a>求解概率问题</h3><p>这里以一道简单的DP算法求解概率的问题为例，总结下此类问题的解决方式。</p>
<blockquote>
<p>Two friends Kunal and Satyam are playing an interesting game. They take turns drawing a ball from a bag which initially contains R red balls and G green balls. Each player draws a ball alternatively and never put it back. The person who is the first to draw a red balls wins. Satyam always draws first. If there are no more balls in the bag and nobody has drawn a red ball, the satyam wins.</p>
<p>What is the probability of the Satyam winning?<br>Input:<br>The first line will contain the number of test cases T.<br>The first line of each test case will contain a number R (number of red balls) and G(number of green balls )</p>
<p>Output<br>For each testcase, print the desired probability.<br>Constraints:<br>1&lt;=T&lt;=10<br>0&lt;=R,G&lt;=10^3<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
</blockquote>
<p><strong>子问题：</strong>我们用$r,g$分别代表红球和绿球的个数，那么$DP_{rg}$代表该情况下Satyam获胜的概率。</p>
<p><strong>找递归状态转移方程：</strong></p>
<p>考虑如下情况：</p>
<ol>
<li>如果Satyam抽出的是红球，那么游戏结束，在这种情况下$DP_{rg}=r/(r+g)$。</li>
<li>如果抽出的是绿球，那么轮到Kunal抽球，Kunal抽到红球的情况下游戏结束，而抽到绿球游戏才会继续，在这种情况下$DP<em>{rg}=g/(r+g)×(g-1)/(r+g-1)×DP</em>{rg-2}$。</li>
</ol>
<p>综合考虑上面两种情况，我们最终得到</p>
<script type="math/tex; mode=display">
DP_{rg}=r/(r+g)+g/(r+g)×(g-1)/(r+g-1)×DP_{rg-2}</script><p>这个式子就后半部分比较绕一些，先是Sytyam抽到绿色球，概率是$g/(r+g)$，然后是Kunal抽到绿色，概率是$(g-1)/(r+g-1)$，最后又是在新的一轮比赛中，Sytyam抽到了红球，概率是$DP_{rg-2}$。这样我们就找到了递归的状态转移方程。</p>
<h3 id="字符串问题"><a href="#字符串问题" class="headerlink" title="字符串问题"></a>字符串问题</h3><h3 id="二维数组DP问题"><a href="#二维数组DP问题" class="headerlink" title="二维数组DP问题"></a>二维数组DP问题</h3><h4 id="求最大面积或形状的个数"><a href="#求最大面积或形状的个数" class="headerlink" title="求最大面积或形状的个数"></a>求最大面积或形状的个数</h4><p><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></p>
<p><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">1277. 统计全为 1 的正方形子矩阵</a></p>
<h3 id="专题：打家劫舍问题（跳跃式动态规划）"><a href="#专题：打家劫舍问题（跳跃式动态规划）" class="headerlink" title="专题：打家劫舍问题（跳跃式动态规划）"></a>专题：打家劫舍问题（跳跃式动态规划）</h3><p>在动态规划中有一类常见问题，即由于选择的不同而出现了分支，这里对此类问题进行总结。</p>
<h4 id="情况1：房屋不构成环，不能偷取相邻的房屋"><a href="#情况1：房屋不构成环，不能偷取相邻的房屋" class="headerlink" title="情况1：房屋不构成环，不能偷取相邻的房屋"></a>情况1：房屋不构成环，不能偷取相邻的房屋</h4><p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></p>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
</blockquote>
<p>这道题目中可以看出，我们每次偷钱是有选择的，对于第i家，有两种情况，要么偷，要么不偷，由此引出了选择二叉树，解决此类问题的方法步骤如下：</p>
<ul>
<li>首先考虑起始的分支情况，要么偷第一间房子，要么偷第二间房子，不存在第三种情况，因为如果一开始就偷第三间房子，就错过了偷第一间房子的机会。</li>
<li>然后根据起始分支情况列出状态转移方程，本题中情况就两种，令$f(i)$为前i个房子的最大值，那么$f(i)$只能来源于以下两种情况<ul>
<li>偷第i间房子，$f(i) = f(i-2)+num[i]$</li>
<li>不偷第i间房子，$f(i) = f(i-1)$</li>
</ul>
</li>
</ul>
<h4 id="情况2：房屋构成环"><a href="#情况2：房屋构成环" class="headerlink" title="情况2：房屋构成环"></a>情况2：房屋构成环</h4><p>在此情况下，房屋构成了环，因此首尾相连，我们不能同时偷首尾的房子，这种情况下我们应当如何利益最大化呢？此时我们考虑首尾的情况，有以下三种：</p>
<ul>
<li>偷首不偷尾</li>
<li>偷尾不偷首</li>
<li>首尾都不偷</li>
</ul>
<p>易知第三种情况肯定达不到利益最大化，因此我们只需要考虑1和2谁最大即可，就转换为了问题1，分别计算偷0,～n-2号的房屋和偷1～n-1号房屋哪个钱更多即可。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">robRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_1 = <span class="number">0</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);   <span class="comment">//从后往前，自底向上</span></span><br><span class="line">        dp_i_2 = dp_i_1;</span><br><span class="line">        dp_i_1 = dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="专题：股票交易问题3"><a href="#专题：股票交易问题3" class="headerlink" title="专题：股票交易问题3"></a>专题：股票交易问题<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h3><p>利润最大化问题包含多个变种，例如交易次数限制，交易包含税率或冻结期等等。本文将针对LeetCode中出现的六种股票交易问题进行总结，本文参考文献出自参考文献<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p>
<h4 id="一般例子"><a href="#一般例子" class="headerlink" title="一般例子"></a>一般例子</h4><p>最一般化的股票交易问题为，给定每日股价，求最大交易利润，这个问题取决于两个方面：</p>
<ol>
<li>我们能进行多少次交易</li>
<li>我们处在第几个交易日，当天股价多少</li>
</ol>
<p>令<code>price</code>表示股价数组，共<code>n</code>天，<code>i</code>表示天数为第几天(从0-<code>i-1</code>)，<code>k</code>表示最大交易次数，那么我们的DP数组含义为：<code>dp[i][k]</code>表示在第<code>i</code>天最多进行<code>k</code>次交易取得的最大利润。基本例为：<code>dp[-1][k] = dp[i][0] = 0</code>，意味着没有交易日或只能进行0次交易时，获得的利润为0。现在我们考虑如何计算<code>dp[i][k]</code>，即寻找<code>dp[i-1][k]</code>、<code>dp[i][k-1]</code>和<code>dp[i-1][k-1]...</code>之间的关系。</p>
<p>现在，为了考虑每一天能够获得的最大利润，我们需要考虑当天进行哪些操作，我们能够进行的操作一共有三种：<strong>买入、持有、卖出</strong>，我们可以依次尝试，看哪一种能够为我们带来最大的利润。当然，我们的操作要符合实际情况，买入时手中尚无股票，卖出时手中必须有股票。这样，我们将<code>dp</code>再进行改进，分为<code>dp[i][k][0]</code>和<code>dp[i][k][1]</code>，分别代表第<code>i</code>天经过<code>k</code>次交易手中没有股票和有股票的最大利润，我们的基本例和状态转移方程如下：</p>
<ul>
<li>基本例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[-1][k][0] = 0, dp[-1][k][1] = -Inf  //初始不买入，资产为0，非法情况定义为-inf</span><br><span class="line">dp[i][0][0] = 0,  dp[i][0][1]  = -Inf</span><br></pre></td></tr></table></figure>
<ul>
<li>状态转移方程</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])     <span class="comment">//max中分别为持有和卖出</span></span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])   <span class="comment">//持有和买入</span></span><br></pre></td></tr></table></figure>
<h4 id="具体问题分析"><a href="#具体问题分析" class="headerlink" title="具体问题分析"></a>具体问题分析</h4><h5 id="情况1：k-1"><a href="#情况1：k-1" class="headerlink" title="情况1：k=1"></a>情况1：k=1</h5><p>在此情况下，我们只有两个变量，<code>dp[i][1][0]</code>和<code>dp[i][1][1]</code>，状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])     //max中分别为持有和卖出</span><br><span class="line">dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])   //持有和买入</span><br><span class="line">dp[i-1][0][0] = 0</span><br></pre></td></tr></table></figure>
<p>我们的代码可以写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp_i10 = <span class="number">0</span>, dp_i11 = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.size();i++)&#123;</span><br><span class="line">        dp_i10 = max(dp_i10, dp_i11 + prices[i]);</span><br><span class="line">        dp_i11 = max(dp_i11, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="情况2：k无限，包含手续费"><a href="#情况2：k无限，包含手续费" class="headerlink" title="情况2：k无限，包含手续费"></a>情况2：k无限，包含手续费</h5><p>在此情况下，我们可以无限次进行交易，此时我们的变量为<code>dp[i][k][0]</code>和<code>dp[i][k][1]</code>，状态转移方程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + price[i]-fee) //fee为卖出时的手续费</span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - price[i])</span><br></pre></td></tr></table></figure>
<p> 表面上看我们需要5个变量，但实际上由于k=Inf，所以<code>dp[][k-1][]=dp[][k][]</code>(一点极限的思想)，因此我们可以减少变量的个数，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[0][0] = 0</span><br><span class="line">dp[0][1] = INT_MIN</span><br><span class="line"></span><br><span class="line">//转移方程</span><br><span class="line">old_dpi0 = dpi0</span><br><span class="line">dpi0 = max(dpi0, dpi1 + price[i])</span><br><span class="line">dpi1 = max(dpi1, old_dpi0 - price[i])</span><br></pre></td></tr></table></figure>
<h5 id="情况3：k为任意值"><a href="#情况3：k为任意值" class="headerlink" title="情况3：k为任意值"></a>情况3：k为任意值</h5><p>在此情况下，我们有交易次数限制，此时我们需要对交易次数进行统计，当达到最大交易次数后，返回最大值。此时我们需要分类讨论</p>
<ul>
<li>当k &gt;= prices.size()时，此时可以退化为情况2</li>
<li>当k &lt; prices.size()时，此时需要三维dp，递推公式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + price[i])</span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - price[i])</span><br></pre></td></tr></table></figure>
<p>我们的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当k过大会导致内存溢出，因此先对case2进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= prices.length &gt;&gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> T_ik0 = <span class="number">0</span>, T_ik1 = Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> T_ik0_old = T_ik0;</span><br><span class="line">            T_ik0 = Math.max(T_ik0, T_ik1 + price);</span><br><span class="line">            T_ik1 = Math.max(T_ik1, T_ik0_old - price);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> T_ik0;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span>[] T_ik0 = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] T_ik1 = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(T_ik1, Integer.MIN_VALUE);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);</span><br><span class="line">            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - <span class="number">1</span>] - price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> T_ik0[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="情况4：k无限，但是有交易冷却"><a href="#情况4：k无限，但是有交易冷却" class="headerlink" title="情况4：k无限，但是有交易冷却"></a>情况4：k无限，但是有交易冷却</h5><p>交易冷却会限制我们的交易频次，当我们在卖出股票后，无法在第二天买入，冷冻期为1天</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-2][0] - price[i])</span><br></pre></td></tr></table></figure>
<p>因此我们在计算过程中，需要保存前天的股票交易情况。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.hackerearth.com/zh/practice/algorithms/dynamic-programming/introduction-to-dynamic-programming-1/practice-problems/algorithm/win-the-game/description/">hackerearth：一个算法练习网站</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/coin-change-2/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-liweiw/">LeetCode 背包问题</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems">股票交易问题的解法</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>大数问题</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>夸父与日逐走，入日；渴，欲得饮，饮于河、渭；河、渭不足，北饮大泽。未至，道渴而死。弃其杖，化为邓林。</p>
</blockquote>
<a id="more"></a>
<h2 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h2><h2 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h2><p>令$m$和$n$分别为<code>num1</code>与<code>num2</code>的长度，且均不为0，则<code>num1</code>和<code>num2</code>乘积的长度为$m+n$或$m+n-1$。因此我们创建一个长度为$m+n$的数组<code>arr</code>用于保存结果。对于任意的$0\le i&lt;m$和$0\le j&lt;n$，<code>num1[i]</code>和<code>num2[j]</code>的乘积位于<code>arr[i+j+1]</code>中，如果有进位，那么将进位部分加至<code>arr[i+j]</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = num1.size(), n = num2.size();</span><br><span class="line">        <span class="keyword">auto</span> ansArr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = num1.at(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.at(j) - <span class="string">'0'</span>;</span><br><span class="line">                ansArr[i + j + <span class="number">1</span>] += x * y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ansArr[i - <span class="number">1</span>] += ansArr[i] / <span class="number">10</span>;</span><br><span class="line">            ansArr[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = ansArr[<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; m + n) &#123;</span><br><span class="line">            ans.push_back(ansArr[index] + <span class="string">'0'</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="大数减法"><a href="#大数减法" class="headerlink" title="大数减法"></a>大数减法</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/">快速幂</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>堆栈</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对堆栈相关知识进行讲解。</p>
<a id="more"></a>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种先入后出的数据结构</p>
<h3 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h3><h4 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h4><p>栈有两个基本操作，push和pop。</p>
<h4 id="栈的特殊操作"><a href="#栈的特殊操作" class="headerlink" title="栈的特殊操作"></a>栈的特殊操作</h4><h5 id="判断某个序列是否为栈的有效弹出序列"><a href="#判断某个序列是否为栈的有效弹出序列" class="headerlink" title="判断某个序列是否为栈的有效弹出序列"></a>判断某个序列是否为栈的有效弹出序列</h5><p>LeetCode <a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">面试题31. 栈的压入、弹出序列</a></p>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>采用贪心算法，创建一个栈，将pushed中的元素依次压入，然后判断栈顶的元素是否等于pop中指定的元素，如果是就出栈，最后判断栈是否为空即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num_stack&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : pushed)&#123;</span><br><span class="line">        num_stack.push(v);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;popped.size() &amp;&amp; !num_stack.empty() &amp;&amp; popped[i] == num_stack.top())&#123;</span><br><span class="line">            num_stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num_stack.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特殊的栈"><a href="#特殊的栈" class="headerlink" title="特殊的栈"></a>特殊的栈</h3><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>单调栈，顾名思义其中的元素是单调递增或单调递减的，单调栈在有些情况下很有用，例如获得一个数组中的递增子序列等。</p>
<h5 id="单调栈应用场景"><a href="#单调栈应用场景" class="headerlink" title="单调栈应用场景"></a>单调栈应用场景</h5><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></p>
<blockquote>
<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>给定一个普通的数组，如果我们想要按照循环的方式对其进行处理，那么可以采用求余的方法，当超过了数组长度，就对数组长度求余，这样就可以开始循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i) &#123; </span><br><span class="line">            <span class="keyword">int</span> cur_num = i % n;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; nums[s.top() % n] &lt; nums[cur_num]) &#123; </span><br><span class="line">                ans[s.top() % n] = nums[cur_num];</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉K位数字</a></p>
<blockquote>
<p>给定一个以字符串表示的非负整数 <em>num</em>，移除这个数中的 <em>k</em> 位数字，使得剩下的数字最小。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>利用栈的贪心算法，对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，对于 $A = 1axxx，B = 1bxxx$，如果 $a &gt; b$ 则 $A &gt; B$。所以在删除数字时应当从左向右迭代。<br>在确定了迭代顺序后，我们需要制定如何删除数字的标准，为了讨论方便，我们利用下面的例子进行说明：对于序列$425$，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，小于它的左邻居 4。则我们应该去掉数字 4。如果不这么做，则随后无论做什么，都不会得到最小数。</p>
<p><strong>任务</strong></p>
<ul>
<li>确定迭代顺序</li>
<li>制定删除数字标准</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p>
<p>思路</p>
<p>1.暴力法</p>
<p>暴力法依次遍历每一个高度，分别向两边延伸，寻找严格小于当前位置高度的矩形，然后计算长度，求得面积。最坏情况下，每次延伸的复杂度为$O(n)$，所以总复杂度为$O(n^2)$</p>
<p>2.空间换时间的单调栈法</p>
<p>我们可以利用一个栈，栈中元素保存的是数组下标$j_1,j_2,…,j_s$，同时保证$height[j_1]<height[j_2]<...<height[j_s]$，即一个单调栈。当我们遇到$i$，使$height[i]<height[s.top()]$时，说明我们找到了$s.top()$所在下标高度的右侧边界。我们不断弹出栈，直到$height[i]>height[s.top]$，此时说明我们找到了以$i$为下标的高度的左侧边界，这就是对暴力法的优化。因此，我们需要两个数组，分别保存$i$的左边界和右边界。</p>
<h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><h5 id="最小栈应用场景"><a href="#最小栈应用场景" class="headerlink" title="最小栈应用场景"></a>最小栈应用场景</h5><blockquote>
<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>使用辅助栈的方式，将数据和最小值分别保存至两个栈中。当添加新数据时，如果新数据比辅助栈的栈顶数据还要小，那么就添加至栈中，否则没有必要更新辅助栈；当删除数据时，如果两个栈栈顶元素相同，则同时删除，否则只删除数据栈元素。</p>
<h4 id="895-最大频率栈"><a href="#895-最大频率栈" class="headerlink" title="895. 最大频率栈"></a><a href="https://leetcode-cn.com/problems/maximum-frequency-stack/">895. 最大频率栈</a></h4><blockquote>
<p>实现 FreqStack，模拟类似栈的数据结构的操作的一个类。FreqStack 有两个函数：</p>
<ul>
<li>push(int x)，将整数 x 推入栈中。</li>
<li>pop()，它移除并返回栈中出现最频繁的元素。如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</li>
</ul>
<p>示例：</p>
<p>输入：<br>[“FreqStack”,”push”,”push”,”push”,”push”,”push”,”push”,”pop”,”pop”,”pop”,”pop”],<br>[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]<br>输出：[null,null,null,null,null,null,null,5,7,5,4]<br>解释：<br>执行六次 .push 操作后，栈自底向上为 [5,7,5,7,4,5]。然后：</p>
<p>pop() -&gt; 返回 5，因为 5 是出现频率最高的。<br>栈变成 [5,7,5,7,4]。</p>
<p>pop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。<br>栈变成 [5,7,5,4]。</p>
<p>pop() -&gt; 返回 5 。<br>栈变成 [5,7,4]。</p>
<p>pop() -&gt; 返回 4 。<br>栈变成 [5,7]。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>这道题一开始想用双向链表做，但是仔细考虑了一下，双向链表虽然能够有效地进行添加或删除操作，但是由于最频繁的元素不只一个，无法用某种有效手段判断当前应该删除哪一个元素。因此我们还是从栈的角度考虑问题。我们需要解决如下几个问题：</p>
<ul>
<li>如何统计元素频率：使用哈希表</li>
<li>在具有相同的（最大）频率的元素中，怎么判断那个元素是最新的：我们可以使用栈来查询这一信息：靠近栈顶的元素总是相对更新一些。</li>
</ul>
<p>因此我们需要创建两个map，一个用于保存元素频率，另一个保存频率到该频率下的所有元素映射，例如输入的例子为：<code>1 2 3 1 1 3 3 4 5</code>，则产生的栈如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2           3           3</span><br><span class="line">1           1           1</span><br><span class="line">频率为1      频率为2      频率为3</span><br></pre></td></tr></table></figure>
<p>每次添加元素，我们将元素添加至对应的频率的栈中，删除时删除对应最大频率的栈顶元素即可</p>
<h3 id="栈的一些应用场景"><a href="#栈的一些应用场景" class="headerlink" title="栈的一些应用场景"></a>栈的一些应用场景</h3><p>栈的一个典型应用是配对问题，如括号的配对。</p>
<h4 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h4><h5 id="LeetCode-1021-删除最外层括号"><a href="#LeetCode-1021-删除最外层括号" class="headerlink" title="LeetCode 1021 删除最外层括号"></a>LeetCode 1021 删除最外层括号</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;(()())(())&quot;</span><br><span class="line">输出：&quot;()()()&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;。</span><br></pre></td></tr></table></figure>
<p>本题目分为两步，第一步是对字符串进行原语化分解，这里就用到了栈，当栈为空时，意味着找到了一个原语</p>
<h5 id="394-字符串解码2"><a href="#394-字符串解码2" class="headerlink" title="394. 字符串解码2"></a><a href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码</a><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h5><blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">&gt; 输出：&quot;aaabcbc&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路</p>
<p>这个题目本质上是一个括号配对问题，因为我们需要从内向外生成拼接字符串，和栈先入后出特性一致。当我们遇到左括号时，将数字和当前得到的字符串入栈，而当我们遇到右括号时，令<code>res = last_res + cur_counter * res</code>，其中<code>last_res</code>为上一个字符串，即栈顶的字符串。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res&#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; counter_stack&#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; res_stack&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;v : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v &gt;= <span class="string">'0'</span> &amp;&amp; v &lt;= <span class="string">'9'</span>) counter = counter*<span class="number">10</span> + (v-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v == <span class="string">'['</span>)&#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                **    保存该括号的重复次数</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                counter_stack.push(counter);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                **    将括号外的结果进行保存</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                res_stack.push(res);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                **    重置计数器和答案（因为答案已经保存在栈中）</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                counter = <span class="number">0</span>;</span><br><span class="line">                res = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v == <span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> repeat_time = counter_stack.top();</span><br><span class="line">                counter_stack.pop();</span><br><span class="line">                <span class="built_in">string</span> temp&#123;&#125;;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                **    res 保存括号内的字符，而栈顶保存当前括号重复次数</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;repeat_time;i++)&#123;</span><br><span class="line">                    temp += res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                **    将括号外的字符串和括号中重复的字符串进行拼接</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                res = res_stack.top() + temp;</span><br><span class="line">                res_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="LeetCode-232-用栈实现队列"><a href="#LeetCode-232-用栈实现队列" class="headerlink" title="LeetCode 232 用栈实现队列"></a>LeetCode 232 用栈实现队列</h4><p>一看这道题，栈和队列一个FIFO一个FILO，怎么能用栈实现队列呢？这里使用了两个栈，一个进行入队操作，一个进行出队操作。</p>
<h4 id="LeetCode-768-最多能完成排序的块"><a href="#LeetCode-768-最多能完成排序的块" class="headerlink" title="LeetCode 768   最多能完成排序的块"></a>LeetCode 768   最多能完成排序的块</h4><p>arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>
<p>我们最多能将数组分成多少块？</p>
<blockquote>
<p>输入: arr = [5,4,3,2,1]<br>输出: 1<br>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 </p>
<p>输入: arr = [2,1,3,4,4]<br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。<br>然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 </p>
</blockquote>
<p>解题思路<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>
<ul>
<li><p>排序块定义：</p>
<ul>
<li>设一个块中最大数字为$h$, 若块后面的所有数字都$&gt;=h$ ，则此块为排序块。排序块最短长度为1。</li>
</ul>
<p>例如，对于数组[1 2 1 3 4 7 5 6]，可以划分为：[1 | 2 1 | 3 | 4 | 7 5 6] 共5个排序块</p>
</li>
<li><p>贪心法则：</p>
</li>
</ul>
<h4 id="专题：语法分析"><a href="#专题：语法分析" class="headerlink" title="专题：语法分析"></a>专题：语法分析</h4><p>栈由于其先入后出的特性，可以用来进行语法特性分析，本专题将针对栈进行语法特性分析的一些场景进行总结。首先，在进行语法分析时，我们要明确何时进行入栈操作，何时进行出栈操作。以下题为例</p>
<p><a href="https://leetcode-cn.com/problems/simplify-path/">71. 简化路径</a></p>
<p>首先，在分析路径时，我们需要根据<code>&#39;/&#39;</code>对路径进行分割，然后看得到的所有操作符号，如果是<code>&quot;..&quot;</code>进行出栈操作，如果是<code>&quot;.&quot;</code>或<code>&quot;&quot;</code>则跳过，如果是普通路径，进行入栈操作。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>堆总是一棵完全二叉树。</li>
</ul>
<p>将<strong>根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆</strong>。常见的堆有二叉堆(优先队列)、斐波那契堆等。如果有问题要求<strong>从小到大或从大到小，可以考虑维护一个最小堆</strong>。或者按照如下方式构造堆：</p>
<h3 id="优先队列（大小顶堆）"><a href="#优先队列（大小顶堆）" class="headerlink" title="优先队列（大小顶堆）"></a>优先队列（大小顶堆）</h3><p>在C++中，优先队列即为大顶堆的实现，可以利用优先队列，实现堆排序的功能，当然，由于队列是先进先出的，因此每次只能得到最大值，如果想获得任意值，可以维护一个set作为优先队列，set是排序的，且可以获得其中任意值。或者按照如下方式构造堆：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; <span class="comment">//小顶堆</span></span><br></pre></td></tr></table></figure>
<p>如果想要获得前K小的元素，可以考虑维护一个大顶堆，然后依次将元素插入堆中，并保证堆的大小始终为K，如果超过K，将堆顶元素弹出。同理，如果获得前K大的元素，可以用小顶堆。(大用小，小用大)。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-deng-jie-/">LeetCode 768 题解</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/">LeetCode394题解</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>图</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 图(Graph)是表示物件与物件之间的网状关系的数学对象,是图论基本研究对象，本文将对图相关知识进行总结。</p>
<a id="more"></a>
<h2 id="图类问题解决步骤"><a href="#图类问题解决步骤" class="headerlink" title="图类问题解决步骤"></a>图类问题解决步骤</h2><h3 id="图的表示：邻接矩阵或邻接表"><a href="#图的表示：邻接矩阵或邻接表" class="headerlink" title="图的表示：邻接矩阵或邻接表"></a>图的表示：邻接矩阵或邻接表</h3><p>邻接矩阵或邻接表能够方便地查询顶点之间的关系，在邻接表中，键为起点，值为终点，而邻接矩阵中，<code>joint[i][j] == 1</code>表示从$i$到$j$有连接，邻接表占用空间较小而邻接矩阵占用空间较大。邻接表和邻接矩阵建立方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无向图邻接表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : edges)&#123;</span><br><span class="line">    graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">    graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//有向图邻接表    </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : edges)&#123;</span><br><span class="line">    graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的基本要素"><a href="#图的基本要素" class="headerlink" title="图的基本要素"></a>图的基本要素</h2><p>一般来说，当讨论图问题时，会有如下要素：</p>
<ul>
<li>顶点及顶点值，顶点集的大小叫做图的阶</li>
<li>顶点的度，即与某个顶点相连的边数。（对于有向图，度可进一步分为入度和出度即顶点的入边条数及出边条数）</li>
<li>边及边权重</li>
</ul>
<h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="图的DFS和BFS遍历"><a href="#图的DFS和BFS遍历" class="headerlink" title="图的DFS和BFS遍历"></a>图的DFS和BFS遍历</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Boolean visited[MAX_VERTEX_NUM]; <span class="comment">// 访问标志数组</span></span><br><span class="line">Status (*VisitFunc)(<span class="keyword">int</span> v); <span class="comment">// VisitFunc是访问函数，对图的每个顶点调用该函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span> <span class="params">(Graph G, Status(*Visit)(<span class="keyword">int</span> v))</span> </span>&#123;</span><br><span class="line">    VisitFunc = Visit;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        visited[v] = FALSE; <span class="comment">// 访问标志数组初始化</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span> (!visited[v])</span><br><span class="line">            DFS(G, v);  <span class="comment">// 对尚未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// 从第v个顶点出发递归地深度优先遍历图G</span></span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    VisitFunc(v);   <span class="comment">// 访问第v个顶点</span></span><br><span class="line">    <span class="keyword">for</span> (w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w))</span><br><span class="line">        <span class="comment">// FirstAdjVex返回v的第一个邻接顶点，若顶点在G中没有邻接顶点，则返回空（0）。</span></span><br><span class="line">        <span class="comment">// 若w是v的邻接顶点，NextAdjVex返回v的（相对于w的）下一个邻接顶点。</span></span><br><span class="line">        <span class="comment">// 若w是v的最后一个邻接点，则返回空（0）。</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            DFS(G, w);  <span class="comment">// 对v的尚未访问的邻接顶点w调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Boolean visited[ MAX_VERTEX_NUM ]; <span class="comment">// 访问标志数组</span></span><br><span class="line">Status (* VisitFunc)(<span class="keyword">int</span> v); <span class="comment">// VisitFunc是访问函数，对图的每个顶点调用该函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G, Status(* Visit)(<span class="keyword">int</span> v))</span> </span>&#123;</span><br><span class="line">    VisitFunc = Visit;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line">    initQueue(Q); <span class="comment">// 置空辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">            visited[v] = TRUE;</span><br><span class="line">            VisitFunc(v);</span><br><span class="line">            EnQueue(Q, v); <span class="comment">// v入队列</span></span><br><span class="line">            <span class="keyword">while</span> (!QueueEmpty(Q)) &#123;</span><br><span class="line">                DeQueue(Q, u); <span class="comment">// 队头元素出队并置为u</span></span><br><span class="line">                <span class="keyword">for</span> (w = FirstAdjVex(G, u);</span><br><span class="line">                        w &gt;= <span class="number">0</span>; w = NextAdjVex(G, u, w))</span><br><span class="line">                    <span class="keyword">if</span> (!Visited[w]) &#123; <span class="comment">// w为u的尚未访问的邻接顶点</span></span><br><span class="line">                        Visited[w] = TRUE;</span><br><span class="line">                        VisitFunc(w);</span><br><span class="line">                        EnQueue(Q, w);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h4 id="二分图定义1"><a href="#二分图定义1" class="headerlink" title="二分图定义1"></a>二分图定义<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h4><p><strong>二分图</strong>（<strong>Bipartite graph</strong>）是一类特殊的<strong>图</strong>，它可以被划分为两个部分，每个部分内的点互不相连。下图是典型的二分图。可以看到，$X$与$Y$内部节点互不连接，而相互之间有连接。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/v2-81f21981c992bc0b5b1acf04b37ff6c2_720w.jpg" width = "250"  alt="图片名称" align=center /></p>
<p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p>
<h4 id="二分图性质"><a href="#二分图性质" class="headerlink" title="二分图性质"></a>二分图性质</h4><ul>
<li>一个图若果为合法的二分图应是不存在一个或多个包含奇数个元素的环。</li>
</ul>
<h4 id="二分图基本操作"><a href="#二分图基本操作" class="headerlink" title="二分图基本操作"></a>二分图基本操作</h4><h5 id="判断二分图（染色法）"><a href="#判断二分图（染色法）" class="headerlink" title="判断二分图（染色法）"></a>判断二分图（染色法）</h5><p>思路</p>
<p>二分图和红黑树有一些类似，对于红黑树来说，一个节点要么是红要么是黑；同理，对于二分图，其节点要么为红，要么为黑。我们可以使用贪心的方法给图进行着色，一个节点为黑，那么所有邻接节点均为红，其邻接节点的邻接节点均为黑，以此类推。我们可以使用DFS或BFS解决此类问题。需要注意的是因为图中可能存在孤岛，因此需要遍历所有的节点。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = graph.size();</span><br><span class="line">     <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!dfs(graph, visited,i,<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> cur,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> last_color)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[cur] != <span class="number">0</span>)&#123;   <span class="comment">//说明当前节点已经被访问 1: 节点属于1, -1：节点属于-1</span></span><br><span class="line">        <span class="keyword">return</span> visited[cur] != last_color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[cur] = last_color == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[cur].size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(graph, visited, graph[cur][i],visited[cur])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="匈牙利算法（用于解决二分图最大匹配和最小点覆盖问题）"><a href="#匈牙利算法（用于解决二分图最大匹配和最小点覆盖问题）" class="headerlink" title="匈牙利算法（用于解决二分图最大匹配和最小点覆盖问题）"></a>匈牙利算法（用于解决二分图最大匹配和最小点覆盖问题）</h4><ol>
<li>最大匹配问题</li>
</ol>
<p>在上面的图中，如果X和Y中节点只能是一一匹配的关系，那么最大能够有多少个匹配数？</p>
<ol>
<li>最小点覆盖问题</li>
</ol>
<p>另外一个关于二分图的问题是求<strong>最小点覆盖</strong>：我们想找到<strong>最少</strong>的一些<strong>点</strong>，使二分图所有的边都<strong>至少有一个端点</strong>在这些点之中。倒过来说就是，删除包含这些点的边，可以删掉所有边。在上面的图中，删除Y2、X3、Y4即可删除所有的边。</p>
<h5 id="匈牙利算法应用"><a href="#匈牙利算法应用" class="headerlink" title="匈牙利算法应用"></a>匈牙利算法应用</h5><ol>
<li>棋盘覆盖（LeetCode LCP4）<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
</ol>
<p>你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为1 * 2的多米诺骨牌，你想把这些骨牌不重叠地覆盖在完好的格子上，请找出你最多能在棋盘上放多少块骨牌？这些骨牌可以横着或者竖着放。</p>
<blockquote>
<p>输入：n = 2, m = 3, broken = [[1, 0], [1, 1]]<br>输出：2<br>解释：我们最多可以放两块骨牌：[[0, 0], [0, 1]]以及[[0, 2], [1, 2]]。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/domino_example_1.jpg" width = "250"  alt="图片名称" align=center /></p>
<p>棋盘覆盖是一个经典的问题，查看下面的棋盘：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/v2-952b78faeed7a68af4349357e34efe8f_720w.jpg" width = "250"  alt="图片名称" align=center /></p>
<p>我们将棋盘染色，使黑白相互间隔，那么染色之后棋盘构成了一个二分图，白格只与黑格相连接，每个未删除的格子都与上下左右紧邻的未删除的格子相连，那么二分图的最大匹配数就是能放下的多米诺骨牌数目。</p>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><h3 id="无向图的定义"><a href="#无向图的定义" class="headerlink" title="无向图的定义"></a>无向图的定义</h3><p>在无向图中没有方向，节点u和v如果连接，则可以相互访问。</p>
<h3 id="无向图基本操作"><a href="#无向图基本操作" class="headerlink" title="无向图基本操作"></a>无向图基本操作</h3><h4 id="保存索引"><a href="#保存索引" class="headerlink" title="保存索引"></a>保存索引</h4><p>在使用无向图直线，要先将边的两个节点构成的索引对利用哈希进行保存，从而实现快速查找，需要注意的是，一个节点可能与多个节点相连，所以索引的值是vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : edges)&#123;</span><br><span class="line">    graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">    graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><a href="https://leetcode-cn.com/problems/clone-graph/">133. 图的深拷贝</a>图的深拷贝过程中，由于有环的存在，可能会出现重复搜索的情况，因此我们需要一个hashmap，对已经访问过的节点进行保存，如果发现某个节点已经被拷贝，那么直接返回复制的节点即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; neighbors;</span><br><span class="line">    </span><br><span class="line">    Node() &#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">        neighbors = <span class="built_in">vector</span>&lt;Node*&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = <span class="built_in">vector</span>&lt;Node*&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="keyword">int</span> _val, <span class="built_in">vector</span>&lt;Node*&gt; _neighbors) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; node_map&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node_map.find(node) != node_map.end()) <span class="keyword">return</span> node_map[node];</span><br><span class="line"></span><br><span class="line">        Node* result = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        node_map[node] = result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : node-&gt;neighbors)&#123;</span><br><span class="line">            result-&gt;neighbors.push_back(cloneGraph(v));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关问题还包括二叉树或链表的深拷贝</p>
<h4 id="计算无向图中连通分量的数目"><a href="#计算无向图中连通分量的数目" class="headerlink" title="计算无向图中连通分量的数目"></a>计算无向图中连通分量的数目</h4><p><a href="https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/">323. 无向图中连通分量的数目</a></p>
<blockquote>
<p>给定编号从 0 到 n-1 的 n 个节点和一个无向边列表（每条边都是一对节点），请编写一个函数来计算无向图中连通分量的数目。</p>
<p>示例 1:</p>
<p>输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]]</p>
<pre><code>0          3
|          |
1 --- 2    4 
</code></pre><p>输出: 2<br>示例 2:</p>
<p>输入: n = 5 和 edges = [[0, 1], [1, 2], [2, 3], [3, 4]]</p>
<pre><code>0           4
|           |
1 --- 2 --- 3
</code></pre><p>输出:  1<br>注意:<br>你可以假设在 edges 中不会出现重复的边。而且由于所以的边都是无向边，[0, 1] 与 [1, 0]  相同，所以它们不会同时在 edges 中出现。</p>
</blockquote>
<p>示例 1:</p>
<p>输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]]</p>
<pre><code> 0          3
 |          |
 1 --- 2    4 
</code></pre><p>输出: 2<br>你可以假设在 edges 中不会出现重复的边。而且由于所以的边都是无向边，[0, 1] 与 [1, 0]  相同，所以它们不会同时在 edges 中出现。</p>
<h5 id="解法1：DFS"><a href="#解法1：DFS" class="headerlink" title="解法1：DFS"></a>解法1：DFS</h5><p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(edges.empty() )<span class="keyword">return</span> n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : edges)&#123;</span><br><span class="line">        graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            ans ++;</span><br><span class="line">            dfs(graph, visited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    visited[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : graph[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">            dfs(graph, visited, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法2：BFS"><a href="#解法2：BFS" class="headerlink" title="解法2：BFS"></a>解法2：BFS</h5><h5 id="解法3：查并集"><a href="#解法3：查并集" class="headerlink" title="解法3：查并集"></a>解法3：查并集</h5><h4 id="判断是否成环"><a href="#判断是否成环" class="headerlink" title="判断是否成环"></a>判断是否成环</h4><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/undirected_graph_cycle.png" width = "450"  alt="图片名称" align=center /></p>
<h5 id="解法1：DFS-1"><a href="#解法1：DFS-1" class="headerlink" title="解法1：DFS"></a>解法1：DFS</h5><p>思路</p>
<p>我们从下面的图进行考虑<br><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      0</span><br><span class="line">    /   \</span><br><span class="line">   1     2 </span><br><span class="line">       /   \</span><br><span class="line">     3-------4</span><br><span class="line">     </span><br><span class="line">可以看到，图中2,3,4顶点构成了环，我们把没访问过的顶点记录为i，访问过的记录为i*，从顶点0开始进行访问，设定其父顶点为-1</span><br><span class="line"></span><br><span class="line">      0*</span><br><span class="line">    /   \</span><br><span class="line">   1     2 </span><br><span class="line">       /   \</span><br><span class="line">     3-------4</span><br><span class="line">访问后，顶点0状态改变，顶点</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; point&#123;&#125;;</span><br><span class="line">point.push(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(!point.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = point.top();</span><br><span class="line">    point.pop();</span><br><span class="line">    visited[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(graph[cur][i] == <span class="number">1</span>)&#123;    <span class="comment">//添加和当前搜索点相连的节点</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//例如有三个节点 i,j,k；通过i可以访问j和k，因此j和k要被压入栈中，而如果通过j访问到了k，且k已经被访问，说明i,j,k之间构成了环形</span></span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">           	graph[cur][i] = <span class="number">0</span>;  <span class="comment">//已经访问过的节点要删掉，防止重复访问</span></span><br><span class="line">            graph[i][cur] = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            point.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法2：BFS-1"><a href="#解法2：BFS-1" class="headerlink" title="解法2：BFS"></a>解法2：BFS</h5><p>和DFS类似</p>
<h5 id="解法3：查并集-1"><a href="#解法3：查并集-1" class="headerlink" title="解法3：查并集"></a>解法3：查并集</h5><p>查并集这种数据结构对于判断环是非常有用的，我们只需要判断一条边两个节点是否已经连接在一起，即可判断是否成环。</p>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><a href="https://leetcode-cn.com/problems/graph-valid-tree/">261. 以图判树</a></p>
<h4 id="判断图中子图的连通性"><a href="#判断图中子图的连通性" class="headerlink" title="判断图中子图的连通性"></a>判断图中子图的连通性</h4><p>在有些图中，子图之间可能没有桥，从而子图被分割为了两个部分，这种情况下需要我们对连通性进行判断，判断方法也比较简单，对图进行遍历，更新visited矩阵，然后遍历visited矩阵，看是否所有的图都能被访问到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//有顶点没有被访问，说明出现了断桥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="专题：染色问题"><a href="#专题：染色问题" class="headerlink" title="专题：染色问题"></a>专题：染色问题</h3><p>染色问题要求我们在图中对节点进行染色，相邻的节点为不同的颜色。本节将对常见的染色问题进行总结。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花</a></p>
<blockquote>
<p>有 N 个花园，按从 1 到 N 标记。在每个花园中，你打算种下四种花之一。</p>
<p>paths[i] = [x, y] 描述了花园 x 到花园 y 的双向路径。</p>
<p>另外，没有花园有 3 条以上的路径可以进入或者离开。</p>
<p>你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。</p>
<p>以数组形式返回选择的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用  1, 2, 3, 4 表示。保证存在答案。</p>
</blockquote>
<p>思路</p>
<p>我们的染色集合为$C={1,2,3,…,n}$，假设目前我们处理第$i$个节点，与节点$i$相连的节点集合为$P<em>i={j_1,j_2,…,j_m}$，其颜色集合为$C_i={C</em>{j<em>1},C</em>{j<em>2},C</em>{j<em>3}…,C</em>{j_m}}$，那么$i$可选取的颜色为$C\cap C_i$</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">gardenNoAdj</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; paths_table&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: paths)&#123;</span><br><span class="line">        paths_table[v[<span class="number">0</span>]<span class="number">-1</span>].push_back(v[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">        paths_table[v[<span class="number">1</span>]<span class="number">-1</span>].push_back(v[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; color&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; paths_table[i].size();k++)&#123;</span><br><span class="line">            color.erase(ans[paths_table[i][k]]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = *(color.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h3 id="有向图的定义"><a href="#有向图的定义" class="headerlink" title="有向图的定义"></a>有向图的定义</h3><h3 id="有向图基本操作"><a href="#有向图基本操作" class="headerlink" title="有向图基本操作"></a>有向图基本操作</h3><h4 id="判断是否成环（有向无环图）"><a href="#判断是否成环（有向无环图）" class="headerlink" title="判断是否成环（有向无环图）"></a>判断是否成环（有向无环图）</h4><h5 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h5><ul>
<li>借助一个标志表<code>visited</code>，用于判断每个节点<code>i</code>的状态<ul>
<li>$i=0$：尚未访问</li>
<li>$i=1$：已被当前节点出发的DFS访问</li>
<li>$i=-1$：已被其他节点出发的DFS访问</li>
</ul>
</li>
<li>对图中所有节点依次执行DFS，判断每个节点出发的DFS是否存在环，存在则返回False，流程如下：<ul>
<li>终止条件<ul>
<li>当<code>visited == -1</code>，说明当前访问节点已被其他节点出发的DFS访问，无需重复搜索，直接返回$true$</li>
<li>当<code>visited == 1</code>，说明当前访问节点已被本节点出发的DFS第二次访问，存在环，直接返回$false$</li>
</ul>
</li>
<li>将当前节点<code>i</code>对应的<code>visited[i]</code>置1，代表本节点已被访问</li>
<li>递归访问<code>i</code>的邻接节点，发现环直接返回$false$</li>
<li>当前节点所有邻接节点已被访问，不存在环，则将<code>visited[i]</code>设为-1并返回$true$</li>
</ul>
</li>
<li>整个图均未发现环，则返回$true$</li>
</ul>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : prerequisites)&#123;</span><br><span class="line">        graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(graph, visited, i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="keyword">int</span> cur_course)</span></span>&#123; <span class="comment">//true : 图无环</span></span><br><span class="line">    <span class="keyword">if</span>(visited[cur_course] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(visited[cur_course] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        visited[cur_course] = <span class="number">1</span>; <span class="comment">//正在搜索状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; graph[cur_course].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> next_course = graph[cur_course][i];</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph,visited,next_course)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[cur_course] = <span class="number">-1</span>;  <span class="comment">//搜索完成状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断是否有路径"><a href="#判断是否有路径" class="headerlink" title="判断是否有路径"></a>判断是否有路径</h4><h5 id="查并集"><a href="#查并集" class="headerlink" title="查并集"></a>查并集</h5><h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h5><p><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/">面试题 04.01. 节点间通路</a></p>
<blockquote>
<p>节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p>
<p> 输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2<br> 输出：true</p>
</blockquote>
<p>使用图的深度优先搜索即可完成，这一部分请参考图的深度优先搜索部分。</p>
<h3 id="带权值有向图"><a href="#带权值有向图" class="headerlink" title="带权值有向图"></a>带权值有向图</h3><h4 id="使用查并集处理带权有向图问题"><a href="#使用查并集处理带权有向图问题" class="headerlink" title="使用查并集处理带权有向图问题"></a>使用查并集处理带权有向图问题</h4><h5 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h5><p><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></p>
<blockquote>
<p>给出方程式 A / B = k, 其中 A 和 B 均为用字符串表示的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。</p>
<p>示例 :<br>给定 a / b = 2.0, b / c = 3.0<br>问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?<br>返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]</p>
<p>输入为: vector<pair<string, string>&gt; equations, vector<double>&amp; values, vector<pair<string, string>&gt; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector<double>类型。</p>
<p>基于上述例子，输入如下：</p>
<p>equations(方程式) = [ [“a”, “b”], [“b”, “c”] ],<br>values(方程式结果) = [2.0, 3.0],<br>queries(问题方程式) = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ].<br>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。</p>
</blockquote>
<p>思路</p>
<p>本题目就是典型的带权有向图问题。在解决问题之前，我们先做出如下定义：</p>
<ul>
<li>$f(a,b) = \frac{a}{b}$</li>
<li><code>parent[b] = a</code></li>
<li>令$b$在查并集中的根节点为<code>root(b)</code></li>
<li><code>weight[b]</code>表示<code>root(b)/b</code>的值，即</li>
</ul>
<script type="math/tex; mode=display">
w_b=\frac{r_b}{b}</script><p>假设<code>root(a)</code>到<code>a</code>的路径为</p>
<pre class="mermaid">graph LR
    nodera((root_a))
    nodea1((a1))
    nodea2((a2))
    nodean((an))
    nodea((a))

    nodera-->nodea1
    nodea1-->nodea2
    nodea2-->|...|nodean
    nodean-->nodea</pre>

<p>考虑$\frac{r_a}{r_b}$，我们有如下递推关系式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{r_a}{r_b} &= \frac{r_a/a_1}{r_b/b_1}\frac{a_1}{b_1}\\
&=\frac{f(r_a,a_1)*a_1}{f(r_b,b_1)*b_1}\\
&=\frac{f(r_a,a_1)*f(a_1,a_2)*a_2}{f(r_b,b_1)*f(b_1,b_2)*b_2}\\
&...\\
&=\frac{f(r_a,a_1)*f(a_1,a_2)*...*f(a_n,a)*a}{f(r_b,b_1)*f(b_1,b_2)*...*f(b_m,b)*b}\\
&=\frac{pm(a)}{pm(b)}\frac{a}{b}
\end{aligned}</script><p>如果我们知道了$r_a,r_b,pm(a),pm(b)$，即可求出$a/b$的值，$pm(a)=f(p(a),a)*pm(p(a))$，其中$p(a)$为$a$的父节点</p>
<p>代码</p>
<h3 id="专题：有向图的出度与入度"><a href="#专题：有向图的出度与入度" class="headerlink" title="专题：有向图的出度与入度"></a>专题：有向图的出度与入度</h3><p>对有向图而言，度可以分为入度和出度，有些问题需要我们计算有向图顶点的静流量，此时我们需要利用入度和出度进行计算。</p>
<h4 id="使用出入度的常见场景"><a href="#使用出入度的常见场景" class="headerlink" title="使用出入度的常见场景"></a>使用出入度的常见场景</h4><ul>
<li>对于一棵二叉树，根节点入度一定为0，叶节点出度为0，中间节点则既有出度也有入度</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/validate-binary-tree-nodes/">1361. 验证二叉树</a></p>
<blockquote>
<p>二叉树上有 n 个节点，按从 0 到 n - 1 编号，其中节点 i 的两个子节点分别是 leftChild[i] 和 rightChild[i]。只有 所有 节点能够形成且 只 形成 一颗 有效的二叉树时，返回 true；否则返回 false。如果节点 i 没有左子节点，那么 leftChild[i] 就等于 -1。右子节点也符合该规则。注意：节点没有值，本问题中仅仅使用节点编号。</p>
</blockquote>
<pre class="mermaid">graph TB
    node0((0))
    node1((1))
    node2((2))
    node3((3))

    node0-->node1
    node0-->node2
    node2-->node3</pre>

<blockquote>
<p>输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]<br>输出：true</p>
</blockquote>
<p>思路</p>
<p>我们首先要找到根节点，即入度为0的节点（可能不止一个，稍后讨论不止一个的情况），然后从该节点开始，进行搜索，看所有的节点是否都只访问了一次（如果多次，说明存在环或者多条路径，如果没访问，说明存在孤岛节点），从而判断是否为二叉树。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，本题使用中序遍历时间复杂度过高，所以采用前序实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateBinaryTreeNodes</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; leftChild, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rightChild)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inIndex</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftChild[i] !=<span class="number">-1</span>)  inIndex[leftChild[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(rightChild[i]!=<span class="number">-1</span>) inIndex[rightChild[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inIndex[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                root = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nodes&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">seen</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> curr = root;</span><br><span class="line">        <span class="keyword">int</span> seen_nodes_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        nodes.push(curr);</span><br><span class="line">        seen[curr]++;</span><br><span class="line">        seen_nodes_num++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = nodes.top();</span><br><span class="line">            nodes.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(leftChild[u] != <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(seen[leftChild[u]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    seen[leftChild[u]]++;</span><br><span class="line">                    seen_nodes_num++;</span><br><span class="line">                    nodes.push(leftChild[u]);</span><br><span class="line">                &#125; </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rightChild[u] != <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(seen[rightChild[u]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    seen[rightChild[u]]++;</span><br><span class="line">                    seen_nodes_num++;</span><br><span class="line">                    nodes.push(rightChild[u]);</span><br><span class="line">                &#125; </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seen_nodes_num == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其实就是在前序中多了几步判断，要求每个节点至少且至多访问一次。</span></span><br></pre></td></tr></table></figure>
<h4 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode-cn.com/problems/find-the-town-judge/">997. 找到小镇的法官</a></p>
<blockquote>
<p>找到阶为N的图中的某个顶点，其入度为N-1，出度为0</p>
</blockquote>
<p>思路</p>
<p>只要计算每个定点的出度与入度即可。</p>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="拓扑排序的定义"><a href="#拓扑排序的定义" class="headerlink" title="拓扑排序的定义"></a>拓扑排序的定义</h3><p>假设有$n$个变量，还有$m$个二元组$(u,v)$，分别表示变量$u$小于$v$，那么所有变量从小到大排列的结果应该为什么样呢？例如四个变量$a,b,c,d$，如果已知$a&lt;b,c&lt;d,d&lt;c$，则可能排序结果为：$a&lt;d&lt;c&lt;b$或$d&lt;a&lt;c&lt;b$。如果我们将变量视为一个点，小于关系看作一条有向边，那么就得到了一个有向图。<strong>我们的实际任务是把图所有节点排序，使$(u,v)$对应的$u$排在$v$之前</strong>。</p>
<h3 id="拓扑排序的性质"><a href="#拓扑排序的性质" class="headerlink" title="拓扑排序的性质"></a>拓扑排序的性质</h3><ul>
<li>如果图 $G$ 中存在环，那么图 $G$ 不存在拓扑排序</li>
<li>有向无环图拓扑排序可能不唯一</li>
</ul>
<h3 id="拓扑排序实现代码"><a href="#拓扑排序实现代码" class="headerlink" title="拓扑排序实现代码"></a>拓扑排序实现代码</h3><h4 id="解法1：DFS-2"><a href="#解法1：DFS-2" class="headerlink" title="解法1：DFS"></a>解法1：DFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;numCourses = numCourses;</span><br><span class="line">    graph.resize(numCourses);</span><br><span class="line">    visited.resize(numCourses);</span><br><span class="line">    hasCircle = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v:prerequisites)&#123;</span><br><span class="line">        graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses &amp;&amp; !hasCircle;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hasCircle) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>; <span class="comment">//搜索中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : graph[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123; <span class="comment">//节点未搜索</span></span><br><span class="line">            dfs(v);</span><br><span class="line">            <span class="keyword">if</span>(hasCircle) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)&#123;   <span class="comment">//节点搜索中，说明形成了环？此处存疑</span></span><br><span class="line">            hasCircle = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">2</span>;</span><br><span class="line">    ans.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拓扑排序其实和判断有向无环图代码类似，只不过多加了一步保存搜索结束的节点的过程</span></span><br></pre></td></tr></table></figure>
<h4 id="解法2：BFS-2"><a href="#解法2：BFS-2" class="headerlink" title="解法2：BFS"></a>解法2：BFS</h4><h2 id="路径规划3"><a href="#路径规划3" class="headerlink" title="路径规划3"></a>路径规划<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>图的生成树是一棵含有其所有的顶点的无环联通子图，一幅加权图的<strong>最小生成树（ MST ）</strong> 是它的一颗权值（树中所有边的权值之和）最小的生成树。</p>
<h4 id="求加权图的最小生成树算法"><a href="#求加权图的最小生成树算法" class="headerlink" title="求加权图的最小生成树算法"></a>求加权图的最小生成树算法</h4><p>假定一个图中有$N$个顶点，连接两个顶点会有一个成本<code>cost</code>，返回连接所有顶点的最小权值。对于加权图的最小生成树，我们可以确定的一点，最小生成树一定是无环的，因为如果有环，删掉一条边之后，权重一定会变小。</p>
<h4 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="kruskal 算法"></a>kruskal 算法</h4><p>Kruskal算法的基本原理是排序+查并集，首先将所有路径进行排序，然后利用查并集连接节点，如果某条边会够成环，就跳过该边，最后对路径数目进行累加，如果路径数目为$N-1$，代表所有的节点已经连接。具体步骤如下：</p>
<ol>
<li>将所有的边按照权重从小到大排序。</li>
<li>取一条权重最小的边。</li>
<li>使用并查集（union-find）数据结构来判断加入这条边后是否会形成环。若不会构成环，则将这条边加入最小生成树中。</li>
<li>检查所有的结点是否已经全部联通，这一点可以通过目前已经加入的边的数量来判断。若全部联通，则结束算法；否则返回步骤 2.</li>
</ol>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>Prim算法本质上是一个贪心算法，其基本原理</p>
<h3 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h3><h4 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h4><p>考虑如下问题，在加权无向图中，给定一个阈值距离$D$，找到某个节点$i$，使该节点在阈值距离$D$内邻居节点数目最少，此类问题我们可以使用Floyd算法解决。该算法本质上是一种动态规划算法，步骤如下：</p>
<ul>
<li>令<code>dp[i][j]</code>为从i到j的最短距离</li>
<li>$n$个节点依次作为插入节点，例如当前插入节点为$k$，若<code>dp[i][k] + dp[k][j] &lt; dp[i][j]</code>，更新<code>dp[i][j]</code>，即<code>dp[i][j]=min(dp[i][k]+dp[k][j], dp[i][j])</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Floyd算法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line"><span class="comment">// n个顶点依次作为插入点</span></span><br><span class="line"><span class="comment">// 注意插点k是放在第一层循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = min(dp[i][k]+dp[k][j], dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么k要放在第一层循环<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>
<p>这个源自Floyd的核心思想—动态规划，代码中的二维状态转移方程<code>D[i][j] = min(D[i,k]+D[k,j],D[i,j]);</code>，其实是从三维简化得到的。我们不妨从最初的三维说起，思路和二维一样：</p>
<ul>
<li>首先定义状态数组（也就是距离矩阵）<code>D[n][n][n]</code>，其中<code>D[k][i][j]</code>表示顶点<code>i</code>, 顶点<code>j</code>通过前<code>k</code>个顶点（0~k）得到的最短距离。</li>
<li><code>D[k][i][j]</code>是从<code>D[k-1][i][j]</code>和<code>D[k-1][i][k] + D[k-1][k][j]</code>两者中值较小的一个转移得到的，也就是说要在前k-1个顶点已经插入，更新距离矩阵状态之后，第k个顶点才能作为插入顶点。</li>
<li>归纳得到状态转移方程：<code>D[k][i][j] = min(D[k-1][i][j], D[k-1][i][k] + D[k-1][k][j])</code>。</li>
</ul>
<p>其中k的作用是标志到达了第几个插入点，也就是状态数组到达了哪个状态，不用刻意记录，于是减去第一维就变成了二维。明白了Floyd的三维dp思想，根据状 态转移方程在编码时就很自然的会将 k 放在第一层循环，而将k放在最后一层则是错误的编码。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://zhuanlan.zhihu.com/p/96229700">二分图</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/broken-board-dominoes/">棋盘覆盖问题</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://leetcode-cn.com/problems/connecting-cities-with-minimum-cost/solution/zui-di-cheng-ben-lian-tong-suo-you-cheng-shi-by-le/">图的最小生成树</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solution/yu-zhi-ju-chi-nei-lin-ju-zui-shao-de-cheng-shi-flo/">Floyd算法</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>多叉树</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%A4%9A%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Listen, a tree is growing</p>
</blockquote>
<a id="more"></a>
<p>有两个以上节点的树叫做多叉树。</p>
<h2 id="B树家族"><a href="#B树家族" class="headerlink" title="B树家族"></a>B树家族</h2><p>B树的典型应用是磁盘信息的存储，如果采用二叉树，会导致存储的信息过于分散，从而增大读取时间。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><h4 id="B树操作"><a href="#B树操作" class="headerlink" title="B树操作"></a>B树操作</h4><ul>
<li><p>查找操作</p>
</li>
<li><p>插入操作</p>
</li>
</ul>
<p>在插入过程中，会遇到三种情况： </p>
<ol>
<li>键值放入有空间的叶节点中</li>
</ol>
<p>这种情况直接把值放进去就可以。</p>
<ol>
<li>要插入键值的叶节点已经满了</li>
</ol>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Btreeinsert1.png" width = "480" alt="向一个满叶节点中插入数字6" align=center /></p>
<p>第一步，分裂叶节点，创建一个新叶节点，然后将已经慢了的一半键值转移至新叶节点中</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Btreeinsert2.png" alt="节点分裂"></p>
<p>第二步，将中间值放入父节点中，然后在父节点中放置一个指向新节点的指针，这里的中间值为6</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Btreeinsert3.png" alt="将中间值6放入父节点中，如果父节点已经满了，那么继续分裂"></p>
<ol>
<li>一种特殊情况，B树的根节点满了，这是唯一一个会引起B树高度增长的情况</li>
</ol>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Btreeinsert4.png" alt=""></p>
<ul>
<li>删除操作</li>
</ul>
<ol>
<li>如果删除键值K后，叶节点保持半满，那么直接删除即可</li>
<li>如果不能保持半满，会引起下溢</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B*树"></a>B*树</h3><p>B*树是B树的一种变种，要求除了根节点至少$2/3$满</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/400px-Bplustree.png" alt=""></p>
<h4 id="什么是B-树"><a href="#什么是B-树" class="headerlink" title="什么是B+树"></a>什么是B+树</h4><p>B+树可以简单理解为：<strong>叶节点是数据，内部节点是索引集</strong>。</p>
<ul>
<li>内部节点：存储键值、键值数量及指针</li>
<li>叶节点：存储键值、数据文件中与键值对应的引用以及指向下一叶节点的指针</li>
</ul>
<h4 id="B-树的技术特点与约束"><a href="#B-树的技术特点与约束" class="headerlink" title="B+树的技术特点与约束"></a>B+树的技术特点与约束</h4><ul>
<li>阶数$m$，每个节点中最多键值数，即上图一个大节点中的键值个数</li>
<li>半满约束，内节点键值最少为$\left \lfloor \frac{m}{2}+1 \right \rfloor$，即半满状态，当然根节点除外，根节点可以只有一个键值</li>
<li>每个节点对应一页的大小</li>
</ul>
<h4 id="B-树操作"><a href="#B-树操作" class="headerlink" title="B+树操作"></a>B+树操作</h4><ol>
<li>搜索算法<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">func tree-search(nodePointer, search-key-value K) <span class="keyword">return</span> nodePointer</span><br><span class="line">    <span class="keyword">if</span> *nodePointer 是叶节点 then</span><br><span class="line">        <span class="keyword">return</span> nodePointer;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> K&lt;K1 then</span><br><span class="line">            <span class="keyword">return</span> tree_search(P[<span class="number">0</span>],K);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> K &gt;= Kn then</span><br><span class="line">            <span class="keyword">return</span> tree_search(P[n],K);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            find i such that Ki&lt;=K&lt;=Ki+<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> tree_search(Pi,K);</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">endfunc;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/bplustreenew.png" alt=""></p>
<p>从上面的图可知，节点中的值是进行排序的，且小于父节点中的值。</p>
<ol>
<li>插入算法（节点分裂）</li>
</ol>
<p>以上图为例，插入18，可以发现节点未满，直接将18放入节点即可</p>
<p>插入8，发现需要被插入的节点已经满了，因此需要创建一个新的节点，来放置新的值，同时由于第一个节点已经满了，因此将节点1中的一半的值放进新节点中。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/bplustreeinsert2.png" alt=""></p>
<p>然后多了一个节点需要处理，有一个指针引向了上层，然而发现根节点已经没有位置了，就需要对根节点进行分裂，提出中间值作为根节点，然后将剩下的值进行分裂。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/btreeinsert3.png" alt=""></p>
<p>可以看到树深度增加了。B+树的插入算法如下所示：<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ program for B-Tree insertion </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A BTree node </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> *keys; <span class="comment">// An array of keys </span></span><br><span class="line">    <span class="keyword">int</span> t;	 <span class="comment">// Minimum degree (defines the range for number of keys) </span></span><br><span class="line">    BTreeNode **C; <span class="comment">// An array of child pointers </span></span><br><span class="line">    <span class="keyword">int</span> n;	 <span class="comment">// Current number of keys </span></span><br><span class="line">    <span class="keyword">bool</span> leaf; <span class="comment">// Is true when node is leaf. Otherwise false </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    BTreeNode(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">bool</span> _leaf); <span class="comment">// Constructor </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A utility function to insert a new key in the subtree rooted with </span></span><br><span class="line">    <span class="comment">// this node. The assumption is, the node must be non-full when this </span></span><br><span class="line">    <span class="comment">// function is called </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertNonFull</span><span class="params">(<span class="keyword">int</span> k)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A utility function to split the child y of this node. i is index of y in </span></span><br><span class="line">    <span class="comment">// child array C[]. The Child y must be full when this function is called </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splitChild</span><span class="params">(<span class="keyword">int</span> i, BTreeNode *y)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A function to traverse all nodes in a subtree rooted with this node </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A function to search a key in the subtree rooted with this node. </span></span><br><span class="line">    <span class="function">BTreeNode *<span class="title">search</span><span class="params">(<span class="keyword">int</span> k)</span></span>; <span class="comment">// returns NULL if k is not present. </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Make BTree friend of this so that we can access private members of this </span></span><br><span class="line"><span class="comment">// class in BTree functions </span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BTree</span>;</span> </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A BTree </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTree</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    BTreeNode *root; <span class="comment">// Pointer to root node </span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="comment">// Minimum degree </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// Constructor (Initializes tree as empty) </span></span><br><span class="line">    BTree(<span class="keyword">int</span> <span class="keyword">_t</span>) </span><br><span class="line">    &#123; root = <span class="literal">NULL</span>; t = <span class="keyword">_t</span>; &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// function to traverse the tree </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">if</span> (root != <span class="literal">NULL</span>) root-&gt;traverse(); &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// function to search a key in this tree </span></span><br><span class="line">    <span class="function">BTreeNode* <span class="title">search</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> (root == <span class="literal">NULL</span>)? <span class="literal">NULL</span> : root-&gt;search(k); &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// The main function that inserts a new key in this B-Tree </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor for BTreeNode class </span></span><br><span class="line">BTreeNode::BTreeNode(<span class="keyword">int</span> t1, <span class="keyword">bool</span> leaf1) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// Copy the given minimum degree and leaf property </span></span><br><span class="line">    t = t1; </span><br><span class="line">    leaf = leaf1; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for maximum number of possible keys </span></span><br><span class="line">    <span class="comment">// and child pointers </span></span><br><span class="line">    keys = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*t<span class="number">-1</span>]; </span><br><span class="line">    C = <span class="keyword">new</span> BTreeNode *[<span class="number">2</span>*t]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the number of keys as 0 </span></span><br><span class="line">    n = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to traverse all nodes in a subtree rooted with this node </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeNode::traverse</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// There are n keys and n+1 children, travers through n keys </span></span><br><span class="line">    <span class="comment">// and first n children </span></span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// If this is not leaf, then before printing key[i], </span></span><br><span class="line">        <span class="comment">// traverse the subtree rooted with child C[i]. </span></span><br><span class="line">        <span class="keyword">if</span> (leaf == <span class="literal">false</span>) </span><br><span class="line">            C[i]-&gt;traverse(); </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; keys[i]; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the subtree rooted with last child </span></span><br><span class="line">    <span class="keyword">if</span> (leaf == <span class="literal">false</span>) </span><br><span class="line">        C[i]-&gt;traverse(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to search key k in subtree rooted with this node </span></span><br><span class="line"><span class="function">BTreeNode *<span class="title">BTreeNode::search</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Find the first key greater than or equal to k </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; k &gt; keys[i]) </span><br><span class="line">        i++; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the found key is equal to k, return this node </span></span><br><span class="line">    <span class="keyword">if</span> (keys[i] == k) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key is not found here and this is a leaf node </span></span><br><span class="line">    <span class="keyword">if</span> (leaf == <span class="literal">true</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go to the appropriate child </span></span><br><span class="line">    <span class="keyword">return</span> C[i]-&gt;search(k); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// The main function that inserts a new key in this B-Tree </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTree::insert</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// If tree is empty </span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Allocate memory for root </span></span><br><span class="line">        root = <span class="keyword">new</span> BTreeNode(t, <span class="literal">true</span>); </span><br><span class="line">        root-&gt;keys[<span class="number">0</span>] = k; <span class="comment">// Insert key </span></span><br><span class="line">        root-&gt;n = <span class="number">1</span>; <span class="comment">// Update number of keys in root </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// If tree is not empty </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// If root is full, then tree grows in height </span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;n == <span class="number">2</span>*t<span class="number">-1</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// Allocate memory for new root </span></span><br><span class="line">            BTreeNode *s = <span class="keyword">new</span> BTreeNode(t, <span class="literal">false</span>); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make old root as child of new root </span></span><br><span class="line">            s-&gt;C[<span class="number">0</span>] = root; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Split the old root and move 1 key to the new root </span></span><br><span class="line">            s-&gt;splitChild(<span class="number">0</span>, root); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// New root has two children now. Decide which of the </span></span><br><span class="line">            <span class="comment">// two children is going to have new key </span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">if</span> (s-&gt;keys[<span class="number">0</span>] &lt; k) </span><br><span class="line">                i++; </span><br><span class="line">            s-&gt;C[i]-&gt;insertNonFull(k); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Change root </span></span><br><span class="line">            root = s; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// If root is not full, call insertNonFull for root </span></span><br><span class="line">            root-&gt;insertNonFull(k); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to insert a new key in this node </span></span><br><span class="line"><span class="comment">// The assumption is, the node must be non-full when this </span></span><br><span class="line"><span class="comment">// function is called </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeNode::insertNonFull</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Initialize index as index of rightmost element </span></span><br><span class="line">    <span class="keyword">int</span> i = n<span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a leaf node </span></span><br><span class="line">    <span class="keyword">if</span> (leaf == <span class="literal">true</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// The following loop does two things </span></span><br><span class="line">        <span class="comment">// a) Finds the location of new key to be inserted </span></span><br><span class="line">        <span class="comment">// b) Moves all greater keys to one place ahead </span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; keys[i] &gt; k) </span><br><span class="line">        &#123; </span><br><span class="line">            keys[i+<span class="number">1</span>] = keys[i]; </span><br><span class="line">            i--; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Insert the new key at found location </span></span><br><span class="line">        keys[i+<span class="number">1</span>] = k; </span><br><span class="line">        n = n+<span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// If this node is not leaf </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Find the child which is going to have the new key </span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; keys[i] &gt; k) </span><br><span class="line">            i--; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// See if the found child is full </span></span><br><span class="line">        <span class="keyword">if</span> (C[i+<span class="number">1</span>]-&gt;n == <span class="number">2</span>*t<span class="number">-1</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// If the child is full, then split it </span></span><br><span class="line">            splitChild(i+<span class="number">1</span>, C[i+<span class="number">1</span>]); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// After split, the middle key of C[i] goes up and </span></span><br><span class="line">            <span class="comment">// C[i] is splitted into two. See which of the two </span></span><br><span class="line">            <span class="comment">// is going to have the new key </span></span><br><span class="line">            <span class="keyword">if</span> (keys[i+<span class="number">1</span>] &lt; k) </span><br><span class="line">                i++; </span><br><span class="line">        &#125; </span><br><span class="line">        C[i+<span class="number">1</span>]-&gt;insertNonFull(k); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to split the child y of this node </span></span><br><span class="line"><span class="comment">// Note that y must be full when this function is called </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeNode::splitChild</span><span class="params">(<span class="keyword">int</span> i, BTreeNode *y)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Create a new node which is going to store (t-1) keys </span></span><br><span class="line">    <span class="comment">// of y </span></span><br><span class="line">    BTreeNode *z = <span class="keyword">new</span> BTreeNode(y-&gt;t, y-&gt;leaf); </span><br><span class="line">    z-&gt;n = t - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the last (t-1) keys of y to z </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t<span class="number">-1</span>; j++) </span><br><span class="line">        z-&gt;keys[j] = y-&gt;keys[j+t]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the last t children of y to z </span></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;leaf == <span class="literal">false</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++) </span><br><span class="line">            z-&gt;C[j] = y-&gt;C[j+t]; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reduce the number of keys in y </span></span><br><span class="line">    y-&gt;n = t - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since this node is going to have a new child, </span></span><br><span class="line">    <span class="comment">// create space of new child </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= i+<span class="number">1</span>; j--) </span><br><span class="line">        C[j+<span class="number">1</span>] = C[j]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Link the new child to this node </span></span><br><span class="line">    C[i+<span class="number">1</span>] = z; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A key of y will move to this node. Find the location of </span></span><br><span class="line">    <span class="comment">// new key and move all greater keys one space ahead </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= i; j--) </span><br><span class="line">        keys[j+<span class="number">1</span>] = keys[j]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the middle key of y to this node </span></span><br><span class="line">    keys[i] = y-&gt;keys[t<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increment count of keys in this node </span></span><br><span class="line">    n = n + <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver program to test above functions </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">BTree <span class="title">t</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// A B-Tree with minium degree 3 </span></span><br><span class="line">    t.insert(<span class="number">10</span>); </span><br><span class="line">    t.insert(<span class="number">20</span>); </span><br><span class="line">    t.insert(<span class="number">5</span>); </span><br><span class="line">    t.insert(<span class="number">6</span>); </span><br><span class="line">    t.insert(<span class="number">12</span>); </span><br><span class="line">    t.insert(<span class="number">30</span>); </span><br><span class="line">    t.insert(<span class="number">7</span>); </span><br><span class="line">    t.insert(<span class="number">17</span>); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Traversal of the constucted tree is "</span>; </span><br><span class="line">    t.traverse(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">6</span>; </span><br><span class="line">    (t.search(k) != <span class="literal">NULL</span>)? <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nPresent"</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nNot Present"</span>; </span><br><span class="line"></span><br><span class="line">    k = <span class="number">15</span>; </span><br><span class="line">    (t.search(k) != <span class="literal">NULL</span>)? <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nPresent"</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nNot Present"</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>删除算法（节点合并）</p>
<h3 id="B与B-树的区别"><a href="#B与B-树的区别" class="headerlink" title="B与B+树的区别"></a>B与B+树的区别</h3><p>B+树是B树的延伸，他们的主要区别如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">B Tree</th>
<th style="text-align:center">B+ Tree</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据存放在叶节点和普通节点中</td>
<td style="text-align:center">数据只存放在叶节点中</td>
</tr>
<tr>
<td style="text-align:center">搜索速度较慢</td>
<td style="text-align:center">搜索速度较快</td>
</tr>
<tr>
<td style="text-align:center">不需要额外的索引键</td>
<td style="text-align:center">需要保存额外的索引键</td>
</tr>
<tr>
<td style="text-align:center">删除操作很复杂</td>
<td style="text-align:center">删除操作比较简单，因为数据可以直接从叶节点中删除</td>
</tr>
<tr>
<td style="text-align:center">叶节点相互之间没有连接</td>
<td style="text-align:center">叶节点通过链表方式进行连接，从而便于遍历操作</td>
</tr>
</tbody>
</table>
</div>
<h2 id="字典树（前缀树）"><a href="#字典树（前缀树）" class="headerlink" title="字典树（前缀树）"></a>字典树（前缀树）</h2><h3 id="字典树的定义"><a href="#字典树的定义" class="headerlink" title="字典树的定义"></a>字典树的定义</h3><p>Trie树，即字典树，又称单词查找树或键树，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：<strong>最大限度地减少无谓的字符串比较，查询效率比哈希表高</strong>。字典树的基本原理就像查询字典一样，因此可以快速定位单词，非常高效。</p>
<h3 id="字典树的性质"><a href="#字典树的性质" class="headerlink" title="字典树的性质"></a>字典树的性质</h3><ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h3 id="字典树及其方法的实现"><a href="#字典树及其方法的实现" class="headerlink" title="字典树及其方法的实现"></a>字典树及其方法的实现</h3><p>下面给出一种常用字典树及其方法的实现，包括添加单词和搜索单词两种操作，字典树类成员变量如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Trie*&gt; children;  <span class="comment">//子节点，每个节点都是一个Trie* 结构</span></span><br><span class="line">    <span class="keyword">bool</span> is_end;             <span class="comment">//用于判断一棵分支是否已经到达叶节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<p>一些基本成员函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Trie() : children&#123;<span class="built_in">vector</span>&lt;Trie*&gt;(R)&#125;,</span><br><span class="line">         is_end&#123;<span class="literal">false</span>&#125; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contain_key</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;                      <span class="comment">//当前节点为根节点下是否包含字符ch</span></span><br><span class="line">    <span class="keyword">return</span> children[ch - <span class="string">'a'</span>] != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Trie* <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;                   <span class="comment">//返回子树</span></span><br><span class="line">    <span class="keyword">return</span> children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch, Trie* node)</span> </span>&#123;       <span class="comment">//将node拼接至节点下</span></span><br><span class="line">    children[ch -<span class="string">'a'</span>] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    is_end = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_is_end</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> is_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入键"><a href="#插入键" class="headerlink" title="插入键"></a>插入键</h4><p>我们通过搜索 Trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况：</p>
<ul>
<li>链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。</li>
<li>链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。</li>
</ul>
<p>重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;ch : word)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ch - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;children[idx] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            node-&gt;children[idx] = <span class="keyword">new</span> Trie();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;is_end = <span class="literal">true</span>;    <span class="comment">//树结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/tireinsert.png" width = "550"  alt="图片名称" align=center /></p>
<h4 id="搜索键及前缀"><a href="#搜索键及前缀" class="headerlink" title="搜索键及前缀"></a>搜索键及前缀</h4><p>每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：</p>
<ul>
<li><p>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。</p>
</li>
<li><p>不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false :</p>
<ul>
<li>还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。</li>
<li>没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;  </span><br><span class="line">    Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>&amp; ch : word)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx=ch-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;children[idx] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        node = node-&gt;children[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;is_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搜索前缀与搜索键类似，只是不需要判断是否结尾，如果前缀能够完整在树中找到，那么直接返回true即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">    Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>&amp; ch : prefix)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx=ch-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;children[idx] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        node = node-&gt;children[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字典树应用场景"><a href="#字典树应用场景" class="headerlink" title="字典树应用场景"></a>字典树应用场景</h3><p>字典树常用应用场景如下：</p>
<ul>
<li>自动补全</li>
<li>拼写检查</li>
<li>IP路由</li>
<li>打字预测等</li>
</ul>
<h3 id="字典树与哈希表对比"><a href="#字典树与哈希表对比" class="headerlink" title="字典树与哈希表对比"></a>字典树与哈希表对比</h3><p>尽管哈希表可以在 $O(1)$ 时间内寻找键值，却无法高效的完成以下操作：</p>
<ul>
<li>找到具有同一前缀的全部键值</li>
<li>按词典序枚举字符串的数据集</li>
</ul>
<p>Trie 树优于哈希表的另一个理由是，随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到$O(n)$，其中 $n$ 是插入的键的数量。与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 Trie 树只需要 $O(m)$ 的时间复杂度，其中$m$为键长。而在平衡树中查找键值需要$O(m \log n)$ 时间复杂度。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/">实现Trie树</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对数组的相关知识进行总结。</p>
<a id="more"></a>
<h2 id="数组基本性质"><a href="#数组基本性质" class="headerlink" title="数组基本性质"></a>数组基本性质</h2><ul>
<li>一个长度为$N$的数组共有$\frac{(1+N)N}{2}$个子数组</li>
</ul>
<h2 id="特殊数组"><a href="#特殊数组" class="headerlink" title="特殊数组"></a>特殊数组</h2><h3 id="树状数组（Binary-Indexed-Tree）"><a href="#树状数组（Binary-Indexed-Tree）" class="headerlink" title="树状数组（Binary Indexed Tree）"></a>树状数组（Binary Indexed Tree）</h3><h2 id="数组基本操作"><a href="#数组基本操作" class="headerlink" title="数组基本操作"></a>数组基本操作</h2><h3 id="从非起始位置遍历"><a href="#从非起始位置遍历" class="headerlink" title="从非起始位置遍历"></a>从非起始位置遍历</h3><p>有些时候，我们需要从数组的中间某个位置开始，对数组进行遍历。我们可以写两个循环，第一个循环遍历后半部分，第二个循环从0开始遍历前半部分，但是更简洁的写法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">    <span class="built_in">array</span>[(pos + i) % length] = <span class="number">0</span>;   <span class="comment">// pos是数组中间某个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个数组交集"><a href="#求两个数组交集" class="headerlink" title="求两个数组交集"></a>求两个数组交集</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums1_set</span><span class="params">(nums1.begin(),nums1.end())</span></span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res_set;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; nums2.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(nums1_set.find(nums2[i]) != nums1_set.end())  <span class="comment">//set寻找语句</span></span><br><span class="line">                res_set.insert(nums2[i]);      <span class="comment">//set插入语句</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res_set.begin(),res_set.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;   <span class="comment">//这段代码能够找到两个数组中相同的元素，但是如果两个数组中存在重复元素，并不能找到</span></span><br></pre></td></tr></table></figure>
<p>LeetCode <a href="https://leetcode-cn.com/problems/master-mind-lcci/">面试题 16.15. 珠玑妙算</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">masterMind</span><span class="params">(<span class="built_in">string</span> solution, <span class="built_in">string</span> guess)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; s,g;<span class="comment">//双字典记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: solution)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.find(c)==s.end()) s[c]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> s[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: guess)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g.find(c)==g.end()) g[c]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> g[c]++;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">//这里采用双字典，即使有重复元素，也能够找到</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=s.begin();it!=s.end();it++)&#123;<span class="comment">//计算“猜中“和“伪猜中”的总个数</span></span><br><span class="line">            <span class="keyword">if</span>(g.find((*it).first)!=g.end()) </span><br><span class="line">                ans[<span class="number">1</span>]+=min((*it).second,g[(*it).first]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(solution[i]==guess[i])&#123;</span><br><span class="line">                ans[<span class="number">0</span>]++;<span class="comment">//“猜中“</span></span><br><span class="line">                ans[<span class="number">1</span>]--;<span class="comment">//总个数-“猜中“=“伪猜中”</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="string转整数"><a href="#string转整数" class="headerlink" title="string转整数"></a>string转整数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>(i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">    ans = ans*<span class="number">10</span>+nums[i];   <span class="comment">//十进制就乘10，二进制就乘2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LeetCode1018 <a href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/">可被 5 整除的二进制前缀</a></p>
<h2 id="数组特殊操作"><a href="#数组特殊操作" class="headerlink" title="数组特殊操作"></a>数组特殊操作</h2><h3 id="寻找数组中特定元素类"><a href="#寻找数组中特定元素类" class="headerlink" title="寻找数组中特定元素类"></a>寻找数组中特定元素类</h3><h4 id="寻找多数元素"><a href="#寻找多数元素" class="headerlink" title="寻找多数元素"></a>寻找多数元素</h4><blockquote>
<p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>这里介绍一种莫尔投票法，初始选择一个数作为众数候选人，然后遍历，如果下一个元素等于众数，那么票数+1，否则票数-1，如果票数为-1，那么说明需要更换候选人，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找到前三大的数和前2小的两个数"><a href="#找到前三大的数和前2小的两个数" class="headerlink" title="找到前三大的数和前2小的两个数"></a>找到前三大的数和前2小的两个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= min1) &#123;</span><br><span class="line">        min2 = min1;</span><br><span class="line">        min1 = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= min2) &#123;     <span class="comment">// n lies between min1 and min2</span></span><br><span class="line">        min2 = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= max1) &#123;            <span class="comment">// n is greater than max1, max2 and max3</span></span><br><span class="line">        max3 = max2;            </span><br><span class="line">        max2 = max1;</span><br><span class="line">        max1 = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= max2) &#123;     <span class="comment">// n lies betweeen max1 and max2</span></span><br><span class="line">        max3 = max2;</span><br><span class="line">        max2 = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= max3) &#123;     <span class="comment">// n lies betwen max2 and max3</span></span><br><span class="line">        max3 = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串常见性质"><a href="#字符串常见性质" class="headerlink" title="字符串常见性质"></a>字符串常见性质</h3><ol>
<li>一个长度为$n$的字符串的字串一共有$n!$个</li>
</ol>
<h3 id="字符串常见操作"><a href="#字符串常见操作" class="headerlink" title="字符串常见操作"></a>字符串常见操作</h3><h4 id="字符串分割1"><a href="#字符串分割1" class="headerlink" title="字符串分割1"></a>字符串分割<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h4><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data = <span class="string">"1_2_3_4_5_6"</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> item;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::getline(ss, item, <span class="string">'_'</span>))    <span class="comment">//以指定字符_对字符串进行分割</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用正则表达式匹配</span></span><br><span class="line"><span class="function">regex <span class="title">ws_re</span><span class="params">(<span class="string">"\\s+"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v</span><span class="params">(sregex_token_iterator(s.begin(),s.end(),ws_re,<span class="number">-1</span>), sregex_token_iterator())</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;n:v)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手工实现字符串分割，其中s表示被分割的字符串，c表示分割符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SplitString</span><span class="params">(<span class="built_in">string</span> &amp; s,<span class="built_in">string</span> &amp; c, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos1 = <span class="number">0</span>, pos2 = s.find(c);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">string</span>::npos != pos2)&#123;</span><br><span class="line">        v.push_back(s.substr(pos1, pos2 - pos1));</span><br><span class="line">        pos1 = pos2 + c.size();</span><br><span class="line">        pos2 = s.find(c, pos1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos1 != s.length())</span><br><span class="line">        v.push_back(s.substr(pos1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录字符串中单词的个数（此处单词为广义单词，仅为字符串被空格分隔的片段个数）</span></span><br><span class="line"><span class="comment">//这里采用了一种倒序法，判断字母前一个位置是否为空格，如果是，说明此处出现新单词，当然第一个单词需要额外进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( (i == <span class="number">0</span> || s[i<span class="number">-1</span>] == <span class="string">' '</span> ) &amp;&amp; s[i] != <span class="string">' '</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法有一些问题，如果字符串中包含有多个连续空格，那么会产生空的子字符串，所以需要进行特判，将这些空子字符串进行排除。</p>
<h4 id="字符串提取字串"><a href="#字符串提取字串" class="headerlink" title="字符串提取字串"></a>字符串提取字串</h4><h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><p>KMP算法能够在$O(m+n)$的时间复杂度实现两个字符串的匹配。所谓匹配，指给定字符串<code>S</code>和模式串<code>P</code>，判断<code>P</code>是否为<code>S</code>的子串。</p>
<h5 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *buff = <span class="string">"this is a test string"</span>;</span><br><span class="line"><span class="keyword">char</span> subbuff[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memcpy</span>( subbuff, &amp;buff[<span class="number">10</span>], <span class="number">4</span> );   <span class="comment">//提取从buff[10]开始的4个长度的字符串</span></span><br><span class="line">subbuff[<span class="number">4</span>] = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="string用法总结"><a href="#string用法总结" class="headerlink" title="string用法总结"></a>string用法总结</h3><p>string本质上是一个特化的容器类，可以视为<code>vector&lt;char&gt;</code>。本节对string的常用方法进行总结。</p>
<h4 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(s.begin()+n,s.end())</span></span>;     <span class="comment">//注意拷贝范围是0至end-1,左闭右开区间</span></span><br></pre></td></tr></table></figure>
<h4 id="提取子string"><a href="#提取子string" class="headerlink" title="提取子string"></a>提取子string</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> a = s.substr(<span class="number">0</span>,<span class="number">5</span>);     <span class="comment">//获得字符串s中从第0位开始的长度为5的字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="实现strstr函数"><a href="#实现strstr函数" class="headerlink" title="实现strstr函数"></a>实现strstr函数</h4><blockquote>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span>&amp; haystack, <span class="built_in">string</span>&amp; needle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; haystack.size() &amp;&amp; second &lt; needle.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(haystack[first] != needle[second])&#123;</span><br><span class="line">            first = first-second+<span class="number">1</span>; <span class="comment">//回溯，从下一个位置开始搜索</span></span><br><span class="line">            second = <span class="number">0</span>;             <span class="comment">//回溯，将指针回至0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            first++;</span><br><span class="line">            second++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(second &gt;= needle.size()) <span class="keyword">return</span> first - needle.size();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用计数器处理string中字符"><a href="#使用计数器处理string中字符" class="headerlink" title="使用计数器处理string中字符"></a>使用计数器处理string中字符</h4><p>在有些情况下，我们需要统计string中出现字符的次数，如果仅仅考虑26个英文单词，那么我们可以设置一个大小为26的vector，然后将对应位加一，例如LeetCode<a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></p>
<p>判断两个string是否包含相同的字母，只是字母顺序发生变化，那么我们可以设置一个计数器，遍历两个string，一个对计数器递增，一个递减，最后判断是否都为0即可。</p>
<p>LeetCode <a href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></p>
<h4 id="字符串原地替换"><a href="#字符串原地替换" class="headerlink" title="字符串原地替换"></a>字符串原地替换</h4><p>在有些时候，我们需要将字符串中某些字符进行替换，例如在字符串URL化过程中，我们需要将空格替换为‘%20’，这种情况下我们需要进行两步操作</p>
<ul>
<li>对字符串进行空间扩充</li>
<li>利用双指针，一个指向最后一个不为空格的字符，另一个指向字符串的末尾，从后往前进行替换，这样可以保证不会把前面的替换掉</li>
</ul>
<h4 id="字符串相同字符统计"><a href="#字符串相同字符统计" class="headerlink" title="字符串相同字符统计"></a>字符串相同字符统计</h4><p>给定下面的代码，可以统计字符串中包含相同字符的子串的个数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countLetters</span><span class="params">(<span class="keyword">char</span> * S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i<span class="number">-1</span>] == S[i])</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (count * (count + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (count * (count + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高维数组"><a href="#高维数组" class="headerlink" title="高维数组"></a>高维数组</h2><h3 id="高维数组索引"><a href="#高维数组索引" class="headerlink" title="高维数组索引"></a>高维数组索引</h3><p>LeetCode面试题04 二维数组中的查找</p>
<blockquote>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>[<br> [1,   4,  7, 11, 15],<br> [2,   5,  8, 12, 19],<br> [3,   6,  9, 16, 22],<br> [10, 13, 14, 17, 24],<br> [18, 21, 23, 26, 30]<br>]</p>
</blockquote>
<p>这类数组有一个特点，即存在标志数，即左下角或右上角元素，左下角元素为所在列最大元素，所在行最小元素。将该标志数记为flag，则有</p>
<ul>
<li>flag &gt; target：说明target一定在flag之上，即flag所在行可以消去，即(row—)</li>
<li>flag == target：找到返回</li>
<li>flag &lt; target：说明target在flag右侧，flag所在列可以消去(col++)</li>
</ul>
<h3 id="专题：区间问题"><a href="#专题：区间问题" class="headerlink" title="专题：区间问题"></a>专题：区间问题</h3><h3 id="高维子数组"><a href="#高维子数组" class="headerlink" title="高维子数组"></a>高维子数组</h3><p>当我们处理迷宫问题或者进行图像处理时，往往需要分析高维数组的子数组，此时我们可以借助方向矩阵或者子数组提取循环，这样可以避免写出大量的边界判断语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取3×3的子矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nr = r<span class="number">-1</span>; nr &lt;= r+<span class="number">1</span>; ++nr)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nc = c<span class="number">-1</span>; nc &lt;= c+<span class="number">1</span>; ++nc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C)</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode上关于数组的题目"><a href="#LeetCode上关于数组的题目" class="headerlink" title="LeetCode上关于数组的题目"></a>LeetCode上关于数组的题目</h2><h3 id="专题：大数相加问题"><a href="#专题：大数相加问题" class="headerlink" title="专题：大数相加问题"></a>专题：大数相加问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ans_stack&#123;&#125;;</span><br><span class="line">        <span class="built_in">string</span> ans&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> flag&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> curr_ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!num1.empty() &amp;&amp; !num2.empty())&#123;</span><br><span class="line">            curr_ans = (num1[num1.size()<span class="number">-1</span>] - <span class="string">'0'</span>) + (num2[num2.size()<span class="number">-1</span>] - <span class="string">'0'</span>) + flag;</span><br><span class="line">            flag = curr_ans / <span class="number">10</span>;</span><br><span class="line">            curr_ans %= <span class="number">10</span>;</span><br><span class="line">            ans_stack.push(curr_ans+<span class="string">'0'</span>);</span><br><span class="line">            num1.erase(num1.size()<span class="number">-1</span>);</span><br><span class="line">            num2.erase(num2.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!num1.empty())&#123;</span><br><span class="line">            curr_ans = (num1[num1.size()<span class="number">-1</span>] - <span class="string">'0'</span>) + flag;</span><br><span class="line">            flag = curr_ans / <span class="number">10</span>;</span><br><span class="line">            curr_ans %= <span class="number">10</span>;</span><br><span class="line">            ans_stack.push(curr_ans+<span class="string">'0'</span>);</span><br><span class="line">            num1.erase(num1.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!num2.empty())&#123;</span><br><span class="line">            curr_ans = (num2[num2.size()<span class="number">-1</span>] - <span class="string">'0'</span>) + flag;</span><br><span class="line">            flag = curr_ans / <span class="number">10</span>;</span><br><span class="line">            curr_ans %= <span class="number">10</span>;</span><br><span class="line">            ans_stack.push(curr_ans+<span class="string">'0'</span>);</span><br><span class="line">            num2.erase(num2.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans_stack.push(flag+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!ans_stack.empty())&#123;</span><br><span class="line">            ans += ans_stack.top();</span><br><span class="line">            ans_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路并不复杂，但是这个模板比较常用，建议熟练掌握，其中使用栈对结果进行了保存。</p>
<h3 id="专题：子序列问题"><a href="#专题：子序列问题" class="headerlink" title="专题：子序列问题"></a>专题：子序列问题</h3><h3 id="42-接雨水2"><a href="#42-接雨水2" class="headerlink" title="42 接雨水2"></a>42 接雨水<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/rainwatertrap.png" alt=""></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<h4 id="思路1-按列求-动态规划"><a href="#思路1-按列求-动态规划" class="headerlink" title="思路1 按列求+动态规划"></a>思路1 按列求+动态规划</h4><p>一列一列求雨水，然后按照木桶原理，确定左右两端最高的墙。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/542754f4431d93141920185252aee31664a96dd17285b92dfe390e9e977bebb1-image.png" alt=""></p>
<p>只有当正在求的列高度小于min(max_left,max_right)，才能够存储水，为了找到每个列两侧最大值，普通方法是遍历，会重复求解，可以利用动态规划，设置两个数组，<code>max_left [i]</code>代表第 <code>i</code> 列左边最高的墙的高度，<code>max_right[i]</code> 代表第 <code>i</code> 列右边最高的墙的高度。</p>
<p>对于 <code>max_left</code>我们其实可以这样求:<code>max_left [i] = Max(max_left [i-1]</code>,<code>height[i-1])</code></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> *max_left = <span class="keyword">new</span> <span class="keyword">int</span>[height.size()]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> *max_right = <span class="keyword">new</span> <span class="keyword">int</span>[height.size()]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i &lt;= height.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            max_left[i] = max(max_left[i<span class="number">-1</span>],height[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=height.size() - <span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            max_right[i] = max(max_right[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;height.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> min_wall_height = min(max_left[i],max_right[i]);</span><br><span class="line">            <span class="keyword">if</span>(min_wall_height &gt; height[i])&#123;</span><br><span class="line">                ans += min_wall_height - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.cnblogs.com/shuqingstudy/p/9622793.html">字符串分割</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/">接雨水参考答案</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>一去二三里，烟村四五家，亭台六七座，八九十枝花</p>
</blockquote>
<a id="more"></a>
<h2 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h2><h3 id="插入排序（稳定）"><a href="#插入排序（稳定）" class="headerlink" title="插入排序（稳定）"></a>插入排序（稳定）</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>将数组分为未排序的和已排序的两部分，在未排序的数组中依次读取新的元素，然后在已经排好序的数组中进行插入操作。关于插入排序更详细的描述请参考<a href="/2024/10/13/计算机/算法/课程/MIT6006-3/" title="MIT课程中关于sort排序的讲解">MIT课程中关于sort排序的讲解</a></p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>优点：已经排列好的数据不会被移动</li>
<li>缺点：插入动作可能导致大量元素的移动，平均时间复杂度为$O(n^2)$</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(T data[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;n;i++)&#123;    <span class="comment">//令data[0]为第一个已经排好序的数组</span></span><br><span class="line">        T temp = data[i];      <span class="comment">//1到n-1则是未排序的数组，data[i]是还未排序的元素</span></span><br><span class="line">        <span class="keyword">for</span>(j = i; j&gt;<span class="number">0</span> &amp;&amp; temp &lt; data[j<span class="number">-1</span>]; j--)   <span class="comment">//将data[i]依次与已排序数组中的元素对比，进行移动操作，temp &lt; data[j-1]代表前面比后面大，位置不对</span></span><br><span class="line">            data[j] = data[j<span class="number">-1</span>];  <span class="comment">//将元素依次移位，前面的大的挪到后面</span></span><br><span class="line">        data[j] = temp;      <span class="comment">//进行插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>何时使用：当不需要额外空间，排序比较简单，当对连续的数据流进行排序时</li>
<li>何时不用：当平均情况很差时</li>
</ul>
<h3 id="选择排序（不稳定）"><a href="#选择排序（不稳定）" class="headerlink" title="选择排序（不稳定）"></a>选择排序（不稳定）</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>找到数组中最小的元素，将其与第一个位置的元素交换，然后在剩余的data[1],……,data[n]中找到最小的元素，把他放到第二个位置。</p>
<h4 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h4><ul>
<li>优点：赋值次数少</li>
<li>缺点：交换次数多</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(T data[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j,least; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>,least = i; j &lt; n; j++)&#123; <span class="comment">//每次循环，least都等于i</span></span><br><span class="line">            <span class="keyword">if</span>(data[j] &lt; data[least])</span><br><span class="line">                least = j;   <span class="comment">//least是最小元素的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != least)</span><br><span class="line">        	swap(data[least],data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序（稳定）"><a href="#冒泡排序（稳定）" class="headerlink" title="冒泡排序（稳定）"></a>冒泡排序（稳定）</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>不断交换相邻逆序元素实现排序</p>
<h4 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h4><ul>
<li>优点：空间复杂度为$O(1)$</li>
<li>缺点：时间复杂度$O(n^2)$，做了大量无用比较</li>
</ul>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T data[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i; --j)</span><br><span class="line">            <span class="keyword">if</span>(data[j] &lt; data[j<span class="number">-1</span>])</span><br><span class="line">                swap(data[j],data[j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高效排序算法"><a href="#高效排序算法" class="headerlink" title="高效排序算法"></a>高效排序算法</h2><h3 id="希尔排序（不稳定）"><a href="#希尔排序（不稳定）" class="headerlink" title="希尔排序（不稳定）"></a>希尔排序（不稳定）</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>实际上是一种改进的插入排序算法，将数组分为$h$个子数组，然后每一段进行排序，排序方法一般选择插入排序（考虑插入排序的优点，对几乎已经排好的数据可以达到线性操作）。</p>
<p>增量选择一般服从如下条件：</p>
<script type="math/tex; mode=display">
h_1=1\\
h_{i+1}=3h_i+1</script><p>当$h_{i+1}&gt;n$时停止，希尔排序的原理可以用如下图进行表示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/shell_sort_gap_4.jpg" alt=""></p>
<p>此处$h=4$，先对跨步长选取的子数组进行排序，排好序之后数列变为<code>14 19 27 10 35 33 27 44</code>，然后令$h=1$，再进行选择排序即可</p>
<h4 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h4><ul>
<li>优点：降低了时间复杂度</li>
<li>缺点：不稳定，复杂度仍然较高</li>
</ul>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(T data[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i,j,h_cnt,h;  <span class="comment">//暗示程序会对这些变量进行频繁使用</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; increments&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(h = <span class="number">1</span>; h &lt; n; i++)&#123;</span><br><span class="line">        increments.push_back(h);</span><br><span class="line">        h = <span class="number">3</span>h + <span class="number">1</span>;</span><br><span class="line">    &#125;  <span class="comment">//创建增量数组</span></span><br><span class="line">    i--;</span><br><span class="line">    <span class="comment">//对增量进行循环</span></span><br><span class="line">    <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        h = increments[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//划分增量子数组</span></span><br><span class="line">        <span class="keyword">for</span>(h_cnt = h; h_cnt &lt; <span class="number">2</span>*h; h_cnt++)&#123;  <span class="comment">//h_cnt = 2h 后，就开始重复了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对子数组进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(j = h_cnt; j &lt; n)&#123;   </span><br><span class="line">                T tmp = data[j];</span><br><span class="line">                k = j;</span><br><span class="line">                <span class="keyword">while</span>(k-h&gt;<span class="number">0</span> &amp;&amp; tmp &lt; data[k-h])&#123;  </span><br><span class="line">                    data[k] = data[k-h];</span><br><span class="line">                    k-=h;</span><br><span class="line">                &#125;</span><br><span class="line">                data[k] = tmp;</span><br><span class="line">                j += h;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序（不稳定）"><a href="#堆排序（不稳定）" class="headerlink" title="堆排序（不稳定）"></a>堆排序（不稳定）</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>利用堆这种数据结构所设计的一种排序算法，堆本身是一个完全二叉树</p>
<h4 id="性能-4"><a href="#性能-4" class="headerlink" title="性能"></a>性能</h4><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span>     <span class="comment">//创建堆，将堆的末端子节点作调整，使得子节点永远小于父节点</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//找到i的左右节点最大值，并与i进行交换</span></span><br><span class="line">    <span class="keyword">int</span> largest = i; <span class="comment">// Initialize largest as root </span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// left = 2*i + 1      左节点</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// right = 2*i + 2     右节点</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If left child is larger than root </span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) </span><br><span class="line">        largest = l; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If right child is larger than largest so far </span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) </span><br><span class="line">        largest = r; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If largest is not root </span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123; </span><br><span class="line">        swap(arr[i], arr[largest]); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Recursively heapify the affected sub-tree </span></span><br><span class="line">        heapify(arr, n, largest);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// main function to do heap sort </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Build heap (rearrange array)  i從最後一個父節點開始調整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        heapify(arr, n, i);   </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// One by one extract an element from heap 相当于进行一个逆序过程，数组递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        <span class="comment">// Move current root to end </span></span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// call max heapify on the reduced heap </span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序（不稳定）"><a href="#快速排序（不稳定）" class="headerlink" title="快速排序（不稳定）"></a>快速排序（不稳定）</h3><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>在排序时设置基准点，将小于基准点的数放置在左侧，大于的则放置在右侧，交换距离增大。快速排序本质上是一种基于二分法的递归排序方法，同时，快速排序还利用到了双指针。快速排序是不稳定的。</p>
<h4 id="性能-5"><a href="#性能-5" class="headerlink" title="性能"></a>性能</h4><ul>
<li>优点：平均时间复杂度低（$O(NlogN)$）</li>
<li>缺点：如果数组中最小（大）的元素被选为边界点，那么时间复杂度为$O(n^2)$，不适合小数组</li>
</ul>
<p>快速排序步骤：</p>
<ol>
<li>找到边界值（通常以数组中间值作为边界值）</li>
<li>扫描数组，将数组中元素放入适当的子数组中</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">quicksort</span>(<span class="title">T</span> <span class="title">data</span>[], <span class="title">int</span> <span class="title">first</span>, <span class="title">int</span> <span class="title">last</span>)&#123;</span></span><br><span class="line">    <span class="comment">/*寻找边界值*/</span></span><br><span class="line">    <span class="keyword">if</span>(first &lt; <span class="number">0</span> || first &gt;= data.size() || last &lt; <span class="number">0</span> || last &gt;= data.size() || first &gt; last) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lower = first + <span class="number">1</span>;  <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">int</span> upper = last;</span><br><span class="line">    T bound = data[first];  <span class="comment">//以第一个元素作为中间值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*进行排序操作*/</span></span><br><span class="line">    <span class="keyword">while</span>(lower &lt;= upper)&#123;</span><br><span class="line">        <span class="keyword">while</span>(lower &lt;= upper &amp;&amp; data[lower] &lt; bound) lower ++;   <span class="comment">//这里存在隐患，如果最大的元素就是bound，lower会一直增长直到非正常中断，可以改为while(data[lower] &lt; bound &amp;&amp; lower &lt; last)</span></span><br><span class="line">        <span class="keyword">while</span>(lower &lt;= upper &amp;&amp; data[upper] &gt; bound) upper --;</span><br><span class="line">        <span class="keyword">if</span>(lower &lt; upper) swap(data[lower++], data[upper--]);</span><br><span class="line">        <span class="keyword">else</span> lower ++; <span class="comment">//结束循环的条件，也可以写upper--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*交换边界值*/</span></span><br><span class="line">    swap(data[first],data[upper]);   <span class="comment">//first 此时作为分界点，需要被移动到合适的位置，即upper所在处</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*递归*/</span></span><br><span class="line">    <span class="keyword">if</span>(first &lt; upper - <span class="number">1</span>)</span><br><span class="line">        quicksort(data,first,upper - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(upper + <span class="number">1</span> &lt; last)</span><br><span class="line">        quicksort(data, upper+<span class="number">1</span>, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决上述代码中的问题(如果数组中最小（大）的元素被选为边界点)，可以加入一段辅助代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,max;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>,max=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(nums[max]&lt;nums[i])</span><br><span class="line">    		max = i;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[n<span class="number">-1</span>],nums[max]);   <span class="comment">//把最大值放在最后一个，防止最大值影响排序速度</span></span><br><span class="line">    quicksort(nums,<span class="number">0</span>,n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h4><p>快速排序的思想在很多场合都可以借鉴，特别是在涉及数组元素移动的问题中。</p>
<p>一 LeetCode <a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>思路</strong></p>
<p>我们可以设置快慢指针，慢指针指向0，快指针指向0后的第一个非0元素，然后交换快慢指针所指的值，然后递增慢指针。这里某个元素是否为0就可以视作快速排序中的基准值，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>; <span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            swap(nums[first], nums[i]);</span><br><span class="line">            first++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h4><p>分而治之，对子数组进行排序，分治的思想也可以延续到许多问题中。</p>
<h4 id="性能-6"><a href="#性能-6" class="headerlink" title="性能"></a>性能</h4><ul>
<li>优点：最好和最坏情况下时间复杂度相同，都是$O(n\text{log}n)$</li>
<li>缺点：合并数组需要额外空间</li>
</ul>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Merges two subarrays of arr[]. </span></span><br><span class="line"><span class="comment">// First subarray is arr[l..m] </span></span><br><span class="line"><span class="comment">// Second subarray is arr[m+1..r] </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i, j, k; </span><br><span class="line">    <span class="keyword">int</span> n1 = m - l + <span class="number">1</span>;    <span class="comment">//左子数组长度</span></span><br><span class="line">    <span class="keyword">int</span> n2 =  r - m; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* create temp arrays */</span></span><br><span class="line">    <span class="keyword">int</span> L[n1], R[n2]; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Copy data to temp arrays L[] and R[] */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n1; i++) </span><br><span class="line">        L[i] = arr[l + i]; </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n2; j++) </span><br><span class="line">        R[j] = arr[m + <span class="number">1</span>+ j]; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Merge the temp arrays back into arr[l..r]*/</span></span><br><span class="line">    i = <span class="number">0</span>; <span class="comment">// Initial index of first subarray </span></span><br><span class="line">    j = <span class="number">0</span>; <span class="comment">// Initial index of second subarray </span></span><br><span class="line">    k = l; <span class="comment">// Initial index of merged subarray  </span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2)    <span class="comment">//当两个数组都没有结束时</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) </span><br><span class="line">        &#123; </span><br><span class="line">            arr[k] = L[i]; </span><br><span class="line">            i++; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; </span><br><span class="line">            arr[k] = R[j]; </span><br><span class="line">            j++; </span><br><span class="line">        &#125; </span><br><span class="line">        k++; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Copy the remaining elements of L[], if there </span></span><br><span class="line"><span class="comment">       are any */</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) </span><br><span class="line">    &#123; </span><br><span class="line">        arr[k] = L[i]; </span><br><span class="line">        i++; </span><br><span class="line">        k++; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Copy the remaining elements of R[], if there </span></span><br><span class="line"><span class="comment">       are any */</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) </span><br><span class="line">    &#123; </span><br><span class="line">        arr[k] = R[j]; </span><br><span class="line">        j++; </span><br><span class="line">        k++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* l is for left index and r is right index of the </span></span><br><span class="line"><span class="comment">   sub-array of arr to be sorted */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Same as (l+r)/2, but avoids overflow for </span></span><br><span class="line">        <span class="comment">// large l and h </span></span><br><span class="line">        <span class="keyword">int</span> m = l+(r-l)/<span class="number">2</span>; </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Sort first and second halves </span></span><br><span class="line">        mergeSort(arr, l, m); </span><br><span class="line">        mergeSort(arr, m+<span class="number">1</span>, r); </span><br><span class="line">  </span><br><span class="line">        merge(arr, l, m, r);    <span class="comment">//合并操作</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序原理上并不难理解，难的是如何实现相关代码，这里利用了递归的方式，空间复杂度是$O(n)$，如果想使空间复杂度为常数，可以使用自底向上的归并算法。</p>
<p>自底向上的归并算法，先两两排序合并，在44排序合并，直至结束，例如：[4,3,1,7,8,9,2,11,5,6]，其合并过程为<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step=1: (3-&gt;4)-&gt;(1-&gt;7)-&gt;(8-&gt;9)-&gt;(2-&gt;11)-&gt;(5-&gt;6)</span><br><span class="line">step=2: (1-&gt;3-&gt;4-&gt;7)-&gt;(2-&gt;8-&gt;9-&gt;11)-&gt;(5-&gt;6)</span><br><span class="line">step=4: (1-&gt;2-&gt;3-&gt;4-&gt;7-&gt;8-&gt;9-&gt;11)-&gt;5-&gt;6</span><br><span class="line">step=8: (1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;11)</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<p>见链表章节，使用归并排序对链表进行操作。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>单词的排序实际上就是基数排序，每一个字母表中包含了开头是相同字母的单词，然后再根据第二个字母，第三个字母这样依次划分下去。</p>
<h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h4 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h4><p>通过对数组中每个数字i出现的次数进行计数，将个数添加至count[i]中。</p>
<h4 id="性能-7"><a href="#性能-7" class="headerlink" title="性能"></a>性能</h4><ul>
<li>优点：线性排序</li>
<li>缺点：如果数据偏差很大，可能导致空间开销非常大</li>
</ul>
<h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><p>在有些情况下，排序规则可能比较复杂，此时我们需要自定义排序规则，此处举一些例子总结自定义排序的写法。</p>
<h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><blockquote>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
</blockquote>
<p>C++ STL中有关于字典序排列的函数，用法如下：<code>next_permutation(nums.begin(), nums.end());</code></p>
<h2 id="排序算法复杂度分析"><a href="#排序算法复杂度分析" class="headerlink" title="排序算法复杂度分析"></a>排序算法复杂度分析</h2><p>排序算法本质上可以转换一个决策树问题，根据决策树的深度可知，排序算法平均情况下最好的时间复杂度为$O(NlogN)$</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/">排序链表</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>查找</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>众里寻她千百度</p>
</blockquote>
<a id="more"></a>
<h2 id="常见查找算法"><a href="#常见查找算法" class="headerlink" title="常见查找算法"></a>常见查找算法</h2><h3 id="深度优先查找DFS（不撞南墙不回头）"><a href="#深度优先查找DFS（不撞南墙不回头）" class="headerlink" title="深度优先查找DFS（不撞南墙不回头）"></a>深度优先查找DFS（不撞南墙不回头）</h3><h4 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dfs(int step)&#123;</span><br><span class="line">    //判断边界并返回，阶段二</span><br><span class="line">    //如果有备忘录，那么此时可以返回备忘录中的值</span><br><span class="line">    //尝试每一种可能 for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        继续下一步 dfs(step+1)      //自上而下搜索</span><br><span class="line">    &#125;</span><br><span class="line">    //返回  自下而上计算结果并返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre class="mermaid">graph TB
    node("开始")
    judge1{"已遍历所有节点？"}
    node2("结束")
    dfs["进行深度优先搜索"]

    node-->judge1
    judge1-->|N|dfs
    dfs-->judge1
    judge1-->|Y|node2</pre>

<h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>深度优先搜索通常使用递归形式实现，如果要改为迭代形式，那么需要利用栈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; search_set&#123;&#125;; <span class="comment">// 在迭代实现中，我们采用栈保存当前待搜索对象</span></span><br><span class="line">    search_set.push(first);  <span class="comment">// 放入初始搜索点，例如树的根节点或数组的第一个节点或者图的初始任意节点</span></span><br><span class="line">    <span class="keyword">while</span>(!search_set.empty()) &#123;  <span class="comment">//搜索区间未空，就不能停止搜索</span></span><br><span class="line">        <span class="keyword">int</span> cur = search_set.top(); <span class="comment">//获取当前搜索点</span></span><br><span class="line">        search_set.pop();   </span><br><span class="line">        </span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加和cur相关的新的搜索点，例如树的左子树、右子树，图的与当前节点相连的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="难点总结"><a href="#难点总结" class="headerlink" title="难点总结"></a>难点总结</h4><h5 id="理解dfs"><a href="#理解dfs" class="headerlink" title="理解dfs"></a>理解dfs</h5><p>在dfs中，每进行一次递归，就相当于深入一层。有些情况下可能会有不同路径，例如在迷宫类问题中，有上下左右四个方向，此时需要进行四次递归，相当于走了四条路径，构成了一个四叉树。</p>
<h5 id="dfs思路"><a href="#dfs思路" class="headerlink" title="dfs思路"></a>dfs思路</h5><p>dfs分为两个阶段，在写dfs时要考虑清楚每个阶段的过程：</p>
<ul>
<li>自上而下搜索</li>
<li>自下而上计算结果并返回<ul>
<li>在搜索的叶节点处直接返回叶节点值</li>
<li>在非叶节点处根据下层计算结果与当前节点值进行计算</li>
</ul>
</li>
</ul>
<p>这里以<a href="https://leetcode-cn.com/problems/triangle/">leetcode120. 三角形最小路径和</a>为例，对dfs思路进行整理。给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (triangle.size() - <span class="number">1</span> == row) &#123;  <span class="comment">//到达最后一行, 在搜索的叶节点处直接返回叶节点值</span></span><br><span class="line">        <span class="keyword">return</span> triangle[row][col];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> down = helper(triangle, row + <span class="number">1</span>, col);   <span class="comment">//自上而下搜索</span></span><br><span class="line">    <span class="keyword">int</span> right = helper(triangle, row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min(down, right) + triangle[row][col];    <span class="comment">//在非叶节点处根据下层计算结果与当前节点值进行计算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(triangle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="搜索入口"><a href="#搜索入口" class="headerlink" title="搜索入口"></a>搜索入口</h5><p>为了保证搜索覆盖的全面性，我们需要对所有的待搜索的点进行搜索，例如我们对一个有$n$个节点的图进行搜索，代码框架如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">        dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使图中有不相连的部分，因为我们经过了遍历，所以深度优先搜索能保证所有的节点都访问到。</p>
<h5 id="边界判断"><a href="#边界判断" class="headerlink" title="边界判断"></a>边界判断</h5><p>边界判断是DFS的重要部分，保证了DFS能够顺利退出递归，以下总结一些常见的DFS退出条件。首先，由于DFS是递归算法，所以很可能会搜索到重复的位置，因此往往需要一个visited向量，用于保存已经访问的位置，如果已经visited，那么直接返回。</p>
<ol>
<li>指针类DFS</li>
</ol>
<p>多见于处理链表或二叉树问题的DFS中，常见退出条件如下：</p>
<ul>
<li>head == nullptr：return head;</li>
<li>visited(head) == true：return head;</li>
</ul>
<ol>
<li>数组类DFS</li>
</ol>
<p>常见退出条件如下：</p>
<ul>
<li>范围超过数组边界：<code>if(cur_m &lt; 0 || cur_n &lt; 0 ||cur_m &gt;= m || cur_n &gt;= n)</code></li>
<li>已经访问过指定位置：<code>if(visited[cur_m][cur_n] == 1)</code></li>
<li>所在位置不满足搜索要求：<code>if(int_to_sum(cur_m) + int_to_sum(cur_n) != k)</code></li>
<li>给定数组搜索范围<code>[left,right)</code>（左开右闭区间），那么搜索结束的标志为left == right，见leetcode<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></li>
</ul>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>递归由于涉及到多次函数调用，因此返回值的计算可能会比较麻烦，这里针对dfs给出一个比较套路化的返回规则，首先，如果不满足条件，那么就在进入递归函数后立刻返回；其次，最终的返回值应当放在递归函数结尾给出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span> )    <span class="comment">//第一返回位置，不满足条件，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=traverse(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right=traverse(root-&gt;right);</span><br><span class="line">    tilt+=Math.<span class="built_in">abs</span>(left-right);</span><br><span class="line">    <span class="keyword">return</span> left+right+root-&gt;val;  <span class="comment">//第二返回位置，在递归体结束后返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="何时增加深度"><a href="#何时增加深度" class="headerlink" title="何时增加深度"></a>何时增加深度</h5><p>当明确有一条搜索路径时，我们再去增加递归深度，例如在二叉树搜索中，如果我们明确了某个子节点不为空，再向这条子节点进行搜索，这样可以减少递归深度，提高效率：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123; <span class="comment">//左节点存在时，再进行深度搜索哦</span></span><br><span class="line">    dfs(root-&gt;left, temp, ans); </span><br><span class="line">    <span class="keyword">if</span>(temp.back() == <span class="string">'&gt;'</span>)temp.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp.back() != <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">        temp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="被搜索节点的状态"><a href="#被搜索节点的状态" class="headerlink" title="被搜索节点的状态"></a>被搜索节点的状态</h5><p>在深度优先搜索中，一个被搜索节点一般有三个状态：</p>
<ul>
<li>未搜索：该节点尚未被搜索</li>
<li>搜索中：我们正在搜索该节点和相邻的节点，但是该节点相邻的节点还未搜索完成</li>
<li>已完成：我们搜索过所有的相邻节点，回溯了该节点，搜索已完成</li>
</ul>
<h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><p>在某些情况下，我们需要剪枝操作，例如当前位置和前一个位置相同，那么我们直接跳过该步骤即可，剪枝的操作代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != start &amp;&amp; s[i] == s[i<span class="number">-1</span>]) <span class="keyword">continue</span>;  <span class="comment">//去除重复</span></span><br></pre></td></tr></table></figure>
<p>将上述语句放入dfs的for循环中，即可实现剪枝操作。</p>
<h4 id="常见DFS类型总结及模板"><a href="#常见DFS类型总结及模板" class="headerlink" title="常见DFS类型总结及模板"></a>常见DFS类型总结及模板</h4><h5 id="判断搜索路径是否存在"><a href="#判断搜索路径是否存在" class="headerlink" title="判断搜索路径是否存在"></a>判断搜索路径是否存在</h5><p>此类问题要求我们判断搜索树中是否存在一条符合条件的搜索路径，因此搜索过程中，一旦找到了路径，我们应当立刻返回，以免不必要的递归造成效率的降低。这里以<a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/">面试题 04.01. 节点间通路</a>为例，对此类问题模板进行总结。</p>
<p>思路</p>
<p>我们希望找到答案后直接返回，而找到答案的可能性有两种，一种是在本层中直接找到答案；另一种是在深层递归中找到答案。因此我们需要进行两次判断，当在本层中找到答案后直接返回；当在下层搜索后，判断是否找到答案，然后根据情况中断搜索，模板如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;                    </span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_pos = adList[start][i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (viewed[cur_pos]==<span class="number">0</span>)&#123;         <span class="comment">//对没有搜索的点处理</span></span><br><span class="line">            <span class="keyword">if</span>(cur_pos==target)&#123;         <span class="comment">//找到后直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = search(cur_pos,target);   <span class="comment">//递归搜索</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">true</span>)                 <span class="comment">//找到后中断搜索</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    viewed[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;                    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;adList[start].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_pos = adList[start][i];     <span class="comment">//循环遍历所有分支</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (viewed[cur_pos]==<span class="number">0</span>)&#123;         <span class="comment">//对没有搜索的点处理</span></span><br><span class="line">            <span class="keyword">if</span>(cur_pos==target)&#123;         <span class="comment">//找到后直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = search(cur_pos,target);   <span class="comment">//递归搜索</span></span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">true</span>)                 <span class="comment">//找到后中断搜索</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们可以看到，此时判断是否退出的条件放在了循环体中，意味着我们找到答案后会立刻退出，另外递归后也加了一条判断语句，确保找到答案立刻退出。</p>
<h5 id="获取累加值"><a href="#获取累加值" class="headerlink" title="获取累加值"></a>获取累加值</h5><p>有些dfs问题需要我们记录累加值，这种情况下，我们需要在dfs开始时设置一个临时变量，然后结尾处返回该临时变量，每个递归函数都会定义自己的局部变量，而第一次递归时定义的局部变量即为最终的计算结果。一个框架如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(...)&#123; <span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> ...; <span class="comment">//返回边界值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123; <span class="comment">//遍历当前搜索集合</span></span><br><span class="line">        ans += dfs(depth+<span class="number">1</span>);   <span class="comment">//遍历搜索树的每一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算递归深度"><a href="#计算递归深度" class="headerlink" title="计算递归深度"></a>计算递归深度</h5><p>在有些情况下，我们需要计算递归树的深度，例如计算二叉树的深度，其代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 关键语句，我们遍历了所有可行分支，对于二叉树来说，一共有两个分支，然后获得其中的最大深度</span></span><br><span class="line">    depth = max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">    <span class="comment">// 返回值需要+1，因为计算深度时要包含当前节点</span></span><br><span class="line">    <span class="keyword">return</span> depth+<span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以此类推，我们可以延伸到计算任意递归函数的深度，只需要循环遍历所有分支，找到分支最大深度即可。例如leetcode<a href="https://leetcode-cn.com/problems/nested-list-weight-sum-ii/">364. 加权嵌套序列和 II</a>，计算递归深度的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ni : nestedList)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ni.isInteger())&#123;</span><br><span class="line">            sum += depth * ni.getInteger();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum += getSum(ni.getList(), depth - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获得所有可能解的DFS"><a href="#获得所有可能解的DFS" class="headerlink" title="获得所有可能解的DFS"></a>获得所有可能解的DFS</h5><p>例题</p>
<p><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></p>
<p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。说明: 输入可能包含了除 <code>(</code> 和 <code>)</code> 以外的字符。</p>
<p>思路</p>
<p>这个问题可以划分为三个子问题：</p>
<ul>
<li>判断括号是否合法</li>
<li>计算有多少个左右括号需要删除</li>
<li>递归删除括号，得到结果后进行保存</li>
</ul>
<p>前两个子问题我们可以通过栈实现，后一个可以通过DFS实现 ，重点是第三个问题，第三个问题中，我们又可以列举出如下几个问题：</p>
<ul>
<li>先删除哪种括号？先删除右括号，如果先删除左括号，可能导致前缀非法，例如对于<code>())(</code>，如果我们先删除了第一个左括号，那么会变成<code>))(</code>，原来合法的前缀反而不合法了。这样会构成额外的枝。</li>
<li>如何避免重复解 ，例如对于<code>(()</code>，删掉第一个和第二个左括号，得到的结果都为<code>()</code>，所以我们需要剪枝操作</li>
</ul>
<p>例子</p>
<p>我们以<code>s = &quot;)())(&quot;</code>为例，需要删除两个右括号，一个左括号，那么我们的递归函数为<code>dfs(s, l=1, r=2)</code>，删除过程的递归树如下：</p>
<pre class="mermaid">graph TB
    node["dfs( s = )())( , l=1, r=2)"]
    node1["dfs(s = *())( , l=1, r=1)"]
    node2["dfs(s = )(*)( , l=1, r=1)"]
    node3["dfs(s = )()*( , l=1, r=2)"]
    node4["dfs(s = *(*)( , l=1, r=0)"]
    node5["dfs(s = *(*)* , l=0, r=0): 合法"]
    node6["dfs(s = )(**( , l=1, r=0)"]
    node7["dfs(s = )(*** , l=0, r=0): 非法"]

    node---node1
    node---node2
    node--冗余枝条---node3
    node1---node4
    node4---node5
    node2---node6
    node6---node7</pre>

<p>可以看出递归深度为$l+r$，所以时间复杂度为$2^{l+r}$</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span> ch : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'('</span>) ++count;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">')'</span>) --count;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//小于0说明右括号落单，一定是非法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    **    计算最少需要的左括号和右括号的值，这里没有用栈的方法，而是</span></span><br><span class="line"><span class="comment">    **    使用了投票法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span> ch : s)&#123;</span><br><span class="line">        l += (ch == <span class="string">'('</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span>)                 <span class="comment">//表示右括号会落单，因此如果l==0，如果出现右括号，一定删除</span></span><br><span class="line">            r += (ch == <span class="string">')'</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l -= (ch == <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    dfs(s, <span class="number">0</span>, l, r, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">*    dfs -- 递归进行括号删除                                  </span></span><br><span class="line"><span class="comment">*                                                           </span></span><br><span class="line"><span class="comment">*    INPUT: s     -- 待处理字符串                   </span></span><br><span class="line"><span class="comment">*           start -- 上一次删除的括号的位置，每次删除从该位置之后开始</span></span><br><span class="line"><span class="comment">*           l     -- 剩余待删除左括号数目</span></span><br><span class="line"><span class="comment">*           r     -- 剩余待删除右括号数目</span></span><br><span class="line"><span class="comment">*           ans   -- 答案</span></span><br><span class="line"><span class="comment">*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isValid(s)) ans.push_back(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != start &amp;&amp; s[i] == s[i<span class="number">-1</span>]) <span class="keyword">continue</span>;  <span class="comment">//去除重复</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'('</span> || s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr = s;</span><br><span class="line">            curr.erase(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(r &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">')'</span>) dfs(curr, i, l, r<span class="number">-1</span>, ans);    <span class="comment">//优先删除右括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">'('</span>) dfs(curr, i, l<span class="number">-1</span>, r, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DFS优化"><a href="#DFS优化" class="headerlink" title="DFS优化"></a>DFS优化</h4><h5 id="动态规划与DFS结合"><a href="#动态规划与DFS结合" class="headerlink" title="动态规划与DFS结合"></a>动态规划与DFS结合</h5><p>在深度优先搜索中，可能会产生大量重复计算，如果我们能像动态规划那样，牺牲一些空间来保存中间结果，能够有效减少计算时间，DFS与DP结合的代码框架如下，其中有两个关键步骤，记录与提取：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mem, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> row, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.size() - <span class="number">1</span> == row) &#123;</span><br><span class="line">        <span class="keyword">return</span> board[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem[row][col]) <span class="keyword">return</span> mem[row][col];            <span class="comment">//返回备忘录中的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> down = helper(board, mem, row + <span class="number">1</span>, col);        <span class="comment">//向下向右搜索</span></span><br><span class="line">    <span class="keyword">int</span> right = helper(board, mem, row, col + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = min(down, right) + board[row][col];</span><br><span class="line">    mem[row][col] = ans;                                <span class="comment">//记录备忘录中的值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></p>
<p>给定一个整数矩阵，找出最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;        <span class="comment">// Row num of matrix</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;        <span class="comment">// Column num of matrix</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    **    Moving directions</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy = &#123;<span class="number">0</span>, <span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **    Init work</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        r = matrix.size();</span><br><span class="line">        c = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **    This dp vector stores the mid results to avoid duplicate calculation</span></span><br><span class="line"><span class="comment">        **    dp[i][j] means the longest pathes length which is end at (i,j)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c,<span class="number">0</span>))</span></span>;   </span><br><span class="line">                                                   </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **    Search at each element of the matrix</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                ans = max(ans,dfs(matrix, i, j, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*----------------------------------------------------------</span></span><br><span class="line"><span class="comment">    *  dfs -- Find all the possible pathes of the matrix</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  INPUT:  matrix -- The matrix which needs to be searched</span></span><br><span class="line"><span class="comment">    *          cur_r  -- Current row in the matrix</span></span><br><span class="line"><span class="comment">    *          cur_c  -- Current col in the matrix</span></span><br><span class="line"><span class="comment">    *          dp     -- The matrix which store mid results</span></span><br><span class="line"><span class="comment">    *  OUTPUT: The longest pathes of current search position</span></span><br><span class="line"><span class="comment">    *          ended at (cur_r, cur_c)</span></span><br><span class="line"><span class="comment">    *----------------------------------------------------------*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> cur_r, <span class="keyword">int</span> cur_c, </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        **    Return if dp[cur_r][cur_c] != 0 which means the result </span></span><br><span class="line"><span class="comment">        **    at position (cur_r, cur_c) has already been calculated</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(dp[cur_r][cur_c] != <span class="number">0</span>) <span class="keyword">return</span> dp[cur_r][cur_c];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nr = cur_r + dx[i], nc = cur_c + dy[i];    <span class="comment">// New row and col</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            **    Only if the adjcent is valid then apply dfs</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(nr &gt;= <span class="number">0</span> &amp;&amp; nr &lt; r &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nc &lt; c &amp;&amp; matrix[nr][nc] &lt; matrix[cur_r][cur_c])   </span><br><span class="line">                dp[cur_r][cur_c] = max(dp[cur_r][cur_c],dfs(matrix, nr, nc, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++dp[cur_r][cur_c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>广度优先搜索能够保证在搜索到<code>d+1</code>距离的位置时，距离为<code>d</code>的位置都已经搜索过，所以可以使用广度优先搜索处理例如迷宫中最短路径等问题。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>创建队列保存搜索点</li>
<li>保存初始搜索点</li>
<li>弹出搜索点，并以搜索点为基准，遍历所有搜索分支，例如在迷宫当中，有上下左右四个方向，即四个搜索分支</li>
<li>每个搜索分支下，添加新的搜索点，扩大搜索范围</li>
</ul>
<h4 id="基本模型-1"><a href="#基本模型-1" class="headerlink" title="基本模型"></a>基本模型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度优先通常采用迭代形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断是否返回</span></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; res&#123;&#125;;</span><br><span class="line">    res.push(root-&gt;val);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bfs 循环</span></span><br><span class="line">    <span class="keyword">while</span>(!res.empty())&#123;</span><br><span class="line">        <span class="comment">//新建vector&lt;int&gt; temp 用于保存每一层的结果</span></span><br><span class="line">        <span class="keyword">int</span> width = res.size();  <span class="comment">//保存当前层长度</span></span><br><span class="line">        <span class="comment">//当前层循环打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">            <span class="comment">//1. 出队列</span></span><br><span class="line">            <span class="comment">//2. 访问</span></span><br><span class="line">            <span class="comment">//3. 入队列  将待搜索的位置放入队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将temp添加至res</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广度优先搜索一般要利用队列，来实现对于一层的存储。</p>
<h4 id="难点及要点总结"><a href="#难点及要点总结" class="headerlink" title="难点及要点总结"></a>难点及要点总结</h4><p>广度优先过程中会出现<strong>重复搜索</strong>的问题，即相邻两个待搜索对象，第一个时刻由对象1搜索到了对象2，第二个时刻又由对象2搜索到了对象1，解决方法是使用visited矩阵或集合进行标记，已经搜索过的就直接跳过。</p>
<h3 id="DFS与BFS的比较"><a href="#DFS与BFS的比较" class="headerlink" title="DFS与BFS的比较"></a>DFS与BFS的比较</h3><p>这张图直观地对DFS与BFS进行了比较：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/1_GT9oSo0agIeIj6nTg3jFEA.gif" width = "450"  alt="图片名称" align=center /></p>
<h3 id="专题：图的DFS和BFS搜索"><a href="#专题：图的DFS和BFS搜索" class="headerlink" title="专题：图的DFS和BFS搜索"></a>专题：图的DFS和BFS搜索</h3><h4 id="DFS搜索"><a href="#DFS搜索" class="headerlink" title="DFS搜索"></a>DFS搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在图中搜索所有为'O'的格子，然后将格子置为'#'</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'#'</span>) <span class="keyword">return</span>; <span class="comment">//不满足搜索结果</span></span><br><span class="line">    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    dfs(board, i+<span class="number">1</span>, j, m,n);</span><br><span class="line">    dfs(board, i<span class="number">-1</span>, j, m,n);</span><br><span class="line">    dfs(board, i, j+<span class="number">1</span>, m,n);</span><br><span class="line">    dfs(board, i, j<span class="number">-1</span>, m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS搜索"><a href="#BFS搜索" class="headerlink" title="BFS搜索"></a>BFS搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rooms[row][col] == GATE) &#123;</span><br><span class="line">            q.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; row, col &#125;);   <span class="comment">//将所有搜索点放入队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] point = q.poll();</span><br><span class="line">    <span class="keyword">int</span> row = point[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> col = point[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : DIRECTIONS) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = row + direction[<span class="number">0</span>];     <span class="comment">//下一个搜索位置</span></span><br><span class="line">        <span class="keyword">int</span> c = col + direction[<span class="number">1</span>];   </span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= m || c &gt;= n || rooms[r][c] != EMPTY) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        rooms[r][c] = rooms[row][col] + <span class="number">1</span>;   </span><br><span class="line">        q.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; r, c &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用画图的形式解释BFS在图中的搜索，那么其形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//以传染病模型为例，其中1是被感染的人，一开始他会将上下左右四个方向上的人全部感染，产生四个新感染的人，即四个新的搜索点</span><br><span class="line">0 0 0 0 0       0 1 0 0 0       0 1 0 0 0        0 1 0 0 0         0 1 0 0 0</span><br><span class="line">0 1 0 0 0       0 1 0 0 0       0 1 1 0 0        0 1 1 0 0         1 1 1 0 0</span><br><span class="line">0 0 0 0 0       0 0 0 0 0       0 0 0 0 0        0 1 0 0 0         0 1 0 0 0</span><br><span class="line">0 0 0 0 0       0 0 0 0 0       0 0 0 0 0        0 0 0 0 0         0 0 0 0 0</span><br><span class="line"></span><br><span class="line">这四个新的搜索点会继续扩散，直到所有的人都感染为止。所以BFS类似于一种传染病模型，会将临近的单位全部感染</span><br><span class="line"></span><br><span class="line">那么问题来了，当BFS有不只一个搜索点，例如在传染病模型中，有多个初始病人，那么我们如何知道新病人是由哪个病人感染的呢？这个问题不必担心，由于BFS是一种临近搜索，因此新病人必然是由离得最近的病人感染的，BFS的特性能够保证传播符合实际情况，不会出现病人被离得远的病人所感染。</span><br></pre></td></tr></table></figure>
<h3 id="专题：岛屿问题"><a href="#专题：岛屿问题" class="headerlink" title="专题：岛屿问题"></a>专题：岛屿问题</h3><p>岛屿问题是经典的二维搜索问题，本节将对常见的岛屿问题进行总结。</p>
<h4 id="求连通域数目"><a href="#求连通域数目" class="headerlink" title="求连通域数目"></a>求连通域数目</h4><ol>
<li>leetcode 695</li>
</ol>
<p>求4-连通域最大面积，这个问题很经典，需要记住代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"> </span><br><span class="line"> 返回6</span><br></pre></td></tr></table></figure>
<p>答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.size() || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].size() </span><br><span class="line">          || grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//查找到某一块边界点，停止</span></span><br><span class="line">        grid[r][c] = <span class="number">0</span>;   <span class="comment">//防止重复查找，也可以通过设置一个flag矩阵，保存已经查找过的区域</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> + area(r+<span class="number">1</span>,c,grid)+area(r<span class="number">-1</span>,c,grid)+area(r,c+<span class="number">1</span>,grid)+area(r,c<span class="number">-1</span>,grid));  <span class="comment">//一直查找直到达到边界点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.size() == <span class="number">0</span> || grid[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>;r&lt;grid.size();r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;grid[<span class="number">0</span>].size();c++)&#123;    <span class="comment">//遍历岛屿的每一个格子</span></span><br><span class="line">                <span class="keyword">int</span> temp = area(r,c,grid);    <span class="comment">//一次执行过程中，area函数就会将相邻的连通区域全部置零，如果需要统计连通域个数，那么设置一个标记位进行统计即可。</span></span><br><span class="line">                ans = max(ans,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> <a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域搜索</a><br> 给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>运行函数后，矩阵变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>如果我们认为O所在位置为海岛，那么该问题的本质就是求所有与边界不联通的海岛的位置，然后进行替换。所以我们应当从边界位置处的海岛O开始搜索，找到所有的和边界相连的海岛，那么剩下的海岛就一定是被X包围的。</p>
<p><strong>任务</strong></p>
<ul>
<li>找到边界岛屿</li>
<li>从找到的边界岛屿处开始搜索（每一个边界岛屿都要作为搜索的起始点）</li>
<li>搜索过程中，将与边界相连的海岛替换为#（方便后续恢复）</li>
<li>遍历棋盘，将不与边界相连的海岛淹没，将与边界相连的海岛恢复</li>
</ul>
<p><strong>代码</strong></p>
<p>解法1：深度优先搜索</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size() == <span class="number">0</span> || board[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">bool</span> isEdge = (i == <span class="number">0</span> || j == <span class="number">0</span> || i == m<span class="number">-1</span> || j == n<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    dfs(board, i, j,m,n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>) board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'#'</span>) board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'#'</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        dfs(board, i+<span class="number">1</span>, j, m,n);</span><br><span class="line">        dfs(board, i<span class="number">-1</span>, j, m,n);</span><br><span class="line">        dfs(board, i, j+<span class="number">1</span>, m,n);</span><br><span class="line">        dfs(board, i, j<span class="number">-1</span>, m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p>
<h3 id="专题：迷宫问题"><a href="#专题：迷宫问题" class="headerlink" title="专题：迷宫问题"></a>专题：迷宫问题</h3><p>迷宫问题中，我们可能遇到有效路径、遍历迷宫以及最短路径等问题，本节将针对常见的迷宫问题进行总结</p>
<h4 id="寻找迷宫中的门"><a href="#寻找迷宫中的门" class="headerlink" title="寻找迷宫中的门"></a>寻找迷宫中的门</h4><blockquote>
<p>你被给定一个 <em>m × n</em> 的二维网格，网格中有以下三种可能的初始化值：</p>
<ol>
<li><code>-1</code> 表示墙或是障碍物</li>
<li><code>0</code> 表示一扇门</li>
<li><code>INF</code> 无限表示一个空的房间。然后，我们用 <code>231 - 1 = 2147483647</code> 代表 <code>INF</code>。你可以认为通往门的距离总是小于 <code>2147483647</code> 的。</li>
</ol>
<p>你要给每个空房间位上填上该房间到 <em>最近</em> 门的距离，如果无法到达门，则填 <code>INF</code> 即可。</p>
<p>例如，给定迷宫</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;INF  -1  0  INF</span><br><span class="line">&gt;INF INF INF  -1</span><br><span class="line">&gt;INF  -1 INF  -1</span><br><span class="line">&gt;  0  -1 INF INF</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;  3  -1   0   1</span><br><span class="line">&gt;  2   2   1  -1</span><br><span class="line">&gt;  1  -1   2  -1</span><br><span class="line">&gt;  0  -1   3   4</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>从门使用BFS进行搜索，能够以扩散传播的方式，对周边区域进行搜索，从而确保周围的房间能够到达最近的门</p>
<p><strong>任务</strong></p>
<ul>
<li>找到门坐标</li>
<li>从门坐标开始，进行深度优先搜索</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rooms.size() == <span class="number">0</span> || rooms[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = rooms.size();</span><br><span class="line">    <span class="keyword">int</span> n = rooms[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; direction&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; point_queue&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rooms[i][j] == <span class="number">0</span>) point_queue.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!point_queue.empty())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = point_queue.front();</span><br><span class="line">        point_queue.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;direction.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = p[<span class="number">0</span>] + direction[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = p[<span class="number">1</span>] + direction[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= m || c &gt;= n || rooms[r][c] != <span class="number">2147483647</span>) <span class="keyword">continue</span>;</span><br><span class="line">            rooms[r][c] = rooms[p[<span class="number">0</span>]][p[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">            point_queue.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;r,c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断是否能走到终点"><a href="#判断是否能走到终点" class="headerlink" title="判断是否能走到终点"></a>判断是否能走到终点</h4><p>迷宫三问</p>
<p><a href="https://leetcode-cn.com/problems/the-maze/">490. 迷宫</a></p>
<p><a href="https://leetcode-cn.com/problems/the-maze-ii/">505. 迷宫 II</a></p>
<p>迷宫II是对迷宫I的问题的延伸，我们不仅要判断能否到达终点，还要记录从起点到终点的最短路径。这里我们定义了一个distance矩阵，把每一个可以到达的方块距离起点的最短距离记录下来，然后返回目标点所在的值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] dest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[maze.length][maze[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: distance)</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE);</span><br><span class="line">        distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        dfs(maze, start, distance);</span><br><span class="line">        <span class="keyword">return</span> distance[dest[<span class="number">0</span>]][dest[<span class="number">1</span>]] == Integer.MAX_VALUE ? -<span class="number">1</span> : distance[dest[<span class="number">0</span>]][dest[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[][] distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir: dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = start[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = start[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; maze.length &amp;&amp; y &lt; maze[<span class="number">0</span>].length &amp;&amp; maze[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                x += dir[<span class="number">0</span>];</span><br><span class="line">                y += dir[<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x-dir[<span class="number">0</span>]; y = y-dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 注意！上面的循环结束时，实际上走到了非法区域，需要后退一步，才能走到正确的位置，所以需要x = x-dir[0]; y = y-dir[1];</span></span><br><span class="line">            <span class="keyword">if</span> (distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] + count &lt; distance[x][y]) &#123;    </span><br><span class="line">                distance[x][y] = distance[start[<span class="number">0</span>]][start[<span class="number">1</span>]] + count;</span><br><span class="line">                dfs(maze, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;, distance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迷宫遍历"><a href="#迷宫遍历" class="headerlink" title="迷宫遍历"></a>迷宫遍历</h4><p>有些问题需要我们遍历迷宫中所有可以行走的路径，例如<a href="https://leetcode-cn.com/problems/robot-room-cleaner/">489. 扫地机器人</a></p>
<blockquote>
<p>房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。扫地机器人提供4个API，可以向前进，向左转或者向右转。每次转弯90度。当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。请利用提供的4个API编写让机器人清理整个房间的算法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Robot &#123;</span><br><span class="line">  // 若下一个方格为空，则返回true，并移动至该方格</span><br><span class="line">  // 若下一个方格为障碍物，则返回false，并停留在原地</span><br><span class="line">  boolean move();</span><br><span class="line"></span><br><span class="line">  // 在调用turnLeft/turnRight后机器人会停留在原位置</span><br><span class="line">  // 每次转弯90度</span><br><span class="line">  void turnLeft();</span><br><span class="line">  void turnRight();</span><br><span class="line"></span><br><span class="line">  // 清理所在方格</span><br><span class="line">  void clean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路</p>
<p>由于我们不清楚起始位置在哪里，因此只能使用相对信息对位置坐标进行记录，令起始点坐标为(0,0)，然后实施dfs</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;F, S&gt; &#123;</span></span><br><span class="line">    <span class="keyword">public</span> F first;</span><br><span class="line">    <span class="keyword">public</span> S second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(F first, S second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Pair&lt;F, S&gt; p = (Pair&lt;F, S&gt;) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(p.first, first) &amp;&amp; Objects.equals(p.second, second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.hashCode() ^ second.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// going clockwise : 0: 'up', 1: 'right', 2: 'down', 3: 'left'</span></span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    Set&lt;Pair&lt;Integer, Integer&gt;&gt; visited = <span class="keyword">new</span> HashSet();</span><br><span class="line">    Robot robot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        robot.turnRight();</span><br><span class="line">        robot.turnRight();</span><br><span class="line">        robot.move();</span><br><span class="line">        robot.turnRight();</span><br><span class="line">        robot.turnRight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        visited.add(<span class="keyword">new</span> Pair(row, col));</span><br><span class="line">        robot.clean();</span><br><span class="line">        <span class="comment">// going clockwise : 0: 'up', 1: 'right', 2: 'down', 3: 'left'</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newD = (d + i) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + directions[newD][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newCol = col + directions[newD][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 当下一个点未访问过并且可以到达时，再进行dfs</span></span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(<span class="keyword">new</span> Pair(newRow, newCol)) &amp;&amp; robot.move()) &#123;</span><br><span class="line">                backtrack(newRow, newCol, newD);</span><br><span class="line">                goBack();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// turn the robot following chosen direction : clockwise</span></span><br><span class="line">            robot.turnRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanRoom</span><span class="params">(Robot robot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.robot = robot;</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找（常常和二叉树一起出现）"><a href="#二分查找（常常和二叉树一起出现）" class="headerlink" title="二分查找（常常和二叉树一起出现）"></a>二分查找（常常和二叉树一起出现）</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>每一次循环都能排除掉一半以上的元素，最后把区间限定在一个元素，<strong>二分查找要求被查找的对象必须经过排序</strong>。循环条件为left &lt; right，如果被查找元素未经排序，那么循环条件可能发生改变，例如<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">LeetCode154旋转数组</a>。</p>
<h4 id="算法要求"><a href="#算法要求" class="headerlink" title="算法要求"></a>算法要求</h4><ol>
<li>必须采用顺序存储结构</li>
<li>必须按照关键字大小有序排列</li>
</ol>
<h4 id="算法适用场景及每个场景对应框架-重要！"><a href="#算法适用场景及每个场景对应框架-重要！" class="headerlink" title="算法适用场景及每个场景对应框架(重要！)"></a>算法适用场景及每个场景对应框架(重要！)</h4><p>二分查找最适用的场景包括三个：寻找一个数、寻找左侧边界、寻找右侧边界。大部分涉及寻找特定值$x$的问题，都可以使用二分查找进行解决，例如寻找一个数的整数开方问题等。</p>
<h5 id="二分查找基本框架2"><a href="#二分查找基本框架2" class="headerlink" title="二分查找基本框架2"></a>二分查找基本框架<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;           <span class="comment">//right的值为查找的右边界（搜索结果包括右边界）</span></span><br><span class="line">                                         <span class="comment">//对于本题，就是nums.size()-1</span></span><br><span class="line">    <span class="comment">//搜索区间为][left,right]，左闭右闭</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;  <span class="comment">//结束时 left == right 留下的搜索区间为[left,right];</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;    <span class="comment">//使用else if显示所有情况</span></span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;    <span class="comment">//这里需要对nums[left]进行单独判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;       </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="寻找左侧边界的二分查找"><a href="#寻找左侧边界的二分查找" class="headerlink" title="寻找左侧边界的二分查找"></a>寻找左侧边界的二分查找</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt;= target) &#123; <span class="comment">//即使找到也不能停止，要不断压缩右边界，确保找到的一定是左边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况，这个程序也可以用来搜索第一个大于target的位置（如果nums[left]!=target）</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">//收缩左侧边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法要点及难点"><a href="#算法要点及难点" class="headerlink" title="算法要点及难点"></a>算法要点及难点</h4><p>本节将对二分查找的一些难点及要点进行总结。</p>
<h5 id="二维矩阵中的二分查找"><a href="#二维矩阵中的二分查找" class="headerlink" title="二维矩阵中的二分查找"></a>二维矩阵中的二分查找</h5><p>有些情况下，我们需要对二维矩阵进行二分查找的操作，如果我们按照先分行再分列的方法，搜索效率很低，因此我们采用整体搜索法，假设矩阵大小为$m×n$，那么待搜索的元素的个数为$m×n$，所以<code>left = 0, right = m*n-1</code>，在矩阵中进行二分查找的框架如下所示，时间复杂度为$O(log(mn))$：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">    pivotElement = matrix[pivotIdx / n][pivotIdx % n];   <span class="comment">// 关键，行为当前索引p/n，列为p%n</span></span><br><span class="line">    <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h4><blockquote>
<p>注：以下内容在难以判断循环结束后left是否为搜索位置时较为好用</p>
</blockquote>
<ol>
<li>取中位数索引</li>
</ol>
<p>二分法第一个麻烦的问题就是对中位数索引的判断，如果按照如下方式写，可能发生越界情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>所以可以写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>一个更好的写法是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = <span class="keyword">unsigned</span>(left+right)&gt;&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><strong>中位数的处理方法</strong></p>
<p>根据元素个数为奇数还是偶数，中位数的选取也会比较麻烦，当元素个数为偶数时，有左右中位数的区分</p>
<ul>
<li>当数组的元素个数是偶数的时候：</li>
</ul>
<p>使用 <code>int mid = unsigned(left + right) &gt;&gt; 1</code> 得到左中位数的索引；</p>
<p>使用<code>int mid = unsigned(left + right + 1) &gt;&gt; 1</code>得到右中位数的索引。</p>
<ol>
<li>边界选取</li>
</ol>
<p>左右边界选取时要注意，如果左右边界不包括目标数值，会导致错误，例如LeetCode 第 35 题：“搜索插入位置” ，当 target 比数组中的最后一个数字还要大（不能等于）的时候，插入元素的位置就是数组的最后一个位置 + 1，即 (len - 1 + 1 ) =  len，如果忽略掉这一点，把右边界定为 len - 1 ，代码就不能通过在线测评<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。所以<code>left = 0</code>，<code>right = len</code>而不是len-1。</p>
<ol>
<li>循环条件</li>
</ol>
<p>循环条件一般可以写为：<code>left &lt; right</code>，当循环结束时，一定有<code>left == right</code>，返回left或者right都可以，但是，退出循环的时候遗漏了一个元素没有看，那就是left或right索引上的值。</p>
<ol>
<li>分支逻辑编写</li>
</ol>
<p>二分法的分支逻辑很简单，这里有一个关键是，在分支逻辑中，<strong>一个分支是包括中位数的，另一个是排除中位数的</strong>。根据上面的分支逻辑的分析，那么会有两种情况出现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******1******/</span></span><br><span class="line"><span class="keyword">if</span>(排除中位数的逻辑分支)&#123;</span><br><span class="line">    left = mid+<span class="number">1</span>;  <span class="comment">//目标元素至少是中位数，但不包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    right = mid;  <span class="comment">//目标元素至多是中位数，且包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******2******/</span></span><br><span class="line"><span class="keyword">if</span>(排除中位数的逻辑分支)&#123;</span><br><span class="line">    right = mid<span class="number">-1</span>;  <span class="comment">//目标元素至多是中位数，但不包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    left = mid;  <span class="comment">//目标元素至少是中位数，且包括中位数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据分支逻辑选择左右中位数，选择标准是避免死循环</li>
</ol>
<p>死循环容易发生在区间只有两个元素的时候</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*下面的代码中，如果只有两个元素，一旦进入左边界，那么左边界不收缩，如此下去会进入死循环，因此需要换成右中位数*/</span></span><br><span class="line"><span class="keyword">int</span> mid = <span class="keyword">unsigned</span>(left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(排除中位数的逻辑分支)&#123;</span><br><span class="line">    right = mid<span class="number">-1</span>;  <span class="comment">//目标元素至多是中位数，但不包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    left = mid;  <span class="comment">//目标元素至少是中位数，且包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一样的道理，下面的也需要换成左中位数*/</span> </span><br><span class="line"><span class="keyword">int</span> mid = <span class="keyword">unsigned</span>(left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(排除中位数的逻辑分支)&#123;</span><br><span class="line">    left = mid+<span class="number">1</span>;  <span class="comment">//目标元素至多是中位数，但不包括中位数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    right = mid;  <span class="comment">//目标元素至少是中位数，且包括中位数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>后处理</li>
</ol>
<p>当退出循环后，我们可能需要对两边夹逼剩下的那个数做一个单独的处理，何时要进行后处理呢：</p>
<ul>
<li><p>如果你的业务逻辑保证了你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 left 或者 right，无需再做判断；</p>
</li>
<li><p>如果你的业务逻辑不能保证你要找的数一定在左边界和右边界所表示的区间里出现，那么只要在退出循环以后，再针对 nums[left] 或者 nums[right] （此时 nums[left] == nums[right]）单独作一次判断，看它是不是你要找的数即可，这一步操作常常叫做“后处理”。</p>
</li>
</ul>
<p>例如</p>
<p>LeetCode 第 704 题：二分查找</p>
<blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
</blockquote>
<p>分析：因为目标数有可能不在数组中，当候选区间夹逼成一个数的时候，要单独判断一下这个数是不是目标数，如果不是，返回 -1。</p>
<h5 id="模板-来自例题1"><a href="#模板-来自例题1" class="headerlink" title="模板(来自例题1)"></a>模板(来自例题1)</h5><p>二分查找的一个难点主要是边界条件的控制，如果控制不好，可能会陷入死循环当中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();     </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="keyword">unsigned</span> <span class="keyword">int</span>(left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; mid) &#123; </span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (counter &gt;= mid) &#123;   <span class="comment">//小数较多</span></span><br><span class="line">            right = mid - <span class="number">1</span>;        <span class="comment">//收缩右边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;             <span class="comment">//大数较多</span></span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说了这么多，总结一下常用模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = left + ((right-left)&gt;&gt;<span class="number">1</span>);   <span class="comment">//左中位数</span></span><br><span class="line">    <span class="keyword">if</span>(target &gt; mid) left = mid + <span class="number">1</span>;            <span class="comment">//排除中位数的逻辑分支，left++</span></span><br><span class="line">    <span class="keyword">else</span> right = mid;                           <span class="comment">//包含中位数的逻辑分支，right保持不变</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>思路：使用二分查找的方式，把1～n个数字从中间数m分为两部分，统计每个区间中数字的个数，如果某个区间数字个数大于m，那么一定存在重复数字。下面是一个二分法的模板，可以</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();     </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;    <span class="comment">//n/2</span></span><br><span class="line">            <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt; mid) &#123;  </span><br><span class="line">                    counter++;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (counter &gt;= mid) &#123;   </span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二、LeetCode 35</p>
<p>三、最大值最小化问题</p>
<blockquote>
<p>考虑下列问题，把一个包含$n$个正整数的序列划分为$m$个连续子序列，设第$i$个序列各数之和为$S(i)$，你的任务是让所有$S(i)$的最大值尽量小，例如序列1 2 3 2 5 4，划分为3个序列的最优方案为1 2 3| 2 5 | 4，其中$S(1)$、$S(2)$和$S(3)$分别为6、7、4，最大值为7，如果划分为1 2|3 2|5 4，最大值为9，不如刚才的好。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>最大值尽量小是一种常见的优化问题，我们考虑一个新问题，能否把输入序列划分为$m$个连续子序列，使所有$S(i)$均不超过$x$？那么让答案为真的最小的$x$就是原题的答案，接下来随便猜一个数字$x_0$，如果不满足，那么说明答案比$x_0$大，否则答案小于等于$x_0$。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> arr[MAXN], sum, min, ans;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> M)</span></span>&#123;   <span class="comment">//对数组进行划分，返回的是当最大值为M时，所需的划分组数的最小值，即最少需要分为多少组，才能满足最大值最小化的要求</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos=m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&gt;=<span class="number">0</span> &amp;&amp; sum+arr[pos]&lt;=M)&#123;    <span class="comment">//如果该组目前还小于最大值，说明还可以继续往里添加数</span></span><br><span class="line">            ok=<span class="literal">false</span>;</span><br><span class="line">            sum += arr[pos];</span><br><span class="line">            --pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">            <span class="keyword">return</span> k+<span class="number">1</span>; <span class="comment">// 返回一个大于k的数，说明划分的组数超过了k，M不满足要求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=<span class="number">0</span>) vis[pos] = <span class="literal">true</span>;  </span><br><span class="line">        ++cnt;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;  <span class="comment">//返回划分的组数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">binary</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left=min, right=sum, mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(divide(mid)&lt;=k)     <span class="comment">//说明所需的组数小于k，则还可以添加新组，最大值可以继续缩小</span></span><br><span class="line">            right=mid;</span><br><span class="line">        <span class="keyword">else</span>              <span class="comment">//所需组数大于k，说明不能再添加新组，最大值应当适当扩大</span></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=divide(ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m<span class="number">-1</span>&amp;&amp;cnt&lt;k; ++i)<span class="keyword">if</span>(!vis[i])&#123;  <span class="comment">//返回的组数有可能小于k，那么说明还有几组空闲，那么我在任意多划分几组，满足要求即可</span></span><br><span class="line">        vis[i]=<span class="literal">true</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i) <span class="built_in">printf</span>(<span class="string">" %lld"</span>,arr[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" /"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;k);</span><br><span class="line">        sum=<span class="number">0</span>;  min=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;arr[i]);</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;min) min=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=binary();</span><br><span class="line">        output();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「shuangde800」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/shuangde800/java/article/details/7828695</span></span><br></pre></td></tr></table></figure>
<h2 id="常见搜索算法应用场景"><a href="#常见搜索算法应用场景" class="headerlink" title="常见搜索算法应用场景"></a>常见搜索算法应用场景</h2><h3 id="BFS及DFS应用"><a href="#BFS及DFS应用" class="headerlink" title="BFS及DFS应用"></a>BFS及DFS应用</h3><h4 id="迷宫类题目"><a href="#迷宫类题目" class="headerlink" title="迷宫类题目"></a>迷宫类题目</h4><p>深度及广度优先搜索有一个重要的应用就是在迷宫中寻找路径。本节将针对该类问题进行一个总结。</p>
<ol>
<li>处理迷宫方向</li>
</ol>
<p>我们可以使用方向向量，处理迷宫中任务的移动方向，方向数组如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dx[2] = &#123;0, 1, -1,  0&#125;;   //下、右、左、上</span><br><span class="line">int dy[2] = &#123;1, 0,  0, -1&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li>
</ol>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">二分法讲解</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/">二分查找相关细节</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>查并集</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E6%9F%A5%E5%B9%B6%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>朋友的朋友就是我的朋友</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是查并集？"><a href="#什么是查并集？" class="headerlink" title="什么是查并集？"></a>什么是查并集？</h2><p>查并集是一种数据结构，用于<strong>跟踪不相连子集中的元素</strong>，查并集有两个重要操作：</p>
<ul>
<li><p>搜索（查）：决定元素位于哪一个子集中，例如在下式中，$5\in S_2$。</p>
</li>
<li><p>联合（并）：将两个子集合并为一个更大的子集</p>
</li>
</ul>
<p>从查并集的定义中可以看出，其中的各个子集是<strong>相互独立的</strong>，可以将每一个子集视为一个独立的组织，例如按势力将武侠小说中的人物进行划分（丐帮和峨眉是两个独立门派，二者之间没有交集）。例如下式中，$S_1$与$S_2$是相互独立的。</p>
<script type="math/tex; mode=display">
S_1 = \{1,2,3,4\}\\
S_2 = \{5,6,7,8\}\\
S_1\cap S_2=\varnothing</script><pre class="mermaid">graph LR
    subgraph S1
    node1((1))
    node2((2))
    node3((3))
    node4((4))
    end
    subgraph S2
    node5((5))
    node6((6))
    node7((7))
    node8((8))
    end

    node1---node2
    node2---node3
    node3---node4
    node5---node6
    node6---node7
    node7---node8</pre>

<p>联合操作示意如下，例如我们要联合节点$4$和$8$，即<code>union(4,8)</code>，那么得到的结果为$S_1\cup S_2 ={1,2,3,4,5,6,7,8}$，即联合的结果就是将两个不同的集合合并</p>
<pre class="mermaid">graph LR
    subgraph S1\cap S2
    node1((1))
    node2((2))
    node3((3))
    node4((4))

    node5((5))
    node6((6))
    node7((7))
    node8((8))
    end

    node1---node2
    node2---node3
    node3---node4
    node5---node6
    node6---node7
    node7---node8

    node8---node4</pre>

<h2 id="查并集基本操作及实现3"><a href="#查并集基本操作及实现3" class="headerlink" title="查并集基本操作及实现3"></a>查并集基本操作及实现<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>从查并集的名字可以看出，查并集主要操作有两个：即查和并。当然，为了判断是否连通，我们还需判断两个点是否在同一连通区域内部，以及某个节点是否在查并集中。</p>
<ul>
<li><p><code>init(int n)</code>: 初始化并查集，将每个节点的父节点设置为自身节点。</p>
</li>
<li><p><code>find(int m)</code>：这是并查集的基本操作，查找<code>m</code>的根节点。</p>
</li>
<li><code>union(int m,int n)</code>：合并<code>m,n</code>两个点所在的连通区域。</li>
<li><code>isConnected(int m,int n)</code>：判断<code>m,n​</code>两个点是否在一个连通区域。</li>
<li><code>isContained(int node)</code>：判断是否在查并集中</li>
<li><code>getMaxSize()</code>：获得查并集中最大子集的规模</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>令$P={p_1,}$</p>
<p>基本操作的流程和代码如下：</p>
<pre class="mermaid">graph TB
     start(Start)
     judge1{"parent[node] == node?"}
     return["return node"]
     End("end")
     state1["parent[node] = parent[parent[node]]"]

     start-->judge1
     judge1-->return</pre>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* parents;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行初始化，开始时每一个节点的父节点都是自身</span></span><br><span class="line">    UnionFind(<span class="keyword">int</span> totalNodes) &#123;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[totalNodes];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalNodes; i++) &#123;</span><br><span class="line">            parents[i] = i;   <span class="comment">//记录每个节点的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        count = totalNodes;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;   <span class="comment">//找到某个节点的根节点</span></span><br><span class="line">        <span class="keyword">while</span> (parents[node] != node) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的父节点 指向父节点的父节点.</span></span><br><span class="line">            <span class="comment">// 保证一个连通区域最终的parents只有一个，即根节点（门派掌门）</span></span><br><span class="line">            parents[node] = parents[parents[node]];  <span class="comment">//追根溯源，最终找到所有人的跟节点，这一步操作是路径压缩操作，可以降低树的高度，从而提高查找效率</span></span><br><span class="line">            node = parents[node];   <span class="comment">//更新节点为父节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = find(node1);</span><br><span class="line">        <span class="keyword">int</span> root2 = find(node2);</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) &#123;</span><br><span class="line">            parents[root2] = root1;</span><br><span class="line">            count--;      <span class="comment">// 合并之后，集合的规模会变小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(node1) == find(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;   <span class="comment">//获取连通分量个数</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre class="mermaid">graph TB
    subgraph find
        A((root))
        B((node1))
        C((node2))
        D((node3))
        E((node4))

        A---B
        B---C
        C---D
        B---E

    end

    subgraph union
    end

    subgraph isConnected
    end</pre>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="数组实现查并集"><a href="#数组实现查并集" class="headerlink" title="数组实现查并集"></a>数组实现查并集</h4><h2 id="查并集应用"><a href="#查并集应用" class="headerlink" title="查并集应用"></a>查并集应用</h2><h3 id="解决连通性问题"><a href="#解决连通性问题" class="headerlink" title="解决连通性问题"></a>解决连通性问题</h3><p>查并集常用于解决连通性问题，即将一个图中的连通部分进行划分。当判断图中两点是否存在路径时，可以根据判断他们是否在一个连通区域内。</p>
<h3 id="解决邻接问题"><a href="#解决邻接问题" class="headerlink" title="解决邻接问题"></a>解决邻接问题</h3><p>在有些问题中，可能出现诸如找到所有连续的整数构成的子集，这种情况下可以把问题转换为一个查并集问题，假设当前正在寻找的对象为v，如果nums中存在v+1或者v-1，我们就可以把v和v+1（v-1）归并至一个集合内部。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p>
<blockquote>
<p>给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 <em>O(n)</em>。</p>
<p>输入: [100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p>
</blockquote>
<p>思路</p>
<p>我们可以构造一个查并集，并利用map进行索引，如果v的相邻数存在，那么我们对v和v的相邻数进行union操作，需要注意的是数组中可能存在重复元素，这种情况下我们需要一个visited集合，如果数已经出现，直接跳过即可。</p>
<p>关键代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在union中，当合并两个set时，我们可以顺手更新set的规模</span></span><br><span class="line">sets_size[root1] += sets_size[root2];   </span><br><span class="line">sets_size.erase(root2);</span><br><span class="line">max_subset_size = max_subset_size &gt; sets_size[root1] ? max_subset_size : sets_size[root1];</span><br></pre></td></tr></table></figure>
<h3 id="判断无向图是否成环"><a href="#判断无向图是否成环" class="headerlink" title="判断无向图是否成环"></a>判断无向图是否成环</h3><p>给定集合如下：</p>
<script type="math/tex; mode=display">
\mu=\{1,2,3,4,5,6,7,8\}</script><p>其构成的无向图为（边上为序号）：</p>
<pre class="mermaid">graph TB
    node1((1))
    node2((2))
    node3((3))
    node4((4))
    node5((5))
    node6((6))
    node7((7))
    node8((8))

    node1--7---node3
    node1--1---node2
    node2--5---node4
    node3--2---node4
    node2--6---node5    
    node5--9---node7
    node5--3---node6
    node6--8---node8
    node7--4---node8</pre>

<p>在上图中，我们寻找circle的过程如下：</p>
<p>找到第一条边的Union，即<code>union(1,2)</code>，我们的集合变为</p>
<script type="math/tex; mode=display">
\mu=\{3,4,5,6,7,8\}\\
S_1=\{1,2\}</script><p>重复上述步骤：</p>
<script type="math/tex; mode=display">
\mu=\varnothing\\
S_1=\{1,2\}\\
S_2=\{3,4\}\\
S_3=\{5,6\}\\
S_4=\{7,8\}\\</script><p>当从第五条边开始，我们开始进行集合间的合并：</p>
<script type="math/tex; mode=display">
\textrm{union edge 5, that is node 2 and 4}\\
S_3=\{5,6\}\\
S_4=\{7,8\}\\
S_5=\{1,2,3,4\}\\
---
\\
\textrm{union edge 6}\\
S_4=\{7,8\}\\
S_6=\{1,2,3,4,5,6\}</script><p>而当我们处理第七条边时，发现第七条边的两个node均在$S_6$中，说明出现了环。因为一开始每条边都是独立的set，所以当出现一个边的两个节点在同一个集合中，<strong>第一说明这两个节点是相连的，第二说明这两个节点之    前已经通过其他边连在一起，所以会有环</strong>。</p>
<p>我们再用图的步骤描述上面的过程，访问前四条边后，我们找到了四个集合：</p>
<pre class="mermaid">graph BT
    subgraph set1
    node1((1))
    node2((2))
    end
    subgraph set2
    node3((3))
    node4((4))
    end
    subgraph set3
    node5((5))
    node6((6))
    end
    subgraph set4
    node7((7))
    node8((8))
    end

    node2-->node1
    node4-->node3
    node6-->node5
    node8-->node7</pre>

<p> 我们令<code>union(u,v)</code>中，$u$为父节点，$v$为子节点，当我们进行<code>union(2,4)</code>即处理第5条边的操作后，图变为：</p>
<pre class="mermaid">graph BT
    subgraph set1
    node1((1))
    node2((2))

    node3((3))
    node4((4))
    end
    subgraph set2
    node5((5))
    node6((6))
    end
    subgraph set3
    node7((7))
    node8((8))
    end

    node2-->node1
    node4-->node3
    node3-->node1
    node6-->node5
    node8-->node7</pre>

<p>即将4所在的集合的父节点3作为2所在集合的父节点1的子节点，同理，处理第6条边结果如下：</p>
<pre class="mermaid">graph BT
    subgraph set1
    node1((1))
    node2((2))

    node3((3))
    node4((4))

    node5((5))
    node6((6))
    end
    subgraph set2
    node7((7))
    node8((8))
    end

    node2-->node1
    node4-->node3
    node3-->node1
    node5-->node1
    node6-->node5
    node8-->node7</pre>

<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Cycle-in-graph.png" alt=""></p>
<p>伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> each unvisited <span class="title">edge</span> <span class="params">(u,v)</span> in <span class="built_in">set</span> E</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Find(u) == Find(v))  <span class="comment">//在同一个子集中，构成环</span></span><br><span class="line">        <span class="comment">//检测到了环</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Union(x,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">1319. 连通网络的操作次数</a></p>
<p>本题的宗旨是判断查并集内环和独立子集的个数，比较简单。</p>
<h2 id="查并集优化"><a href="#查并集优化" class="headerlink" title="查并集优化"></a>查并集优化</h2><h3 id="平衡性优化"><a href="#平衡性优化" class="headerlink" title="平衡性优化"></a>平衡性优化</h3><p>当查并集中两个集合进行合并时，我们希望规模较小的集合接到规模大的集合的下面，这样可以避免树头重脚轻，使树更加平衡，此时我们需要一个额外的size数组，对每个集合的规模进行统计，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1 = find(node1);</span><br><span class="line">    <span class="keyword">int</span> root2 = find(node2);</span><br><span class="line">    <span class="keyword">if</span> (root1 == root2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 小集合并入大集合，大集合的根作为合并后的根</span></span><br><span class="line">    <span class="keyword">if</span> (size[root1] &gt; size[root2]) &#123;</span><br><span class="line">        parent[root2] = root1;</span><br><span class="line">        size[root1] += size[root2];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[root1] = root2;</span><br><span class="line">        size[root2] += size[root1];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路径压缩优化"><a href="#路径压缩优化" class="headerlink" title="路径压缩优化"></a>路径压缩优化</h3><p>路径压缩优化是针对<code>find</code>操作的优化，通过路径压缩，可以进一步降低搜索树的深度，提高查询效率。经过深度的路径压缩，查询效率甚至可以接近O(1)。路径压缩的基本操作就是在查找时将树深度不断降低，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[node] != node) &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        parent[node] = parent[parent[node]];</span><br><span class="line">        node = parent[node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.geeksforgeeks.org/union-find/">geeksforgeeks上关于查并集的介绍</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/evaluate-division/">LeetCode399</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://leetcode-cn.com/problems/surrounded-regions/solution/bfsdi-gui-dfsfei-di-gui-dfsbing-cha-ji-by-ac_pipe/">查并集应用</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>正则表达式是一种字符序列描述方法，其特点是高效灵活，相比较传统的字符串搜索和替换，它可以处理动态文本，所以有必要对基本的正则表达式进行掌握。</p>
<a id="more"></a>
<h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><ul>
<li>模式匹配：检查一个字符串中是否含有某种字串</li>
<li>替换与抽取：将匹配的子串进行替换或者抽取某种符合条件的子串</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>在一个正则表达式中，一般会包含多种字符，常见字符及功能如下：</p>
<h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。其中非打印字符如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\n</td>
<td>回车加换行</td>
</tr>
<tr>
<td>\r</td>
<td>回车，回到本行行首</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 <sup><a href="#fn_ \f\n\r\t\v" id="reffn_ \f\n\r\t\v"> \f\n\r\t\v</a></sup>。</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
</tbody>
</table>
</div>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>特殊字符即在正则表达式中具有特定语义功能的字符，如果要匹配特殊字符，必须在其之前加<code>\</code>，进行转义，代表将这些字符作为普通字符处理。</p>
<h5 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h5><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配，限定符有六种，分别如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次，贪婪的，会尽可能多匹配</td>
<td>zo* 能匹配 “z” 以及 “zoo”，等价于{0,}</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次，贪婪的，会尽可能多匹配</td>
<td>‘zo+’ 能匹配 “zo” 以及 “zoo”，等价于 {1,}</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面的子表达式零次或一次</td>
<td>“do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。</td>
<td>‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。</td>
<td>‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o</td>
</tr>
<tr>
<td>{n,m}</td>
<td>最少匹配 n 次且最多匹配 m 次</td>
<td>“o{1,3}” 将匹配 “fooooood” 中的前三个 o</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，限定符*和+是贪婪的，即它们会尽可能多地进行匹配，只有在它们后面加上?才能实现非贪婪匹配或最小匹配。</p>
<h5 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h5><p>定位符会定位正则表达式的起始位置，正则表达式中定位符如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配输入字符串开始的位置</td>
<td><code>/^Chapter [1-9][0-9]{0,1}/</code>，匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置</td>
<td><code>/^Chapter [1-9][0-9]{0,1}$/</code>，匹配章节标题，并且改行只有章节标题，没有其他内容</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置。</td>
<td><code>/\bCha/</code>，匹配单词开头三个字母Cha；<code>/ter\b/</code>，匹配单词结尾的三个字母ter</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配</td>
<td><code>/\Bapt/</code>，该表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt，因为apt在Chapter中位于非边界位置，在aptitude中位于边界位置</td>
</tr>
</tbody>
</table>
</div>
<h2 id="常见匹配模式总结"><a href="#常见匹配模式总结" class="headerlink" title="常见匹配模式总结"></a>常见匹配模式总结</h2><h3 id="数字类"><a href="#数字类" class="headerlink" title="数字类"></a>数字类</h3><h4 id="匹配指定位数的数字"><a href="#匹配指定位数的数字" class="headerlink" title="匹配指定位数的数字"></a>匹配指定位数的数字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^[0-9]&#123;5&#125;$       # 匹配五位数字，且必须以数字开头数字结尾</span><br><span class="line"></span><br><span class="line">12345  # 符合</span><br><span class="line">a12345 # 不符合</span><br><span class="line">12345a # 不符合</span><br><span class="line">123454 # 不符合</span><br><span class="line"></span><br><span class="line">在上面的解析式中，^和$ 共同限定了长度必须为5位</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>小孩子才做选择，我全都要！</p>
</blockquote>
<a id="more"></a>
<h2 id="贪心算法简介"><a href="#贪心算法简介" class="headerlink" title="贪心算法简介"></a>贪心算法简介</h2><h3 id="什么是贪心？"><a href="#什么是贪心？" class="headerlink" title="什么是贪心？"></a>什么是贪心？</h3><p>当我们对问题求解时，<strong>总是做出在当前看起来是最好的选择</strong>，即不从全局最优的角度考虑，做出局部最优解。</p>
<p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。这样才能保证结果的全局最优性。</p>
<p>贪心算法一般用于解决最优化问题。</p>
<h3 id="贪心的局限性"><a href="#贪心的局限性" class="headerlink" title="贪心的局限性"></a>贪心的局限性</h3><p>在许多情况下，贪心可能会陷入局部最优解，而无法找到全局最优。</p>
<h3 id="例题一："><a href="#例题一：" class="headerlink" title="例题一："></a>例题一：</h3><blockquote>
<p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p>输入：nums = [3,30,34,5,9]<br>输出：”9534330”</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            vs.push_back(to_string(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vs.begin(), vs.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; left, <span class="keyword">const</span> <span class="built_in">string</span>&amp; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> left + right &gt; right + left;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : vs)&#123;</span><br><span class="line">            ans += v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>] == <span class="string">'0'</span> ? <span class="string">"0"</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="贪心法常见难点及要点总结"><a href="#贪心法常见难点及要点总结" class="headerlink" title="贪心法常见难点及要点总结"></a>贪心法常见难点及要点总结</h2><h3 id="贪心策略的选择"><a href="#贪心策略的选择" class="headerlink" title="贪心策略的选择"></a>贪心策略的选择</h3><p>贪心策略的选择是贪心过程的最大难点之一，这里以Leetcode45题为例，介绍贪心策略的选择</p>
<p><a href="https://leetcode-cn.com/problems/jump-game-ii/submissions/">45. 跳跃游戏 II</a></p>
<blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p>
</blockquote>
<p>看到这个题后，我的第一反应是，找每次跳跃能够跳到的下一个最大的数所在的位置。即假设当前位置为<code>i</code>，那么下一个位置为<code>max(num[i+1], num[i+num[i]])</code>所在元素的下标。但是实际上这个贪心策略是错误的。正确的贪心策略是寻找每一步能够走到的最大位置，即<code>nums[i]+i</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; nums.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        max_pos = max(max_pos, nums[i]+i); <span class="comment">// 当前位置所能达到的最远边界，贪心</span></span><br><span class="line">        <span class="keyword">if</span>(i == end)&#123;        <span class="comment">// 触碰到最远边界了，需要更新，因此推进边界</span></span><br><span class="line">            end = max_pos;   <span class="comment">// 边界更新，同时递增一步，在这个边界范围内，都是可以一步走到的</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="贪心方法"><a href="#贪心方法" class="headerlink" title="贪心方法"></a>贪心方法</h3><h4 id="一、模拟法"><a href="#一、模拟法" class="headerlink" title="一、模拟法"></a>一、模拟法</h4><p>在模拟法中，我们将根据可能的情况执行相应的步骤，然后考虑每一步中的最优结果，例如<a href="https://leetcode-cn.com/problems/lemonade-change/">860. 柠檬水找零</a></p>
<h4 id="二、由简到繁"><a href="#二、由简到繁" class="headerlink" title="二、由简到繁"></a>二、由简到繁</h4><p>有些情况下，我们并不能很好地找到贪心策略，这种情况下我们首先从简单问题考虑，直接想只有一种最优情况该如何选择，然后加入另一个情况，看如何达到最优策略，从而找到递推公式：</p>
<p>例题1：<a href="https://leetcode-cn.com/problems/reducing-dishes/">1402. 做菜顺序</a></p>
<h2 id="专题：背包问题"><a href="#专题：背包问题" class="headerlink" title="专题：背包问题"></a>专题：背包问题</h2><h2 id="LeetCode上关于贪心的相关题目"><a href="#LeetCode上关于贪心的相关题目" class="headerlink" title="LeetCode上关于贪心的相关题目"></a>LeetCode上关于贪心的相关题目</h2><h4 id="LeetCode300-最长上升子序列"><a href="#LeetCode300-最长上升子序列" class="headerlink" title="LeetCode300 最长上升子序列"></a>LeetCode300 最长上升子序列</h4><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<blockquote>
<p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p>
</blockquote>
<p>起初的思路是这个上升子序列要么位于左侧数组，要么位于右侧，要么横穿左右，考虑用二分法+递归解决，但是这样有一个问题，当合并左右两个数组的时候会出现问题，因为不知道左右两个数组应当怎么拼接，所以这种方法弃用。</p>
<p>此时考虑贪心算法，贪心规则为：如果使上升序列尽可能长，那么上升序列应尽可能慢，我们希望在上升子序列后添加的数尽可能小。基于该思路，我们维护一个数组d[i]，表示<strong>长度为$i$的最长上升子序列末尾元素的最小值</strong>，同时用len记录上升子序列的长度，起始<code>len=1,d[1]=num[0]</code>。可以证明，d一定是单调递增的。</p>
<p>接下来的操作就是，遍历<code>num</code>，如果<code>num[i]&gt;d[len]</code>，直接将<code>num[i]</code>追加至<code>d</code>之后，否则在d数组中寻找第一个大于<code>num[i]</code>的数字的下标$j$，将$j$上的元素替换为<code>num[i]</code>。</p>
<p>以输入序列 [0, 8, 4, 12, 2][0,8,4,12,2] 为例：</p>
<ul>
<li><p>第一步插入 0，d = [0]；</p>
</li>
<li><p>第二步插入 8，d = [0, 8]；</p>
</li>
<li><p>第三步插入 4，d = [0, 4]；</p>
</li>
<li><p>第四步插入 12，d = [0, 4, 12]；  </p>
</li>
<li><p>第五步插入 2，d = [0, 2, 12]。</p>
</li>
</ul>
<p>需要特别注意的是，d<strong>不是最长上升子序列，而是代表长度为$i$的上升序列末尾最小值为d[i]</strong>，例如，d[2] = 2代表长度为2的上升子序列末尾最小值为2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) d[++len] = nums[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="LeetCode-监控二叉树"><a href="#LeetCode-监控二叉树" class="headerlink" title="LeetCode 监控二叉树"></a>LeetCode 监控二叉树</h4><h4 id="LeetCode968-监控二叉树"><a href="#LeetCode968-监控二叉树" class="headerlink" title="LeetCode968 监控二叉树"></a>LeetCode968 监控二叉树</h4><blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong>计算监控树的所有节点所需的最小摄像头数量。</p>
</blockquote>
<h4 id="LeetCode406"><a href="#LeetCode406" class="headerlink" title="LeetCode406"></a>LeetCode406</h4><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对<code>(h, k)</code>表示，其中<code>h</code>是这个人的身高，<code>k</code>是排在这个人前面且身高大于或等于<code>h</code>的人数。 编写一个算法来重建这个队列。</p>
<blockquote>
<p>输入:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p>
<p>输出:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>
</blockquote>
<p>这种题有一个特点，就是：<strong>小数对大数没有影响</strong>，例如[7,0]前面放多少个[4,5]，[5,6]都可以，因为高个看不到矮子，只能看到比他更高的。所以解决这种题目的第一个方法，先对队列进行排序，保证队列满足如下顺序</p>
<blockquote>
<ol>
<li><p>按照h递减 (lhs[0] &gt; rhs[0])</p>
</li>
<li><p>h相同时，按照k递增 (lhs[1] &lt;= rhs[1])</p>
</li>
</ol>
</blockquote>
<p>这里参考C++ Lambda，编写一个针对题目的sort函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(people.begin(), people.end(),</span><br><span class="line">                [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rhs)</span><br><span class="line">                 &#123;<span class="keyword">return</span> lhs[<span class="number">0</span>] == rhs[<span class="number">0</span>] ? lhs[<span class="number">1</span>] &lt;= rhs[<span class="number">1</span>] : lhs[<span class="number">0</span>] &gt; rhs[<span class="number">0</span>];&#125;);</span><br></pre></td></tr></table></figure>
<p>然后将排好序的人依次插入，因为高个在前，不受矮个影响，所以插到指定位置即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">reconstructQueue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        sort(people.begin(), people.end(),</span><br><span class="line">                [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rhs)</span><br><span class="line">                 &#123;<span class="keyword">return</span> lhs[<span class="number">0</span>] == rhs[<span class="number">0</span>] ? lhs[<span class="number">1</span>] &lt;= rhs[<span class="number">1</span>] : lhs[<span class="number">0</span>] &gt; rhs[<span class="number">0</span>];&#125;);</span><br><span class="line">        <span class="keyword">int</span> len = people.size();</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tmp;</span><br><span class="line">        <span class="comment">// 循环插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = tmp.begin();</span><br><span class="line">            advance(pos, people[i][<span class="number">1</span>]);   <span class="comment">//将pos平移people[i][1]个位置</span></span><br><span class="line">            tmp.insert(pos, people[i]);   <span class="comment">//然后将people[i]插入list，这里使用list插入效率比较高，这个插入过程就体现了贪心算法，每一次的插入都是局部最优插入，所以所有的都插入之后依然是最优结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重建vector返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(tmp.begin(), tmp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.google.com/books?hl=zh-CN&amp;lr=&amp;id=v-b0CAAAQBAJ&amp;oi=fnd&amp;pg=PR5&amp;dq=data+structure+and+algorithm+in+c%2B%2B&amp;ots=C_TqwgXHOv&amp;sig=IZJed9W71UYAYM77rjCoMFDgab0">Drozdek A. Data Structures and algorithms in C++[M]. Cengage Learning, 2012.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">力扣46题解</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>状态机在处理一些比较复杂的状态转移问题时往往非常有用。它能够较为清晰地列举出每种状态之间的关系，当给定某个输入时，能够给出输出的状态，本文将对状态机的知识及使用场景进行总结。</p>
<a id="more"></a>
<h2 id="状态机定义及分类"><a href="#状态机定义及分类" class="headerlink" title="状态机定义及分类"></a>状态机定义及分类</h2><p>状态机由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作、完成特定操作的控制中心。有限状态机简写为FSM（Finite State Machine），主要分为2大类：</p>
<ul>
<li><p>Moore机：若输出只和状态有关而与输入无关</p>
</li>
<li><p>Mealy状态机：输出不仅和状态有关而且和输入有关系</p>
</li>
</ul>
<p>在算法中，状态机是一个有向图形，由一组节点和一组相应的转移函数组成。状态机通过响应一系列事件而“运行”。每个事件都在属于“当前” 节点的转移函数的控制范围内，其中函数的范围是节点的一个子集。函数返回“下一个”（也许是同一个）节点。<strong>这些节点中至少有一个必须是终态</strong>。当到达终态， 状态机停止。</p>
<h2 id="状态机的组成"><a href="#状态机的组成" class="headerlink" title="状态机的组成"></a>状态机的组成</h2><ul>
<li>状态集（states）</li>
<li>一个起始状态（start state）</li>
<li>一组输入符号集（alphabet）</li>
<li>一个映射输入符号</li>
<li>当前状态到下一状态的转换函数（transition function）的计算模型</li>
</ul>
<h2 id="状态机的使用步骤"><a href="#状态机的使用步骤" class="headerlink" title="状态机的使用步骤"></a>状态机的使用步骤</h2><p>本节将对状态机使用步骤进行总结，具体使用案例参考本文状态机应用章节。</p>
<h3 id="考虑所有可能的状态和状态转移方程"><a href="#考虑所有可能的状态和状态转移方程" class="headerlink" title="考虑所有可能的状态和状态转移方程"></a>考虑所有可能的状态和状态转移方程</h3><p>我们将初始状态设为状态0，非法状态设为-1，然后根据状态转移方程，可以获得中间状态。</p>
<h3 id="列出状态转移图"><a href="#列出状态转移图" class="headerlink" title="列出状态转移图"></a>列出状态转移图</h3><p>状态机最关键的一个步骤就是列出状态转移图。首先由初始态开始，然后根据不同的状态转移方程，列举出状态转移图</p>
<h3 id="列出状态转移表"><a href="#列出状态转移表" class="headerlink" title="列出状态转移表"></a>列出状态转移表</h3><p>根据状态转移图，列出状态转移表，其中行表示不同的状态，列表示状态转移方程。</p>
<h3 id="列出有效状态"><a href="#列出有效状态" class="headerlink" title="列出有效状态"></a>列出有效状态</h3><p>在所有状态中，筛选出符合条件的状态，并保存至一个集合中</p>
<h3 id="根据状态表和有效状态，编写程序"><a href="#根据状态表和有效状态，编写程序" class="headerlink" title="根据状态表和有效状态，编写程序"></a>根据状态表和有效状态，编写程序</h3><h2 id="状态机应用"><a href="#状态机应用" class="headerlink" title="状态机应用"></a>状态机应用</h2><h3 id="判断某个字符串是否合法"><a href="#判断某个字符串是否合法" class="headerlink" title="判断某个字符串是否合法"></a>判断某个字符串是否合法</h3><p>LeetCode <a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">面试题20. 表示数值的字符串</a></p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<p><strong>思路</strong></p>
<ul>
<li><p>设置初始状态为状态0，那么字符串中共有6个状态转移方程，分别是数字、小数点、+-号，指数标志e或E、空格、其他字符。</p>
</li>
<li><p>根据状态转移方程，获得中间状态并绘制状态转移图</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/statemachine.jpg" width = "650"  alt="图片名称" align=center /></p>
<ul>
<li>根据状态转移图列出状态转移方程</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">num</th>
<th style="text-align:center">dot</th>
<th style="text-align:center">+-</th>
<th style="text-align:center">e</th>
<th style="text-align:center">空格</th>
<th style="text-align:center">other</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">7</td>
<td style="text-align:center">5</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">7</td>
<td style="text-align:center">5</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">7</td>
<td style="text-align:center">5</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">9</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>列出有效状态</li>
</ul>
<p>legal_state = {1,4,5,6,8}</p>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_col</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) str = <span class="string">"number"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'.'</span>) str = <span class="string">"dot"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) str = <span class="string">"sign"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'e'</span> || c == <span class="string">'E'</span>) str = <span class="string">"exp"</span>;</span><br><span class="line">        else if('\ ' == c) str = "space";</span><br><span class="line">        <span class="keyword">else</span> str = <span class="string">"other"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   <span class="comment">//获得状态转移方程</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; trans_table&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">6</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">6</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">6</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">8</span>,<span class="number">-1</span>,<span class="number">9</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">8</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">8</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;;  <span class="comment">//状态转移表</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; legal_state&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;  <span class="comment">//有效状态</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; cols&#123;</span><br><span class="line">            &#123;<span class="string">"number"</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"dot"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"sign"</span>,<span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"exp"</span>,<span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"space"</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"other"</span>,<span class="number">5</span>&#125;</span><br><span class="line">        &#125;;    <span class="comment">//状态映射</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;       <span class="comment">//初始状态</span></span><br><span class="line">        <span class="built_in">string</span> trans_fun; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            get_col(trans_fun, s[i]);</span><br><span class="line">            state = trans_table[state][cols[trans_fun]]; <span class="comment">//状态转移</span></span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(legal_state.find(state) != legal_state.end()) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//终态在有效状态中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>你站在桥上看风景，看风景的人在楼上看你。明月装饰了你的窗子，你装饰了别人的梦。——《断章》</p>
</blockquote>
<a id="more"></a>
<h2 id="递归简介"><a href="#递归简介" class="headerlink" title="递归简介"></a>递归简介</h2><h3 id="递归组成"><a href="#递归组成" class="headerlink" title="递归组成"></a>递归组成</h3><p>递归由两部分组成：</p>
<ol>
<li>锚或者叫基例，顾名思义，它是产生集合中其他元素的基本元素（<strong>基例是递归调用链中最后一步，用于停止递归，可以避免陷入无限循环</strong>）</li>
<li>构造规则，用于由基本元素或已有对象产生新对象的构造规则</li>
</ol>
<h3 id="递归的例子"><a href="#递归的例子" class="headerlink" title="递归的例子"></a>递归的例子</h3><p>二叉搜索树，比当前结果小，搜索左树，否则搜索右树。</p>
<h3 id="递归优缺点"><a href="#递归优缺点" class="headerlink" title="递归优缺点"></a>递归优缺点</h3><p>优点：</p>
<ol>
<li>使程序简洁易读，当我们能够确定，大问题能划分为相似的小问题时，我们可以用递归</li>
<li>递归在栈、树及图中广泛应用（我们可以使用循环，但较复杂）</li>
<li>递归在排序、分治、贪心和动态规划中广泛使用</li>
<li>递归一般是自底向上进行搜索，例如二叉树的前序遍历，递归过程是一路搜索到最下端，然后从叶子节点向上逐步返回</li>
</ol>
<p>缺点：<br>空间时间效率都不如迭代，递归调用过程会使用栈，所以空间消耗也要考虑进去。</p>
<p>综上，当我们能够将大问题拆分为小问题，不在乎时间空间消耗，想要尽快编写一个解而不考虑效率， 可以使用递归。</p>
<h3 id="递归的实现"><a href="#递归的实现" class="headerlink" title="递归的实现"></a>递归的实现</h3><p>注：这一部分涉及递归调用在c++中的实现，如果不需要了解递归过程中函数是如何调用的，可以跳过这一段，一句话来说递归是通过<strong>压栈入栈</strong>实现的。所以如果有需要栈实现的问题，也完全可以使用递归实现，例如<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">面试题06. 从尾到头打印链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a=reversePrint(head-&gt;next);</span><br><span class="line">    a.push_back(head-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同的递归类型"><a href="#不同的递归类型" class="headerlink" title="不同的递归类型"></a>不同的递归类型</h2><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>尾递归的定义是递归调用是递归函数的最后一条语句，并且在此之前也没有其他直接或间接递归调用，对于前面的状态不需要保存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,n);</span><br><span class="line">    <span class="keyword">return</span> fun(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fun(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序输出为3 2 1。</p>
<p>如何理解对于前面的状态不需要保存呢？看上面的代码，我们知道递归调用是一个不断压栈的过程，而由于尾递归中递归是最后一条语句，返回后没有别的语句需要执行，因此直接出栈即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Push</th>
<th style="text-align:center">Pop</th>
<th style="text-align:center">Pop</th>
<th style="text-align:center">Pop</th>
<th style="text-align:center">Pop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fun(0)</td>
<td style="text-align:center">return</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">fun(1)</td>
<td style="text-align:center">执行prinf; Act f1</td>
<td style="text-align:center">Act f1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">fun(2)</td>
<td style="text-align:center">执行prinf; Act f2</td>
<td style="text-align:center">Act f2</td>
<td style="text-align:center">Act f2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">fun(3)</td>
<td style="text-align:center">执行prinf; Act f3</td>
<td style="text-align:center">Act f3</td>
<td style="text-align:center">Act f3</td>
<td style="text-align:center">Act f3</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">main</td>
<td style="text-align:center">Act m</td>
<td style="text-align:center">Act m</td>
<td style="text-align:center">Act m</td>
<td style="text-align:center">Act m</td>
<td style="text-align:center">Act m</td>
</tr>
</tbody>
</table>
</div>
<h3 id="非尾递归"><a href="#非尾递归" class="headerlink" title="非尾递归"></a>非尾递归</h3><p>与尾递归相对应的是非尾递归，即递归不是函数中的最后一条语句，递归函数返回之后有一些遗留的东西需要处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    fun(n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fun(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Push</th>
<th style="text-align:center">Pop</th>
<th style="text-align:center">Pop</th>
<th style="text-align:center">Pop</th>
<th style="text-align:center">Pop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fun(0)</td>
<td style="text-align:center">return</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">fun(1)</td>
<td style="text-align:center">Act f1</td>
<td style="text-align:center">Act f1</td>
<td style="text-align:center">执行printf(“1 “)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">fun(2)</td>
<td style="text-align:center">Act f2</td>
<td style="text-align:center">Act f2</td>
<td style="text-align:center">Act f2</td>
<td style="text-align:center">执行printf(“2 “)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">fun(3)</td>
<td style="text-align:center">Act f3</td>
<td style="text-align:center">Act f3</td>
<td style="text-align:center">Act f3</td>
<td style="text-align:center">Act f3</td>
<td style="text-align:center">执行printf(“3”)</td>
</tr>
<tr>
<td style="text-align:center">main</td>
<td style="text-align:center">Act m</td>
<td style="text-align:center">Act m</td>
<td style="text-align:center">Act m</td>
<td style="text-align:center">Act m</td>
<td style="text-align:center">Act m</td>
</tr>
</tbody>
</table>
</div>
<p>输出结果为1 2 3，所以非尾递归可以用于倒序输出。</p>
<p>注意：非尾递归转换为迭代形式，需要显式使用栈操作。</p>
<p>一个容易迷惑的例子，看似是尾递归，实则是非尾递归：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在函数返回后，需要计算n * fact(n - 1)，因此以前的结果需要保留。计算过程分为如下两个部分：</p>
<ul>
<li>将递归函数逐层展开</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(5 * fact(4))</span><br><span class="line">(5 * (4 * fact(3))))</span><br><span class="line">...</span><br><span class="line">(5 * (4 * (3 * (2 * (1 * 1)))))) //完全展开</span><br></pre></td></tr></table></figure>
<ul>
<li>自底向上计算并合并结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(5 * (4 * (3 * (2 * 1)))))</span><br><span class="line">(5 * (4 * (3 * 2))))</span><br><span class="line">(5 * (4 * 6)))</span><br><span class="line">...</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
<p>所以普通的尾递归其实效率并不高。</p>
<h2 id="常见递归算法"><a href="#常见递归算法" class="headerlink" title="常见递归算法"></a>常见递归算法</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>本节请参考</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>回溯是深度优先搜索的一种，也是一种常用的暴力搜索方法，可以找出一部分或所有解，回溯法在最坏情况下复杂度为指数时间。应用场景在后续结果依赖于前面的选择。</p>
<h4 id="回溯法要点"><a href="#回溯法要点" class="headerlink" title="回溯法要点"></a>回溯法要点</h4><p>回溯法本质上是递归的一种，所以在考虑的时候要从递归的特点入手，<strong>着重解决递归退出的条件</strong>。使用回溯的问题可以被视为一个多叉树，树的深度取决于给定元素的个数。一条从根节点到叶节点的路径即为一个可行解。本节将针对回溯法的要点与难点进行分析，并总结常见的回溯形式。</p>
<h5 id="回溯法基本步骤"><a href="#回溯法基本步骤" class="headerlink" title="回溯法基本步骤"></a>回溯法基本步骤</h5><ul>
<li>抽象问题，将问题转换为“排列、子集、组合”的一种</li>
<li>画出递归树，找到状态变量(回溯函数的参数)<ul>
<li>树的总深度（数组的长度，链表的长度）</li>
<li>当前深度</li>
<li>搜索集合</li>
</ul>
</li>
<li>根据题意，确立结束条件</li>
<li>找准选择列表(与函数参数相关),与第一步紧密关联※</li>
<li>判断是否需要剪枝</li>
<li>作出选择，递归调用，进入下一层</li>
<li>撤销选择</li>
</ul>
<h5 id="回溯法基本框架"><a href="#回溯法基本框架" class="headerlink" title="回溯法基本框架"></a>回溯法基本框架</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回条件，指针不满足，超过边界等等</span></span><br><span class="line">    push_value();</span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加答案</span></span><br><span class="line">    back_track(...);  <span class="comment">// 递归</span></span><br><span class="line">    </span><br><span class="line">    pop_value();  <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第一类，寻找全部解的回溯法"><a href="#第一类，寻找全部解的回溯法" class="headerlink" title="第一类，寻找全部解的回溯法"></a>第一类，寻找全部解的回溯法</h5><p>一 树或链表类：此类问题要求寻找树或链表中全部解或者统计解的个数，因此在找到解的时候，不能返回，需要对解进行记录，该类问题的回溯法算法流程如下：</p>
<ul>
<li>输入递推参数：当前节点root，目标值target，解空间ans，临时解temp_ans；</li>
<li>判断终止条件：当root == nullptr时，返回</li>
<li>进行递推工作<ul>
<li>临时解更新，将当前root-&gt;val加入temp_ans；</li>
<li>目标值更新，target = target - root-&gt;val；</li>
<li>解空间更新，当 target 为 0（满足目标值）并且满足其他特定条件时，将此临时解加入解空间</li>
<li>深度优先搜索，更新相关参数</li>
<li>路径恢复，将root-&gt;val 从 temp_ans中弹出。</li>
</ul>
</li>
</ul>
<p>例题1 LeetCode面试题34 二叉树中和为某一值的路径</p>
<p>二 一维数组类：此类问题要求寻找数组中全部解或统计解个数，该类问题的回溯法算法流程如下：</p>
<ul>
<li>输入递推参数：递归树深度或数组长度n，解空间ans，临时解temp_ans，当前深度first</li>
<li>判断终止条件：当first == n，即搜索已经超过数组长度时</li>
<li>进行递推工作<ul>
<li>临时解更新，</li>
</ul>
</li>
</ul>
<h5 id="第二类，寻找解是否存在的回溯法"><a href="#第二类，寻找解是否存在的回溯法" class="headerlink" title="第二类，寻找解是否存在的回溯法"></a>第二类，寻找解是否存在的回溯法</h5><h5 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h5><p>剪枝一般出现在需要去除重复或者不符合条件的解的场合，参考LeetCode中非重复的全排列。剪枝过程包括如下几个流程：</p>
<ul>
<li>创建visited数组，用于判断当前节点是否已经访问</li>
<li>对待处理的数组进行排序处理，从而保证能够通过num[i-1] 是否等于 num[i]确定是否需要剪枝</li>
<li>递归时将visited置1，回溯时置0</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.size() == nums.size())&#123; </span><br><span class="line">        ans.push_back(curr);       </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;  <span class="comment">//for循环保证了搜索的广度</span></span><br><span class="line">        <span class="comment">//两个if进行减枝操作</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;    <span class="comment">//如果已经访问过当前节点，则跳过，保证每次循环不会访问到重复节点   </span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果当前节点和前一个节点相同，且没有访问前一个节点，那说明前一个节点必然会产生和当前节点相同的结论，跳过即可</span></span><br><span class="line">        curr.push_back(nums[i]);</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        backtrack(ans, nums, curr, visited);</span><br><span class="line">        curr.pop_back();</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回溯法常见应用："><a href="#回溯法常见应用：" class="headerlink" title="回溯法常见应用："></a>回溯法常见应用：</h4><h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p>一. 组合，求$C_n^k$，这个模板也很常用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> first,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span></span>&#123;</span><br><span class="line">        <span class="comment">/********************关键代码*********************/</span></span><br><span class="line">        <span class="keyword">if</span>(temp.size() == k) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;=n;i++)&#123;    <span class="comment">//first 当前深度 </span></span><br><span class="line">            temp.push_back(i);</span><br><span class="line">            backtrack(k,n,i+<span class="number">1</span>,ans,temp);   <span class="comment">//i+1保证了组合始终是后向寻找，不会包含重复的，是i+1,不是first+1，也不需要利用visited数组判断某个元素是否访问，后向寻找保证了访问的唯一性</span></span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp&#123;&#125;;</span><br><span class="line">        backtrack(k,n,<span class="number">1</span>,ans,temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>正确理解上面的代码是很重要的，接下来我们将以图示的形式解释其中的关键部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;=n;i++)&#123;</span><br><span class="line">    temp.push_back(i);</span><br><span class="line">    backtrack(k,n,i+<span class="number">1</span>,ans,temp);   <span class="comment">//i+1保证了组合始终是后向寻找，不会包含重复的，是i+1,不是first+1</span></span><br><span class="line">    temp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">          |</span><br><span class="line">-------------------------</span><br><span class="line">|   |   |   |   |   |   |       </span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>      <span class="keyword">for</span>循环的作用，遍历当前搜索集合（广度）</span><br><span class="line">|</span><br><span class="line">---------------------          递归的作用，增加搜索树的深度（深度）</span><br><span class="line">|   |   |   |   |   |</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line">        </span><br><span class="line">所以在回溯算法中，当考虑搜索的广度时，使用迭代；当考虑搜索深度时，使用递归</span><br></pre></td></tr></table></figure>
<p>二. 可重复被选取的组合：LeetCode 39</p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这种题目一看就是用回溯法，但是本题有一个条件，就是数字可以无限制重复被选取，这意味着我们在回溯的循环过程中，每一次回溯start都是<code>i</code>。另外求总和等于target，可以采用自顶向下的方法，即每次减去一个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start;</span><br><span class="line">     i &lt; nums.size() &amp;&amp; target - nums[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">    path.push_back(nums[i]);</span><br><span class="line">    backtrack(i, target - nums[i]);   <span class="comment">//是i而不是i+1，如果是i+1会变成不重复的组合</span></span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用深度优先搜素时，必须先对nums进行排序，才能进行减枝处理。</p>
<h5 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h5><p>一. 非减枝全排列</p>
<p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：我们在写全排列问题时，一般是先确定一位，然后对剩下的子数组进行全排列，才能做到不重复也不遗漏，传统循环方式肯定是行不通的，时间复杂度过高。回溯法将问题转换为对树的搜索问题，通过<strong>深度优先遍历 + 状态重置（回溯） + 剪枝（可选）</strong>，实现全排列的搜索。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/561e67d343f2ca828644095a67f39694628b730dfffa24b52af9cbc6e011f134-46-1.png" alt=""></p>
<p>在每一层，我们都有若干条分支供我们选择。下一层的分支数比上一层少 1 ，因为每一层都会排定 1 个数，从这个角度，再来理解一下为什么要使用额外空间记录那些元素使用过；全部的“排列”正是在这棵递归树的所有叶子结点。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result&#123;&#125;;  </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();  <span class="comment">//树的深度，n个数就则树有n层</span></span><br><span class="line">        backtrack(n, result, nums, <span class="number">0</span>);   <span class="comment">//进行回溯，从第0层开始</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n,                          <span class="comment">//树深度</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt;&amp; output,   <span class="comment">//总结果</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,              <span class="comment">//一条路径的结果</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> first)</span></span>&#123;                     <span class="comment">//开始回溯的深度</span></span><br><span class="line">        <span class="keyword">if</span>(first == n) output.push_back(nums);     <span class="comment">//到达第n层，即已经进行了0～n-1层的递进，递进了n层</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = first; i&lt;n; i++)&#123;              <span class="comment">//i = 当前层数至最大层数</span></span><br><span class="line">            <span class="keyword">if</span>(i == first) &#123;</span><br><span class="line">                backtrack(n, output, nums, first+<span class="number">1</span>);   <span class="comment">//深度优先遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums[first],nums[i]);             <span class="comment">//采用交换的 方式，构造新的结果</span></span><br><span class="line">                <span class="comment">// temp.push_back(nun[i]);   [1,2]  -&gt; [1,2,3]  [1] -&gt; [1,2]</span></span><br><span class="line">                <span class="comment">// [1,2,3] -&gt; [1,3,2]</span></span><br><span class="line">                backtrack(n, output, nums, first+<span class="number">1</span>);   <span class="comment">//深度优先遍历</span></span><br><span class="line">                swap(nums[first],nums[i]);              <span class="comment">//重置 </span></span><br><span class="line">                <span class="comment">//temp.pop_back();           [1,2,3] -&gt; [1,2]    [1,2]-&gt;[1]  </span></span><br><span class="line">                <span class="comment">// [1,3,2] -&gt; [1,2,3]</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//  [1] -&gt; [1,2] 递归，深度优先搜索 dfs    -&gt;      [1,2] -&gt;[1]  回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二. 剪枝全排列</p>
<p>如果需要排除重复的情况，那么就是带有减枝的操作，如leetcode47及1079，非重复的全排列，题目如下：</p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>这个模板很通用，记住</strong>（这个代码还需要多理解几次）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.size())&#123; </span><br><span class="line">            ans.push_back(curr);       </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;  <span class="comment">//for循环保证了搜索的广度</span></span><br><span class="line">            <span class="comment">//两个if进行减枝操作</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;    <span class="comment">//如果已经访问过当前节点，则跳过，保证每次循环不会访问到重复节点   </span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果当前节点和前一个节点相同，且没有访问前一个节点，那说明前一个节点必然会产生和当前节点相同的结论，跳过即可</span></span><br><span class="line">            curr.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            backtrack(ans, nums, curr, visited);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//执行完</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());   <span class="comment">//必须排序，才能判断nums[i]==nums[i-1]</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;          </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;                 </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;  <span class="comment">//是否访问的flag vector</span></span><br><span class="line">        backtrack(ans, nums, curr, visited);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里比较让人迷惑的是减枝条件判断的第三个条件，其解释如下：</p>
<blockquote>
<p>以 [2, 3, 3, 3] 中的 3 个 3 为例，相同的 3 个 3 有 6 个排列。我们只要保留 1 个就好了。</p>
<p>它们的索引分列是：</p>
<p>[1, 2, 3] （数组中的数组表示 3 这个元素在 [2, 3, 3, 3] 这个数组中的索引，在全排列中可能的“排列”，下同）<br>[1, 3, 2]<br>[2, 1, 3]<br>[2, 3, 1]<br>[3, 1, 2]<br>[3, 2, 1]<br>发现其实又是一个全排列问题。首先联系数组 used[i - 1] 的语义：used[i - 1] == true 表示索引 i 位置的前一个位置元素已经使用过。在 used[i - 1] == true 的时候全部 continue 掉，则只剩下了 used[i - 1] == false 的情况，即当前遍历的元素的之前的元素均未使用过，因此保留了 [3, 2, 1] 这种排列。</p>
<p>作者：liweiwei1419<br>链接：<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>三. 下一个排列</p>
<p>四. 第K个排列</p>
<p>给出集合<code>[1,2,3,…,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;123&quot;</span><br><span class="line">&quot;132&quot;</span><br><span class="line">&quot;213&quot;</span><br><span class="line">&quot;231&quot;</span><br><span class="line">&quot;312&quot;</span><br><span class="line">&quot;321&quot;</span><br></pre></td></tr></table></figure>
<p>给定 n 和 k，返回第 k 个排列。</p>
<p><strong>思路</strong></p>
<p>排列的每种情况均可以使用十进制或者二进制的形式进行表示，相当于使用掩码对排列进行操作：</p>
<p>五. N皇后问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessBoard</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChessBoard();</span><br><span class="line">    ChessBoard(<span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findSolutions</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans&#123;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans_temp;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> norm;</span><br><span class="line">    <span class="keyword">bool</span> *column, *leftDiagnoal, *rightDiagnoal;</span><br><span class="line">    <span class="keyword">int</span> *positionInRow, howMany;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putQueen</span><span class="params">(<span class="keyword">int</span> row)</span></span>;</span><br><span class="line">    <span class="comment">//void printBoard(ostream&amp;);</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialization</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChessBoard::ChessBoard():</span><br><span class="line">    n&#123;<span class="number">8</span>&#125;,</span><br><span class="line">    norm&#123;n<span class="number">-1</span>&#125;&#123;</span><br><span class="line">    initialization();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChessBoard::ChessBoard(<span class="keyword">int</span> _n):</span><br><span class="line">    n&#123;_n&#125;,</span><br><span class="line">    norm&#123;_n<span class="number">-1</span>&#125;&#123;</span><br><span class="line">    initialization();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChessBoard::initialization</span><span class="params">()</span></span>&#123;</span><br><span class="line">    column = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    leftDiagnoal = <span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">2</span>*n<span class="number">-1</span>];</span><br><span class="line">    rightDiagnoal = <span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">2</span>*n<span class="number">-1</span>];</span><br><span class="line">    positionInRow = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        column[i] = <span class="literal">true</span>;</span><br><span class="line">        positionInRow[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        leftDiagnoal[i] = <span class="literal">true</span>;</span><br><span class="line">        rightDiagnoal[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">one_row</span><span class="params">(n,<span class="string">'.'</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans_temp.push_back(one_row);</span><br><span class="line">    &#125;</span><br><span class="line">    howMany = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChessBoard::putQueen</span><span class="params">(<span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(column[col] == <span class="literal">true</span> &amp;&amp; rightDiagnoal[row + col] == <span class="literal">true</span> &amp;&amp; leftDiagnoal[row - col + norm] == <span class="literal">true</span>)&#123;   <span class="comment">//如果这个格子上可以放置皇后</span></span><br><span class="line">            </span><br><span class="line">            column[col] = <span class="literal">false</span>;</span><br><span class="line">            rightDiagnoal[row + col] = <span class="literal">false</span>;</span><br><span class="line">            leftDiagnoal[row - col + norm] = <span class="literal">false</span>;  <span class="comment">//放置皇后</span></span><br><span class="line">            ans_temp[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(row == n - <span class="number">1</span>)&#123;   <span class="comment">//已经放了8个皇后，得到一个结果</span></span><br><span class="line">                howMany ++;    <span class="comment">//这里记住不需要返回</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:ans_temp)&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                ans.push_back(ans_temp);   </span><br><span class="line">            &#125;</span><br><span class="line">            putQueen(row + <span class="number">1</span>);   <span class="comment">//放置下一行的皇后</span></span><br><span class="line">            column[col] = <span class="literal">true</span>;  <span class="comment">//将当前皇后拿起</span></span><br><span class="line">            rightDiagnoal[row + col] = <span class="literal">true</span>;</span><br><span class="line">            leftDiagnoal[row - col + norm] = <span class="literal">true</span>;</span><br><span class="line">            ans_temp[row][col] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChessBoard::findSolutions</span><span class="params">()</span></span>&#123;</span><br><span class="line">    putQueen(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; howMany &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h5 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h5><p>子集(leetcode 78)</p>
<p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/34eae756ea7b9483956e2f18fec7642968e8f24d17234405bf7fcdecae55afbf-%E5%9B%BE%E7%89%872.png" alt=""></p>
<p>递归问题最重要的就是找到基例和构造规则，本题基例不难找，关键是构造规则比较麻烦</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">compute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;subset_set,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;now_set,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i&gt;=nums.size())&#123;   <span class="comment">//基例</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这里没有搞清楚递归的过程！！！！！！！！！！！！！！！！！！！*/</span></span><br><span class="line">    now_set.push_back(nums[i]);     <span class="comment">//进入下一条路</span></span><br><span class="line">    subset_set.push_back(now_set);  </span><br><span class="line">    compute(subset_set,nums,now_set,i+<span class="number">1</span>);     <span class="comment">//本质上是二叉树前序遍历的过程</span></span><br><span class="line">    now_set.pop_back();  <span class="comment">//返回上一条路</span></span><br><span class="line">    compute(subset_set,nums,now_set,i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;subset_set;<span class="comment">//保存最终结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;now_set=&#123;&#125;;    <span class="comment">//保存临时结果</span></span><br><span class="line">        subset_set.push_back(now_set);      <span class="comment">//空集 </span></span><br><span class="line">        compute(subset_set,nums,now_set,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> subset_set;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>这种题的一般思路就是一个元素一个元素往上加，先考虑集合中只有一个元素的情况，然后一个元素讨论清楚了，再考虑两个元素，一般两个元素就能找到回溯规律。</strong>本题可以等价为二叉树遍历的问题，子集中选不选择某个元素，就可以视作是yes or no问题，是一个典型的二分类。</p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>在计算机科学中，分治法是构建基于多项分支递归的一种很重要的算法范式。字面上的解释是「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序、归并排序）、傅立叶变换（快速傅立叶变换）。分治法的思路如下所示：</p>
<pre class="mermaid">graph TB
    node["原问题"]
    node1["子问题"]
    node2["子问题"]
    node3["子问题的解"]
    node4["子问题的解"]
    node5["原问题的解"]

    node-->node1
    node-->node2
    node1-->node3
    node2-->node4
    node3-->node5
    node4-->node5</pre>



<h4 id="分治法应用场景"><a href="#分治法应用场景" class="headerlink" title="分治法应用场景"></a>分治法应用场景</h4><p>分治法最适用于能够将大问题拆分成两个或多个相似子问题的场景。</p>
<h2 id="递归使用步骤"><a href="#递归使用步骤" class="headerlink" title="递归使用步骤"></a>递归使用步骤</h2><p>递归使用过程中常见步骤如下：</p>
<ul>
<li>确定返回值的意义</li>
<li>确定返回值是否需要保存</li>
<li>确定基例</li>
<li>确定递归构造规则</li>
</ul>
<h2 id="递归难点总结"><a href="#递归难点总结" class="headerlink" title="递归难点总结"></a>递归难点总结</h2><h3 id="使用递归时，尽可能保证递归体的简单性"><a href="#使用递归时，尽可能保证递归体的简单性" class="headerlink" title="使用递归时，尽可能保证递归体的简单性"></a>使用递归时，尽可能保证递归体的简单性</h3><p>由于递归可能涉及复杂的出入栈操作，因此在一定程度上会导致程序分析困难，所以应当尽可能保证递归体简洁性，保证一个递归操作只完成一个任务。例如LeetCode 面试题36：</p>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
</blockquote>
<p>思路比较简单，先创建一个vector，中序遍历保存所有节点，然后将节点依次相连即可。在编写代码过程中，我们将中序遍历单独写为一个递归函数，实现节点遍历及保存的功能。相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; nodeVector&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node* root)</span></span>&#123;    <span class="comment">//中序遍历保存节点，此外不作任何事情</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            inorder(root-&gt;left);</span><br><span class="line">            nodeVector.push_back(root);</span><br><span class="line">            inorder(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">int</span> n = nodeVector.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;   <span class="comment">//循环条件要保证循环体内索引不超过vector长度，如果循环体内有i+1，那么此处判断条件要写为n-1</span></span><br><span class="line">            nodeVector[i] -&gt; right  = nodeVector[i+<span class="number">1</span>];</span><br><span class="line">            nodeVector[i+<span class="number">1</span>] -&gt; left = nodeVector[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nodeVector[<span class="number">0</span>]-&gt;left = nodeVector[n<span class="number">-1</span>];</span><br><span class="line">        nodeVector[n<span class="number">-1</span>]-&gt;right = nodeVector[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> nodeVector[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h3><p>递归实际上包含了分治的思想，将大问题逐步拆解成简单的小问题，因此我们在使用递归时，一个非常重要的步骤就是找到分治的方法。我们将以<a href="https://leetcode-cn.com/problems/hanota-lcci/"> 汉诺塔问题</a>对找到分治的过程进行总结。</p>
<blockquote>
<p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p>输入：A = [2, 1, 0], B = [], C = []<br>输出：C = [2, 1, 0]</p>
</blockquote>
<p>考虑一个盘子，那么我们直接将盘子从A移动至C，即<code>C.push_back(A.pop_back());</code></p>
<p>当有两个盘子时，我们首先将小盘子移动至B，然后将大盘子移动至C，最后将小盘子移动至C，这个过程为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">B.push_back(A.pop_back());</span><br><span class="line">C.push_back(A.pop_back());</span><br><span class="line">C.push_back(B.pop_back());</span><br></pre></td></tr></table></figure>
<p>当有n个盘子时，我们可以将盘子分成两部分，n-1个小盘子先移动到B，然后将最后一个大盘子移动到C，最后将n-1个小盘子移动到C，这个过程可以写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move(n-1, A, C, B);           //n-1个小盘子移动到B</span><br><span class="line">C.push_back(A.back());    //将大盘子移动至C</span><br><span class="line">A.pop_back();</span><br><span class="line">move(n-1, B, A, C);</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanota</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span> </span>&#123;</span><br><span class="line">    move(A.size(),A,B,C);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        C.push_back(A.back());</span><br><span class="line">        A.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    move(n<span class="number">-1</span>,A, C, B);</span><br><span class="line">    C.push_back(A.back());</span><br><span class="line">    A.pop_back();</span><br><span class="line">    move(n<span class="number">-1</span>,B, A, C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.google.com/books?hl=zh-CN&amp;lr=&amp;id=v-b0CAAAQBAJ&amp;oi=fnd&amp;pg=PR5&amp;dq=data+structure+and+algorithm+in+c%2B%2B&amp;ots=C_TqwgXHOv&amp;sig=IZJed9W71UYAYM77rjCoMFDgab0">Drozdek A. Data Structures and algorithms in C++[M]. Cengage Learning, 2012.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">力扣46题解</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>溢出处理及负数表示</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%B6%8A%E4%BD%8D%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>由于计算机硬件的限制，C++中具体类型的表示范围是有限制的，所以可能会在运算中出现溢出的情况，特别是在涉及负数运算的情况下，本文将对C++中溢出及负数等相关知识进行总结。</p>
<a id="more"></a>
<h2 id="常见类型范围"><a href="#常见类型范围" class="headerlink" title="常见类型范围"></a>常见类型范围</h2><h3 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h3><p>int类型范围是-2147483648~2147483647，表示为科学计数法为$-2^{31}$到$2^{31}-1$，在C++中，int的边界为宏定义INT_MIN与INT_MAX，特别注意INT_MIN不能取负值，否则会越界。所以在需要对一个负数进行取反之前，首先要判断是否大于INT_MIN，如果等于INT_MIN，那么取反的结果为INT_MAX</p>
<p><code>(dividend == INT_MIN ? INT_MAX : -dividend);</code></p>
<h3 id="long-long类型"><a href="#long-long类型" class="headerlink" title="long long类型"></a>long long类型</h3><p>long long范围是$-2^{63}$到$2^{63}-1$，两个int类型相乘是可以保证不会越过long long的类型范围的。</p>
<h2 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h2><p>在计算机中，正数与负数均使用补码进行表示，有符号类型的最高位代表符号位。</p>
<h3 id="正数的表示"><a href="#正数的表示" class="headerlink" title="正数的表示"></a>正数的表示</h3><p>正数原码、反码与补码均相同，考虑8位的char类型，正数二进制表示范围是0000,0000-0111,1111，即$0$到$2^7-1$。</p>
<h3 id="负数的表示"><a href="#负数的表示" class="headerlink" title="负数的表示"></a>负数的表示</h3><p>负数的补码可以表示为该数绝对值的原码的反码+1，以-127为例</p>
<ul>
<li>127原码为0111,1111</li>
<li>127反码为1000,0000</li>
<li>127的反码加1: 1000,0001</li>
</ul>
<p>故-127补码为1000,0001</p>
<p>那么问题来了，-128如何表示呢，这里直接规定<strong>-128的补码就是1000,0000</strong>，所以负数的表示范围为1000,0000到1111,1111，即从-128到-1。</p>
<h3 id="为何要使用补码"><a href="#为何要使用补码" class="headerlink" title="为何要使用补码"></a>为何要使用补码</h3>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>CPU</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>虚拟体验也好，梦也罢，这个世上的信息，既现实也虚幻；无论如何，人一生所能接触的事物也只是沧海一粟罢了</p>
</blockquote>
<a id="more"></a>
<h2 id="CPU组成部分"><a href="#CPU组成部分" class="headerlink" title="CPU组成部分"></a>CPU组成部分</h2><p>CPU由<strong>控制器</strong>和<strong>运算器</strong>两个部分组成。其逻辑结构图如下所示：</p>
<p><img src="https://examradar.com/wp-content/uploads/2016/10/Block-Diagram-of-8086.png" width = "580" alt="图片名称" align=center /></p>
<p>上面的图中，左半部分为指令执行单元（EU），右半部分为总线接口单元（BIU），下面针对这两个单元分别介绍：</p>
<h3 id="总线接口单元BIU"><a href="#总线接口单元BIU" class="headerlink" title="总线接口单元BIU"></a>总线接口单元BIU</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>作为CPU与外部（存储器和IO）的接口，提供16位双向数据线和20位地址线，完成所有外部总线操作，包括地址形成、取指令、指令排队、读写操作数和总线控制。</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul>
<li>16位段寄存器：CS/DS/ES/SS</li>
<li>16位指令指针寄存器IP</li>
<li>20位物理地址加法器（图中的$\sum$）：将16位逻辑地址变为20位物理地址</li>
<li>六字节指令队列：存放6字节指令代码</li>
<li>总线控制逻辑电路：发出总线控制信号</li>
</ul>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><ol>
<li>CS+IP进行20位寻址，送往地址总线，总线控制逻辑发出存储器读信号$\overline{\textrm{RD}}$，按给定地址从存储器中取出指令，送到指令队列中。</li>
<li>指令队列可以存储六字节指令，当指令队列空余时，BIU自动取指令；指令队列已满并且EU未申请读写存储器操作时，BIU空闲。</li>
<li>EU从指令队列取走指令，经过译码后向BIU申请从存储器或IO端口读写操作。只要收到EU送来的逻辑地址，BIU将通过地址加法器转换成物理地址，在读写周期访问存储器或IO完成IO操作。（EU执行指令，BIU传输运算结果）</li>
<li>BIU控制指令指针寄存器IP自动指向下一条待执行指令，并从后续地址存放的指令序列中取指令填充指令队列</li>
</ol>
<h3 id="指令执行部件EU"><a href="#指令执行部件EU" class="headerlink" title="指令执行部件EU"></a>指令执行部件EU</h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>完成译码和执行指令的功能</p>
<h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul>
<li>算术逻辑单元ALU：完成8位或16位二进制运算</li>
<li>标志寄存器：保存ALU运算结果特征</li>
<li>寄存器组：4个通用16位寄存器（AX为累加器），4个专用16位寄存器</li>
<li>EU控制器：从指令队列取指令、指令译码和时序控制部件</li>
</ul>
<h4 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h4><ol>
<li>EU从指令队列取指令并译码，如果指令需要访问存储器或IO，则EU通过内部16位总线将逻辑地址送给BIU，BIU访问存储器或IO，获得操作数发送给EU，EU执行指令</li>
<li>ALU完成各种算数及逻辑运算，运算操作数可以从存储器或寄存器组取得，运算结果由内部总线送至寄存器组或BIU的内部寄存器。运算后结果的特征改变标志寄存器flags的某些状态位，可供测试或判断及转移指令之用。</li>
<li>一般情况下EU从指令队列而非存储器中取指令，所以取指令和执行可以并行操作。但如果有转移、调用或返回指令，会导致指令队列失效，这时必须新取得指令后才可以继续执行，但是这种情况比较少见，所以EU和BIU相互配合的非同步并行提高了效率。</li>
</ol>
<h2 id="CPU工作过程"><a href="#CPU工作过程" class="headerlink" title="CPU工作过程"></a>CPU工作过程</h2><p>一般来说，CPU的工作过程可以概括为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">    run next instruction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CPU的工作状态"><a href="#CPU的工作状态" class="headerlink" title="CPU的工作状态"></a>CPU的工作状态</h3><p>CPU可以分为管态（特权态）与目态（常态）</p>
<h2 id="8086CPU介绍"><a href="#8086CPU介绍" class="headerlink" title="8086CPU介绍"></a>8086CPU介绍</h2><p>本文以经典的x86系列CPU的鼻祖8086CPU为例，详细介绍一下CPU的系统结构</p>
<h3 id="CPU引脚及其功能"><a href="#CPU引脚及其功能" class="headerlink" title="CPU引脚及其功能"></a>CPU引脚及其功能</h3><p>8086CPU的外部引脚图如下所示：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/8086-pin-diagram.png?raw=true" width = "350" alt="图片名称" align=center /></p>
<h4 id="地址线"><a href="#地址线" class="headerlink" title="地址线"></a>地址线</h4><p>地址线为AD0-AD19共20条，其中AD0-AD15为16条地址/数据总线，而AD16-AD19为地址/数据/状态三态输出、分时复用。</p>
<h4 id="数据线"><a href="#数据线" class="headerlink" title="数据线"></a>数据线</h4><p>数据线为AD0-AD15共16条</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>DMA</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/DMA_CLIB_AES/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>I hope that one day I can extract myself from the meaningless work and do<br>something real valuable.</p>
</blockquote>
<a id="more"></a>
<p>In this article, I will give an introduction of the DMA module we used in our<br>project.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Function Name</th>
<th>Description</th>
<th>Param</th>
<th>Return</th>
</tr>
</thead>
<tbody>
<tr>
<td>DMAGetTTFCType</td>
<td>Get the transfer type</td>
<td>src_addr/dst_addr</td>
<td>transfer type</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将对链表相关知识进行一个总结。</p>
<a id="more"></a>
<h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>链表是一种长度可变的线性数据结构（线性的意思是列表中每个节点只能访问相邻节点，不能跨节点访问），链表中每个节点都是一个独立元素（不影响其他节点），一个节点由三部分组成：</p>
<ol>
<li>value</li>
<li>指向下一个节点的指针</li>
<li>节点自身的地址</li>
</ol>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/dsa_linkedlist.jpg" alt="链表图示"></p>
<h2 id="链表的组成"><a href="#链表的组成" class="headerlink" title="链表的组成"></a>链表的组成</h2><p>链表由如下部分组成：</p>
<ol>
<li>Node：包括值和指向下一个节点的指针</li>
<li>Head：指向第一个节点的指针，用于访问链表第一个Node</li>
<li>Tail：指向最后一个节点的指针，用于访问最后一个Node，从而方便添加尾节点（否则需从头遍历，效率很低）</li>
</ol>
<h2 id="链表类型及作用"><a href="#链表类型及作用" class="headerlink" title="链表类型及作用"></a>链表类型及作用</h2><h3 id="链表类型"><a href="#链表类型" class="headerlink" title="链表类型"></a>链表类型</h3><ol>
<li>单向链表，Single Link List（SLL）：保存后向节点的指针，不保存前向的（一条蛇）</li>
<li>循环单向链表，Circular SLL：与SLL唯一的区别是最后一个节点保存第一个节点的指针（一条咬住尾巴的蛇）</li>
<li>双向链表，DLL：保存前向和后向节点的指针，一个节点可访问前向和后向（一列火车）</li>
<li>循环双向链表，CDLL（一列首尾相连的火车）<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3></li>
</ol>
<p>SLL是最基本的链表类型，用于运行期添加删除元素。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/1b76d10.png" alt=""></p>
<p>CSLL为了解决SLL不能循环访问的缺点，想象一个下棋游戏，最后一个玩家进行完后需要返回，由第一个玩家进行，SLL不能胜任这种任务，但是CSLL可以。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/circular-singly-linked-list.png" alt=""></p>
<p>DLL为了解决SLL不能前向访问的缺点，想象一个音乐播放器，当我们按下上一首，下一首，我们希望访问前一个和后一个节点，这种情况下使用双向链表可以解决这种问题。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/DLL1.png" alt=""></p>
<p>CDLL则兼具CSLL和DLL的优点，可以循环及前向访问。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Circular-doubly-linked-list.png" alt=""></p>
<h2 id="链表基本操作"><a href="#链表基本操作" class="headerlink" title="链表基本操作"></a>链表基本操作</h2><p>链表基本操作包括：</p>
<ul>
<li>链表的创建与删除</li>
<li>链表插入</li>
<li>链表遍历</li>
<li>链表搜索</li>
<li>链表节点删除</li>
</ul>
<h3 id="单向链表的操作"><a href="#单向链表的操作" class="headerlink" title="单向链表的操作"></a>单向链表的操作</h3><h4 id="单向链表的建立"><a href="#单向链表的建立" class="headerlink" title="单向链表的建立"></a>单向链表的建立</h4><ol>
<li>创建Head和Tail并初始化为Null</li>
<li>建立节点1·，节点1指向Null</li>
<li>将Head与Tail指向节点1</li>
</ol>
<p>时间与空间复杂度都是$O(1)$。</p>
<h4 id="单向链表的插入"><a href="#单向链表的插入" class="headerlink" title="单向链表的插入"></a>单向链表的插入</h4><p>插入分为三种：在头在尾在中间。三种操作都需要创建一个新节点。</p>
<ul>
<li>在头插入</li>
</ul>
<ol>
<li>将新节点指向第一个节点（即Head中的值）</li>
<li>将Head指向新节点</li>
</ol>
<ul>
<li>在尾插入</li>
</ul>
<ol>
<li>将最后一个节点指向新节点</li>
<li>将Tail指向新节点</li>
</ol>
<ul>
<li>在中间插入</li>
</ul>
<ol>
<li>将新节点指向被插入点后的节点</li>
<li>将被插入点前的节点指向新节点</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">insert(head, node_value, location)&#123;</span><br><span class="line">    create a <span class="keyword">new</span> node</span><br><span class="line">    node.value = node_value;</span><br><span class="line">    <span class="keyword">if</span>(head = null)</span><br><span class="line">        <span class="keyword">return</span> error <span class="comment">// SLL does not exist</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(location == <span class="number">0</span>)  <span class="comment">//在头插入</span></span><br><span class="line">        node.next = head</span><br><span class="line">        head = node</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(location == last)  <span class="comment">//在尾部插入</span></span><br><span class="line">        node.next = null</span><br><span class="line">        tail.next = node</span><br><span class="line">        tail = node</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//在中间插入</span></span><br><span class="line">        loop:tmp_node = <span class="number">0</span> to location - <span class="number">1</span>  <span class="comment">//tmp_node 就是被插入的节点</span></span><br><span class="line">        node.next = tmp_node.next</span><br><span class="line">        tmp_node.next = node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为$O(n)$，空间复杂度为O(1)。</p>
<h4 id="链表的遍历与搜索"><a href="#链表的遍历与搜索" class="headerlink" title="链表的遍历与搜索"></a>链表的遍历与搜索</h4><p>时间复杂度$O(n)$，空间为$O(1)$。</p>
<h4 id="链表节点的删除"><a href="#链表节点的删除" class="headerlink" title="链表节点的删除"></a>链表节点的删除</h4><ul>
<li>删除头节点</li>
</ul>
<p>如果只有一个节点，那么使用一个临时Node指针保存头节点，然后将Head和Tail指向nullptr，最后删除tmp。</p>
<p>如果有多个节点，将Head指向Head-&gt;next。</p>
<ul>
<li>删除尾节点</li>
</ul>
<p>如果只有一个节点，那么使用临时节点保存尾节点，然后Head和Tail置空，最后删除tmp。</p>
<p>如果有多个节点，需要进行遍历，找到倒数第二个节点，将其next置空并另Tail指向它。然后删除tmp</p>
<ul>
<li>删除中间节点</li>
</ul>
<p>遍历找到待删除的前一个节点，临时Node指针保存待删除节点，将前一个节点指向待删除节点next，然后删除待删除节点。</p>
<h4 id="获取中间节点"><a href="#获取中间节点" class="headerlink" title="获取中间节点"></a>获取中间节点</h4><p>可以采用快慢指针的方式获取中间节点，如果需要从中间节点之前断开链表，可以使用另外一个额外的变量prevPtr对中间节点之前的节点进行保存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    ListNode* slow, *fast, *prev;</span><br><span class="line">    prev = <span class="literal">nullptr</span>;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        prev = slow;             <span class="comment">//保存中间节点的前一个节点</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prev != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        prev-&gt;next = <span class="literal">nullptr</span>;   <span class="comment">//从中间节点前断开，中间节点属于后半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表的操作"><a href="#双向链表的操作" class="headerlink" title="双向链表的操作"></a>双向链表的操作</h3><h2 id="链表高级操作"><a href="#链表高级操作" class="headerlink" title="链表高级操作"></a>链表高级操作</h2><ul>
<li><code>merge(l1,l2)</code>，双路归并</li>
<li><code>cut(l,n)</code>，断链操作，将链表<code>l</code>切掉前n个节点，并返回后半部分链表头</li>
<li><code>reverse</code>，反转操作</li>
<li>删除特定节点</li>
</ul>
<h3 id="merge操作"><a href="#merge操作" class="headerlink" title="merge操作"></a>merge操作</h3><p>将两个List排序后合并，过程和数组的合并比较类似，就是链表操作过程比较麻烦。</p>
<ol>
<li>迭代法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummyHead</span><span class="params">(<span class="number">0</span>)</span></span>;   </span><br><span class="line">    <span class="keyword">auto</span> p = &amp;dummyHead;   <span class="comment">//p是辅助指针</span></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;     </span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;             </span><br><span class="line">            p = l1;                  </span><br><span class="line">            l1 = l1-&gt;next;           </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;               <span class="comment">//</span></span><br><span class="line">            p = l2;                     <span class="comment">//移动p</span></span><br><span class="line">            l2 = l2-&gt;next;              <span class="comment">//移动l2，相当于数组中的i++操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = l1 ? l1 : l2;             <span class="comment">//将剩余部分合并到链表中</span></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>递归法</li>
</ol>
<p>递归法的递推公式如下，先选出两个节点中较小的那个，然后将剩下的部分递推，返回值是较小链表节点的指针。</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{ll}
\operatorname{list} 1[0]+\operatorname{merge}(\operatorname{list} 1[1:], \text {list2}) & \operatorname{list} 1[0]<\operatorname{list} 2[0] \\
\operatorname{list} 2[0]+\operatorname{merge}(\operatorname{list} 1, \operatorname{list} 2[1:]) & \text {otherwise}
\end{array}\right.</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">        <span class="keyword">return</span> l1;          <span class="comment">//返回较小的链表的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        l2-&gt;next = mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cut操作"><a href="#cut操作" class="headerlink" title="cut操作"></a>cut操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = head;</span><br><span class="line">    <span class="keyword">while</span> (--n &amp;&amp; p) &#123;</span><br><span class="line">    p = p-&gt;next;    <span class="comment">//移动头结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">nullptr</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> next = p-&gt;next;    <span class="comment">//保存下一节点指针</span></span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;      <span class="comment">//断开链表</span></span><br><span class="line">    <span class="keyword">return</span> next;            <span class="comment">//返回下一段链表头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reverse操作"><a href="#reverse操作" class="headerlink" title="reverse操作"></a>reverse操作</h3><p>这是一道很经典的题目，将一个链表进行翻转，可以使用递归和迭代的方式进行操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* prev = <span class="literal">nullptr</span>;   <span class="comment">//前一个节点</span></span><br><span class="line">    ListNode* curr = head;      <span class="comment">//当前节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(curr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ListNode* nextTemp = curr-&gt;next;   <span class="comment">//后一个节点</span></span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表里一个比较麻烦的问题就是断链后后一个节点如果不保存，就再也找不到了，因此需要将前一个节点，当前节点和后一个节点都保存起来。<strong>链表翻转一定是从头开始的，因为一旦从尾部开始，前面节点的指针就找不到了。</strong></p>
<ul>
<li>递归法</li>
</ul>
<p>假设链表为：</p>
<script type="math/tex; mode=display">
n_1→...→n_{k−1}→n_k→n_{k+1}→...→n_m→\emptyset</script><p>若从节点 $n<em>{k+1} $到 $n</em>{m}$ 已经被反转，而我们正处于 $n_{k}$。</p>
<script type="math/tex; mode=display">
n_1→...→n_{k−1}→n_k→n_{k+1}←...←n_m</script><p>我们希望$n_{k+1}$指向$n_k$，所以<code>nk-&gt;next-&gt;next = nk</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;   <span class="comment">//关键操作</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要小心的是 $n_{1}$ 的下一个必须指向 Ø ，否则可能会产生循环。递归的方式还挺麻烦的，最好用栈模型对上面的代码进行一下分析。</p>
<h3 id="删除特定节点"><a href="#删除特定节点" class="headerlink" title="删除特定节点"></a>删除特定节点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="keyword">auto</span> p = dummy;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;val == val)&#123;   <span class="comment">//删除所有node-&gt;val == val的节点</span></span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LeetCode 86</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>与浅拷贝对应的是深拷贝，浅拷贝只复制指向某个对象的指针，并不复制对象本身，新旧对象共享一块内存。而深拷贝会另外开辟空间，创建新的对象，新旧对象不共享内存，修改新对象不会影响旧对象。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/51803415d5440d4589ae6b2e1a157bc6df4aa2f3ac62195cedb5f5ee97055db1-1.png" width = "600"  alt="图片名称" align=center /></p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol>
<li>LeetCode面试35 复杂链表的复制</li>
</ol>
<blockquote>
<p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/e1.png" width = "500"  alt="图片名称" align=center /></p>
<p><strong>思路</strong></p>
<p>链表的复制可以采用DFS方法，关于DFS方法的讨论请参考</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( visited[head] != <span class="literal">nullptr</span>) <span class="keyword">return</span> visited[head];  <span class="comment">// 如果已经访问了，说明该节点已经复制，那么直接返回即可</span></span><br><span class="line"></span><br><span class="line">    Node* copy = <span class="keyword">new</span> Node(head-&gt;val);              </span><br><span class="line">    visited[head] = copy;              </span><br><span class="line">    copy -&gt; next = copyRandomList(head-&gt;next);</span><br><span class="line">    copy -&gt; random = copyRandomList(head-&gt;random);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsExistLoop</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span> ( fast &amp;&amp; fast-&gt;next )</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> ( slow == fast )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表难点总结"><a href="#链表难点总结" class="headerlink" title="链表难点总结"></a>链表难点总结</h2><h3 id="递归时的返回条件判断"><a href="#递归时的返回条件判断" class="headerlink" title="递归时的返回条件判断"></a>递归时的返回条件判断</h3><p>当链表需要进行和两个节点有关的操作时，判断条件为<code>if(head == nullptr || head-&gt;next == nullptr)</code>，否则只对链表本身进行判断。迭代也是同样的道理：<code>while(temp.next != null &amp;&amp; temp.next.next != null)</code></p>
<h2 id="LeetCode上关于链表的相关题目"><a href="#LeetCode上关于链表的相关题目" class="headerlink" title="LeetCode上关于链表的相关题目"></a>LeetCode上关于链表的相关题目</h2><ol>
<li>使用链表进行大数相加</li>
</ol>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置变量</span></span><br><span class="line">        ListNode result(0), *p = &amp;result;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || flag)&#123; </span><br><span class="line">            <span class="comment">//难点1：循环条件</span></span><br><span class="line">            <span class="comment">//当l1不为空或者l2不为空或者需要进位时，都需要创建新节点</span></span><br><span class="line">            <span class="comment">/*************************计算当前两位相加和*************************/</span></span><br><span class="line">            <span class="keyword">int</span> tmp_value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>) tmp_value += l1-&gt;val;  </span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">nullptr</span>) tmp_value += l2-&gt;val;</span><br><span class="line">            tmp_value += flag;   </span><br><span class="line">            </span><br><span class="line">            flag = tmp_value / <span class="number">10</span>;</span><br><span class="line">            tmp_value %= <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*************************创建新节点，用于保存新值*************************/</span></span><br><span class="line">            ListNode *next = <span class="keyword">new</span> ListNode(tmp_value);</span><br><span class="line">            next-&gt;val = tmp_value;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*************************更新节点*************************/</span></span><br><span class="line">            <span class="comment">//难点2： 对于节点更新的处理</span></span><br><span class="line">            p -&gt; next = next;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            l1 = (l1 != <span class="literal">nullptr</span> ? l1 -&gt; next : <span class="literal">nullptr</span>);</span><br><span class="line">            l2 = (l2 != <span class="literal">nullptr</span> ? l2 -&gt; next : <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="comment">//难点3： 返回值的处理</span></span><br><span class="line">        <span class="keyword">return</span> result.next; <span class="comment">//注意返回的结果链表是从result的next开始的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>问题本身不难，两遍法第一遍遍历找到列表长度，第二遍移除$L-n+1$个节点即可，<strong>注意，算法题解决过程中下标从1开始，不要从0，否则计算起来很麻烦</strong>。</p>
<p>而一个更紧凑的方法是如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *d = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        d-&gt;next = head;</span><br><span class="line">        ListNode* first;</span><br><span class="line">        ListNode* second;</span><br><span class="line">        first = second = d;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(first == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> d-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该代码创建了一个<strong>辅助哑节点</strong>，哑节点可以简化链表需要删除头节点的情况，注意最后返回的是d-&gt;next，不能返回head，因为head有可能已经被删掉了。</p>
<ol>
<li><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>一般像这种题都有一个暴力解法，本题暴力解法是将所有元素放到一个vector中，然后排序，然后生成新的链表，时间复杂度$O(NlogN)$，N是节点总数目。空间复杂度$O(n)$。</p>
<ol>
<li>链表的自底向上归并排序</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummyHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="keyword">auto</span> p = head;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算长度</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        ++length;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; length; size &lt;&lt;= <span class="number">1</span>) &#123;   <span class="comment">//左移相当于乘2</span></span><br><span class="line">        <span class="keyword">auto</span> cur = dummyHead.next;   </span><br><span class="line">        <span class="keyword">auto</span> tail = &amp;dummyHead;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = cur; </span><br><span class="line">            <span class="keyword">auto</span> right = cut(left, size); <span class="comment">// left-&gt;@-&gt;@ right-&gt;@-&gt;@-&gt;@...</span></span><br><span class="line">            cur = cut(right, size); <span class="comment">// left-&gt;@-&gt;@ right-&gt;@-&gt;@  cur-&gt;@-&gt;...</span></span><br><span class="line"></span><br><span class="line">            tail-&gt;next = merge(left, right); <span class="comment">//两两归并</span></span><br><span class="line">            <span class="keyword">while</span> (tail-&gt;next) &#123;   <span class="comment">//找到merge后的尾节点</span></span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表的递归操作类"><a href="#链表的递归操作类" class="headerlink" title="链表的递归操作类"></a>链表的递归操作类</h3><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.google.com/books?hl=zh-CN&amp;lr=&amp;id=v-b0CAAAQBAJ&amp;oi=fnd&amp;pg=PR5&amp;dq=data+structure+and+algorithm+in+c%2B%2B&amp;ots=C_TqwgXHOv&amp;sig=IZJed9W71UYAYM77rjCoMFDgab0">Drozdek A. Data Structures and algorithms in C++[M]. Cengage Learning, 2012.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://blog.csdn.net/x55x5/article/details/82493185">哑节点的使用</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/lian-biao-de-shen-kao-bei-by-z1m/">链表深拷贝</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>DMA + CLIB</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/DMA_CLIB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>In our trust engine, we use a DMA engine with a crypto lib to do authentication/encr/decr work, this article introduces the whole structure of this DMA + CLIB structure and summarize all transfer patterns.</p>
<a id="more"></a>
<h2 id="Structure-of-DMA-CLIB"><a href="#Structure-of-DMA-CLIB" class="headerlink" title="Structure of DMA + CLIB"></a>Structure of DMA + CLIB</h2><p>The structure of DMA + CLIB is shown below, DMA has two channels and connected to SoC NoC for inbound and outbound data, on the other side of DMA it is connected to an interface which contains INFIFO and OUTFIFO to store data temprorily; Finally the interface is connected to CLIB which consume plaindata and generate AES results.<br><img src="https://github.com/sqduan/blog/assets/51660739/5dc826e8-76a6-4ae6-ac50-ab87cf9a6894" alt="image"></p>
<h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>Cache</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/cache/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>CPU很快、内存很慢；内存很快、硬盘很慢；硬盘很快、网络很慢，这个世界总归是不完美的。</p>
</blockquote>
<a id="more"></a>
<p>Cache的作用是位于速度较快和较慢的两种硬件中，用于协调数据传输的速度差异。本文主要以CPU和内存间的cache为例进行讲解。</p>
<h1 id="cache简介"><a href="#cache简介" class="headerlink" title="cache简介"></a>cache简介</h1><h2 id="缓存的结构及机制"><a href="#缓存的结构及机制" class="headerlink" title="缓存的结构及机制"></a>缓存的结构及机制</h2><p>CPU的缓存是完全由硬件电路控制的，不能显式对其进行控制，cache的物理结构如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220531213133.png" width = "640" alt="图片名称" align=center /></p>
<p>其中，L1和L2cache为Core独有的，L3 Cache是一个cluster内共享的，L1 cache包括Data Cache(D Cache)和Instruction Cache(I Cache)，下面我们讨论一下缓存的机制，</p>
<h1 id="Cache经典问题"><a href="#Cache经典问题" class="headerlink" title="Cache经典问题"></a>Cache经典问题</h1><h2 id="缓存一致性（重要）"><a href="#缓存一致性（重要）" class="headerlink" title="缓存一致性（重要）"></a>缓存一致性（重要）</h2><h3 id="一致性介绍"><a href="#一致性介绍" class="headerlink" title="一致性介绍"></a>一致性介绍</h3><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/cachecoherence1.svg" width = "640" alt="图片名称" align=center /></p>
<p>假设我们现在有四个CPU，每个CPU斗有自己的独立缓存，通过BUS与内存相连，数据流是单路的，也就是所有的核通过一条bus读取内存，假设每个核都读取了变量<code>a</code>所在的内存，并进行了修改，那么每个核的私有缓存中保存的内容都是不一致的。所以我们引出了缓存一致性的问题，<strong>共享的数据资源在多个局部cache中被保存</strong>，所以我们需要维护一致性，当一个核更新了数据，如何保证其他的核上能够同步。所以缓存一致性是由于多个cache引起的</p>
<p>为了解决缓存一致性，我们先要了解cache的结构，cache内部实际上是一条条cache line或者cache block组成的，大小可能是64 Byte或者128 Byte</p>
<h3 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h3><p>为了解决一致性带来的问题，计算机使用了<strong>总线窥视器</strong>监视总线上的读写动作，并根据一些协议修改缓存状态，这里我们介绍经典的<code>snooping</code>协议，在该协议中，缓存行有四个状态，随着读写操作发生变化：</p>
<ul>
<li><strong>已修改Modified (M)</strong>：缓存行与主存的值不同。如果别的CPU内核要读主存这块数据，该缓存行必须回写到主存，状态变为共享(S).</li>
<li><strong>独占Exclusive (E)</strong>：缓存行只在当前缓存中，但是干净的（clean）—缓存数据同于主存数据。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态。</li>
<li><strong>共享Shared (S)</strong>：缓存行也存在于其它缓存中且是干净的。缓存行可以在任意时刻抛弃。</li>
<li><strong>无效Invalid (I)</strong>：缓存行是无效的，需要从其他缓存或者内存中读取</li>
</ul>
<p>MESI协议的状态转换图如下</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220531223700.png" width = "480" alt="图片名称" align=center /></p>
<p>举例：一个CPU A对变量<code>a</code>进行写操作，还未写回memory中，此时状态为Modified，如果CPU B从内存中读取<code>a</code>，得到的是脏数据，而CPU A能够监听到这个读操作，将<code>a</code>的值写入内存，而CPU B由于未得到响应，会重新发起读请求，从memory中读到最新值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">初始状态</th>
<th style="text-align:center">操作</th>
<th style="text-align:left">响应</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Invalid(I)</td>
<td style="text-align:center">PrRd</td>
<td style="text-align:left">给总线发BusRd信号<br />其他处理器看到BusRd，检查自己是否有有效的数据副本，通知发出请求的缓存<br /> 如果其他缓存有有效的副本，状态转换为(S)<strong>Shared</strong>，否则状态转换为(E)<strong>Exclusive</strong><br />如果其他缓存有有效的副本, 其中一个缓存发出数据；否则从主存获得数据</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">PrWr</td>
<td style="text-align:left">给总线发BusRdX信号<br />状态转换为(M)<strong>Modified</strong><br />如果其他缓存有有效的副本, 见到BusRdX信号后无效其副本<br />向缓存块中写入修改后的值</td>
</tr>
<tr>
<td style="text-align:center">Exclusive(E)</td>
<td style="text-align:center">PrRd</td>
<td style="text-align:left">无总线事务生成<br />状态保持不变<br />读操作为缓存命中</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">PrWr</td>
<td style="text-align:left">无总线事务生成<br />状态转换为(M)<strong>Modified</strong><br />向缓存块中写入修改后的值PrWr</td>
</tr>
<tr>
<td style="text-align:center">Shared(S)</td>
<td style="text-align:center">PrRd</td>
<td style="text-align:left">无总线事务生成<br />状态保持不变<br />读操作为缓存命中</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">PrWr</td>
<td style="text-align:left">发出总线事务BusUpgr<br />信号状态转换为(M)<strong>Modified</strong><br />其他缓存看到BusUpgr总线信号，标记其副本为(I)Invalid.</td>
</tr>
<tr>
<td style="text-align:center">Modified(M)</td>
<td style="text-align:center">PrRd</td>
<td style="text-align:left">无总线事务生成<br />状态保持不变<br />读操作为缓存命中</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">PrWr</td>
<td style="text-align:left">无总线事务生成<br />状态保持不变<br />写操作为缓存命中</td>
</tr>
</tbody>
</table>
</div>
<h2 id="缓存命中问题"><a href="#缓存命中问题" class="headerlink" title="缓存命中问题"></a>缓存命中问题</h2><p>当CPU申请访问数据，我们要考虑该数据是否已经缓存至cache中，这就是缓存的命中问题。缓存不命中会导致CPU直接访问内存数据，降低运行效率。</p>
<pre class="mermaid">graph LR
    node1[Memory]
    node2[Cache]
    node3[CPU]

    node3--hit-->node2
    node3--miss-->node1</pre>

<h3 id="缓存不命中发生条件"><a href="#缓存不命中发生条件" class="headerlink" title="缓存不命中发生条件"></a>缓存不命中发生条件</h3><p>当发生以下情况时，缓存不命中</p>
<ul>
<li>数据不在cache中</li>
<li>数据在cache中，但是被移除</li>
</ul>
<h3 id="如何提高缓存命中率"><a href="#如何提高缓存命中率" class="headerlink" title="如何提高缓存命中率"></a>如何提高缓存命中率</h3><p>通过采用一些缓存管理策略，常见缓存管理策略如下：</p>
<ul>
<li>FIFO：先进先出</li>
<li>LIFO：后进先出</li>
<li>LRU：最近最少使用</li>
<li>MRU：最近最多使用</li>
</ul>
<h2 id="关于Cache的一些术语"><a href="#关于Cache的一些术语" class="headerlink" title="关于Cache的一些术语"></a>关于Cache的一些术语</h2><h3 id="冷热缓存"><a href="#冷热缓存" class="headerlink" title="冷热缓存"></a>冷热缓存</h3><p>冷缓存代表当前Cache没有保存任何有价值的值，不能提供性能加速；而热缓存代表已经存有一些有用的值，可以提高性能。相应地，我们向缓存中添加数据，就是预热的过程；而从缓存中清理数据，就是冷却的过程。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>Modelsim 编译及仿真</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Modelsim%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将对使用modelsim进行verilog电路仿真及测试的过程进行概述</p>
<a id="more"></a>
<h2 id="工程建立及模块编写"><a href="#工程建立及模块编写" class="headerlink" title="工程建立及模块编写"></a>工程建立及模块编写</h2><p>此处较为简单，请参考网上关于Modelsim的使用说明，我们以一个简单的异步复位同步释放寄存器为例，其代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Register (q, clk, rst, d);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IO</span></span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> rst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> N = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">input</span>  [N - <span class="number">1</span> : <span class="number">0</span>] d;</span><br><span class="line">    <span class="keyword">output</span> [N - <span class="number">1</span> : <span class="number">0</span>] q;</span><br><span class="line">    <span class="keyword">reg</span>    [N - <span class="number">1</span> : <span class="number">0</span>] q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Asynchronous reset logic</span></span><br><span class="line">    <span class="keyword">reg</span> rst1, rst2;</span><br><span class="line">    <span class="keyword">always</span> @ ( <span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst) <span class="keyword">begin</span></span><br><span class="line">            rst1 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">            rst2 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            rst1 &lt;= <span class="number">1'b1</span>;</span><br><span class="line">            rst2 &lt;= rst1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> rstSync = rst2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actual logic of the register</span></span><br><span class="line">    <span class="keyword">always</span> @ ( <span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstSync ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ( rstSync == <span class="number">1'b0</span> )</span><br><span class="line">            q &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q &lt;= d;    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="TestBench"><a href="#TestBench" class="headerlink" title="TestBench"></a>TestBench</h2><p>完成模块编写后，我们需要针对该模块编写对应的测试用例，在测试用例中，我们要创建对应的模块，给定输入信号作为激励，观察输出是否与预期一致，测试模型如下，其中DUT即为我们的待测单元：</p>
<p><img src="https://www.chipverify.com/images/uvm/simple-testbench.png"  alt="图片名称" align=center /></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/10ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Register_tb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Input stimulus, we set the input as a register since we want the input to be stable</span></span><br><span class="line">    <span class="comment">// and output as a wire to directly connected to the output of DUT</span></span><br><span class="line">    <span class="keyword">reg</span> clkIn;</span><br><span class="line">    <span class="keyword">reg</span> rstIn;</span><br><span class="line">    <span class="keyword">parameter</span> REG_WIDTH = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">reg</span> [REG_WIDTH - <span class="number">1</span> : <span class="number">0</span>]dIn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [REG_WIDTH - <span class="number">1</span> : <span class="number">0</span>]qOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create test unit</span></span><br><span class="line">    Register DUT (<span class="variable">.q</span>(qOut), </span><br><span class="line">                  <span class="variable">.clk</span>(clkIn),</span><br><span class="line">                  <span class="variable">.rst</span>(rstIn),</span><br><span class="line">                  <span class="variable">.d</span>(dIn));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Give a sequence of input signals</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        clkIn &lt;= <span class="number">0</span>;</span><br><span class="line">        rstIn &lt;= <span class="number">1</span>;</span><br><span class="line">        dIn   &lt;= <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span></span><br><span class="line">        rstIn &lt;= <span class="number">0</span>;</span><br><span class="line">        dIn   &lt;= <span class="number">1</span>;</span><br><span class="line">        #<span class="number">20</span></span><br><span class="line">        rstIn &lt;= <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        dIn   &lt;= <span class="number">8'h10</span>;</span><br><span class="line">        #<span class="number">60</span></span><br><span class="line">        rstIn &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drive clock</span></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> clkIn = ~clkIn;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>在完成testbench的编写后，我们可以对其进行仿真，点击<strong>Compile All</strong>编译所有的组件，然后点击<strong>Simulate - Start Simulation</strong>，在work中选择待仿真的对象，此处不要勾选Enable Optimization，否则会出现无法导入信号的情况</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20221102210818.png"  alt="图片名称" align=center /></p>
<p>在objects中选择待观测的信号，右键选择Add Wave，即可将信号导入波形图中：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20221102211101.png"  alt="图片名称" align=center /></p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20221102211345.png"  alt="图片名称" align=center /></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>内存</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>C1103A-2 H9971S500</p>
</blockquote>
<a id="more"></a>
<p>内存分为只读存储器（ROM）、随机读写存储器（RAM）以及高速缓冲存储器（Cache），本文将针对内存的相关原理进行总结</p>
<h2 id="内存的种类"><a href="#内存的种类" class="headerlink" title="内存的种类"></a>内存的种类</h2><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><h4 id="ROM工作原理及特性"><a href="#ROM工作原理及特性" class="headerlink" title="ROM工作原理及特性"></a>ROM工作原理及特性</h4><p>ROM是非易失的存储器，掉电后不丢失，但是一旦存储资料便无法改变或删除。经常存放一些比较关键的内容，例如BIOS</p>
<h3 id="ROMPATCH"><a href="#ROMPATCH" class="headerlink" title="ROMPATCH"></a>ROMPATCH</h3><p>在TrustEngine module中，我们使用了ROMPATCH，能够对ROM进行打补丁的操作，从而实现对特定ROM空间的修改与更新。ROMPATCH是由若干个entry组成的，每个entry 32bits，能够与一个ROM cell一一对应。配置时需要对每个ROMPATCH的entry进行操作，设置其地址和数据，并进行使能：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> entry = <span class="number">0</span>; entry &lt; PCAM_ENTRIES; entry++)</span><br><span class="line">&#123;</span><br><span class="line">    pcam.address = rom_address;</span><br><span class="line">    pcam.data    = data[entry];</span><br><span class="line">    pcam.No      = entry;</span><br><span class="line">    pcam.enable  = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    VVDRV_riscv_configure_pcam(pcam);</span><br><span class="line">    rom_address += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在将patchcam的entry和ROM cell进行映射后，如果访问ROM，我们得到的就是保存在PATCHCAM中的值。PATCHCAM还支持Lock功能，lock的entry不支持修改。</p>
<h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><h4 id="DRAM工作原理及特性"><a href="#DRAM工作原理及特性" class="headerlink" title="DRAM工作原理及特性"></a>DRAM工作原理及特性</h4><h5 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h5><p>DRAM实际就是一个电容和二极管组成的二维矩阵，下图展示了DRAM的电气结构，一个4*4的矩阵。矩阵的每一个节点代表一个二进制bit。具体表示如下</p>
<ul>
<li>当电容充电，代表1</li>
<li>当电容未充电，代表0</li>
</ul>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/Square_array_of_mosfet_cells_read.png/375px-Square_array_of_mosfet_cells_read.png" width = "280" alt="图片名称" align=center /></p>
<p>由于晶体管有漏电电流，因此DRAM需要动态刷新，且掉电后数据挥发，所以被成为动态存储。</p>
<h5 id="读写操作2"><a href="#读写操作2" class="headerlink" title="读写操作2"></a>读写操作<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h5><p>由于DRAM电路是矩阵形式，所以操作也是二维操作，先定位行，再定位列，接下来我们针对内存中的读写操作进行总结。</p>
<h6 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h6><h5 id="DRAM相关特性"><a href="#DRAM相关特性" class="headerlink" title="DRAM相关特性"></a>DRAM相关特性</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>与SRAM相比，DRAM结构简单，一个bit需要一个二极管一个电容进行表示，所以存储密度高，成本较低。</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>访问速度慢，耗电量大</p>
<h2 id="内存结构3"><a href="#内存结构3" class="headerlink" title="内存结构3"></a>内存结构<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h2><p>这里我们以2GB的DDR3内存为例，对内存结构进行讲解，内存结构图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20210323095938.png" width = "480" alt="图片名称" align=center /></p>
<ul>
<li><code>Rank</code>：内存的一排，上面的内存由两个rank组成，每个rank有8个clip</li>
<li><code>Clip</code>：颗粒，一个rank包含8个颗粒，每个128MB，共提供1GB内存</li>
<li><code>Bank</code>：存储数据的矩阵单元，一个颗粒8个bank，根据行列定位随机存储的数据块</li>
<li><code>Cell</code>：单元，用于存储一个数据单位，DDR3为8bit，如果CPU是32位，那么可以一次读写4个cell</li>
</ul>
<h2 id="内存特点"><a href="#内存特点" class="headerlink" title="内存特点"></a>内存特点</h2><ul>
<li>速度较快（1.3GHz左右）</li>
<li>价格较高</li>
</ul>
<h2 id="内存单元"><a href="#内存单元" class="headerlink" title="内存单元"></a>内存单元</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果我们把内存看作是一个大的存储箱，那么内存单元就是这个存储箱中一个个小隔间，内存单元是我们唯一的一种使用内存的方式。内存单元是可以寻址的，我们在计算机中的地址实际就是指向一个内存单元。一般来说，内存单元是字节寻址的，即内存的划分粒度为字节，一个内存单元的大小是一个字节，我们可以访问内存中单个的字节。这个是由计算机的硬件决定的，你可以将内存想象为一个$n\times 8$的矩阵电路，$n$代表的是地址数，根据CPU总线数决定；而$8$代表一次能够读取8个位，即一个字节。字节寻址的机器又叫做“字节机”。对于字节寻址的内存，我们需要注意如下两点：</p>
<ul>
<li>一个地址总是指向一个字节的空间</li>
<li>一个字是一个字节组，根据CPU数据总线的大小，可以是2、4或8个字节</li>
</ul>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>假设我们现在有一个指针nextfree，显示下一个空闲的内存单元的地址，其值为0xff105000，而我们需要存储4096字节的数据。那么存储完后，nextfree的值是多少？</p>
<p>答：由于一个内存单元大小为一个字节，而一个地址指向一个内存单元大小的空间，那么我们的计算非常简单，公式如下：</p>
<script type="math/tex; mode=display">
\textrm{nextfree} = \textrm{nextfree}+\textrm{size}</script><p>所以$\textrm{nextfree}=\textrm{0xff105000}<em>{H}+4096</em>{D}=\textrm{0xff106000}$</p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO是FPGA设计中常用的IP核，即一个先进先出的内存结构，可以分为同步（读写同时钟）与异步（读写时钟分开）两种。最重要的功能就是进行缓存。异步FIFO还有跨时钟域的作用。FIFO中关键信号如下：</p>
<ul>
<li>写时钟/数据/使能</li>
<li>读时钟/数据/使能</li>
<li>复位信号</li>
<li>空/满信号（抑制读写）</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="%5Bhttps://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8%5D(https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8)">维基百科对于DRAM的解释</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.youtube.com/watch?v=x3jGqOrXXc8">DRAM读写循环</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.derror.com/p/memory-physical-structure/">内存结构</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理单元</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201210220955.png" width = "280" alt="图片名称" align=center /></p>
<a id="more"></a>
<p>内存管理单元（Memory Management Unit, MMU）负责虚拟内存到物理内存的映射，一般会集成在CPU当中，本文单独对MMU进行介绍。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="MMU的本质"><a href="#MMU的本质" class="headerlink" title="MMU的本质"></a>MMU的本质</h3><p>MMU的本质是一张表，由内核告诉MMU如何进行虚拟地址到物理地址的转换，转换过程实际就是查表的过程。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>:</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>原码、反码与补码</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8E%9F%E3%80%81%E5%8F%8D%E3%80%81%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>困难的事情不是我们如何理解机器，而是机器如何理解我们</p>
</blockquote>
<a id="more"></a>
<p>计算机依赖二进制进行运算，而为了配合二进制计算设计硬件电路，人们提出了原码、反码以及补码的概念。本文将针对这些概念及相互之间的转换进行总结。</p>
<h2 id="原、反、补码的概念"><a href="#原、反、补码的概念" class="headerlink" title="原、反、补码的概念"></a>原、反、补码的概念</h2><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码由两部分组成</p>
<ul>
<li>符号位</li>
<li>真值的绝对值</li>
</ul>
<p>原码的第一位为符号位，其余位为值位，例如：</p>
<script type="math/tex; mode=display">
\begin{aligned}
+1_{[原]}=0000 ,0001\\
-1_{[原]}=1000 ,0001
\end{aligned}</script><p>其中符号位0为正，1为负。原码的表示范围为：<code>[1111 1111, 0111 1111]</code>，即-127到127。从形式上看，原码符合人类对于数字的认知，所以是人比较能理解的计数方式。</p>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码的表示方法为：</p>
<ul>
<li>正数即本身</li>
<li>负数符号不变、其余取反</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
+1 = [0000 ,0001]_{原}= [0000,0001]_{反}\\
-1 = [1000 ,0001]_{原}= [1111,1110]_{反}
\end{aligned}</script><p>一会儿再讨论为什么要这样设计，先记住其定义。</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码的表示方法为：</p>
<ul>
<li>正数即本身</li>
<li>负数在反码基础上+1</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
+1 = [0000 ,0001]_{原}= [0000,0001]_{反}= [0000,0001]_{补}\\
-1 = [1000 ,0001]_{原}= [1111,1110]_{反}= [1111,1111]_{补}
\end{aligned}</script><h2 id="为何使用原码、反码与补码"><a href="#为何使用原码、反码与补码" class="headerlink" title="为何使用原码、反码与补码"></a>为何使用原码、反码与补码</h2><p>根本原因是为了简化电路设计，我们知道加法是很简单的，但是如果要在计算机中引入减法，就会导致电路设计的复杂，所以有没有一种方案能够将减法转换为加法呢？简单来说，减法可以表示为一个数加上另一个数的负数，而通过引入反码与补码的方式，我们可以让符号位也参与到运算中，从而只需要加法即可。我们以1-1=0为例，探讨反码与补码的运算过程。</p>
<p>如果我们使用原码计算1-1即1+(-1)，那么得到的结果是：</p>
<script type="math/tex; mode=display">
1 - 1 = 1 + (-1) = [00000001]_原 + [10000001]_原 = [10000010]_原 = -2</script><p>显然结果不正确。如果我们使用反码计算，那么结果为：</p>
<script type="math/tex; mode=display">
1 - 1 = 1 + (-1) = [0000 0001]_原 + [1000 0001]_原= [0000 0001]_反 + [1111 1110]_反 = [1111 1111]_反 = [1000 0000]_原 = -0</script><p>我们发现结果的值部分虽然是正确的，但是问题就处在0上，0带符号是没有任何意义的，如果用反码，会出现两个0，即+0和-0，这显然不是我们想要的结果。于是人们提出了补码，解决了0的问题：</p>
<script type="math/tex; mode=display">
1-1 = 1 + (-1) = [0000 0001]_原 + [1000 0001]_原 = [0000 0001]_补 + [1111 1111]_补 = [0000 0000]补=[0000 0000]原</script><p>修复之后，0有了唯一的表示，同时，多出来的1000,0000还可以用来表示-128，但是由于实际上的-0表示了-128，所以-128并没有对应的原码和反码表示。</p>
<p>总之一句话：<strong>反码和补码是出于对计算机电路简化设计而引申出的定义</strong>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>IO设备</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%A4%96%E8%AE%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>若吾起舞时，丽人皆沉醉。</p>
<p>若吾起舞时，皓月亦鸣音。</p>
<p>神降合婚夜，破晓鸫鸟啼。</p>
</blockquote>
<a id="more"></a>
<p>外设分为字符设备和块设备，通过IO接口与CPU相连，本文将对外设相关的知识进行总结。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是外设"><a href="#什么是外设" class="headerlink" title="什么是外设"></a>什么是外设</h3><h3 id="外设特点"><a href="#外设特点" class="headerlink" title="外设特点"></a>外设特点</h3><ul>
<li>种类多</li>
<li>工作速度比CPU慢，且速度分布宽</li>
<li>信号类型与信息格式多样化</li>
</ul>
<h2 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h2><h3 id="定义及组成"><a href="#定义及组成" class="headerlink" title="定义及组成"></a>定义及组成</h3><p>IO接口是一个电子电路，内部有若干寄存器和相应控制逻辑电路。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>作为CPU和IO设备交换信息的媒介，IO接口基本功能如下：</p>
<ul>
<li>速度匹配</li>
<li>信号形式匹配（AD/DA/串并/并串）</li>
<li>电平转换及驱动能力增加</li>
<li>信息格式及时序匹配</li>
</ul>
<h3 id="IO端口"><a href="#IO端口" class="headerlink" title="IO端口"></a>IO端口</h3><p>IO端口是IO接口中的一组能和处理器交换信息的寄存器，CPU对外设的访问实际是通过对IO端口的访问实现的。IO端口一般包含如下几个部分：</p>
<ul>
<li>数据端口：存放数据</li>
<li>控制端口：存放控制指令</li>
<li>状态端口：存放状态信息</li>
</ul>
<h4 id="IO端口编址方式"><a href="#IO端口编址方式" class="headerlink" title="IO端口编址方式"></a>IO端口编址方式</h4><h5 id="传统电脑：采用专用的IO地址"><a href="#传统电脑：采用专用的IO地址" class="headerlink" title="传统电脑：采用专用的IO地址"></a>传统电脑：采用专用的IO地址</h5><ul>
<li>和访问内存的方式类似</li>
<li>有1024个IO地址</li>
<li>通过IN、OUT命令访问</li>
</ul>
<p>下面的代码展示了一个向打印设备写入一个byte的过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_PORT    0x378</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_PORT  0x379</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   BUSY 0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTROL_PORT 0x37A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   STROBE 0x01</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">lpt_putc(<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* wait for printer to consume previous byte */</span></span><br><span class="line">  <span class="keyword">while</span>((inb(STATUS_PORT) &amp; BUSY) == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* put the byte on the parallel lines */</span></span><br><span class="line">  outb(DATA_PORT, c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* tell the printer to look at the data */</span></span><br><span class="line">  outb(CONTROL_PORT, STROBE);</span><br><span class="line">  outb(CONTROL_PORT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="内存映射IO（现代计算机常用）"><a href="#内存映射IO（现代计算机常用）" class="headerlink" title="内存映射IO（现代计算机常用）"></a>内存映射IO（现代计算机常用）</h5><p>这种情况下外设接口与内存进行了统一编址，其优缺点如下：</p>
<ul>
<li>优点<ul>
<li>不需要额外指令</li>
<li>访问控制信号统一</li>
<li>IO地址空间扩展</li>
</ul>
</li>
<li>缺点<ul>
<li>访问类似内存，但是工作行为不是</li>
<li>会占用内存的一部分地址</li>
</ul>
</li>
</ul>
<h2 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>寄存器</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>If I can only remember one thing, I will remember your name</p>
</blockquote>
<a id="more"></a>
<p>寄存器就是CPU中的一些时序逻辑电路，属于暂时存放参与运算的数据和结果。速度非常快，容量非常小。</p>
<h2 id="常用寄存器（ARM）"><a href="#常用寄存器（ARM）" class="headerlink" title="常用寄存器（ARM）"></a>常用寄存器（ARM）</h2><h3 id="通用寄存器组"><a href="#通用寄存器组" class="headerlink" title="通用寄存器组"></a>通用寄存器组</h3><h3 id="异常综合表征寄存器ESR-ELn"><a href="#异常综合表征寄存器ESR-ELn" class="headerlink" title="异常综合表征寄存器ESR_ELn"></a>异常综合表征寄存器ESR_ELn</h3><p><code>ESR</code>寄存器用于异常处理程序确定异常原因。</p>
<h2 id="常用寄存器（x86，了解即可）"><a href="#常用寄存器（x86，了解即可）" class="headerlink" title="常用寄存器（x86，了解即可）"></a>常用寄存器（x86，了解即可）</h2><h3 id="通用寄存器组-1"><a href="#通用寄存器组-1" class="headerlink" title="通用寄存器组"></a>通用寄存器组</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>位于EU中，可以存放16位数据或地址，也可以分为8个8位寄存器使用（只能放数据）</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201126143236.png" width = "280" alt="图片名称" align=center /></p>
<ul>
<li>AX：累加器</li>
<li>BX：基址寄存器</li>
<li>CX：计数寄存器</li>
<li>DX：数据寄存器</li>
</ul>
<p>通用寄存器会有一些特殊用途。</p>
<h3 id="指针和变址寄存器"><a href="#指针和变址寄存器" class="headerlink" title="指针和变址寄存器"></a>指针和变址寄存器</h3><p>下面这些寄存器都是指向内存的</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201126143618.png" width = "200" alt="图片名称" align=center /></p>
<ul>
<li>BP：基址寄存器，与SP共同组成操作数地址（栈底地址）</li>
</ul>
<p>其内部存放指向系统栈栈底的指针，调用子程序时第一句都是push EBP，就是为了保存栈基址，因为ESP总是会变化的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=&gt; 0x7cda:	push   %ebp          # 保存栈基址</span><br><span class="line">=&gt; 0x7cdb:	mov    %esp,%ebp     # 将当前栈顶指针作为栈基址，相当于创建了一个新栈</span><br><span class="line">=&gt; 0x7ce0:	sub    $0xc,%esp     # 在栈中预分配空间</span><br></pre></td></tr></table></figure>
<ul>
<li>SP：堆栈指针寄存器，其内部存放指向系统栈栈顶的指针，PUSH时减小（栈向下生长），在x86中，esp总是4的倍数</li>
<li>SI：源操作数偏移量</li>
<li>DI：目的操作数偏移量，在很多字符串操作指令中，DS:ESI指向源串，ES:EDI指向目标串</li>
</ul>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>段寄存器给出了当前段的基地址，配合IP指令寄存器，可以实现基址+偏移地址的寻址过程。在8086中，CPU可以寻址20位，但寄存器只有16位，因此需要分段。段寄存器给出相应逻辑段首地址。</p>
<h4 id="代码段寄存器CS"><a href="#代码段寄存器CS" class="headerlink" title="代码段寄存器CS"></a>代码段寄存器CS</h4><h4 id="数据段寄存器DS"><a href="#数据段寄存器DS" class="headerlink" title="数据段寄存器DS"></a>数据段寄存器DS</h4><h4 id="堆栈段寄存器SS"><a href="#堆栈段寄存器SS" class="headerlink" title="堆栈段寄存器SS"></a>堆栈段寄存器SS</h4><p>堆栈段寄存器和堆栈段指针寄存器SP共同构成了堆栈段的地址[SS:SP]</p>
<h4 id="附加段寄存器ES"><a href="#附加段寄存器ES" class="headerlink" title="附加段寄存器ES"></a>附加段寄存器ES</h4><h4 id="段寄存器寻址过程（实模式下）"><a href="#段寄存器寻址过程（实模式下）" class="headerlink" title="段寄存器寻址过程（实模式下）"></a>段寄存器寻址过程（实模式下）</h4><p>假设我们有一条地址，其表示为[CS:IP]，而计算机的位数为16位，那么这条指令的实际物理地址计算为：</p>
<script type="math/tex; mode=display">
addr = 16\times \textrm{segment}+\textrm{offset}=16\times\textrm{CS}+\textrm{IP}</script><p>例如有一个指令执行的地址为[f000:fff0]，那么其实际物理地址为：</p>
<script type="math/tex; mode=display">
\textrm{0xf000}\times10+\textrm{0xfff0}=\textrm{0xffff0}</script><h3 id="指令指针寄存器EIP"><a href="#指令指针寄存器EIP" class="headerlink" title="指令指针寄存器EIP"></a>指令指针寄存器EIP</h3><p>8086设置了一个16位指令指针寄存器IP，用于存放下一条指令的偏移地址，从而控制指令序列执行流程。由BIU自动修改，在每条指令执行后递增。可以通过CALL、RET、JMP以及conditional jump等命令进行修改。IP也是指向内存的。</p>
<h3 id="标志寄存器flags"><a href="#标志寄存器flags" class="headerlink" title="标志寄存器flags"></a>标志寄存器flags</h3><p>一共有6个状态标志和3个控制标志，用于控制conditional jump（JP，JN，J[N]Z，J[N]C，J[N]O等）</p>
<h4 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h4><ol>
<li>CF：有进位或借位为1</li>
<li>PF：奇偶校验，低8位有偶数个1时PF为1</li>
<li>AF：辅助进位标志，低4位向高四位进位或借位时，AF=1</li>
<li>ZF：运算结果为0时ZF=1</li>
<li>SF：符号标志位，最高位为1时SF=1</li>
<li>OF：溢出标志位，产生溢出为1</li>
</ol>
<h4 id="控制标志"><a href="#控制标志" class="headerlink" title="控制标志"></a>控制标志</h4><ol>
<li>TF：单步标志，可设置单步执行，每执行一次指令，触发一个中断</li>
<li>IF：中断标志位，IF=1允许CPU响应可执行中断</li>
<li>DF：方向标志位，在串操作指令中，DF=0由低地址向高地址进行操作。</li>
</ol>
<h3 id="内存管理寄存器"><a href="#内存管理寄存器" class="headerlink" title="内存管理寄存器"></a>内存管理寄存器</h3><p>x86提供了四个内存管理计算器，分别为GDTR、LDTR、IDTR和TR，用于指定内存分段管理所用系统表的基地址</p>
<h4 id="全局描述表寄存器GDTR"><a href="#全局描述表寄存器GDTR" class="headerlink" title="全局描述表寄存器GDTR"></a>全局描述表寄存器GDTR</h4><p>GDTR寄存器用于存放全局描述表GDT的32位线性基地址和16位表限长值，基地址指明表中字节0在线性地址空间中的地址，而表长度指明GDT表的字节长度值。由于机器刚上电或复位后基地址默认为0，而长度被设置为0xFFFF，所以在保护模式初始化过程中必须给GDTR一个新值。</p>
<h3 id="控制类寄存器"><a href="#控制类寄存器" class="headerlink" title="控制类寄存器"></a>控制类寄存器</h3><p>共有5个控制类寄存器CR0-CR4，可以控制CPU的特性</p>
<h4 id="CR01"><a href="#CR01" class="headerlink" title="CR01"></a>CR0<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h4><h5 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h5><p>CR0寄存器的主要功能是实现对于CPU的控制，其中比较重要的是实现实模式到保护模式的切换</p>
<h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>CR0长度为32-bit，具体位描述如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Bit</th>
<th style="text-align:center">Name</th>
<th style="text-align:center">Full Name</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">PE</td>
<td style="text-align:center">Protected Mode Enable（保护模式和实模式切换）</td>
<td style="text-align:center">If 1, system is in <a href="https://en.wikipedia.org/wiki/Protected_mode">protected mode</a>, else system is in <a href="https://en.wikipedia.org/wiki/Real_mode">real mode</a></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">MP</td>
<td style="text-align:center">Monitor co-processor</td>
<td style="text-align:center">Controls interaction of WAIT/FWAIT instructions with TS flag in CR0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">EM</td>
<td style="text-align:center">Emulation</td>
<td style="text-align:center">If set, no x87 <a href="https://en.wikipedia.org/wiki/Floating-point_unit">floating-point unit</a> present, if clear, x87 FPU present</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">TS</td>
<td style="text-align:center">Task switched</td>
<td style="text-align:center">Allows saving x87 task context upon a task switch only after x87 instruction used</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">ET</td>
<td style="text-align:center">Extension type</td>
<td style="text-align:center">On the 386, it allowed to specify whether the external math coprocessor was an <a href="https://en.wikipedia.org/wiki/80287">80287</a> or <a href="https://en.wikipedia.org/wiki/80387">80387</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">NE</td>
<td style="text-align:center">Numeric error</td>
<td style="text-align:center">Enable internal <a href="https://en.wikipedia.org/wiki/X87">x87</a> floating point error reporting when set, else enables PC style x87 error detection</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">WP</td>
<td style="text-align:center">Write protect</td>
<td style="text-align:center">When set, the CPU can’t write to read-only pages when privilege level is 0</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">AM</td>
<td style="text-align:center">Alignment mask</td>
<td style="text-align:center">Alignment check enabled if AM set, AC flag (in <a href="https://en.wikipedia.org/wiki/FLAGS_register">EFLAGS</a> register) set, and privilege level is 3</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center">NW</td>
<td style="text-align:center">Not-write through</td>
<td style="text-align:center">Globally enables/disable <a href="https://en.wikipedia.org/wiki/Write_through_cache">write-through caching</a></td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center">CD</td>
<td style="text-align:center"><a href="https://en.wikipedia.org/wiki/CPU_cache">Cache</a> disable</td>
<td style="text-align:center">Globally enables/disable the memory cache</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">PG</td>
<td style="text-align:center">Paging</td>
<td style="text-align:center">If 1, enable <a href="https://en.wikipedia.org/wiki/Paging">paging</a> and use the <a href="https://en.wikipedia.org/wiki/Control_register#CR3">§ CR3</a> register, else disable paging.</td>
</tr>
</tbody>
</table>
</div>
<h4 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h4><p>CR3寄存器是比较重要的一个寄存器，用于线性地址到物理地址的转换过程中，CR3保存了页目录的基地址（物理地址），当进程发生切换时，必须更换至相应进程的页目录。同理，内核作为一个进程，也有自己的页目录。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://en.wikipedia.org/wiki/Control_register">CR0寄存器描述</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>gcc基本使用方法</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/gcc%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p><code>gcc main.c</code></p>
</blockquote>
<a id="more"></a>
<p>本文将针对gcc的一些基本使用方法进行总结。</p>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><ul>
<li><code>-o</code>: 编译并指定输出文件名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc main.c -o helloworld</span><br></pre></td></tr></table></figure>
<h3 id="调试参数"><a href="#调试参数" class="headerlink" title="调试参数"></a>调试参数</h3><ul>
<li><code>-g</code>：编译时产生调试信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc main.c -g</span><br></pre></td></tr></table></figure>
<p>这个选项将会向<code>.s</code>中添加额外的调试信息<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，并带到最终的可执行文件中。这些调试信息描述了源文件的一些特性，包括：文件名、行号、类型、变量、函数及其参数和返回类型等</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://gcc.gnu.org/">gcc官网</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="http://www.math.utah.edu/docs/info/stabs_1.html#SEC2">符号表</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>硬盘</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>罗辑把拐杖高举过头，白发长须舞动着，看上去像分开红海的摩西，庄严地喊道：“把字刻在石头上!”</p>
</blockquote>
<a id="more"></a>
<h2 id="划分单元"><a href="#划分单元" class="headerlink" title="划分单元"></a>划分单元</h2><p>在存储设备中，为了方便IO操作，我们一般会将其分为若干个单元，从小到大分别为Sector、Block、Page和Chunk，下面的表格列举了不同单元的一些属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Sector</td>
<td style="text-align:center">512Byte</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Block</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Page</td>
<td style="text-align:center">2048 or 4096 Byte，4 or 8 Sector</td>
<td style="text-align:center">一般来说，页是为了方便RAM读取设置的，所以大小要和内存单元匹配</td>
</tr>
<tr>
<td style="text-align:center">Chunk</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p> 硬盘在使用前会进行分区操作，从而使其具有不同的功能，本节将分别讨论windows和linux下的分区。</p>
<h3 id="windows分区"><a href="#windows分区" class="headerlink" title="windows分区"></a>windows分区</h3><h4 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h4><p>使用创建并格式化磁盘分区软件，可以看到windows分区情况如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201208195238.png" width = "680" alt="图片名称" align=center /></p>
<p>可以看到，除了用户自定义的分区以及用于保存系统的C盘外，还有若干个分区，其功能分别如下：</p>
<ul>
<li>260MB：EFI系统分区，存储已安装系统的EFI引导加载程序，类型是FAT32</li>
<li>恢复分区：用于恢复系统的分区</li>
<li>OEM分区：装有厂商的还原程序</li>
</ul>
<p>对于NTFS格式的分区，我们可以进行压缩，从而得到一些未经分配的空间</p>
<h3 id="linux分区"><a href="#linux分区" class="headerlink" title="linux分区"></a>linux分区</h3><p>linux的设计原则为一切皆文件，我们将硬盘设备挂载到某个文件夹下，通过访问文件夹的方式就可以对硬盘进行操作，所以所谓的分区实际是一种挂载操作，将某个文件夹映射至磁盘。一般来说，将<code>/</code>映射至一个大的磁盘，而将<code>boot/efi</code>映射至<code>efi</code>启动盘，完成分区的操作。文件<code>/etc/fstab</code>记录了linux下的分区情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h2><p>这里对计算机常用的存储单位及换算方式进行总结，存储单位从小到大分别为：</p>
<ol>
<li>位（bit）</li>
<li>字节（Byte）：1Byte = 8bits</li>
<li>千字节（KB）：1KB = 1024B</li>
<li>兆字节（MB）：1MB = 1024KB</li>
<li>吉字节（GB）：1GB = 1024MB</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>Make基本符号</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Make%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对Make的基本语法进行讲解</p>
<a id="more"></a>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>Make 中有<code>:=</code>、<code>?=</code>、<code>+=</code>(追加)以及<code>=</code>四个赋值运算符，其中<code>=</code>和<code>?=</code>比较常用，这里总结一下两者的区别：</p>
<ul>
<li>对于<code>=</code>，变量的值将会是整个Makefile中最后被指定的值，例如：</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = foo</span><br><span class="line">y = <span class="variable">$(x)</span> bar</span><br><span class="line">x = xyz</span><br></pre></td></tr></table></figure>
<p>最终，<code>y</code>的值是<code>xyz bar</code></p>
<ul>
<li>对于<code>:=</code>，变量的值决定于它在Makefile中的位置，而不是整个Makefile展开后的值</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := xyz</span><br></pre></td></tr></table></figure>
<p>最终，<code>y</code>的值为<code>foo bar</code></p>
<h3 id="变量符号"><a href="#变量符号" class="headerlink" title="变量符号$"></a>变量符号$</h3><h4 id="单独的"><a href="#单独的" class="headerlink" title="单独的$"></a>单独的$</h4><p>$的功能比较多，这里一一进行总结，首先是使用变量</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJECTS=main.o hello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="section">hello: <span class="variable">$(OBJECTS)</span></span></span><br><span class="line">    g++ -o hello <span class="variable">$(OBJECTS)</span></span><br></pre></td></tr></table></figure>
<h4 id="、-lt-以及-1"><a href="#、-lt-以及-1" class="headerlink" title="$@、$&lt;以及$\^1"></a>$@、$&lt;以及$\^<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">all: library.cpp main.cpp</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$@</code> evaluates to <code>all</code>，即目标</li>
<li><code>$&lt;</code> evaluates to <code>library.cpp</code>（第一个文件）</li>
<li><code>$^</code> evaluates to <code>library.cpp main.cpp</code></li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html#Automatic-Variables">Automatic Variables</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/HTTP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p><strong>HTTP/1.1 200 OK</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="HTTP及其工作原理"><a href="#HTTP及其工作原理" class="headerlink" title="HTTP及其工作原理"></a>HTTP及其工作原理</h2><h3 id="HTTP头"><a href="#HTTP头" class="headerlink" title="HTTP头"></a>HTTP头</h3><p>HTTP头字段是HTTP的请求和响应消息中的消息头部分，它们定义了一个超文本传输协议事务中的操作参数，其头部字段可根据自己的需要定义。</p>
<h4 id="请求头信息"><a href="#请求头信息" class="headerlink" title="请求头信息"></a>请求头信息</h4><h5 id="请求头组成"><a href="#请求头组成" class="headerlink" title="请求头组成"></a>请求头组成</h5><h5 id="例子：一个GET请求头"><a href="#例子：一个GET请求头" class="headerlink" title="例子：一个GET请求头"></a>例子：一个GET请求头</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GET /home.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: developer.mozilla.org</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10.9</span>; rv:<span class="number">50.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">50.0</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8</span></span><br><span class="line"><span class="comment">Accept-Language: en-US,en;q=0.5</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate, br</span></span><br><span class="line"><span class="comment">Referer: https://developer.mozilla.org/testpage.html</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="comment">If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT</span></span><br><span class="line"><span class="comment">If-None-Match: "c561c68d0ba92bbeb8b0fff2a9199f722e3a621a"</span></span><br><span class="line"><span class="comment">Cache-Control: max-age=0</span></span><br></pre></td></tr></table></figure>
<h4 id="响应头信息"><a href="#响应头信息" class="headerlink" title="响应头信息"></a>响应头信息</h4><h5 id="响应头组成"><a href="#响应头组成" class="headerlink" title="响应头组成"></a>响应头组成</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">响应头</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Allow：支持的请求方法</td>
<td>服务器支持哪些请求方法（如GET、POST等）。</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding：编码方法</td>
<td>文档的编码方法。只有解码才能正确得到Content-Type头指定的内容类型，一般的编码方式如gzip，通过压缩的方式使HTML文档下载时间显著减少。</td>
</tr>
<tr>
<td style="text-align:left">Content-Length：内容长度</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Content-Type：文档类型</td>
<td>表示后面的文档是什么类型，默认为text/plain，但一般会显式指定为text/html</td>
</tr>
<tr>
<td style="text-align:left">Date：时间</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Last-Modified：最后改动日期</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Server：服务器名字</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Set-Cookie：设置关联Cookie</td>
</tr>
</tbody>
</table>
</div>
<h5 id="例子：一个GET响应头"><a href="#例子：一个GET响应头" class="headerlink" title="例子：一个GET响应头"></a>例子：一个GET响应头</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Date: Mon, 18 Jul 2016 16:06:00 GMT</span><br><span class="line">Etag: &quot;c561c68d0ba92bbeb8b0f612a9199f722e3a621a&quot;</span><br><span class="line">Keep-Alive: timeout=5, max=997</span><br><span class="line">Last-Modified: Mon, 18 Jul 2016 02:36:04 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Set-Cookie: mykey=myvalue; expires=Mon, 17-Jul-2017 16:06:00 GMT; Max-Age=31449600; Path=/; secure</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Vary: Cookie, Accept-Encoding</span><br><span class="line">X-Backend-Server: developer2.webapp.scl3.mozilla.com</span><br><span class="line">X-Cache-Info: not cacheable; meta data too large</span><br><span class="line">X-kuma-revision: 1085259</span><br><span class="line">x-frame-options: DENY</span><br></pre></td></tr></table></figure>
<h3 id="HTTP请求流程"><a href="#HTTP请求流程" class="headerlink" title="HTTP请求流程"></a>HTTP请求流程</h3><pre class="mermaid">sequenceDiagram
    participant DNS服务器
    participant 客户
    participant 服务器

    客户->>DNS服务器:DNS域名解析
    DNS服务器->>客户:服务器IP地址

    loop 尝试TCP连接
        客户->>服务器: TCP三次握手
    end
    客户->>服务器: 发起HTTP请求
    服务器->>客户: 响应HTTP请求，发送HTML代码
    服务器->>客户: 四次挥手，断开连接
    客户->>客户: 浏览器解析HTML代码获得资源
    客户->>客户: 浏览器渲染页面并呈现</pre>

<h4 id="为什么HTTP使用TCP"><a href="#为什么HTTP使用TCP" class="headerlink" title="为什么HTTP使用TCP"></a>为什么HTTP使用TCP</h4><p>由于打开网页需要传输很多数据，而TCP协议提供拥塞控制、数据重排以及错误纠正等机制，所以更适合HTTP使用场景。</p>
<h2 id="HTTP-发展历程"><a href="#HTTP-发展历程" class="headerlink" title="HTTP 发展历程"></a>HTTP 发展历程</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><p>最早版本的HTTP协议是HTTP1.0，其有点是浏览器与服务器只保持短暂连接，且连接不进行记录，这是为了提高效率，但是也造成了一些缺陷，主要包括如下缺点：</p>
<ol>
<li>访问复杂网页会导致多次请求和响应，每次请求响应都会建立新的连接</li>
<li>连接无法复用，导致重复经历三次握手和慢启动</li>
<li>队头阻塞，如果HTTP流水线中有多个请求出现，一个数据包的阻塞会导致后续的数据包都被阻塞</li>
</ol>
<h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>为了改进HTTP1.0的缺陷，人们又提出了1.1，相比1.0，1.1的优点如下：</p>
<h4 id="支持持久连接"><a href="#支持持久连接" class="headerlink" title="支持持久连接"></a>支持持久连接</h4><p>在1.1版本中，支持了持久连接，一个TCP连接可以传送多个HTTP请求与响应，减少了建立和关闭连接的消耗与延迟。一个复杂网页可以在一个连接中进行传输。此外，一些其他优点如下所示：</p>
<h4 id="更多请求和响应头"><a href="#更多请求和响应头" class="headerlink" title="更多请求和响应头"></a>更多请求和响应头</h4><p>例如Host响应头，Host使浏览器能够区分来自同一服务器的不同站点</p>
<ul>
<li>支持断点续传</li>
</ul>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>HTTP2.0相比1.1在性能上有了更大提升，它包含如下特性：</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="HTTP-HTTPS区别"><a href="#HTTP-HTTPS区别" class="headerlink" title="HTTP/HTTPS区别"></a>HTTP/HTTPS区别</h3><p>HTTP运行于TCP上，明文传输，C/S端均无法验证对方身份；HTTPS为身披SSL外壳的HTTP，运行于SSL（安全传输协议）上，而SSL运行于TCP上，架构如下：</p>
<pre class="mermaid">graph TD;
    A["HTTP: 80"]
    B["HTTPS: 443"]
    C["SSL"]
    D["TCP"]

    A-->D;

    B-->C;
    C-->D;</pre>

<p>区别：</p>
<ol>
<li>端口不同</li>
<li>开销不同，HTTPS由于要加密，需要更大开销</li>
<li>HTTPS需要购买证书</li>
</ol>
<h3 id="吃个甜点——Session-Cookie"><a href="#吃个甜点——Session-Cookie" class="headerlink" title="吃个甜点——Session/Cookie"></a>吃个甜点——Session/Cookie</h3><p>Session是服务器对用户进行辨识的机制，由于HTTP是无状态协议，因此服务端在辨识用户时，需要一些记录，从而催生了Session，Session和Cookie的区别是Cookie一般保存在C端，当用户第二次发起请求时，会自动将上次存储的cookie发送至服务器，实现身份辨识。</p>
<p>而Session保存在服务器端，默认存放在服务器一个文件夹中，更加安全，但是占用服务器资源。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Response_header">HTTP响应头</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>Linker Script</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/linker%20script/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p><em>Source code -&gt; compiler -&gt; Assembler -&gt; Object code -&gt; Linker -&gt; Executable file -&gt; Loader</em></p>
</blockquote>
<a id="more"></a>
<p>链接器是将多个obj模块链接成为一个obj文件的程序，说白了就是一个缝合器，将程序进行缝合，本文将对基本的linker script进行介绍。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p>将一个或多个输入文件链接成为一个输出文件（不一定是可执行文件，也有可能是缝合成一个更大的库）</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201204112932.png" width = "200" alt="图片名称" align=center /></p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li><p>输入文件：待链接的目标文件或链接脚本文件，输入文件内的section为输入section</p>
</li>
<li><p>输出文件：目标文件或可执行文件（目标文件在linux下一般为ELF格式），输出文件内的section为输出section</p>
</li>
</ul>
<h3 id="section"><a href="#section" class="headerlink" title="section"></a>section</h3><h4 id="section类型"><a href="#section类型" class="headerlink" title="section类型"></a>section类型</h4><p>对程序划分的段，输入文件内的section叫输入section，输出文件为输出section，一个section至少包含名字和大小，大部分还包含与其关联的一块数据，成为section content。一个section可被标记为<strong>可加载的（loadable）</strong>或<strong>可分配的（allocatable）</strong>，如果一个section不可加载或分配，那么一般包含调试信息（可使用objdump查看）。</p>
<ul>
<li>loadable section：输出文件运行时，对应的内容被加载到进程地址空间</li>
<li>allocatable section：内容为空的section可被标记为可分配的，在输出文件运行时，会预先分配section指定大小的内存（某些情况下该内存强制为0）</li>
</ul>
<h4 id="section地址"><a href="#section地址" class="headerlink" title="section地址"></a>section地址</h4><p>每个可加载或分配的section一般包含两个地址：VMA和LMA，一般情况下两者相同</p>
<ul>
<li>VMA：虚拟内存地址或程序地址空间地址（运行地址）</li>
<li>LMA：加载内存地址或进程地址空间地址（加载地址）</li>
</ul>
<h2 id="Linux下链接器使用"><a href="#Linux下链接器使用" class="headerlink" title="Linux下链接器使用"></a>Linux下链接器使用</h2><h3 id="一个script范例及讲解"><a href="#一个script范例及讲解" class="headerlink" title="一个script范例及讲解"></a>一个script范例及讲解</h3><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Simple linker script for the JOS kernel.</span></span><br><span class="line"><span class="comment">   See the GNU ld 'info' manual ("info ld") to learn the syntax. */</span></span><br><span class="line"></span><br><span class="line">OUTPUT_FORMAT(<span class="string">"elf32-i386"</span>, <span class="string">"elf32-i386"</span>, <span class="string">"elf32-i386"</span>)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)      </span><br><span class="line"></span><br><span class="line">SECTIONS                            <span class="comment">// 使用SECTION关键字表示开始设置SECTION</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Link the kernel at this address: "." means the current address */</span></span><br><span class="line">    . = <span class="number">0xF0100000</span>;                 <span class="comment">// 设置location counter</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AT(...) gives the load address of this section, which tells</span></span><br><span class="line"><span class="comment">	   the boot loader where to load the kernel in physical memory */</span></span><br><span class="line">    .text : AT(<span class="number">0x100000</span>) &#123;          <span class="comment">// 定义一个.text section，位置在(0x100000)，</span></span><br><span class="line">                                    <span class="comment">// 所有的*(.text)都会被归入其中，*代表通配符</span></span><br><span class="line">        *(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PROVIDE(etext = .);	<span class="comment">/* Define the 'etext' symbol to this value */</span></span><br><span class="line"></span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.* .gnu.linkonce.r.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Include debugging information in kernel memory */</span></span><br><span class="line">    .stab : &#123;</span><br><span class="line">        PROVIDE(__STAB_BEGIN__ = .);</span><br><span class="line">        *(.stab);</span><br><span class="line">        PROVIDE(__STAB_END__ = .);</span><br><span class="line">        BYTE(<span class="number">0</span>)		<span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">				   for this section */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .stabstr : &#123;</span><br><span class="line">        PROVIDE(__STABSTR_BEGIN__ = .);  <span class="comment">// 令__STABSTR_BEGIN__为counter所在的地址</span></span><br><span class="line">        *(.stabstr);</span><br><span class="line">        PROVIDE(__STABSTR_END__ = .);</span><br><span class="line">        BYTE(<span class="number">0</span>)		<span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">				   for this section */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust the address for the data segment to the next page */</span></span><br><span class="line">    . = ALIGN(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The data segment */</span></span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bss : &#123;</span><br><span class="line">        PROVIDE(edata = .);</span><br><span class="line">        *(.bss)</span><br><span class="line">        PROVIDE(end = .);</span><br><span class="line">        BYTE(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame .note.GNU-stack)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><h5 id="Location-counter"><a href="#Location-counter" class="headerlink" title="Location counter ."></a>Location counter <code>.</code></h5><p><code>.</code>是链接器中的location counter，表示目前所在的location，SECTIONS开始时默认为0，可以人为调整其位置。同时，location counter会随着输出section的增加自动增加。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://www.360doc.com/content/09/0623/18/36491_4007725.shtml">一篇介绍 linker script的文章</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://blog.louie.lu/2016/11/06/10%E5%88%86%E9%90%98%E8%AE%80%E6%87%82-linker-scripts/">一个linker script范例</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>TCP/IP</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/TCPIP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>First, let us set up the connection</p>
</blockquote>
<a id="more"></a>
<h2 id="TCP-IP简介"><a href="#TCP-IP简介" class="headerlink" title="TCP/IP简介"></a>TCP/IP简介</h2><h3 id="什么是TCP-IP"><a href="#什么是TCP-IP" class="headerlink" title="什么是TCP/IP"></a>什么是TCP/IP</h3><p>TCP/IP是用于网络的通信协议，所谓通信协议，就是指通信双方相互必须遵守的规则，从而能够建立正确的通信。TCP/IP的全称是Transmission Control Protocol/ Internet Protocol，即传输控制协议/网际协议，实际是一套协议族。</p>
<h3 id="TCP-IP组成"><a href="#TCP-IP组成" class="headerlink" title="TCP/IP组成"></a>TCP/IP组成</h3><p>作为一个协议族，TCP/IP由以下五个协议组成</p>
<ul>
<li>TCP - 应用程序间点对点通信，固定连接</li>
<li>UDP - 应用程序间简单通信，无连接</li>
<li>IP - 计算机之间通信，无连接</li>
<li>ICMP（因特网消息控制协议）- 针对错误和状态</li>
<li>DHCP（动态主机配置协议）- 针对动态寻址</li>
</ul>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>理想情况下，TCP通信过程应当类似水流管道，吞吐量随需求规模线性增长，最后达到最大值。如果没有拥塞控制，那通信过程会类似于车辆堵车，最后彻底锁死。当输入负载达到一定吞吐量后，吞吐量不会增加，即一部分网络资源会被抛弃，网络的吞吐量维持在其所能控制的最大值。为了防止TCP传输发生死锁，TCP协议设置了四种拥塞控制算法，分别是：<strong>慢开始、拥塞控制、快重传、快恢复</strong></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Response_header">HTTP响应头</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>使用frp实现内网穿透</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近想搭建一台个人服务器，由于没有公网IPv4地址，因此只能通过内网穿透的方式，实现外部设备对于内网服务器的访问</p>
<a id="more"></a>
<h2 id="内网穿透介绍"><a href="#内网穿透介绍" class="headerlink" title="内网穿透介绍"></a>内网穿透介绍</h2><p>内网穿透的基本原理是引入一个中介，这个中介拥有公网IP，通过将外部设备与内网服务器的流量进行转发，实现外部用户与内网服务器之间的通信。因此，为了实现内网穿透，必须要有一台公网服务器，可以选择买一台NAT VPS当作公网VPS（虚拟个人服务器）。</p>
<h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><p>为了通过内网穿透搭建个人服务器，你需要准备如下材料：</p>
<ol>
<li>一台位于内网的个人服务器（客户端）</li>
<li>一台拥有公网IPV4的虚拟个人服务器，这个服务器不需要很强的性能，但是带宽要大（服务端）</li>
<li>用于访问内网服务器的用户</li>
<li>frp内网穿透软件，下载命令如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li>服务端运行，监听一个主端口，等待客户端的连接；</li>
<li>客户端连接到服务端的主端口，同时告诉服务端要监听的端口和转发类型；</li>
<li>服务端fork新的进程监听客户端指定的端口；</li>
<li>外网用户连接到服务端指定的端口，服务端通过和客户端的连接将数据转发到客户端；</li>
<li>客户端进程再将数据转发到本地服务，从而实现内网对外暴露服务的能力。</li>
</ol>
<h2 id="部署教程"><a href="#部署教程" class="headerlink" title="部署教程"></a>部署教程</h2><h3 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h3><p>服务端的部署请参考文献1，需要补充的一点是，有些VPS还需要在其控制台中配置云服务器安全组规则，例如我使用的华为云，需要在网络控制台-访问控制-安全组中进行规则配置</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20230423120009.png" width = "" alt="Hack computer Arch" align=center /></p>
<p>在入方向规则中，添加对应的frp内网及外网端口，从而实现外部流量与内部服务器流量的输入</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20230423120207.png" width = "" alt="Hack computer Arch" align=center /></p>
<p>在网络控制台中设置安全规则后，还需要在linux服务端防火墙中打开对应的端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=48010/tcp</span><br><span class="line">...</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h3 id="客户端（内网服务器）部署"><a href="#客户端（内网服务器）部署" class="headerlink" title="客户端（内网服务器）部署"></a>客户端（内网服务器）部署</h3><p>请参考文献2进行部署</p>
<h2 id="常用调试命令"><a href="#常用调试命令" class="headerlink" title="常用调试命令"></a>常用调试命令</h2><p>Linux侧查看某个端口的防火墙状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-port=6000/udp</span><br></pre></td></tr></table></figure>
<p>打开某个端口防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=2222/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://itlanyan.com/frp-tunnel-tutorial/">frp内网穿透教程</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.cnblogs.com/zhanggaoxing/p/9221705.html">frps实现远程桌面</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>socket套接字编程——概述</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/Socket%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p><strong>HTTP/1.1 200 OK</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="IP地址和端口号"><a href="#IP地址和端口号" class="headerlink" title="IP地址和端口号"></a>IP地址和端口号</h3><p>IP地址用于区分不同的主机，而端口号则用于区分某个主机上不同的应用程序，端口号为0-65535，一般1024以下保留做系统使用。当我们进行socket编程时，必须区分端口号从而找到正确的应用程序。</p>
<h2 id="socket通信过程"><a href="#socket通信过程" class="headerlink" title="socket通信过程"></a>socket通信过程</h2><h3 id="TCP（流式套接字SOCK-STREAM）"><a href="#TCP（流式套接字SOCK-STREAM）" class="headerlink" title="TCP（流式套接字SOCK_STREAM）"></a>TCP（流式套接字SOCK_STREAM）</h3><h4 id="服务器端编程步骤"><a href="#服务器端编程步骤" class="headerlink" title="服务器端编程步骤"></a>服务器端编程步骤</h4><ol>
<li>创建套接字(socket())</li>
<li>绑定套接字到一个IP地址和一个端口上(bind())；</li>
<li>将套接字设置为监听模式等待连接请求(listen())；</li>
<li>请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字(accept())；</li>
<li>用返回的套接字和客户端进行通信(send()/recv())；</li>
<li>返回，等待另一连接请求；</li>
<li>关闭套接字(closesocket())。</li>
</ol>
<h4 id="客户端编程步骤"><a href="#客户端编程步骤" class="headerlink" title="客户端编程步骤"></a>客户端编程步骤</h4><ol>
<li>加载套接字库，创建套接字(WSAStartup()/socket())；</li>
<li>向服务器发出连接请求(connect())；</li>
<li>和服务器端进行通信(send()/recv())；</li>
<li>关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。</li>
</ol>
<h3 id="UDP（报文式套接字SOCK-DGRAM）"><a href="#UDP（报文式套接字SOCK-DGRAM）" class="headerlink" title="UDP（报文式套接字SOCK_DGRAM）"></a>UDP（报文式套接字SOCK_DGRAM）</h3><h4 id="服务器端编程步骤-1"><a href="#服务器端编程步骤-1" class="headerlink" title="服务器端编程步骤"></a>服务器端编程步骤</h4><ol>
<li>socket：       建立一个socket</li>
<li>bind：          将这个socket绑定在某个端口上（AF_INET）</li>
<li>recvfrom：  如果没有客户端发起请求，则会阻塞在这个函数里</li>
<li>close：         通信完成后关闭socket</li>
</ol>
<h4 id="客户端编程步骤-1"><a href="#客户端编程步骤-1" class="headerlink" title="客户端编程步骤"></a>客户端编程步骤</h4><ol>
<li>socket：      建立一个socket</li>
<li>sendto：     向服务器的某个端口发起请求（AF_INET）</li>
<li>close：        通信完成后关闭socket</li>
</ol>
<h3 id="原始套接字（SOCK-RAW）"><a href="#原始套接字（SOCK-RAW）" class="headerlink" title="原始套接字（SOCK_RAW）"></a>原始套接字（SOCK_RAW）</h3><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>类似于文件的打开操作，socket创建一个socket描述符，通过该描述符进行一些读写操作。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>domain</li>
</ul>
<p>指定协议族（family），决定了socket的地址类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF_UNIX,PF_LOCAL</td>
<td style="text-align:center">本地通信</td>
<td style="text-align:center">PF_X25</td>
<td style="text-align:center">ITU-T X25 / ISO-8208协议</td>
</tr>
<tr>
<td style="text-align:center">AF_INET,PF_INET</td>
<td style="text-align:center">IPv4 Internet协议</td>
<td style="text-align:center">PF_AX25</td>
<td style="text-align:center">Amateur radio AX.25</td>
</tr>
<tr>
<td style="text-align:center">PF_INET6</td>
<td style="text-align:center">IPv6 Internet协议</td>
<td style="text-align:center">PF_ATMPVC</td>
<td style="text-align:center">原始ATM PVC访问</td>
</tr>
<tr>
<td style="text-align:center">PF_IPX</td>
<td style="text-align:center">IPX-Novell协议</td>
<td style="text-align:center">PF_APPLETALK</td>
<td style="text-align:center">Appletalk</td>
</tr>
<tr>
<td style="text-align:center">PF_NETLINK</td>
<td style="text-align:center">内核用户界面设备</td>
<td style="text-align:center">PF_PACKET</td>
<td style="text-align:center">底层包访问</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>type</li>
</ul>
<p>指定socket类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOCK_STREAM</td>
<td style="text-align:left">Tcp连接，提供序列化的、可靠的、双向连接的字节流。支持带外数据传输</td>
</tr>
<tr>
<td style="text-align:center">SOCK_DGRAM</td>
<td style="text-align:left">支持UDP连接（无连接状态的消息）</td>
</tr>
<tr>
<td style="text-align:center">SOCK_SEQPACKET</td>
<td style="text-align:left">序列化包，提供一个序列化的、可靠的、双向的基本连接的数据传输通道，数据长度定常。每次调用读系统调用时数据需要将全部数据读出</td>
</tr>
<tr>
<td style="text-align:center">SOCK_RAW</td>
<td style="text-align:left">RAW类型，提供原始网络协议访问</td>
</tr>
<tr>
<td style="text-align:center">SOCK_RDM</td>
<td style="text-align:left">提供可靠的数据报文，不过可能数据会有乱序</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>protocol</li>
</ul>
<p>指定协议，常用的协议有IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</p>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h3><p>bind()函数将一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p><strong>sockfd</strong>，即要操作的socket描述字，socket()函数的返回值。</p>
<p><strong>addr</strong>，一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ipv4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ipv6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span> </span><br><span class="line">    <span class="keyword">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">/* IPv6 address */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unix</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family;               <span class="comment">/* AF_UNIX */</span> </span><br><span class="line">    <span class="keyword">char</span>        sun_path[UNIX_PATH_MAX];  <span class="comment">/* pathname */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>addrlen</strong>，对应地址的长度。<br> 通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。所以通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<h3 id="listen-与connect-函数"><a href="#listen-与connect-函数" class="headerlink" title="listen()与connect()函数"></a>listen()与connect()函数</h3><h4 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// listen    服务器端，用于监听套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect   客户端，用于发起连接请求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li>listen</li>
</ul>
<p>第一个参数sockfd即为要监听的socket描述字，第二个参数blacklog为相应socket可以排队的最大连接个数。<br>socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<ul>
<li>connect</li>
</ul>
<p>第一个参数sockfd即为客户端的socket描述字，第二个参数addr为要连接的服务器的socket地址，第三个参数addrlen为服务器socket地址的长度。客户端通过调用connect()函数来建立与TCP服务器的连接。</p>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h3><p>在服务端开始监听套接字、客户端发起connect请求后，TCP服务器监听到该请求后，会调用accept()函数接收请求，之后可以开始网络IO操作，类似于普通文件读写。</p>
<h4 id="声明-3"><a href="#声明-3" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom()"></a>recvfrom()</h3><p>UDP中接收客户端发起的请求，如果没有，那么会阻塞在这个函数中</p>
<h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto()"></a>sendto()</h3><p>UDP中发送数据</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><h4 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听socket</span></span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: socket"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将socket与IP和端口号进行绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: bind"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听套接字</span></span><br><span class="line">    <span class="keyword">if</span>(listen(listenfd, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: listen"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接受连接</span></span><br><span class="line">    <span class="keyword">int</span> conn;</span><br><span class="line">    <span class="keyword">char</span> clientIP[INET_ADDRSTRLEN] = <span class="string">""</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"...listening"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        conn = accept(listenfd, (struct sockaddr*)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line">        <span class="keyword">if</span> (conn &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: accept"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inet_ntop(AF_INET, &amp;clientAddr.sin_addr, clientIP, INET_ADDRSTRLEN);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"...connect "</span> &lt;&lt; clientIP &lt;&lt; <span class="string">":"</span> &lt;&lt; ntohs(clientAddr.sin_port) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> len = recv(conn, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">"exit"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"...disconnect "</span> &lt;&lt; clientIP &lt;&lt; <span class="string">":"</span> &lt;&lt; ntohs(clientAddr.sin_port) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            send(conn, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        close(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is client"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    <span class="keyword">int</span> client = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: socket"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// connect</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">    serverAddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (connect(client, (struct sockaddr*)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: connect"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"...connect"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line">        send(client, data, <span class="built_in">strlen</span>(data), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(data, <span class="string">"exit"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"...disconnect"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">int</span> len = recv(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(client);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><h4 id="server端-1"><a href="#server端-1" class="headerlink" title="server端"></a>server端</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;   </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT   8000   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">/* sock_fd --- socket文件描述符 创建udp套接字*/</span>  </span><br><span class="line">    <span class="keyword">int</span> sock_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock_fd &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">"socket"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将套接字和IP、端口绑定 */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_serv, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    addr_serv.sin_family = AF_INET;  　　　　　　　　　　　 <span class="comment">//使用IPV4地址</span></span><br><span class="line">    addr_serv.sin_port = htons(SERV_PORT);  　　　　　　　 <span class="comment">//端口</span></span><br><span class="line">    <span class="comment">/* INADDR_ANY表示不管是哪个网卡接收到数据，只要目的端口是SERV_PORT，就会被该应用程序接收到 */</span>  </span><br><span class="line">    addr_serv.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">//自动获取IP地址</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(addr_serv);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 绑定socket */</span>  </span><br><span class="line">    <span class="keyword">if</span>(bind(sock_fd, (struct sockaddr *)&amp;addr_serv, <span class="keyword">sizeof</span>(addr_serv)) &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">"bind error:"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> recv_num;  </span><br><span class="line">    <span class="keyword">int</span> send_num;  </span><br><span class="line">    <span class="keyword">char</span> send_buf[<span class="number">20</span>] = <span class="string">"i am server!"</span>;  </span><br><span class="line">    <span class="keyword">char</span> recv_buf[<span class="number">20</span>];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_client</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server wait:\n"</span>);  </span><br><span class="line"></span><br><span class="line">        recv_num = recvfrom(sock_fd, recv_buf, <span class="keyword">sizeof</span>(recv_buf), <span class="number">0</span>, (struct sockaddr *)&amp;addr_client, (<span class="keyword">socklen_t</span> *)&amp;len);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(recv_num &lt; <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            perror(<span class="string">"recvfrom error:"</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        recv_buf[recv_num] = <span class="string">'\0'</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server receive %d bytes: %s\n"</span>, recv_num, recv_buf);  </span><br><span class="line"></span><br><span class="line">        send_num = sendto(sock_fd, send_buf, recv_num, <span class="number">0</span>, (struct sockaddr *)&amp;addr_client, len);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(send_num &lt; <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            perror(<span class="string">"sendto error:"</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    close(sock_fd);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="client端-1"><a href="#client端-1" class="headerlink" title="client端"></a>client端</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;   </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEST_PORT 8000   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSET_IP_ADDRESS  <span class="meta-string">"127.0.0.1"</span>   </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">/* socket文件描述符 */</span>  </span><br><span class="line">    <span class="keyword">int</span> sock_fd;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 建立udp socket */</span>  </span><br><span class="line">    sock_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(sock_fd &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">"socket"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置address */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_serv</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr_serv, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr_serv));  </span><br><span class="line">    addr_serv.sin_family = AF_INET;  </span><br><span class="line">    addr_serv.sin_addr.s_addr = inet_addr(DSET_IP_ADDRESS);  </span><br><span class="line">    addr_serv.sin_port = htons(DEST_PORT);  </span><br><span class="line">    len = <span class="keyword">sizeof</span>(addr_serv);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> send_num;  </span><br><span class="line">    <span class="keyword">int</span> recv_num;  </span><br><span class="line">    <span class="keyword">char</span> send_buf[<span class="number">20</span>] = <span class="string">"hey, who are you?"</span>;  </span><br><span class="line">    <span class="keyword">char</span> recv_buf[<span class="number">20</span>];  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client send: %s\n"</span>, send_buf);  </span><br><span class="line"></span><br><span class="line">    send_num = sendto(sock_fd, send_buf, <span class="built_in">strlen</span>(send_buf), <span class="number">0</span>, (struct sockaddr *)&amp;addr_serv, len);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(send_num &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">"sendto error:"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    recv_num = recvfrom(sock_fd, recv_buf, <span class="keyword">sizeof</span>(recv_buf), <span class="number">0</span>, (struct sockaddr *)&amp;addr_serv, (<span class="keyword">socklen_t</span> *)&amp;len);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(recv_num &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">"recvfrom error:"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    recv_buf[recv_num] = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client receive %d bytes: %s\n"</span>, recv_num, recv_buf);  </span><br><span class="line"></span><br><span class="line">    close(sock_fd);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="区分监听套接字与已连接套接字"><a href="#区分监听套接字与已连接套接字" class="headerlink" title="区分监听套接字与已连接套接字"></a>区分监听套接字与已连接套接字</h3><p>在服务器端中，我们实际上用到了两个socket，它们分别为：</p>
<ul>
<li>由listen函数将socket函数创建的socket转换而成的监听套接字，记作listenfd</li>
<li>由accept函数等待来自客户端的连接请求到达listenfd，返回一个已连接套接字，记作connfd</li>
</ul>
<p>两者区别如下：</p>
<p>监听套接字，是服务器作为客户端连接请求的一个端点，它被创建一次，并存在于服务器的整个生命周期。</p>
<p>已连接套接字是客户端与服务器之间已经建立起来了的连接的一个端点，服务器每次接受连接请求时都会创建一次已连接套接字，它只存在于服务器为一个客户端服务的过程中。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.jianshu.com/p/3b233facd6bb">linux c++套接字编程</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>网络分析工具使用</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p><strong>HTTP/1.1 200 OK</strong></p>
</blockquote>
<a id="more"></a>
<p>本文将针对一些比较重要的抓包分析工具进行总结</p>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><h3 id="命令使用实例"><a href="#命令使用实例" class="headerlink" title="命令使用实例"></a>命令使用实例</h3><h4 id="查看指定设备"><a href="#查看指定设备" class="headerlink" title="查看指定设备"></a>查看指定设备</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0</span><br></pre></td></tr></table></figure>
<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><h3 id="命令使用实例-1"><a href="#命令使用实例-1" class="headerlink" title="命令使用实例"></a>命令使用实例</h3><h4 id="查看端口状态"><a href="#查看端口状态" class="headerlink" title="查看端口状态"></a>查看端口状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ntulp |grep 22023</span><br></pre></td></tr></table></figure>
<p>查看22023号端口的情况</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>网络硬件设备</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E7%BD%91%E7%BB%9C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>网络相关的硬件设备构成了现代网络的骨血，本文将针对网络中常见硬件设备的类型、功能、工作协议以及连接关系进行总结。</p>
<a id="more"></a>
<h2 id="常见的网络硬件"><a href="#常见的网络硬件" class="headerlink" title="常见的网络硬件"></a>常见的网络硬件</h2><p>常见网络硬件包括网卡、中继器、桥接器、交换机和路由器，本节将针对这些设备分别进行介绍。</p>
<h3 id="网卡（网络适配器）"><a href="#网卡（网络适配器）" class="headerlink" title="网卡（网络适配器）"></a>网卡（网络适配器）</h3><p>网卡工作在数据链路层，是连接计算机和传输介质的接口，其职责是局域网传输介质间物理及电气连接，在软件层面还涉及帧的发送接收、封装解封、数据编解码及缓存等。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>网卡上装有处理器和存储器（ROM和RAM），网卡与局域网的通信通过串行方式传输，而和计算机间的通信通过IO总线以并行方式传输，这个过程中会发生串/并行转换以及速率匹配。</p>
<h4 id="接口与协议"><a href="#接口与协议" class="headerlink" title="接口与协议"></a>接口与协议</h4><p>这里以瑞昱公司的RTL8821CE无线网络适配器为例，对其硬件配置及相关协议信息进行一个总结。</p>
<ul>
<li>接口：PCI-e 1.1接口</li>
<li>无线网络标准：IEEE 802.11ac</li>
</ul>
<h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>中继器起到远距离传输时信号放大的功能，但是噪声也会被放大，所以目前普遍已经被淘汰。</p>
<h3 id="桥接器（网桥）"><a href="#桥接器（网桥）" class="headerlink" title="桥接器（网桥）"></a>桥接器（网桥）</h3><p>网桥工作在OSI模型中的数据链路层，用于两个局域网进行连接，根据MAC地址实现存储转发，</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器工作在OSI第三层即网络层，负责在通信终端和互联网之间转发IP数据包。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://blog.csdn.net/u010757264/article/details/50748336">网络硬件设备</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>网络模型</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p><strong>HTTP/1.1 200 OK</strong></p>
</blockquote>
<a id="more"></a>
<p>理解网络模型对于掌握网络通信原理至关重要，本文将针对OSI模型和TCP/UDP概念层模型进行总结，并重点对OSI模型中的各层功能及重要协议进行总结</p>
<h2 id="OSI模型及TCP-IP概念层模型总结及对比"><a href="#OSI模型及TCP-IP概念层模型总结及对比" class="headerlink" title="OSI模型及TCP/IP概念层模型总结及对比"></a>OSI模型及TCP/IP概念层模型总结及对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">OSI七层模型</th>
<th style="text-align:center">TCP/UDP概念层模型</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">TCP/IP协议族</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center"></td>
<td style="text-align:center">文件传输、电子邮件及文件服务等</td>
<td style="text-align:center">FTP\HTTP\DNS</td>
</tr>
<tr>
<td style="text-align:center">表示层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">数据格式化及加密</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">会话层</td>
<td style="text-align:center"></td>
<td style="text-align:center">建立或解除连接</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">—————————</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">传输层</td>
<td style="text-align:center">提供端对端接口</td>
<td style="text-align:center">TCP/UDP</td>
</tr>
<tr>
<td style="text-align:center">—————————</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">网络层</td>
<td style="text-align:center">为数据包选择路由</td>
<td style="text-align:center">IP/ICMP</td>
</tr>
<tr>
<td style="text-align:center">—————————</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center"></td>
<td style="text-align:center">传输有地址的帧及错误检测</td>
<td style="text-align:center">PPP</td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">链路层</td>
<td style="text-align:center">在物理介质上传输数据</td>
<td style="text-align:center">IEEE</td>
</tr>
</tbody>
</table>
</div>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP-HTTPS-超文本传输协议"><a href="#HTTP-HTTPS-超文本传输协议" class="headerlink" title="HTTP/HTTPS(超文本传输协议)"></a>HTTP/HTTPS(超文本传输协议)</h3><p>关于这部分详见<a href="/2024/10/13/计算机/网络通信/HTTP/" title="关于HTTP的讲解">关于HTTP的讲解</a></p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><pre class="mermaid">sequenceDiagram

    participant 客户
    participant 服务器


    客户->>客户:主动打开
    服务器->>服务器:被动打开
    客户->>服务器:SYN=1，seq=x
    服务器->>客户:ACK=1,ack=x+1, SYN=1,seq=y
    客户->>服务器:ACK=1,ack=y+1
    客户->>客户:Established
    服务器->>服务器: Established</pre>

<h5 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h5><p>第一次握手（客户到服务器）</p>
<p>其中SYN表示请求建立链接，给定一个序号seq=x，一般为1，<strong>客户进入SYN-SENT阶段</strong></p>
<p>第二次握手（服务器到客户）</p>
<p>标志位为SYN和ACK，表示确认报文seq有效，服务器能正常接收客户端发送的数据，同意创建新连接，给定序号seq=y，确认号ack=x+1，<strong>服务器进入SYN-RECV阶段</strong></p>
<p>第三次握手（客户到服务器）</p>
<p><strong>客户进入Established状态</strong>，标志位为ACK，表示确认收到服务器端同意连接的信号，序号seq=x+1，表示收到服务端的确认号ack，并将其作为自己的序号值，确认号ack=y+1，表示收到服务器端序号seq，并将seq+1作为确认号。<strong>服务器在接收到信号后进入Established状态</strong>，双方开始进行数据收发。</p>
<h5 id="为何进行三次握手"><a href="#为何进行三次握手" class="headerlink" title="为何进行三次握手"></a>为何进行三次握手</h5><p>为了防止服务器端开启一些无用连接增加开销，同时避免已经失效的连接请求报文段突然又传回服务端，产生错误响应。如果只有两次握手，那么服务器不知道客户端是否正确接收到了服务器端返回的消息。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h5 id="四次挥手流程"><a href="#四次挥手流程" class="headerlink" title="四次挥手流程"></a>四次挥手流程</h5><p>第一次挥手：A发出FIN</p>
<p>第二次挥手：B回复ACK</p>
<p>第三次挥手：B发出FIN</p>
<p>第四次挥手：A发出ACK，用于确认收到B的FIN</p>
<p>当B接收到消息，认为双方达成同步，连接可以释放，此时B可以单方面释放端口号及内存等资源。但A不知道B是否接收到ACK，会有如下两种情况</p>
<ol>
<li>如果B未收到ACK，会超时重传FIN，那么A会再次接收到FIN，并发送ACK</li>
<li>如果B接收到了ACK，那么不会回复任何消息</li>
</ol>
<p>无论是那种情况，都需要等待，那索性就等吧，等待两种情况的最坏值，即去向ACK和来向FIN的最大消息存活时间，这是一个被动等死的过程。</p>
<h5 id="为何等待2msl"><a href="#为何等待2msl" class="headerlink" title="为何等待2msl"></a>为何等待2msl</h5><p>为了确认服务器端收到了来自客户端发出的ACK确认报文，如果在2msl内，客户端又接收到了来自服务器端的FIN报文，说明服务器端没能接收到客户端发出的ACK确认。则客户端再次发送，并重置计时器。</p>
<h4 id="TCP协议传输可靠性"><a href="#TCP协议传输可靠性" class="headerlink" title="TCP协议传输可靠性"></a>TCP协议传输可靠性</h4><p>由于TCP是一种面向字节流的传输协议，因此必须有一套机制保证传输过程可靠性，方法如下：</p>
<ul>
<li><strong>字节流服务</strong>：</li>
<li><strong>数据包校验</strong>：</li>
<li><strong>失序重排</strong>：</li>
<li><strong>超时重发</strong></li>
<li><strong>流量控制</strong></li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>USB 3.0 Host Controllers</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/USB30/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对USB3.0的Host Controller进行介绍</p>
<a id="more"></a>
<h2 id="Host-Controller介绍"><a href="#Host-Controller介绍" class="headerlink" title="Host Controller介绍"></a>Host Controller介绍</h2><h3 id="Host-Controller基本结构"><a href="#Host-Controller基本结构" class="headerlink" title="Host Controller基本结构"></a>Host Controller基本结构</h3><p>英特尔发明了xHCI(<a href="https://en.wikipedia.org/wiki/Extensible_Host_Controller_Interface">Extensible Host Controller Interface</a>)用于USB3.0的host controller，该控制器能向下兼容并混合使用各个速率的设备，如下图所示</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220905204442.png" width = "480" alt="图片名称" align=center /></p>
<p>当设备直接连接到Root Hub的端口上时，Host Controller将会判断是3.0还是2.0的设备，并由对应的控制器进行接管。有些SoC还提供了额外的Host Controller，通过挂载在PCIe总线上，支持USB3.1协议。每个Host最多支持127个设备，当系统上电后，和其他的PCI设备类似，系统会遍历所有的Host Controller并初始化。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/usb30diagram.svg" width = "480" alt="图片名称" align=center /></p>
<h3 id="Host-Controller功能"><a href="#Host-Controller功能" class="headerlink" title="Host Controller功能"></a>Host Controller功能</h3><p>对于一个简单的master/slave USB模型，一个Host Controller的功能如下：</p>
<ul>
<li>报告设备的连接/移除</li>
<li>跟踪设备的上下文信息（设备速度/传输类型等）</li>
<li>响应软件的传输请求</li>
<li>初始化USB数据传输</li>
<li>记录传输和其他事务的状态</li>
<li>产生中断</li>
</ul>
<h3 id="Host-Controller初始化"><a href="#Host-Controller初始化" class="headerlink" title="Host Controller初始化"></a>Host Controller初始化</h3><p>为了初始化Host Controller，需要读取并初始化两个寄存器组：</p>
<ul>
<li>PCI配置空间</li>
<li>MMIO. 一个大块的包含xHCI功能结构（软件可以从这些寄存器中读取xHCI支持的功能）/操作寄存器（用于控制Host Controller的行为）/运行寄存器（动态寄存器，用于软件与设备交互）的寄存器块</li>
</ul>
<h2 id="USB-3-0新特性"><a href="#USB-3-0新特性" class="headerlink" title="USB 3.0新特性"></a>USB 3.0新特性</h2><p>相比USB2.0，USB3.0有如下特性：</p>
<ul>
<li>最大的包长度增加：同步/中断/块增大为1024 bytes，控制增大为512 bytes</li>
<li>数据</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>设备驱动</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式介绍</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“每一段故事诞生的地方，都有一种“美”存在。</p>
<p>我们与其邂逅，被其触动，心生涟漪。</p>
<p>新的故事便随之诞生。” —— 赤木明登</p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于工程学，我们有必要建立起一套成体系的设计模式，确保可复用性、可理解性以及可靠性。对于软件工程来说，设计模式使代码编制真正工程化，使我们周围不断重复发生的问题，以及该问题的核心解决方案得以被精确地描述。这里，我们以GOF的 Design Patterns - Elements of Reusable Object-Oriented Software<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>作为指导，对设计模式进行介绍。他们提出的设计模式主要基于以下原则：</p>
<ul>
<li>面向接口编程</li>
<li>优先使用对象组合</li>
</ul>
<h2 id="设计模式类型总结2"><a href="#设计模式类型总结2" class="headerlink" title="设计模式类型总结2"></a>设计模式类型总结<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">模式 &amp; 描述</th>
<th style="text-align:left">包括</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>创建型模式</strong> <br />这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td style="text-align:left">工厂模式（Factory Pattern）<br />抽象工厂模式（Abstract Factory Pattern）<br />单例模式（Singleton Pattern）<br />建造者模式（Builder Pattern）<br />原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>结构型模式</strong> <br />这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td style="text-align:left">适配器模式（Adapter Pattern）<br />桥接模式（Bridge Pattern）<br />过滤器模式（Filter、Criteria Pattern）<br />组合模式（Composite Pattern）<br />装饰器模式（Decorator Pattern）<br />外观模式（Facade Pattern）<br />享元模式（Flyweight Pattern）<br />代理模式（Proxy Pattern）<br /></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>行为型模式</strong> <br />这些设计模式特别关注对象之间的通信。</td>
<td style="text-align:left">责任链模式（Chain of Responsibility Pattern）<br />命令模式（Command Pattern）<br />解释器模式（Interpreter Pattern）<br />迭代器模式（Iterator Pattern）<br />中介者模式（Mediator Pattern）<br />备忘录模式（Memento Pattern）<br />观察者模式（Observer Pattern）<br />状态模式（State Pattern）<br />空对象模式（Null Object Pattern）<br />策略模式（Strategy Pattern）<br />模板模式（Template Pattern）<br />访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>J2EE 模式</strong> <br />这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>
<td style="text-align:left">MVC 模式（MVC Pattern）<br />业务代表模式（Business Delegate Pattern）<br />组合实体模式（Composite Entity Pattern）<br />数据访问对象模式（Data Access Object Pattern）<br />前端控制器模式（Front Controller Pattern）<br />拦截过滤器模式（Intercepting Filter Pattern）<br />服务定位器模式（Service Locator Pattern）<br />传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="设计六原则"><a href="#设计六原则" class="headerlink" title="设计六原则"></a>设计六原则</h2><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1 开闭原则"></a>1 开闭原则</h3><p>开放扩展，关闭修改，使用接口和抽象，使程序扩展性好</p>
<h3 id="2-里氏代换"><a href="#2-里氏代换" class="headerlink" title="2 里氏代换"></a>2 里氏代换</h3><p>任何基类可以出现的地方，子类一定可以出现</p>
<h3 id="3-依赖倒置"><a href="#3-依赖倒置" class="headerlink" title="3 依赖倒置"></a>3 依赖倒置</h3><p>针对接口编程，依赖于抽象而不依赖于具体</p>
<h3 id="4-接口隔离"><a href="#4-接口隔离" class="headerlink" title="4 接口隔离"></a>4 接口隔离</h3><p>降低类间耦合度，使用多个隔离接口比使用单个接口好</p>
<h3 id="5-最少相互作用"><a href="#5-最少相互作用" class="headerlink" title="5 最少相互作用"></a>5 最少相互作用</h3><p>系统功能模块应当尽可能独立</p>
<h3 id="合成复用"><a href="#合成复用" class="headerlink" title="合成复用"></a>合成复用</h3><p>尽量使用组合，而不是继承</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://asi.insa-rouen.fr/enseignement/siteUV/genie_logiciel/supports/ressources/exemples_de_la_vie_reelle_pour_illustrer_pattern.pdf">Gamma E. Design patterns: elements of reusable object-oriented software[M]. Pearson Education India, 1995.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">设计模式简介</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>对我来说，你只是一个小男孩，就像其他成千上万个小男孩一样没有什么两样。我不需要你。你也不需要我。对你来说，我也只是一只狐狸，和其他成千上万的狐狸没有什么不同。但是，如果你驯养了我，我们就会彼此需要。对我来说，你就是我的世界里独一无二的了；我对你来说，也是你的世界里的唯一。</p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>单例模式确保一个类仅有一个实例，并提供一个全局访问点，该实例被所有程序模块共享。</p>
<h3 id="单例模式应用场景"><a href="#单例模式应用场景" class="headerlink" title="单例模式应用场景"></a>单例模式应用场景</h3><p>系统日志输出、GUI应用必须单鼠标，操作系统只能有一个窗口管理器、一台电脑只能连接一个键盘等。</p>
<h2 id="单例模式的C-实现"><a href="#单例模式的C-实现" class="headerlink" title="单例模式的C++实现"></a>单例模式的C++实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_pInstance;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Sinleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pInstance == <span class="literal">nullptr</span>) </span><br><span class="line">            m_pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://asi.insa-rouen.fr/enseignement/siteUV/genie_logiciel/supports/ressources/exemples_de_la_vie_reelle_pour_illustrer_pattern.pdf">Gamma E. Design patterns: elements of reusable object-oriented software[M]. Pearson Education India, 1995.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">设计模式简介</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>聚合模式</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“盒子里面是什么”</p>
<p>“谁知道呢，也许是另一个盒子”</p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是聚合模式"><a href="#什么是聚合模式" class="headerlink" title="什么是聚合模式"></a>什么是聚合模式</h3><p>在聚合模式中，对象模型可以被抽象为一颗树，例如一个盒子里放了五个盒子，这五个盒子又可以放下若干盒子，最后构成了一棵树</p>
<h3 id="聚合模式应用场景"><a href="#聚合模式应用场景" class="headerlink" title="聚合模式应用场景"></a>聚合模式应用场景</h3><p>如果应用的核心模型能够用树状结构表示，使用组合模式才有价值</p>
<h2 id="聚合模式结构"><a href="#聚合模式结构" class="headerlink" title="聚合模式结构"></a>聚合模式结构</h2><h2 id="C-实例"><a href="#C-实例" class="headerlink" title="C++实例"></a>C++实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The base Component class declares common operations for both simple and</span></span><br><span class="line"><span class="comment"> * complex objects of a composition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @var Component</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  Component *parent_;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Optionally, the base Component can declare an interface for setting and</span></span><br><span class="line"><span class="comment">   * accessing a parent of the component in a tree structure. It can also</span></span><br><span class="line"><span class="comment">   * provide some default implementation for these methods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Component() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetParent</span><span class="params">(Component *parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;parent_ = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Component *<span class="title">GetParent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;parent_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * In some cases, it would be beneficial to define the child-management</span></span><br><span class="line"><span class="comment">   * operations right in the base Component class. This way, you won't need to</span></span><br><span class="line"><span class="comment">   * expose any concrete component classes to the client code, even during the</span></span><br><span class="line"><span class="comment">   * object tree assembly. The downside is that these methods will be empty for</span></span><br><span class="line"><span class="comment">   * the leaf-level components.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(Component *component)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Remove</span><span class="params">(Component *component)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * You can provide a method that lets the client code figure out whether a</span></span><br><span class="line"><span class="comment">   * component can bear children.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsComposite</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The base Component may implement some default behavior or leave it to</span></span><br><span class="line"><span class="comment">   * concrete classes (by declaring the method containing the behavior as</span></span><br><span class="line"><span class="comment">   * "abstract").</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;; <span class="comment">// class Component</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Leaf class represents the end objects of a composition. A leaf can't have</span></span><br><span class="line"><span class="comment"> * any children.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Usually, it's the Leaf objects that do the actual work, whereas Composite</span></span><br><span class="line"><span class="comment"> * objects only delegate to their sub-components.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> :</span> <span class="keyword">public</span> Component &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Leaf"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Composite class represents the complex components that may have children.</span></span><br><span class="line"><span class="comment"> * Usually, the Composite objects delegate the actual work to their children and</span></span><br><span class="line"><span class="comment"> * then "sum-up" the result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> :</span> <span class="keyword">public</span> Component &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @var \SplObjectStorage</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Component *&gt; children_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A composite object can add or remove other components (both simple or</span></span><br><span class="line"><span class="comment">   * complex) to or from its child list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(Component *component)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;children_.push_back(component);</span><br><span class="line">    component-&gt;SetParent(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Have in mind that this method removes the pointer to the list but doesn't</span></span><br><span class="line"><span class="comment">   * frees the</span></span><br><span class="line"><span class="comment">   *     memory, you should do it manually or better use smart pointers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(Component *component)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    children_.remove(component);</span><br><span class="line">    component-&gt;SetParent(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsComposite</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The Composite executes its primary logic in a particular way. It traverses</span></span><br><span class="line"><span class="comment">   * recursively through all its children, collecting and summing their results.</span></span><br><span class="line"><span class="comment">   * Since the composite's children pass these calls to their children and so</span></span><br><span class="line"><span class="comment">   * forth, the whole object tree is traversed as a result.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Component *c : children_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == children_.back()) &#123;</span><br><span class="line">        result += c-&gt;Operation();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result += c-&gt;Operation() + <span class="string">"+"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Branch("</span> + result + <span class="string">")"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The client code works with all of the components via the base interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">(Component *component)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"RESULT: "</span> &lt;&lt; component-&gt;Operation();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thanks to the fact that the child-management operations are declared in the</span></span><br><span class="line"><span class="comment"> * base Component class, the client code can work with any component, simple or</span></span><br><span class="line"><span class="comment"> * complex, without depending on their concrete classes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode2</span><span class="params">(Component *component1, Component *component2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (component1-&gt;IsComposite()) &#123;</span><br><span class="line">    component1-&gt;Add(component2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"RESULT: "</span> &lt;&lt; component1-&gt;Operation();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This way the client code can support the simple leaf components...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Component *simple = <span class="keyword">new</span> Leaf;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Client: I've got a simple component:\n"</span>;</span><br><span class="line">  ClientCode(simple);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ...as well as the complex composites.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  Component *tree = <span class="keyword">new</span> Composite;</span><br><span class="line">  Component *branch1 = <span class="keyword">new</span> Composite;</span><br><span class="line"></span><br><span class="line">  Component *leaf_1 = <span class="keyword">new</span> Leaf;</span><br><span class="line">  Component *leaf_2 = <span class="keyword">new</span> Leaf;</span><br><span class="line">  Component *leaf_3 = <span class="keyword">new</span> Leaf;</span><br><span class="line">  branch1-&gt;Add(leaf_1);</span><br><span class="line">  branch1-&gt;Add(leaf_2);</span><br><span class="line">  Component *branch2 = <span class="keyword">new</span> Composite;</span><br><span class="line">  branch2-&gt;Add(leaf_3);</span><br><span class="line">  tree-&gt;Add(branch1);</span><br><span class="line">  tree-&gt;Add(branch2);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Client: Now I've got a composite tree:\n"</span>;</span><br><span class="line">  ClientCode(tree);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Client: I don't need to check the components classes even when managing the tree:\n"</span>;</span><br><span class="line">  ClientCode2(tree, branch1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">设计模式简介</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>减少编程错误</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%87%8F%E5%B0%91%E7%BC%96%E7%A8%8B%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>if(connection == nullptr)</p>
<p>​    goto fail;</p>
<p>​    goto fail;</p>
</blockquote>
<a id="more"></a>
<h2 id="安全编码与未定义行为"><a href="#安全编码与未定义行为" class="headerlink" title="安全编码与未定义行为"></a>安全编码与未定义行为</h2><h3 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h3><h4 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h4><p>查看下面的代码，其输出结果是什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产生了越界访问，导致了未定义行为。建议：</p>
<ul>
<li>不要使用超出边界的指针或数组下标（这不是废话吗）</li>
<li>缓冲区溢出问题在CWE的数据库中排名第二</li>
</ul>
<h4 id="访问已经销毁的局部空间（悬空指针）"><a href="#访问已经销毁的局部空间（悬空指针）" class="headerlink" title="访问已经销毁的局部空间（悬空指针）"></a>访问已经销毁的局部空间（悬空指针）</h4><p>这种最常见的就是在一个函数中定义一段空间，然后返回这段空间的首地址。由于这段空间在函数返回后就被销毁，因此这个地址也成为了悬空指针。</p>
<h4 id="超出类型能容纳的范围"><a href="#超出类型能容纳的范围" class="headerlink" title="超出类型能容纳的范围"></a>超出类型能容纳的范围</h4><p>查看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">Average</span><span class="params">(<span class="keyword">int32_t</span> x, <span class="keyword">int32_t</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x+y)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个整型相加，可能会溢出。建议：</p>
<ul>
<li>确保有符号整数运算不溢出，避免无符号整数运算产生的回绕</li>
</ul>
<h4 id="有符号和无符号混用"><a href="#有符号和无符号混用" class="headerlink" title="有符号和无符号混用"></a>有符号和无符号混用</h4><p>建议：</p>
<ul>
<li>用来表示数值时，不要用char</li>
<li>避免混用有符号和无符号数，如果不得不一起用，显式指定转换类型</li>
<li>类型转换导致的溢出问题在CWE中排11位，有超过800条漏洞</li>
</ul>
<h3 id="未定义行为后果"><a href="#未定义行为后果" class="headerlink" title="未定义行为后果"></a>未定义行为后果</h3><p>未定义行为的一个典型后果是，由于访问了非法内存，所以可以通过精心设计构造的输入，修改栈中保存的返回地址，从而跳转到黑客想要跳转的区域。</p>
<h2 id="表达式与变量"><a href="#表达式与变量" class="headerlink" title="表达式与变量"></a>表达式与变量</h2><h3 id="全局变量初始化"><a href="#全局变量初始化" class="headerlink" title="全局变量初始化"></a>全局变量初始化</h3><p>假设我们在<code>a.cpp</code>中有一个全局变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int g_x = 1;</span><br></pre></td></tr></table></figure>
<p>而在<code>b.cpp</code>中，也有一个全局变量，且使用<code>g_x</code>进行定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_x;</span><br><span class="line"><span class="keyword">int</span> g_y = <span class="number">10</span> + g_x;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; g_y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就有了问题，两个不同文件定义的全局变量，其初始化顺序是不确定的。建议：</p>
<ul>
<li>避免全局变量出现初始化顺序依赖的情况</li>
</ul>
<h2 id="代码度量"><a href="#代码度量" class="headerlink" title="代码度量"></a>代码度量</h2><h3 id="代码的组织"><a href="#代码的组织" class="headerlink" title="代码的组织"></a>代码的组织</h3><ul>
<li>程序必须为阅读者编写，只是顺便用于机器执行</li>
<li>短小的函数总是更简洁、更容易阅读</li>
<li>功能单一的函数更容易复用，简洁明了的代码更容易维护</li>
</ul>
<h2 id="业界指南、规范与工具"><a href="#业界指南、规范与工具" class="headerlink" title="业界指南、规范与工具"></a>业界指南、规范与工具</h2><h3 id="业界指南"><a href="#业界指南" class="headerlink" title="业界指南"></a>业界指南</h3><ul>
<li>谷歌C++风格指南<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，以风格约定与习惯引导为主，不涉及消除安全问题</li>
<li>SEI CERT C++ Coding Standard<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，以消除安全隐患为目的，不涉及风格约定，内容太多，建议作为字典</li>
<li>C++ Core Guideline<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，重点为如何合理应用现代C++特性，这个非常值得一读</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>gcc等编译器本身就能检查很多问题，且几乎不会误报，我们应当做到保持编译器警告清零</p>
<h4 id="辅助检查工具"><a href="#辅助检查工具" class="headerlink" title="辅助检查工具"></a>辅助检查工具</h4><ul>
<li>PC-link Plus：以CERT、MISRA等业界规范作为准则，能检查上千条规则，但是有误报和漏报</li>
<li>CPPCheck：开源静态检查工具，主要检查未定义行为，以减少误报为设计目标</li>
<li>华为云代码检查：<a href="https://www.huaweicloud.com/product/codecheck.html">代码检查CodeCheck<em>精准定位</em>代码缺陷<em>安全检查</em>华为云 (huaweicloud.com)</a></li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">C++ 风格指南 - 内容目录 — Google 开源项目风格指南 (zh-google-styleguide.readthedocs.io)</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://resources.sei.cmu.edu/downloads/secure-coding/assets/sei-cert-cpp-coding-standard-2016-v01.pdf">SEI CERT C++ Coding Standard (2016 Edition) (cmu.edu)</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ Core Guidelines (isocpp.github.io)</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>构建安全代码</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%9E%84%E5%BB%BA%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 本文将针对编码过程中的一些漏洞进行总结，并给出相关示例</p>
<a id="more"></a>
<h2 id="内存操作漏洞"><a href="#内存操作漏洞" class="headerlink" title="内存操作漏洞"></a>内存操作漏洞</h2><h3 id="字符串与数组操作"><a href="#字符串与数组操作" class="headerlink" title="字符串与数组操作"></a>字符串与数组操作</h3><h4 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[] = <span class="string">"duanshiqi"</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input the student id: \n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d, &amp;id"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"student is %d, name is %s\n"</span>, id, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个典型的缓冲区溢出漏洞，id的类型是unsigned char，但是在<code>scanf</code>中格式却是<code>%d</code>，这将导致当输入较大的数字时，会对<code>id</code>后面的空间进行覆盖，导致输出错误。</p>
<h4 id="差一错误"><a href="#差一错误" class="headerlink" title="差一错误"></a>差一错误</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">char</span> buf[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[] = <span class="string">"duanshiqi"</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(str, buf, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是典型的差一错误，HELLO_WORLD后面是有<code>\0</code>的，所以长度实际为12，比11大。</p>
<h4 id="外部可控的format"><a href="#外部可控的format" class="headerlink" title="外部可控的format"></a>外部可控的format</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputLog</span><span class="params">(<span class="keyword">char</span>* loginfo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> password[] =<span class="string">"password"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(loginfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面直接用<code>printf()</code>未经格式化输出loginfo，那么如果外部精心构造了一个<code>format</code>，那么可能导致password泄漏。</p>
<h2 id="函数漏洞"><a href="#函数漏洞" class="headerlink" title="函数漏洞"></a>函数漏洞</h2><h3 id="使用安全的函数"><a href="#使用安全的函数" class="headerlink" title="使用安全的函数"></a>使用安全的函数</h3><h4 id="一些老旧的函数不甚安全"><a href="#一些老旧的函数不甚安全" class="headerlink" title="一些老旧的函数不甚安全"></a>一些老旧的函数不甚安全</h4><p>先看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetScore</span><span class="params">(<span class="keyword">int</span>* scoreList)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">89</span>,<span class="number">123</span>,<span class="number">111</span>&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(scoreList, score, <span class="keyword">sizeof</span>(score)/<span class="keyword">sizeof</span>(score[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面scoreList并没有指定拷贝长度，如果scoreList长度小于score，那么会造成缓冲区溢出，所以在传入指针指向的空间时，要同时传入空间大小。在这里，<code>memcpy</code>就是一个典型的不安全函数。</p>
<p>C11标准对于不安全的函数指定了安全版本，请使用安全版本替代不安全函数。安全函数的安全特性如下：</p>
<ul>
<li>边界检查及入参检查</li>
<li>字符串强制0结尾</li>
<li>增加错误码</li>
<li>内存重叠检查</li>
<li>限定操作内存的最大长度</li>
</ul>
<p>对于<code>memcpy</code>，其安全函数版本如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">errno_t</span> <span class="title">memcpy_s</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">size_t</span> dsetMax, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用安全函数要谨慎"><a href="#使用安全函数要谨慎" class="headerlink" title="使用安全函数要谨慎"></a>使用安全函数要谨慎</h4><p>即使有了安全函数，也可能出现不正确使用的情况，例如将源长度直接作为目的长度，属于典型的掩耳盗铃的做法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">memcpy_s(dest, <span class="keyword">sizeof</span>(src), src, <span class="keyword">sizeof</span>(src));  <span class="comment">// 禁止掩耳盗铃</span></span><br></pre></td></tr></table></figure>
<p>同时，确保目的长度确实地等于传入的目的地址，有时候定义了一个宏作为目的长度，结果输入的目的内存空间长度和宏不相等，也是要禁止的。</p>
<h4 id="必须检查安全函数返回值"><a href="#必须检查安全函数返回值" class="headerlink" title="必须检查安全函数返回值"></a>必须检查安全函数返回值</h4><p>安全函数为我们设置了返回值，我们不能忽略，使用时一定要检查安全函数的返回值。</p>
<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><h3 id="谨慎地进行整数间比较操作"><a href="#谨慎地进行整数间比较操作" class="headerlink" title="谨慎地进行整数间比较操作"></a>谨慎地进行整数间比较操作</h3><p><code>char</code>类型最大值比<code>int</code>类型最大值小，如果使用<code>char</code>的类型和<code>int</code>类型比较，很有可能出现无效比较的情况，需要特别注意。</p>
<h3 id="注意整数越界问题"><a href="#注意整数越界问题" class="headerlink" title="注意整数越界问题"></a>注意整数越界问题</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> g_studentScore[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> short g_curOffset = <span class="number">12</span>;   <span class="comment">// 已经保存的学生成绩个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddStudentScore</span><span class="params">(<span class="keyword">char</span>* score, <span class="keyword">unsigned</span> short num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(score == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> short <span class="keyword">int</span> length = g_curOffset + num;</span><br><span class="line">    <span class="keyword">if</span>(length &gt; (<span class="keyword">sizeof</span>(g_studentScore) - <span class="number">1</span>))&#123;</span><br><span class="line">        err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> short i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        g_studentScore[g_curOffset] = score[i];</span><br><span class="line">        g_curOffset++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码看似会对<code>length</code>进行检查，保证<code>length</code>不超过100，但是问题就出现在相加的语句上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">length = g_curOffset + num;</span><br></pre></td></tr></table></figure>
<p>这一句并没有进行整数越界检查，如果<code>num + g_curOffset</code>超过了65535，那么<code>length</code>会溢出，导致实际相加的结果很小，但是<code>num</code>又很大，后面的循环会导致缓冲区溢出。可以在循环的时候添加检查，如果越界，就退出。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1">[输入验证](<a href="https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html">Input Validation - OWASP Cheat Sheet Series</a>)<a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>Blender Modifier总结</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/Blender/Blender%20Modifier/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在Blender中，我们通过modifier为物体添加一些特定的属性，本文将介绍最常用的一些modifier</p>
<a id="more"></a>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>生成类的modifier一般与物体的生成及形变有关</p>
<h3 id="Subdivision-Surface-细分曲面"><a href="#Subdivision-Surface-细分曲面" class="headerlink" title="Subdivision Surface (细分曲面)"></a>Subdivision Surface (细分曲面)</h3><p>将一个物体的表面使用插值进行光滑化处理，从而得到一个高模</p>
<h3 id="Solidify（固体化）"><a href="#Solidify（固体化）" class="headerlink" title="Solidify（固体化）"></a>Solidify（固体化）</h3><p>给予物体厚度</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>Blender</category>
      </categories>
  </entry>
  <entry>
    <title>编写高质量的代码</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Designing a software is just like designing a jewelry</p>
</blockquote>
<a id="more"></a>
<p>本文属于软件工程系列笔记总结第一部分，如何编写高质量的代码。</p>
<h2 id="编程过程与规范"><a href="#编程过程与规范" class="headerlink" title="编程过程与规范"></a>编程过程与规范</h2><p>此处详见<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，关于注释多说几点，首先注释要解释为什么而不是怎么做，其次不要对明确知道功能的语句进行注释，应当以块作为划分，除非某一条语句特别复杂。应尽可能做到去文档化，使开发文档融合在注释中，最后利用一些工具自动生成开发文档。另外需要注意的是，<strong>对于不好的程序，不要试图修改，而是要直接重新写。</strong></p>
<h2 id="良好的编程实践"><a href="#良好的编程实践" class="headerlink" title="良好的编程实践"></a>良好的编程实践</h2><p>在编程实践中，我们要做到以下几点：</p>
<ul>
<li>看：阅读优秀代码</li>
<li>问：以专业的方式提出问题，通过问题提升技能，这里给出一个网页，描述了应当如何提问<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
<li>练：大量的动手练习</li>
</ul>
<h3 id="开发软件的过程"><a href="#开发软件的过程" class="headerlink" title="开发软件的过程"></a>开发软件的过程</h3><p>开发软件的过程是一个自上而下然后自下而上的过程，我们首先根据指定的问题，将一个大的问题拆分为小的问题，然后针对小问题设计解决模块，最后将小模块进行组合，构成大型的软件系统。为了高质量的完成这个过程，我们需要三种编程实践</p>
<ul>
<li>模块化设计</li>
<li>面向抽象编程</li>
<li>错误与异常处理</li>
</ul>
<h3 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h3><p>将大程序按照功能拆分成一系列小的模块，可以有效降低设计复杂性、提高可靠性、缩短周期、易于维护与功能扩展。常见模块划分原则包括水平、垂直；易变、不易变；基于单一职责。下面是分别使用水平和垂直原则对WEB应用进行的划分</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/softwareStructure.png" width = "500" alt="图片名称" align=center /></p>
<p>所谓易变与不易变，是将代码中可能会经常改动的和不容易经常改动的分开，每次迭代只需改变易变部分；而单一职责原则即设计时一个模块只实现一个职责，注意单一职责不是指单一功能，而是说避免万能类和庞大函数。</p>
<h4 id="案例：生命游戏的模块划分"><a href="#案例：生命游戏的模块划分" class="headerlink" title="案例：生命游戏的模块划分"></a>案例：生命游戏的模块划分</h4><p>生命游戏是一个很经典的细胞自动机算法，对于一个生命游戏，它包括棋盘、逻辑规则和计时器，所以我们可以将上述三个部分设置为三个不同的模块，并通过一定的接口相互调用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模块名称</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>地图模块</td>
<td>管理地图相关的初始化、获取与更新</td>
<td></td>
</tr>
<tr>
<td>逻辑模块</td>
<td>控制完整游戏逻辑，根据地图模块的数据对地图模块进行更新</td>
<td></td>
</tr>
<tr>
<td>时间模块</td>
<td>在适当的时间对地图进行更新</td>
<td></td>
</tr>
<tr>
<td>UI模块</td>
<td>管理用户输入输出交互</td>
</tr>
</tbody>
</table>
</div>
<h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>在设计好模块的基础上，我们可以先设计出各个模块的骨架，或者说对各个模块进行抽象，定义它们之间的接口；模块间相互关联的接口在未来开发中应尽可能保持不变。</p>
<h4 id="案例：生命游戏的接口设计"><a href="#案例：生命游戏的接口设计" class="headerlink" title="案例：生命游戏的接口设计"></a>案例：生命游戏的接口设计</h4><h5 id="地图模块接口"><a href="#地图模块接口" class="headerlink" title="地图模块接口"></a>地图模块接口</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> LifeState&#123;</span><br><span class="line">    NOLIFE = <span class="number">0</span>,</span><br><span class="line">    ALIVE</span><br><span class="line">    DEAD   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameMap</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    GameMap(<span class="keyword">unsigned</span> <span class="keyword">int</span> _height = <span class="number">10</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> _width = <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置地图并填充活细胞</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">float</span> life_ratio)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得指定位置周围的细胞数目</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getNeighborCount</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> row, <span class="keyword">unsigned</span> <span class="keyword">int</span> col)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新地图上某个方格的生命状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLifeState</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> row, <span class="keyword">unsigned</span> <span class="keyword">int</span> col, LifeState life_state)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得地图上某个方格的生命状态</span></span><br><span class="line">    <span class="function">LifeState <span class="title">getLifeState</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> row, <span class="keyword">unsigned</span> <span class="keyword">int</span> col)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得地图的长和宽</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置地图的长和宽</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> _height)</span></span>&#123;</span><br><span class="line">        m_height = _height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> _width)</span></span>&#123;</span><br><span class="line">        m_width  = _width;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_height;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_width;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m_board&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="逻辑模块接口"><a href="#逻辑模块接口" class="headerlink" title="逻辑模块接口"></a>逻辑模块接口</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameControl</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    GameControl();</span><br><span class="line">    ~GameControl();</span><br><span class="line">    <span class="comment">// 进行一次游戏循环，将更新一次地图并打印</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在控制台上打印地图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GameMap* <span class="built_in">map</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="时钟模块"><a href="#时钟模块" class="headerlink" title="时钟模块"></a>时钟模块</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置时钟频率</span></span><br><span class="line">    Timer(<span class="keyword">unsigned</span> <span class="keyword">int</span> _interval, <span class="keyword">void</span> fun);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始时钟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h4><p>在模块化分解之后，开发人员可以分别实现各个模块，根据函数单一职责原则，各模块内部可以定义更多函数，与此同时，模块测试的设计工作也可以开始。需要注意的是，前面设计的接口一旦设计好了，<strong>尽可能不要变动，否则可能造成连带性的一系列修改</strong>。</p>
<h4 id="错误和异常处理"><a href="#错误和异常处理" class="headerlink" title="错误和异常处理"></a>错误和异常处理</h4><p>在实现过程中，我们还需要考虑常见的错误和异常应该如何处理，特别是涉及到用户输入的部分，同时，我们还需要针对是否使用异常机制进行一些斟酌。</p>
<h2 id="代码静态检查"><a href="#代码静态检查" class="headerlink" title="代码静态检查"></a>代码静态检查</h2><p>所谓代码静态检查，是指在代码未运行期间，通过对源代码的阅读和审查，保证软件的质量和规范性。为了规范化审查流程，本节给出一些静态检查工具以及静态检查Checklist，帮助我们更好地进行代码静态检查过程。</p>
<h3 id="缺陷检查表"><a href="#缺陷检查表" class="headerlink" title="缺陷检查表"></a>缺陷检查表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>常见缺陷</th>
<th>类别</th>
<th>常见缺陷</th>
</tr>
</thead>
<tbody>
<tr>
<td>编程规范</td>
<td>命名规则、注释、排版、声明初始化、语言格式等</td>
<td>程序流程</td>
<td>循环结束条件是否准确</td>
</tr>
<tr>
<td>面向对象设计</td>
<td>类的设计与抽象是否合适</td>
<td></td>
<td>是否避免了死循环的产生</td>
</tr>
<tr>
<td></td>
<td>是否符合面向接口编程的思想</td>
<td></td>
<td>对循环处理是否合适，是否避免多层嵌套</td>
</tr>
<tr>
<td></td>
<td>是否使用合适的设计模式</td>
<td></td>
<td></td>
</tr>
<tr>
<td>性能方面</td>
<td>是否能够正确处理海量数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>是否选择了合适的数据结构并进行了设置</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>是否滥用数据结构</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>是否采用通用线程池或对象池等高速缓存技术</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>接口是否设计合理，内部是否尽可能没有类型转换</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>是否采用内存或硬盘缓冲机制提高效率</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>并发访问策略</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>IO方面是否使用合适的类或良好的方法提高性能，例如减少序列化，使用buffer类封装</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>同步方法是否正确使用而没有滥用</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>递归迭代深度是否合适</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>如果有阻塞，是否考虑了性能保证的措施</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>避免过度优化，对性能要求高的代码</td>
<td></td>
<td></td>
</tr>
<tr>
<td>资源管理</td>
<td>分配内存是否释放，错误发生时是否保证所有资源都释放掉，是否同一个对象多次释放</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>代码是否保存准确的引用计数</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="代码静态分析工具"><a href="#代码静态分析工具" class="headerlink" title="代码静态分析工具"></a>代码静态分析工具</h3><p>这里给出一些常用的代码分析工具，具体的应用方式请参考</p>
<h4 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h4><p><a href="http://cppcheck.net/">cppcheck：一个C++代码静态检查工具</a></p>
<h2 id="代码性能分析及优化"><a href="#代码性能分析及优化" class="headerlink" title="代码性能分析及优化"></a>代码性能分析及优化</h2><p>优化的目的：<strong>结果相同，效率更高</strong>，根据2/8原则，实现程序重构、优化、扩展及文档相关内容一般会消耗80%工作量。</p>
<h3 id="优化的要点及原则"><a href="#优化的要点及原则" class="headerlink" title="优化的要点及原则"></a>优化的要点及原则</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul>
<li>针对时间和空间两个方面进行优化</li>
<li>正确性、可靠性、健壮性、可读性是前提</li>
<li>全局效率为主，局部效率为辅</li>
<li>先找到代码中的效率瓶颈</li>
<li><strong>先优化数据结构和算法，后优化执行代码</strong></li>
<li>时间效率和空间效率可能是对立的，此时就需要进行权衡</li>
<li>从设计之初就开始考虑优化程序性能</li>
<li>测试数据很重要，要覆盖所有情况</li>
<li>永远不要在执行性能评估的情况下尝试对代码优化</li>
</ul>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>一般来说，优化是一个追求性价比的问题，要优先对优化性价比最高的部分进行优化，所谓性价比，是指投入的优化精力和得到的优化效果达到平衡的一个时刻。并不是说程序最耗时的部分就是最难优化的，因为可能这部分优化起来很困难。记住一个原则：<strong>进行最有性价比的优化。</strong></p>
<h3 id="优化的一般步骤"><a href="#优化的一般步骤" class="headerlink" title="优化的一般步骤"></a>优化的一般步骤</h3><pre class="mermaid">graph LR
    node["证明需要优化"]
    node1["找出优化关键部分"]
    node2["代码测试"]
    node3["进行优化"]
    node4["评测优化结果"]

    node-->node1 
    node1-->node2
    node2-->node3
    node3-->node4</pre>

<h3 id="案例：词频统计代码"><a href="#案例：词频统计代码" class="headerlink" title="案例：词频统计代码"></a>案例：词频统计代码</h3><p>使用Python读入一个文本文件，然后统计该文本文件中英文单词出现的频率，并输出词频最高的100个单词，单词指的是被空格和标点符号进行分割的字符串。Python的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitWords</span><span class="params">(InputFile)</span></span></span><br><span class="line"><span class="function">	# 文件<span class="title">IO</span></span></span><br><span class="line"><span class="function">	<span class="title">try</span>:</span></span><br><span class="line">        alltext = fileobject.read()    <span class="comment"># 文件IO通常比较慢</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        fileobject.close()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分割单词</span></span><br><span class="line">    words = re.split(<span class="string">'[^a-zA-Z]+'</span>, alltext)  <span class="comment"># 使用正则表达式分词</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计单词词频</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> dic.keys():         <span class="comment"># 词频统计</span></span><br><span class="line">            dic[word] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dic[word] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 排序</span></span><br><span class="line">    result = sorted(dic.items(), key = <span class="keyword">lambda</span> dic:dic[<span class="number">1</span>], reverse = <span class="literal">True</span>) <span class="comment"># 排序，使用内置算法</span></span><br></pre></td></tr></table></figure>
<p>为了获得影响程序性能的部分，我们需要一定的工具对代码进行测试，确定性能瓶颈，python中提供了profile帮助我们自动确定软件的性能，一个简单的使用例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profileTest</span><span class="params">()</span>:</span></span><br><span class="line">    Total = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Total = Total*(i+<span class="number">1</span>)</span><br><span class="line">        print(Total)</span><br><span class="line">    <span class="keyword">return</span> Total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    profile.run(<span class="string">"profileTest()"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      15 function calls in 0.016 seconds</span><br><span class="line"></span><br><span class="line">Ordered by: standard name</span><br><span class="line">ncalls    tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">     1    0.000    0.000    0.000    0.000 :0(exec)</span><br><span class="line">    10    0.000    0.000    0.000    0.000 :0(print)</span><br><span class="line">     1    0.016    0.016    0.016    0.016 :0(setprofile)</span><br><span class="line">     1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)</span><br><span class="line">     1    0.000    0.000    0.016    0.016 profile:0(profileTest())</span><br><span class="line">     0    0.000             0.000          profile:0(profiler)</span><br><span class="line">     1    0.000    0.000    0.000    0.000 profileTest.py:3(profileTest)</span><br></pre></td></tr></table></figure>
<p>可以看到函数的调用次数以及运行时间，具体参数解释如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ncalls</td>
<td>调用次数</td>
</tr>
<tr>
<td>tottime</td>
<td>函数运行总时间，除去函数中调用的其他函数</td>
</tr>
<tr>
<td>percall</td>
<td>一次时间</td>
</tr>
<tr>
<td>cumtime</td>
<td>函数运行总时间，包括函数中调用的其他函数</td>
</tr>
<tr>
<td>filename:lineno(function)</td>
<td>文件名，函数行号，函数名</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h2><p>所谓结对编程，就是两人合作，同时针对一个功能进行开发，类似于开车过程中的领航员和驾驶员，合作可能得到更优的结果</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">Google C++编程风格</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://github.com/seajs/seajs/issues/545">如何正确提问</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>软件设计概要说明书</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81%E8%AF%B4%E6%98%8E%E4%B9%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>preparation may quicken the process</p>
</blockquote>
<a id="more"></a>
<h2 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h2><h3 id="什么是概要设计"><a href="#什么是概要设计" class="headerlink" title="什么是概要设计"></a>什么是概要设计</h3><p>确定软件系统的总体布局，各个子模块的功能和模块间的关系，与外部系统的关系，选择的技术路线。有一些研究与论证性的内容。并输出《软件概要设计说明书》。<strong>搞清楚“总体实现方案”</strong>。概要设计是用来评价软件整体设计可行性的重要支撑标准，由于每个模块这个阶段已经开始确定，可以很好的检查已有的模块是否已经足够完整，还可以用于评估工作量以及知道下一步的主要计划，它是一个纲领。</p>
<h3 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h3><ul>
<li>用来评价总体设计的可行性。</li>
<li>用来检查设计的模块是否完整，保证每一个功能都有对应的模块来实现。</li>
<li>用来评估开发工作量、指导开发计划（在不写详细设计的情况下）。</li>
<li><strong>概要设计阶段过于重视业务流程是个误区。</strong></li>
</ul>
<h2 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h3><h4 id="1-1-编写目的"><a href="#1-1-编写目的" class="headerlink" title="1.1 编写目的"></a>1.1 编写目的</h4><p>本阶段完成系统的大致设计并明确系统的数据结构与软件结构。本概要设计说明书的目的就是进一步细化软件设计阶段得出的软件概貌，把它加工成在程序细节上非常接近与源程序开发的软件表示。</p>
<h4 id="1-2-预期读者"><a href="#1-2-预期读者" class="headerlink" title="1.2 预期读者"></a>1.2 预期读者</h4><p>开发人员、测试人员、分析人员</p>
<h4 id="1-3-项目背景"><a href="#1-3-项目背景" class="headerlink" title="1.3 项目背景"></a>1.3 项目背景</h4><h5 id="1-3-1-相关单位"><a href="#1-3-1-相关单位" class="headerlink" title="1.3.1 相关单位"></a>1.3.1 相关单位</h5><ul>
<li>任务提出者：xxx人员</li>
<li>开发者：xxx</li>
<li>使用者：</li>
</ul>
<h4 id="1-4-定义"><a href="#1-4-定义" class="headerlink" title="1.4 定义"></a>1.4 定义</h4><p>列出本文档中所用到的专门术语的定义和缩写词的原意</p>
<h4 id="1-5-参考资料"><a href="#1-5-参考资料" class="headerlink" title="1.5 参考资料"></a>1.5 参考资料</h4><h3 id="2-总体设计"><a href="#2-总体设计" class="headerlink" title="2 总体设计"></a>2 总体设计</h3><h4 id="2-1-设计前提和约束条件"><a href="#2-1-设计前提和约束条件" class="headerlink" title="2.1 设计前提和约束条件"></a>2.1 设计前提和约束条件</h4><ol>
<li>系统用户登陆通过与认证系统实名认证；</li>
<li>有合理的通知功能；</li>
<li>遵循项目开发文档所制定的规范；</li>
<li>符合系统权限要求。</li>
</ol>
<h4 id="2-2-基本设计思想"><a href="#2-2-基本设计思想" class="headerlink" title="2.2 基本设计思想"></a>2.2 基本设计思想</h4><p>写出软件的基本设计思路，突出软件的优点，一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">建设项目信息管理涉及业主方、设计单位、施工单位、运营管理单位、政府部门等众多参与方，信息量巨大，信息交换复杂。而传统的信息管理方式凌乱无序，信息利用率低。</span><br><span class="line"></span><br><span class="line">因此，基于BIM的信息管理框架的构建思路的核心就是要改变传统的信息传递和共享方式，通过BIM将不同阶段、不同参与方之间的信息有效地集成起来，真正实现建设项目全生命周期的信息管理。因此，基于BIM的建设项目全生命周期信息管理框架的构建主要从以下三点展开：</span><br><span class="line"></span><br><span class="line">（1）数据问题：</span><br><span class="line"></span><br><span class="line">建设项目信息管理过程中，产生的信息形式多样，各参与方所用的信息管理软件不尽相同，如何实现BIM数据和其他形式数据的共享和利用，保证不同阶段产生的信息能够持续应用，而避免重复输入，就需要建立可以保证不同BIM应用之间的信息提取、关联及扩展的数据库，该数据库也是基于BIM的信息管理框架的基础。</span><br><span class="line"></span><br><span class="line">（2）信息模型：</span><br><span class="line"></span><br><span class="line">数据库是存储信息的地方，而信息模型是承载信息的载体。随着建设项目的进展，信息数据不断增加，如何保证这些信息分门别类有效地存储，需要在全生命周期不同阶段，针对不同的BIM应用形成子信息模型，由各子信息模型来承载不同专业和类别的信息，以保证信息的有序。子信息模型通过提取上一阶段信息模型中的数据，然后再经过扩展和集成，如此继续反复，最终形成全生命周期信息模型。</span><br><span class="line"></span><br><span class="line">（3）功能实现：</span><br><span class="line"></span><br><span class="line">对信息进行存储和管理的最终目的就是有效地应用信息，进行建设项目管理，因此，在管理框架的最上层为功能模块层。不同的功能模块对应着不同的BIM应用，也即为一个功能子信息模型。使用多种研发技术、中间件、设备搭建基于互联网环境的轻量化BIM信息管理平台；采用B/S架构构建平台；</span><br><span class="line"></span><br><span class="line">具体通过以下技术实现：</span><br><span class="line"></span><br><span class="line">基于OpenGL的三维模型引擎，集成BIM+GIS数据；</span><br><span class="line">基于ActiveX的浏览器、移动端APP模型引擎部署；</span><br><span class="line">基于关系型数据库SQL Server的结构化构件数据存储、检索；</span><br><span class="line">基于React的H5前端研发技术；</span><br><span class="line">基于PHP的表单、流程处理功能开发；</span><br><span class="line">基于MySQL的业务表单、流程数据存储；</span><br><span class="line">基于萤石云的视频监控中间件集成。</span><br></pre></td></tr></table></figure>
<h4 id="2-3-总体结构及概要"><a href="#2-3-总体结构及概要" class="headerlink" title="2.3 总体结构及概要"></a>2.3 总体结构及概要</h4><p>概述软件总体结构，或者放一个业务流程图，并做简要介绍</p>
<h4 id="2-4-功能分配"><a href="#2-4-功能分配" class="headerlink" title="2.4 功能分配"></a>2.4 功能分配</h4><p>表明各项功能与程序结构及模块的关系</p>
<h3 id="3-模块概要设计"><a href="#3-模块概要设计" class="headerlink" title="3 模块概要设计"></a>3 模块概要设计</h3><p>模块设计,可以写以下内容：</p>
<ol>
<li>模块描述：说明哪些模块实现了哪些功能；</li>
<li>模块层次结构：可以使用某个视角的软件框架图来表达；</li>
<li>模块间的关系：模块间依赖关系的描述，通信机制描述；</li>
<li>处理方式设计：说一些满足功能和性能的算法；</li>
</ol>
<h4 id="3-1-模块描述"><a href="#3-1-模块描述" class="headerlink" title="3.1 模块描述"></a>3.1 模块描述</h4><div class="table-container">
<table>
<thead>
<tr>
<th>模块名称</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>xxx模块</td>
<td>实现自动路径规划算法</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-2-模块层次结构及关系"><a href="#3-2-模块层次结构及关系" class="headerlink" title="3.2 模块层次结构及关系"></a>3.2 模块层次结构及关系</h4><h3 id="4-接口设计"><a href="#4-接口设计" class="headerlink" title="4 接口设计"></a>4 接口设计</h3><h4 id="4-1-外部接口"><a href="#4-1-外部接口" class="headerlink" title="4.1 外部接口"></a>4.1 外部接口</h4><p>包括软件接口及硬件接口。其中用户界面应当给出总体设计框图及开发框架；软件接口应当给出一些输入输出及通信接口，例如采用Visual C#提供与SQL Server2000连接进行访问数据库的操作等；硬件接口应给出输入/输出所需的软硬件环境等。</p>
<h4 id="4-2-内部接口"><a href="#4-2-内部接口" class="headerlink" title="4.2 内部接口"></a>4.2 内部接口</h4><p>模块之间的接口，确定模块间的连接是怎样的，同时确定模块间信息传递方式，例如采用函数调用、参数传递、返回值的方式。具体参数的结构将在数据结构设计的内容中说明。接口传递的信息将是以数据结构封装了的数据，以参数传递或返回值的形式在各模块间传输。</p>
<h4 id="4-3-用户接口"><a href="#4-3-用户接口" class="headerlink" title="4.3 用户接口"></a>4.3 用户接口</h4><p>用户接口是系统与用户进行信息交换的媒介，一般指软件接口，包括命令接口、程序接口和图形接口</p>
<h3 id="5-运行设计"><a href="#5-运行设计" class="headerlink" title="5 运行设计"></a>5 运行设计</h3><p>在运行设计中，我们主要考虑运行时模块的组合、控制以及时间</p>
<h4 id="5-1-运行模块组合"><a href="#5-1-运行模块组合" class="headerlink" title="5.1 运行模块组合"></a>5.1 运行模块组合</h4><p>在用户选择</p>
<h2 id="范例——软件注册机程序"><a href="#范例——软件注册机程序" class="headerlink" title="范例——软件注册机程序"></a>范例——软件注册机程序</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="编写目的"><a href="#编写目的" class="headerlink" title="编写目的"></a>编写目的</h4><p>本概要设计说明书的目的就是进一步细化软件注册机程序设计阶段得出的软件概貌，把它加工成在程序细节上非常接近与源程序开发的软件表示。</p>
<h4 id="预期读者"><a href="#预期读者" class="headerlink" title="预期读者"></a>预期读者</h4><p>开发人员、测试人员、分析人员</p>
<h4 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h4><h5 id="相关单位"><a href="#相关单位" class="headerlink" title="相关单位"></a>相关单位</h5><ul>
<li>任务提出者：xxx人员</li>
<li>开发者：xxx</li>
<li>使用者：</li>
</ul>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><h4 id="总体结构及概要"><a href="#总体结构及概要" class="headerlink" title="总体结构及概要"></a>总体结构及概要</h4><p> <img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/RegisterStructure.png" width = "300"  alt="图片名称" align=center /></p>
<p>本系统采用三层架构进行设计，层与层之间采用C++接口进行衔接，降低了模块耦合度，并使用工厂模式实现对不同需求对应接口的不同实现，并在每一层功能完成后进行相应层的单元测试，对开发过程中避免了很多不必要的麻烦，节约了开发时间。本系统在开发过程中实现了国际化框架，可以识别不同的浏览器语言相应的显示对应语言的内容，由于开发时间限制，语言包只提供了缺省的中文语言包。</p>
<p><strong>表示层</strong>：该系统具有产品注册和注册码生成两个会话界面，对用户输入的注册信息进行了验证，能够有效约束不符合条件的验证信息，及时在屏幕上反馈给用户，只对符合要求的注册信息提交给下层业务处理层，保证了业务处理层接收到的表单信息的纯净性。</p>
<p><strong>业务逻辑层</strong>：对本系统需要提供的功能进行封装和分类，分成RegisterService和RegisterCodeService两个字系统。</p>
<p><strong>数据访问层</strong>：数据访问层对PC的注册表进行访问，从而实现注册功能。</p>
<h3 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h3><h4 id="模块描述"><a href="#模块描述" class="headerlink" title="模块描述"></a>模块描述</h4><div class="table-container">
<table>
<thead>
<tr>
<th>模块名称</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>UI模块</td>
<td>负责与用户进行交互，根据用户输入的功能，调用不同的模块完成不同的业务逻辑，包括产品注册码生成、产品注册以及软件试用模块</td>
<td></td>
</tr>
<tr>
<td>产品注册模块</td>
<td>负责实现软件注册功能，通过用户提供的注册码，调用注册表管理模块，实现注册表注册</td>
<td></td>
</tr>
<tr>
<td>注册码生成模块</td>
<td>根据用户输入的用户名，生成有效的注册码</td>
<td></td>
</tr>
<tr>
<td>注册表管理模块</td>
<td>负责用户注册表的生成及管理功能</td>
<td></td>
</tr>
<tr>
<td>软件试用管理模块</td>
<td>负责软件试用的管理</td>
</tr>
</tbody>
</table>
</div>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><h4 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h4><h5 id="软件接口"><a href="#软件接口" class="headerlink" title="软件接口"></a>软件接口</h5><p>系统使用Qt库中的QSetting实现对注册表的访问</p>
<h5 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h5><p>输入：采用键盘、鼠标及Qt/C++中标准输入进行输入处理。</p>
<p>输出：采用Qt/C++中标准输出或其他输出设备对输出进行处理</p>
<h4 id="内部接口"><a href="#内部接口" class="headerlink" title="内部接口"></a>内部接口</h4><h5 id="UI模块"><a href="#UI模块" class="headerlink" title="UI模块"></a>UI模块</h5><h5 id="产品注册模块"><a href="#产品注册模块" class="headerlink" title="产品注册模块"></a>产品注册模块</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">接口名称</th>
<th style="text-align:left">输入及输入格式</th>
<th style="text-align:left">输出及输出格式</th>
<th>功能</th>
<th>属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GetCPUID()</td>
<td style="text-align:left">null</td>
<td style="text-align:left">CPU ID：string</td>
<td>获得CPU ID号码</td>
<td>public</td>
</tr>
<tr>
<td style="text-align:left">GetDiskID()</td>
<td style="text-align:left">null</td>
<td style="text-align:left">Disk ID：string</td>
<td>获得磁盘 ID号码</td>
<td>public</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h5 id="注册码生成模块"><a href="#注册码生成模块" class="headerlink" title="注册码生成模块"></a>注册码生成模块</h5><h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><h5 id="用户图形界面"><a href="#用户图形界面" class="headerlink" title="用户图形界面"></a>用户图形界面</h5><p>用户图形界面总体设计，用户图形界面使用Qt Quick实现UI设计</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/UIDesignStructure.png" width = "500"  alt="图片名称" align=center /></p>
<h3 id="运行设计"><a href="#运行设计" class="headerlink" title="运行设计"></a>运行设计</h3><p>客户在注册码生成器UI模块中输入用户名，由注册码生成模块产生相应的注册码，并写入注册码文件中。</p>
<p>用户在注册UI模块中选择注册或试用产品，如选择注册，则调用产品注册模块，通过用户提供的注册码，调用注册表管理模块，实现注册功能；如选择试用，则调用软件试用模块，软件试用模块调用注册表管理模块，根据注册表中的剩余使用次数，决定是否允许用户试用。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>Blender常用快捷键</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/Blender/Blender%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>记录Blender中自己常用的快捷键</p>
<a id="more"></a>
<h2 id="对象选择"><a href="#对象选择" class="headerlink" title="对象选择"></a>对象选择</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>图片</th>
</tr>
</thead>
<tbody>
<tr>
<td>鼠标左键/<code>shift</code></td>
<td>选择</td>
<td></td>
</tr>
<tr>
<td>1/2/3</td>
<td>选择模式：点/线/面</td>
<td></td>
</tr>
<tr>
<td><code>ctrl + i</code></td>
<td>反向选择</td>
<td></td>
</tr>
<tr>
<td><code>H</code></td>
<td>隐藏对象</td>
</tr>
</tbody>
</table>
</div>
<h2 id="对象关系"><a href="#对象关系" class="headerlink" title="对象关系"></a>对象关系</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>图片</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>p</code></td>
<td>拆分对象</td>
<td></td>
</tr>
<tr>
<td><code>ctrl + j</code></td>
<td>合并对象</td>
</tr>
</tbody>
</table>
</div>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>图片</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shift + a</code></td>
<td>创建新对象</td>
<td></td>
</tr>
<tr>
<td><code>shift + d</code></td>
<td>复制新对象</td>
</tr>
</tbody>
</table>
</div>
<h2 id="对象位置"><a href="#对象位置" class="headerlink" title="对象位置"></a>对象位置</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>g + xyz</code></td>
<td>将物体沿着x、y、z轴移动</td>
<td>如果按住ctrl，是网格捕捉移动</td>
</tr>
<tr>
<td><code>shift + TAB</code></td>
<td>移动时吸附</td>
</tr>
</tbody>
</table>
</div>
<h2 id="对象查看"><a href="#对象查看" class="headerlink" title="对象查看"></a>对象查看</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>图片</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alt + z</code></td>
<td>打开x-ray</td>
</tr>
</tbody>
</table>
</div>
<h2 id="轮盘"><a href="#轮盘" class="headerlink" title="轮盘"></a>轮盘</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>图片</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shift + s</code></td>
<td>打开光标轮盘（可以设置光标的位置到指定对象上）</td>
<td></td>
</tr>
<tr>
<td><code>z</code></td>
<td>着色轮盘</td>
</tr>
</tbody>
</table>
</div>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tab</td>
<td>切换编辑模式</td>
<td>如果按1/2/3可以切换点线面选择</td>
</tr>
<tr>
<td>X</td>
<td>删除</td>
<td></td>
</tr>
<tr>
<td>shift-s</td>
<td>打开锚点设置轮盘</td>
<td></td>
</tr>
<tr>
<td>ctrl-r</td>
<td>Loop cut</td>
<td>在某个面上切分一条线，细分模型</td>
</tr>
<tr>
<td>ctrl-b</td>
<td></td>
<td>倒角，和ctrl-r结合使用可以创建细分面</td>
</tr>
<tr>
<td>i</td>
<td></td>
<td>选中某个面之后缩放</td>
</tr>
<tr>
<td>e</td>
<td></td>
<td>将某个面挤出</td>
</tr>
</tbody>
</table>
</div>
<h3 id="编辑模式下操作"><a href="#编辑模式下操作" class="headerlink" title="编辑模式下操作"></a>编辑模式下操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>键位</th>
<th>功能</th>
<th>图片</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tab<br />选择Select mode为face select<br />X delete faces</td>
<td>删除某个面</td>
<td></td>
</tr>
<tr>
<td>shift + tab</td>
<td>开启/关闭吸附功能</td>
<td></td>
</tr>
<tr>
<td>Alt</td>
<td>选择某行线或者面</td>
<td></td>
</tr>
<tr>
<td>o</td>
<td>Proportional Editing，比例编辑，会同时修改比例圈中所有的点/边/面</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>选择好某些点之后，可以按F进行填充</td>
</tr>
</tbody>
</table>
</div>
<h2 id="运动控制"><a href="#运动控制" class="headerlink" title="运动控制"></a>运动控制</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>图片</th>
</tr>
</thead>
<tbody>
<tr>
<td>shift + F12</td>
<td>打开time line</td>
</tr>
</tbody>
</table>
</div>
<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
<th>图片</th>
</tr>
</thead>
<tbody>
<tr>
<td>N</td>
<td>切换显示侧栏</td>
</tr>
</tbody>
</table>
</div>
<h2 id="视角切换"><a href="#视角切换" class="headerlink" title="视角切换"></a>视角切换</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shift + 左键</code></td>
<td>平移拖动</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>~（数字键1旁边的）</td>
<td>视角转盘</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>小键盘0</td>
<td>切换至主摄像机</td>
</tr>
<tr>
<td>Ctrl 0</td>
<td>切换至选择的摄像机</td>
</tr>
<tr>
<td>Ctrl Alt 0</td>
<td>将摄像机切换至当前视角</td>
</tr>
<tr>
<td>Shift <code>~</code></td>
<td>摄像机飞行（wasd控制前后左右，qe控制上下）</td>
</tr>
<tr>
<td>小键盘<code>.</code></td>
<td>切换至选择的物体</td>
</tr>
</tbody>
</table>
</div>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>F12</td>
<td>开始渲染</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>生活</category>
        <category>Blender</category>
      </categories>
  </entry>
  <entry>
    <title>Blender材质</title>
    <url>/2024/10/17/%E7%94%9F%E6%B4%BB/Blender/Blender%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将介绍如何在Blender中创建并添加材质</p>
<a id="more"></a>
<p>材质有三类关键的参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
<th>子参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Surface</td>
<td>使用最多的一类参数，决定物体表面材质，例如纸张、木头或金属</td>
<td>Shader</td>
<td>选择shader，默认是Principled BSDF</td>
</tr>
<tr>
<td>Volume</td>
<td>决定物体内填充的材质，通常用于创造烟雾、云、液体等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Displacement</td>
<td>网格的偏移，通常在创建一些具有凹凸纹理（例如砖墙）时使用</td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>生活</category>
        <category>Blender</category>
      </categories>
  </entry>
  <entry>
    <title>Blender 光</title>
    <url>/2024/12/03/%E7%94%9F%E6%B4%BB/Blender/Blender%20%E5%85%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>上帝说：要有光</p>
</blockquote>
<a id="more"></a>
]]></content>
      <categories>
        <category>生活</category>
        <category>Blender</category>
      </categories>
  </entry>
  <entry>
    <title>Blender渲染</title>
    <url>/2025/01/03/%E7%94%9F%E6%B4%BB/Blender/Blender%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>记录一下blender中的渲染过程</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>生活</category>
        <category>Blender</category>
      </categories>
  </entry>
  <entry>
    <title>AE：人物动作篇</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/AE%EF%BC%9A%E4%BA%BA%E7%89%A9%E5%8A%A8%E4%BD%9C%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://github.com/sqduan/hexoimg/blob/master/65c256a3ef12d23439db6f0816b92e60.gif?raw=true" alt="" align=center /></p>
<p>总结AE中人物动作相关的常见方法</p>
<a id="more"></a>
<h1 id="钢笔"><a href="#钢笔" class="headerlink" title="钢笔"></a>钢笔</h1><p>在看完后面的内容前，请先学习钢笔的使用方法：<a href="https://www.bilibili.com/video/BV1ek4y1k7VM/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0ac0f268155ca9fe0a7df16b11051b29">钢笔的使用方法</a>。钢笔的使用对我们后续的路径绘：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>画板放大缩小</td>
<td>ALT+滚轮</td>
<td></td>
</tr>
<tr>
<td>画布移动</td>
<td>空格键+鼠标拖动</td>
<td></td>
</tr>
<tr>
<td>结束钢笔工具</td>
<td>Enter</td>
</tr>
</tbody>
</table>
</div>
<p>ALT的作用是移动/删除/增加控制杆</p>
<h1 id="基础运动"><a href="#基础运动" class="headerlink" title="基础运动"></a>基础运动</h1><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><ul>
<li>用钢笔绘制出路径，会生成一个形状图层</li>
<li>选择图形的<strong>内容-形状-路径</strong>并复制</li>
<li>选择待移动的对象，<strong>变换-位置</strong>并粘贴</li>
</ul>
<h1 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h1><h2 id="运动捕捉"><a href="#运动捕捉" class="headerlink" title="运动捕捉"></a>运动捕捉</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=N4Z4MdZ1KWY&amp;list=PLR3Ra9cf8aV2Zl8LIqT93rsgnpkSvmevk&amp;index=2&amp;ab_channel=MortMort">Youtube 上关于Aseprite的教程</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.mortmort.net/">mortmort官网</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>生活</category>
        <category>AE</category>
      </categories>
  </entry>
  <entry>
    <title>AE：完整例子</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/AE%EF%BC%9A%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://github.com/sqduan/hexoimg/blob/master/65c256a3ef12d23439db6f0816b92e60.gif?raw=true" alt="" align=center /></p>
<p>总结一些不错的AE的例子以供学习</p>
<a id="more"></a>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=--oTQCysVTs">AE MG动画——游泳小人</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>生活</category>
        <category>AE</category>
      </categories>
  </entry>
  <entry>
    <title>AE效果大全</title>
    <url>/2025/01/01/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/AE%EF%BC%9A%E6%95%88%E6%9E%9C%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://github.com/sqduan/hexoimg/blob/master/65c256a3ef12d23439db6f0816b92e60.gif?raw=true" alt="" align=center /></p>
<p>本文将整理AE常用到的一些效果</p>
<a id="more"></a>
<h2 id="扭曲效果"><a href="#扭曲效果" class="headerlink" title="扭曲效果"></a>扭曲效果</h2><h3 id="湍流置换"><a href="#湍流置换" class="headerlink" title="湍流置换"></a>湍流置换</h3><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>数量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>大小</td>
<td></td>
<td></td>
</tr>
<tr>
<td>复杂度</td>
<td></td>
<td></td>
</tr>
<tr>
<td>演化</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=b0JesMPdeIk&amp;ab_channel=ChrisOVEMERY">Wiggly/Jittery/shaking animation, how and why - AFTER EFFECTS TUTORIAL</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.bilibili.com/video/BV11v411v7ud/?vd_source=0ac0f268155ca9fe0a7df16b11051b29">一个简单的扭曲效果居然还能这么玩？举一反三一下看看ae湍流置换还有哪些玩法。_哔哩哔哩_bilibili</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>生活</category>
        <category>AE</category>
      </categories>
  </entry>
  <entry>
    <title>AE 背景音乐收集</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/AE%EF%BC%9A%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://github.com/sqduan/hexoimg/blob/master/65c256a3ef12d23439db6f0816b92e60.gif?raw=true" alt="" align=center /></p>
<blockquote>
<p>我恳求现实胜过剧作的精彩，并且生活并非像虚构情节那样悲伤</p>
</blockquote>
<a id="more"></a>
<h1 id="About-Life"><a href="#About-Life" class="headerlink" title="About Life"></a>About Life</h1><div class="table-container">
<table>
<thead>
<tr>
<th>Title</th>
<th>Link</th>
<th>Remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>Married Life</td>
<td><a href="https://soundcloud.com/reminiscience/michael-giacchino-married-life">纯钢琴版</a></td>
<td>我们度过的每一个日常（cheems小曲）</td>
</tr>
<tr>
<td>哥德堡变奏曲</td>
<td><a href="https://www.musicenc.com/article/1138809.html">纯钢琴版</a></td>
<td>像是走在寂静的夜晚</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="About-Love"><a href="#About-Love" class="headerlink" title="About Love"></a>About Love</h1><div class="table-container">
<table>
<thead>
<tr>
<th>Title</th>
<th>Link</th>
<th>Remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>To the Moon</td>
<td><a href="https://downloads.khinsider.com/game-soundtracks/album/to-the-moon/27%2520To%2520the%2520Moon%2520%2520-%2520Piano%2520%2528Ending%2520Version%2529.mp3">纯钢琴版</a></td>
<td></td>
</tr>
<tr>
<td>Air on the G string</td>
<td><a href="https://www.youtube.com/watch?app=desktop&amp;v=G5-gATRSF6g">Get Music and SFX that Actually Sound Good (youtube.com)</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>生活</category>
        <category>AE</category>
      </categories>
  </entry>
  <entry>
    <title>AE常用快捷键</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/AE%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://github.com/sqduan/hexoimg/blob/master/65c256a3ef12d23439db6f0816b92e60.gif?raw=true" alt="" align=center /></p>
<p>总结AE中常用的快捷键</p>
<a id="more"></a>
<h2 id="基本快捷键"><a href="#基本快捷键" class="headerlink" title="基本快捷键"></a>基本快捷键</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>V</td>
<td>选取工具</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="合成属性"><a href="#合成属性" class="headerlink" title="合成属性"></a>合成属性</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>位置</td>
</tr>
<tr>
<td>T</td>
<td>透明度</td>
</tr>
</tbody>
</table>
</div>
<h2 id="时间轴与合成"><a href="#时间轴与合成" class="headerlink" title="时间轴与合成"></a>时间轴与合成</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl Shift D</td>
<td>将合成拆分成两个</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>生活</category>
        <category>AE</category>
      </categories>
  </entry>
  <entry>
    <title>AE运动篇1-0 钢笔及运动基础</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/AE%EF%BC%9A%E8%BF%90%E5%8A%A8%E7%AF%871-0%20%E9%92%A2%E7%AC%94%E5%8F%8A%E8%BF%90%E5%8A%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://github.com/sqduan/hexoimg/blob/master/65c256a3ef12d23439db6f0816b92e60.gif?raw=true" alt="" align=center /></p>
<p>总结AE中人物动作相关的常见方法。</p>
<a id="more"></a>
<h1 id="钢笔"><a href="#钢笔" class="headerlink" title="钢笔"></a>钢笔</h1><p>在看完后面的内容前，请先学习钢笔的使用方法：<a href="https://www.bilibili.com/video/BV1ek4y1k7VM/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0ac0f268155ca9fe0a7df16b11051b29">钢笔的使用方法</a>。钢笔的使用对我们后续的路径绘：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>画板放大缩小</td>
<td>ALT+滚轮</td>
<td></td>
</tr>
<tr>
<td>画布移动</td>
<td>空格键+鼠标拖动</td>
<td></td>
</tr>
<tr>
<td>结束钢笔工具</td>
<td>Enter</td>
</tr>
</tbody>
</table>
</div>
<p>ALT的作用是移动/删除/增加控制杆</p>
<h1 id="基础运动"><a href="#基础运动" class="headerlink" title="基础运动"></a>基础运动</h1><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><ul>
<li>用钢笔绘制出路径，会生成一个形状图层</li>
<li>选择图形的<strong>内容-形状-路径</strong>并复制</li>
<li>选择待移动的对象，<strong>变换-位置</strong>并粘贴</li>
</ul>
<h1 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h1><h2 id="运动捕捉"><a href="#运动捕捉" class="headerlink" title="运动捕捉"></a>运动捕捉</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=N4Z4MdZ1KWY&amp;list=PLR3Ra9cf8aV2Zl8LIqT93rsgnpkSvmevk&amp;index=2&amp;ab_channel=MortMort">Youtube 上关于Aseprite的教程</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.mortmort.net/">mortmort官网</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>生活</category>
        <category>AE</category>
      </categories>
  </entry>
  <entry>
    <title>PS基本操作</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/PS%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://fiverr-res.cloudinary.com/images/q_auto,f_auto/gigs/41694069/original/66a90c41f4dbbe1fcbfe6c4a4a4f03dc5ebea34b/create-a-pixel-art-background-and-scenery.png" alt="" align=center /></p>
<p>本文将总结一些常用PS操作。</p>
<a id="more"></a>
<h2 id="图片变换"><a href="#图片变换" class="headerlink" title="图片变换"></a>图片变换</h2><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><h3 id="字符字体"><a href="#字符字体" class="headerlink" title="字符字体"></a>字符字体</h3><p><a href="https://www.dafont.com/bitmap.php">像素字符网站</a></p>
]]></content>
      <categories>
        <category>生活</category>
        <category>美术</category>
        <category>PS</category>
      </categories>
  </entry>
  <entry>
    <title>AE运动篇1-0 钢笔及运动基础</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/AE%EF%BC%9A%E8%BF%90%E5%8A%A8%E7%AF%871-x%20%E4%BA%BA%E7%89%A9%E8%BF%90%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://github.com/sqduan/hexoimg/blob/master/65c256a3ef12d23439db6f0816b92e60.gif?raw=true" alt="" align=center /></p>
<p>总结AE中人物动作相关的常见方法。</p>
<a id="more"></a>
<h1 id="钢笔"><a href="#钢笔" class="headerlink" title="钢笔"></a>钢笔</h1><p>在看完后面的内容前，请先学习钢笔的使用方法：<a href="https://www.bilibili.com/video/BV1ek4y1k7VM/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0ac0f268155ca9fe0a7df16b11051b29">钢笔的使用方法</a>。钢笔的使用对我们后续的路径绘：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>画板放大缩小</td>
<td>ALT+滚轮</td>
<td></td>
</tr>
<tr>
<td>画布移动</td>
<td>空格键+鼠标拖动</td>
<td></td>
</tr>
<tr>
<td>结束钢笔工具</td>
<td>Enter</td>
</tr>
</tbody>
</table>
</div>
<p>ALT的作用是移动/删除/增加控制杆</p>
<h1 id="基础运动"><a href="#基础运动" class="headerlink" title="基础运动"></a>基础运动</h1><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><ul>
<li>用钢笔绘制出路径，会生成一个形状图层</li>
<li>选择图形的<strong>内容-形状-路径</strong>并复制</li>
<li>选择待移动的对象，<strong>变换-位置</strong>并粘贴</li>
</ul>
<h1 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h1><h2 id="运动捕捉"><a href="#运动捕捉" class="headerlink" title="运动捕捉"></a>运动捕捉</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=N4Z4MdZ1KWY&amp;list=PLR3Ra9cf8aV2Zl8LIqT93rsgnpkSvmevk&amp;index=2&amp;ab_channel=MortMort">Youtube 上关于Aseprite的教程</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.mortmort.net/">mortmort官网</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>生活</category>
        <category>AE</category>
      </categories>
  </entry>
  <entry>
    <title>PS抠图操作</title>
    <url>/2025/01/15/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/PS%EF%BC%9A%E6%8A%A0%E5%9B%BE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://fiverr-res.cloudinary.com/images/q_auto,f_auto/gigs/41694069/original/66a90c41f4dbbe1fcbfe6c4a4a4f03dc5ebea34b/create-a-pixel-art-background-and-scenery.png" alt="" align=center /></p>
<p>本文将总结一些常用PS抠图操作。</p>
<a id="more"></a>
<h2 id="扣毛发"><a href="#扣毛发" class="headerlink" title="扣毛发"></a>扣毛发</h2><p>第一步：创建一个红色的纯色图层作为背景</p>
<p>第二步：使用普通套索工具（L），框选头发所在部位，然后点击上方“选择并遮住”</p>
<p>第三步：右侧视图模式视图选择“图层”，输出到选择“新建带有图层蒙版的图层”</p>
<p>第四步：使用左侧第二个调整边缘画笔，涂抹直至所有的头发都被覆盖</p>
<p>第五步：勾选右侧智能半径，移动边缘视情况调节，此处调节为-5，最后点击确定</p>
<h3 id="字符字体"><a href="#字符字体" class="headerlink" title="字符字体"></a>字符字体</h3><p><a href="https://www.dafont.com/bitmap.php">像素字符网站</a></p>
]]></content>
      <categories>
        <category>生活</category>
        <category>美术</category>
        <category>PS</category>
      </categories>
  </entry>
  <entry>
    <title>Aseprite 基本介绍</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://fiverr-res.cloudinary.com/images/q_auto,f_auto/gigs/41694069/original/66a90c41f4dbbe1fcbfe6c4a4a4f03dc5ebea34b/create-a-pixel-art-background-and-scenery.png" alt="" align=center /></p>
<p>本文将针对Pixel动画制作工具Asprite进行基本介绍</p>
<a id="more"></a>
<h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><ul>
<li>铅笔（快捷键B）：铅笔工具的操作和对应的效果如下：</li>
</ul>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/20209211138.png?raw=true" alt="" align=center /></p>
<ul>
<li>线条（快捷键L）<ul>
<li>直线：使用shift绘制特定角度的直线，ctrl绘制中心旋转直线</li>
<li>曲线：曲线可以进行两次弯曲操作</li>
</ul>
</li>
<li>形状（快捷键U）：shift可以绘制正图形</li>
<li>自定义多边形（快捷键D）：注意绘制直线多边形时，添加边需要按住鼠标左键然后移动鼠标，单击左键会结束绘制</li>
<li>橡皮擦（快捷键E）</li>
<li>取色器（Alt）</li>
<li>颜料桶（G）：将指定的连续区域替换为一个颜色，选中Continuous会只绘制连续的区域，如果不选中，那么不连通的但是相同颜色的都会被染色</li>
<li>选择器（M或W）：M是矩形选择器，而W是魔棒，会只能圈中对象。选择特定对象后，画笔等工具将只能在选中范围内起作用，这个特性使得我们能够局部修改而不影响其他部分。右键可以取消选择，而esc可以取消全部选择</li>
<li>文本（T）：插入文本，可以选择字体和字体大小等。</li>
</ul>
<h2 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h2><h3 id="基本参数及操作"><a href="#基本参数及操作" class="headerlink" title="基本参数及操作"></a>基本参数及操作</h3><ul>
<li>画布中一个网格的大小是十六个Pixel</li>
<li>画布调整：按住空格可以对画布进行调整，左键可以移动画布位置，滚轮可以调整大小</li>
</ul>
<h3 id="画布设置"><a href="#画布设置" class="headerlink" title="画布设置"></a>画布设置</h3><p>在菜单栏Sprite中，可以对Sprite和Canvas进行调整，Canvas就是画布，而Sprite是指画面对象的大小。如果要对画面进行裁剪，需要调节的是画布即Canvas的大小</p>
<h2 id="层（快捷键Tab）"><a href="#层（快捷键Tab）" class="headerlink" title="层（快捷键Tab）"></a>层（快捷键Tab）</h2><p>我们可以将一幅画作进行分层，修改某一个层时，不会影响到其他的层。</p>
<h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><ul>
<li>获得层属性：双击层单元</li>
<li>创建新层：shift+N</li>
<li>删除或赋值：右键层单元</li>
<li>移动层中对象：v或ctrl</li>
</ul>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><h3 id="相关操作：分别对应调色盘上面的四个按钮"><a href="#相关操作：分别对应调色盘上面的四个按钮" class="headerlink" title="相关操作：分别对应调色盘上面的四个按钮"></a>相关操作：分别对应调色盘上面的四个按钮</h3><ul>
<li>调色盘（F4）</li>
<li>根据颜色属性（亮度、饱和度等）排序，还可以通过梯度的方式创建颜色值连续递减的颜色</li>
<li>选择别人设置好的调色盘</li>
<li>Options：对于调色盘进行设置，甚至可以根据当前文件导出调色盘</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
        <category>美术</category>
        <category>Aseprite</category>
      </categories>
  </entry>
  <entry>
    <title>AE：人物动作</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://github.com/sqduan/hexoimg/blob/master/65c256a3ef12d23439db6f0816b92e60.gif?raw=true" alt="" align=center /></p>
<p>本文将针对AE中人物动作控制进行总结</p>
<a id="more"></a>
<h2 id="说话"><a href="#说话" class="headerlink" title="说话"></a>说话</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.bilibili.com/video/BV1bA411q7dU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0ac0f268155ca9fe0a7df16b11051b29">AE处理嘴型动作</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>生活</category>
        <category>美术</category>
        <category>AE</category>
      </categories>
  </entry>
  <entry>
    <title>Aseprite资源站</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/%E8%B5%84%E6%BA%90%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://fiverr-res.cloudinary.com/images/q_auto,f_auto/gigs/41694069/original/66a90c41f4dbbe1fcbfe6c4a4a4f03dc5ebea34b/create-a-pixel-art-background-and-scenery.png" alt="" align=center /></p>
<p>本文将总结一些常用的Aseprite的资源。</p>
<a id="more"></a>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><h3 id="字符字体"><a href="#字符字体" class="headerlink" title="字符字体"></a>字符字体</h3><p><a href="https://www.dafont.com/bitmap.php">像素字符网站</a></p>
]]></content>
      <categories>
        <category>生活</category>
        <category>美术</category>
        <category>Aseprite</category>
      </categories>
  </entry>
  <entry>
    <title>校园里的快乐五一</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/%E6%A0%A1%E5%9B%AD%E9%87%8C%E7%9A%84%E5%BF%AB%E4%B9%90%E4%BA%94%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一</p>
<p>火车在桃村停了下来，先前上车的乘客大多在这一站下车，躁动的车厢渐渐变得安静。我从卧铺上下来，坐在窗边。刚过五点，东边泛起浅淡的白色，映着天空中几抹薄云。到终点站还有三个小时，我心中的愿望愈发殷切了。</p>
<a id="more"></a>
<p>那一年我十八岁，身穿一件淡蓝色白格花纹短袖和牛仔裤，背着双肩包，手里拉着一个行李箱，由家人陪着来到威海上学。满载着学生和家长的大巴车开到了一条长路前，路的尽头隐约能看到一座苏联式风格的大楼。路两旁是学生们临时支起的摊子，叫卖着一些生活用品。等走到了学校门口时，我的怀抱中又多了一个脸盆。</p>
<p>从校门进去，迎宾道两旁的水杉笔直地高耸着，校训石坐镇中央，那座苏式大楼是哈工大的标志性主楼，端正地坐落在学校的中轴线上。校园里景色正好，不过一路上肩挑手提，舟车劳顿，此刻我只想早点去宿舍放下行李，再细细欣赏校园的风景。我们跟着人群，经过一段弯弯绕绕，终于来到了公寓，门前的景象却让我黯然。宿舍紧临一片荒地，刚刚下过了雨，地上愈发泥泞，只有两台挖掘机奋力掘土。新建的宿舍楼被这泥地衬托着，显得灰头土脸。看到校园里这番落寞景象，我只能尴尬地挠挠头，感叹自己高考不利，甚至萌生一丝退却的念头了。</p>
<p>进到宿舍，领过被褥，和天南地北的新室友们打过了招呼，终于安顿下来。妈妈要帮我铺床，我却执意要自己来。唉呀，妈，我已经能独立生活，你们不要管我了。我当时大约是这样想的，希望早早显示出自己作为一个成年人的独立性，现在回想起来，只觉得有趣。</p>
<p>收拾妥当之后，我们便从学校的后门出去，后门外是一条依山傍海的公路，向北是一座翠色的小山，往南便通向大海。淡金色的沙滩顺着公路延伸过去，一道道海浪缓缓地飘来，轻柔地抚摸着岸边，荡起一层层白色的泡沫。沙滩上密密麻麻地生长着一种小蟹，不过拇指头大小，呆立着捡食海草，被人惊扰便机敏地卧入湿软的沙中，只留一个小孔暴露在外。清凉的海风随着海浪吹拂而来，带着海水的湿润和海藻淡淡的腥气，让人觉得心旷神怡，我先前的不满和失落便被吹去一大半了。</p>
<p>往后几年的时光里，我时常在这海边散步，感受着海风轻轻吹着我的脸庞。清澈的海浪声从远方传来，流淌进我的耳中，慢慢地成为了我生命的一部分。</p>
<p>二</p>
<p>下了火车，海滨清凉而湿润的空气包裹着我，在这里生活的回忆被水汽滋润，一点点变得鲜活起来。临近五一假期的末尾，街上行人稀少，这座小城又恢复了往日里安静而清淡的气质。出租车驶过古寨西路时，城区倏然开阔起来，待汽车转到文化中路，再向前行驶一截，宋健楼的圆顶便远远地映入了眼中。</p>
<p>从我毕业离开学校之后，已经过去了五年。今年的五一假期，舍友李超要在老家泰安举办婚礼，宿舍三人便从各地赶来为他庆祝。借着这个机会，便心想着绕道威海，重归母校。</p>
<p>我们在校门口那条熟悉的长路前下了车，工大路在学校百年校庆的时候修整一番，路口立起一个星环状的雕塑，那是一颗以哈工大命名的小行星。路中央筑起花坛，里面栽着苍翠的松树，路两旁小店林立。经历了疫情，许多店铺已悄然无踪，不过那几家熟悉的小餐馆还开着，我心头一喜，仿佛看到当年三五好友聚餐小酌的快乐情形。我们就这样沿着工大路慢慢向学校走去，主楼的尖顶一点点变得清晰可见了。</p>
<p> 从校门进去，清风悠悠，水杉依旧，往日的回忆如同海浪般在我心头激荡起来。熟悉的校训石巍然而立，工大的校训质朴无华，只一句规格严格，功夫到家。第一次听到时，我的内心颇有鄙夷，觉得粗浅直白，毫无美感，远不如隔壁山东大学气有浩然，学无止境那般宽阔辽远。然而求学数载，理实交融，我终于慢慢发觉这两句平实的校训，是对于一个理工科学者至高无上的要求。只可惜年轻时我急功近利，很多时候只唯分，不唯实，现在看来，自己是大大地辜负了校训劝勉，想到这里，我的脸上有一些微微发烫。</p>
<p> 校训石的背后，一条笔直的石板路径直通向主楼，路两旁是一个小花园，里面栽着春梅几枝，再向前便是两池清水，一盈一缺，其名日月，日兮月兮，和聚生明。这一汪小小的日月湖，应当是学校希盼我们终能成为通识明理之人吧。</p>
<p> 我们在湖边的长椅上坐下，时值五月，南方暑意渐渐酝酿起来，而胶东仍是一番疏冷气息。日月湖里，去年的荷花枯茎依然挺立着，岸边柳树抽了新芽，在微风中轻轻飘摇，残荷新柳，相映成趣。湖水倒映着主楼淡白色的身影，我看着不远处这一栋宽厚巍峨的苏式建筑，心中的感觉却渐渐复杂起来。</p>
<p>从进校门的那一刻，我便有一个隐隐的忧虑，只怕五年过去，学校于我变得陌生起来。而今我坐在这日月湖畔，看着这再熟悉不过的景致，终于明白自己为何感伤。学校的格局已定，短短几年又怎会有太大的变化，只是这五年过去，我的境遇已经改变许多，早已不再是那个无忧无虑的少年了。</p>
<p>大约是五一假期尚未结束，校园里人迹寥寥，我们好不容易拉住一个学妹，让她帮我们在主楼门前的台阶上拍了照。毕业的那一天，主楼广场一片热烈气氛，少年终得学成，好不意气风发，同舍四人身穿黑袍金领学士服，头戴流苏垂悬方圆帽，站在主楼台阶上合影留念，我们笑着，唱着，将手中的学士帽高高抛起，那帽子像是一只黑色的雨燕，伴随着我们的欢呼声，和青春一起轻快地飞向了远方。</p>
<p>三</p>
<p>十一公寓旁边的荒地后来建成了一个小花园，何时建成的我已经记不大清，大约是大二的时候。夏天傍晚空气湿热难耐，下课之后，舍友几人便身穿背心短裤，提着澡篮，踩着一双拖鞋，从这花园里穿过，慌慌张张地奔向澡堂子。工大男多女少，男浴供不应求，如果去的晚了，只怕是要在门前排起一条长队。澡堂里雾气氤氲，花洒喷出清热的水，洗去一身暑气，待洗的舒服了，几个人再慢悠悠地穿好衣服从澡堂里出来，头发上还挂着点滴水珠。这时候最好去大服二楼买些油炸小吃，用竹签扎着，配着清凉饮料慢慢品尝，十分愜意。我们顺着学子路步行街溜达，人行道上齐整地栽种着梧桐树，梧桐果是一个个浑圆的小球，看似坚实，用脚轻轻一踩便噗地爆开了，里面的梧桐絮四散飞出，像是蒲公英一般。</p>
<p>到了冬天，气候就远远不如夏季这般讨喜了，那时我还年轻，尚未领教过这座海滨冬季肃杀的威严。记得大一的那年冬天上午下课，天上浓云黯淡，忽而飘散起几缕雪花，我便有了一种乍入初冬的欣喜。只是不足一顿饭的时间，那雪便凛冽起来了，伴着从海上呼啸而来的凶烈季风。从食堂出来，被风撕碎的雪沫向我迎头劈开，把我的脸庞打的生疼，一瞬间我几乎要被风吹个趔趄，一屁股坐在地上了。此时我早已无法保持北方人面对大雪的矜持与优雅，抱着脑袋狼狈地奔向宿舍，算是领略到了威海狂风疾雪的威力。从那以后，冬季洗澡变成了令人头疼的事情，我们厚帽绒裘，严阵以待，从宿舍出去便长途奔袭，只捣澡堂，等到洗完了，便火速穿衣，捂着脸挡着风，连滚带爬地跑回公寓，迅速脱衣上床，蜷缩在被子里瑟瑟发抖。外边妖风阵阵，海浪涛涛，房内羽被缠绵，暖意洋洋，宿舍几人便在这喧嚣的声浪里安然入梦了。</p>
<p>五年过去，十一公寓还是那般亲切的模样，像是一处归巢，静静地等待候鸟归来。我们没有进去，只是在外边望了一眼，当年的108宿舍，现在又庇护着来自何处的学子呢？公寓的红砖衬着远处碧蓝的大海，我好像又听到那些日子里宿舍传来的一阵阵欢声笑语。</p>
<p>公寓旁的观海路，向东慢慢延伸到了学校后山，当年只是一片杂草丛生的荒滩，后来这荒滩上慢慢建起花园，赛车场，活动中心。大四那一年，新的图书馆也落成了，只可惜那时已临近毕业，我只去过几次，对她里面的印象寥寥无几。我坐在后山花园的长凳上，黄海的清风缓缓吹来，让我忍不住眯起了眼睛。我从书报亭取走一本陈年杂志，随意翻阅，主楼耸立的楼顶遥相作伴，精致小巧的博物馆在松林中静静酣睡。当年对母校诸多抱怨，都随海风飘散去，如今我却只念及她的好。</p>
<p>四</p>
<p>M楼是我们当年上课的地方，大学第一堂课是工科数学分析，授课的金老师是一个瘦削的朝鲜族男人，带着一副金边眼镜，标标准准的学者模样。金老师治学极为严谨，在学生中口碑颇高。当年工数课每周都安排答疑，我记得临考前几周，我对有些知识点心存疑惑，便来找金老师讨教，金老师坐在M楼的教师休息室里，披着一件厚厚的军大衣，一支钢笔正在学生作业上细细批阅，我便站在一旁，趁他批阅的间隙上前请教。听了我的问题，金老师从一旁抽出一张纸，纷乱的公式便信手拈来，再为我一点点讲解。我资质愚钝，常有一些基础的概念混淆不清，金老师听了难免皱眉，大概是心想你这个学生，是不是又上课走神了。虽然如此，他依然耐心地帮我细细推导，我也因此获益良多。</p>
<p>我们轻轻推开M楼一间教室的木门，蹑手蹑脚地走了进去，生怕惊扰了正在上自习的学生，坐在熟悉的椅子上，隐隐约约能够嗅到课桌散发出淡淡的木香，这香味便直勾勾地引出我当年上课时的回忆了。我记得当时就在这间教室，金老师上完了大一最后一节工数课，在黑板上写下最后一个公式，放下粉笔向我们致意，台下瞬时掌声雷动，经久不息。工大的老师，大抵都如这般严谨治学，才能赢得学生们一生的尊重与挂念吧。</p>
<p>从教学楼出来，我们终于要去看望孙明健老师了。孙老师的办公室在主楼六楼，我们敲门进去的时候，他正在修订控制理论课程的试卷。他是我们的班主任和授课老师，也是大四那年我毕业设计的导师。他的专业课我们自然是上过的，内容我已全然忘记，只记得他说这世界上不存在完美的控制系统，你不能指望一个系统响应速度又快，误差又小，又兼具抗扰性和鲁棒性，就像一个男生，你不能指望他又帅又有钱还体贴，如果一个男生又帅又有钱还体贴，他指定喜欢男人。这一番贴切的比喻直逗的我们哄堂大笑。</p>
<p>见到曾经的学生，孙老师很是开心，招呼我们坐下，待手头剩下的一点活忙完，他煮水沏茶，又招呼在实验室的师弟端来一小盆自家摘来的泰山樱桃。前些日子孙老师受了风寒，怕传染我们，便一直带着口罩，看着恩师熟悉又略带疲惫的面庞，我十分欣喜，也带着些许担忧，不觉间便坐的端正起来。红茶温润可口，樱桃清爽怡人，我们就这么一边吃着小果，啜着茶汤，一边聊着当下和往昔。听闻我们三人境况挺好，孙老师欣慰地点了点头，又谈及三年疫情，诸多变故，让他忍不住摇头叹息。他也是一位极富责任的好老师，待到大三专业课，有些老师开始用着祖传的PPT，孙老师依然坚持板书，这疫情三年上课十分不便，面授时断时续，而理工学科又重在实验，想来他对教学效果是不甚满意的。</p>
<p>茶过三盏，孙老师招呼李港师弟带我们参观实验室，师弟追随老师读博，当年初入团队，而今已成中坚力量。我们在无人机实验室里看到了各种眼花缭乱的飞行器，还有他们亲手打造的载人电车，只感叹自己当年离这些年轻的学弟学妹们相差甚远。宋健楼的检控中心相比多年以前填了几张桌子，摆着庞大的激光器和零零总总的光学元件。中间激光室的墙上贴着实验室的项目介绍，中心参与的项目，或者追随神舟飞船上了天宫，或者深入医疗前线挽救生命，看到实验室硕果累累，我打心底里感到高兴。</p>
<p>从实验室出来以后，天色开始变得晦暗，周围开始弥漫起雨滴湿冷的气息。我们匆匆拍过合影，便由孙老师开车送我们出校。车子在西门外停下，其余几人先下了车，借着车里黯淡的灯光，我便又瞧了瞧恩师的脸庞。这几年他诸事操劳，又逢些许不悦之事，之前病了一场，脸上多了几分憔悴的神色。我想起当年保研，自己一心一意要去一个更好的学校，全然抛下了孙老师为我们创造的种种好处，硕士三年，品尝了在外的炎凉，此刻我终于多少能体会到孙老师的用心良苦了。我突然觉得鼻头一酸，侧过身去，给了恩师一个大大的拥抱。孙老师，您多注意身体，我们会经常回家看您的，我说。</p>
<p>五</p>
<p>婚礼上，柔和而唯美的灯光聚焦着一对新人，我的舍友李超终于要成婚了。这一刻，他穿着一身深蓝色羊绒西服，挽着自己的恋人，新娘头戴光华凝珠，身穿雪白长纱，温柔幸福地依在他的身边。而我们高举手中斟满美酒的高脚杯，共同见证这对新人的幸福时刻。</p>
<p>超哥是我们宿舍的大哥，也是把108凝聚在一起的人。那时我们一同读书，一起生活，兄弟几人意气相投，甚是融洽。我时常回想起我们下课后在海边游玩的情景，我们在沙滩上追逐打闹，奔跑嬉戏，像几个没有长大的孩子。一晃多年过去，当年稚气未脱的少年郎俊，此刻已经是一位成熟稳重的丈夫了。</p>
<p>婚礼的热烈气氛感染了我，我端起酒杯兴高采烈地说，今天超哥结婚，我得多喝几杯。生哥和梁总却忍不住笑话我，就你那个酒量，三杯下去怕不是就躺在那里了，到时候我们可抬不动你。接着便抖出我那陈年糗事，当年那个烧烤店里，肉香酒醇，我们畅谈青葱往事，好不快活，回去的路上我大约真的喝过了头，只觉得自己变成一条鱼，大海传来遥远的呼唤，便要一个猛子扎进海里游泳，得亏舍友拉住，从此就多了一个酒品奇差的美誉。</p>
<p>毕业之后，生哥和梁总一路辗转，回到家乡的国企上班，超哥和我研究生毕业后，分别来到深圳上海打拼，相隔远了，但情谊却总是温热的，有的时候工作累了，呼唤一声，舍友们便出来随性畅聊，我便觉得有一种无言的慰藉。而今超哥找寻到了自己的依靠，看着他幸福的样子，我们十分欣慰。我仰起头来，将杯中甘甜的美酒一饮而尽，悠扬的钢琴曲在我的耳畔婉转，我似乎又有几分飘飘然的醉意。</p>
<p>六</p>
<p>火车驶过徐州的时候，天色渐渐暗淡下来，刚从上午隆重热烈的婚礼气氛中剥离出来，坐在高铁安静的车厢里，我只觉得有一丝空荡荡的恍惚感。我掏出手机，一边吃着火车上生涩的牛肉饭，一边翻看前几日拍摄的照片。看着手机里记录的点滴风景，我又隐隐地思念起我的母校了。</p>
<p>离开学校的第二天，我们驱车环游海滨，熟悉的相框雕塑，方正的幸福门，山海相依的环翠楼，当时只作寻常风景，此刻却看不尽兴。沿着学校后门环海路继续向南，便通向了隔壁山东大学，山大的后山名曰玛珈山，我更愿意叫她天文台山，山顶修建着两口硕大的天文望远镜。夏夜，我偶尔沿着这条依山傍海的小路跑步，有的时候跑的远了些，忘记了时间，一直跑到山林深处，周遭一片寂静，整个世界似乎只剩下我一个人，风轻轻吹拂着山间绿树，传来树叶摩挲的声音，伴着海浪温柔的鸣响，我看着黑黢黢的海面上，远处的渔船亮起星星点点的渔火，恍惚间觉得自己仿佛走进了梵高的画中。冬日，挑一个狂风骤雪后的晴朗日子来到这里，树梢上的雪化了又冻，凝结成一串串冰凌，阳光穿过这清澈透亮的水晶，撞的破碎开来，挥洒出一片光辉，身处这冰清玉洁之中，只让人觉得宛若仙境。</p>
<p>不过我最中意的，还是阵雨后傍晚的落日，雨停了，天空退却了那压抑的昏暗，夕阳的光芒从云层的间隙透射而出，分割成一条条光柱，连接着天海。我站在海湾凸出的观景台上，面前了无遮挡，海从我的脚下延伸，一直淹没了整个世界。余晖在海面上倾泻，将大海蕴染成绚烂的橙红。温暖的金色光斑随着海浪的搅动在海面上下起伏，仿佛神祇将黄金揉碎，肆意散播在大海中。我被这天堂般绝美的景象深深震撼，一种近乎虔诚的感情便从心底里升腾起来。</p>
<p>这一次回来，本想再览海边落日，可惜天气阴郁，我最终还是错过了心心念念的景致，只匆匆留下了一张照片，天空中阴云密布，青灰色的海浪一遍遍冲刷着岸边竦峙的礁石，卷起千堆雪。我长久地看着这张照片，蓦然间，我的心像是被清澈的海水充盈，眼泪开始不由自主地涌溢到眼眶里。我赶忙将头撇向车窗，免得旁人看到我这窘迫的神色。快到虹桥站了，外边渐渐变得繁华明亮起来，黑夜被稀释了几分，我任由海水从我的眼中滴滴答答地流淌着，模糊了窗外星星点点的灯火。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>眼睛</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/%E7%9C%BC%E7%9D%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>眼睛</p>
<p> 当我小的时候，我妈总是叮嘱我要爱惜自己的眼睛，不要像有些小朋友那样，平时不注意，小小年纪就成了近视眼，从此眼镜再也离不开自己。可惜我对于我妈的一番教导从未放在心上，我随意滥用着自己的眼睛，甚至可以说是折磨了。我从不认真做眼保健操(虽然那个东西确实也没有什么用)，在做眼保健操的三分钟里，别人认认真真傻兮兮地用手指刮着自己的脸的时候，我就闭上眼睛装模作样，任由一个小孩子天真而杂乱的想法在脑子里搅拌。我可以坐在电视前看几个小时的电视，在电脑前玩一天的游戏，当然是要在妈妈不在的时候，要不然她一定会大发雷霆，把电视关掉，把电脑从楼上扔出去。最过分的是，我极其喜欢躺在被窝里看书，尤其喜欢看恐怖悬疑故事，要关了灯，蜷缩在被窝里像一只虾一样，打开手电筒，凑着昏暗的灯光看那些光怪陆离的文字，那样才最刺激，那时我仿佛已经出现在三星鲁王宫里，在那庞大昏暗，不知隐藏着多少妖魔邪物的墓群里，挥舞着洛阳铲搜索着宝物。</p>
<a id="more"></a>
<p>普通人怕是有十双眼睛也不够这么毁的，然而离奇的是，我的眼睛不仅经受住了我惨无人道的折磨，还始终情况良好，状态喜人。它从不曾感到过一丝一毫的模糊与朦胧，从我出生到现在，它始终是我身体上最引以为豪的部件。此刻我坐在这里，我可以清楚地看到楼下汽车牌子的每一位数，可以分辨清楚对面那栋楼阳台里的每一件器具，可以看到路旁指示牌上面的小字，当然，需要一些努力，毕竟离我还是有些距离。总之，当我身边的人大都开始无奈地与眼镜作伴的时候，我那一双被造物主眷顾的眼睛，正陪我观察着世界上的各种琐碎的细枝末节。</p>
<p>当然，这并不意味着它是完美无缺的，它也有自己的缺陷，甚至可以说是很严重的疏漏了，或许是上帝在创造我的时候疏忽大意了。我的眼睛不能正确地分辨色彩，这让我倍感遗憾。我是何时察觉到自己不能正确分辨色彩的呢？我忘记了，总之是小时候体检时，体检的护士姐姐拿着一张花花绿绿的图，问我图里是什么，别的小朋友叽叽喳喳地就说出来了，只有我支支吾吾地，努力分辨着图上那些奇形怪状的色块。后来护士姐姐不耐烦了，在我的体检单上面打上色弱两个字，打发我走了。</p>
<p>我的爸妈没有在意这件事情，在他们眼里，事情远没有那么严重，他们说我只是不知道该怎么读那些图而已，你再长大一些就会辨认那些数字了。</p>
<p>后来我长大了，那些奇形怪状的东西依旧奇形怪状，它们成了我的梦魇，成了我的心病。每次体检的时候，看到那个花花绿绿的色盲诊断本我就一阵胃疼，我的体检单上永远都只有一个遗憾，我的眼睛永远是令人羡慕的双眼5.1，可惜我是一个色弱。我的同桌甚至问了我一个哲学问题，同样一个颜色，你叫它蓝色，我也叫它蓝色，但是你看到的蓝色又和我看到的蓝色不是一个蓝色，但我们都叫它蓝色，那到底是怎么判断你说的那个蓝色和我说的那个蓝色不是一个蓝色，你明白我说的意思吧。打住，你都把我绕晕了。</p>
<p>于是我接受了自己是色弱的事实，我甚至开始怀疑，我长这么大，天空和大地真正的颜色到底是怎么样的。听说有人设计了一套能帮助色盲的人看到正常世界的眼镜，带上眼镜的那一刻，许多人都哭了。不过我想我应该不会有什么太大的反应，毕竟我只是色弱，和色盲有本质区别，这个世界依旧对我报以颜色，只不过和别人的略有不同罢了。</p>
<p>这么多次检查都是一样的结果，我的爸妈终于开始意识到问题了，他们买来了检查本，让我照着图念，我看着图上花花绿绿的一片，感到一阵眩晕。这张图这么简单的一个数字，这么明显，你怎么可能看不清呢？你看这不是很明显么。后来我厌烦了，也不再愿意和他们理论，人们对于自己不了解的东西，总是习惯性地按照自己的想法去评判，就像那张花花绿绿的纸，多数人看到的是鸡，少数人看到的是牛，于是看到鸡的人开始质疑，怎么可能看成是牛，那很明显就是鸡嘛。后来我的爸妈也勉强接受了这个事实，那个图片在有的人眼里确实只有牛。他们说要不你去把检测本背下来，体检单上有一项异常毕竟不好看，诶呀烦不烦，那么多套检测本，我怎么知道人家用的哪一个，你这什么馊主意。</p>
<p>实话实说，色弱迄今为止还没有对我的生活造成什么实质性的影响，我记得唯一一次是我的高中班长，有一天他穿了一身水泥灰的T恤，看上去像一块发霉的抹布披在身上，我跟同桌吐槽他的穿衣品味，说你看班长那衣服，灰不拉几的，跟个水泥袋子似的，我同桌瞟了一眼，明明就是骚粉色，什么水泥灰。我又找了几个人确认了一下，还问了问班长，最终确定他穿的确实是骚粉色的，那一刻我终于明白了色弱眼中的世界和别人眼中的世界究竟有什么实质性的不同，那天下午，我就看着班长穿着他的水泥袋子在教室里晃悠，我终于明白了，原来在我的世界里，没有淡淡的骚粉色，只有脏兮兮的水泥灰。</p>
<p>除此之外，我并没有因为色弱而受到刁难，我总担心我没办法正常地去学驾照，害怕自己没办法开车，不过在我跟交管所体检的阿姨说自己是色弱后，她给我换了一个红绿灯的图，我当然能够分辨红绿灯的颜色，于是也就顺利地考了驾照，成为了老司机。当然，因为色弱的关系，许多工作从此与我无缘了，不过幸运的是，我既不想开飞机上天，也不想在山里挖石头，更不想拿着手术刀切开别人的膀胱或是胰腺，我的专业并没有关于辨色能力的要求，于是色弱真的对我的生活一点影响也没有了，除了有时候，我抬头望望天空，还是忍不住去想，今天的天空很蓝，可是我眼中的蓝色，是真实的蓝色么，还是我只是叫它蓝色，但是在别人眼睛里，它其实是另一种颜色呢，想到这里，我竟然觉得有一些伤感，我大概永远也体会不到这个世界本来的样子了。</p>
<p>大概有百分之五左右的人吧，都是色弱，这个比例其实不低，但是也还是少数，如果有一半的人，都是色弱，那这个社会的规则，恐怕要重新制订一下。仔细一想，其实这世上的每个人，某种意义上，都属于少数派，有的人出生就携带着乙肝病毒，有的人没有谷丙转氨酶，有的人血小板含量偏低，有的人得了抑郁症。总的来说，每个人都有自己的十字架要去背负，每个人来到这世上，多少都有一些残缺破损，多少都不会圆满，完美无缺的毕竟是极少数，这大概就是人世间的有趣之处。</p>
<p>身为某一种少数派的一员，我还是很感激自己的缺憾，它让我明白了，尽量避免去用多数派的观点与眼光，来审视评论别人的状态，也不要将自己的想法强行安排到别人的身上，对自己或者多数人不了解的东西，还是带着尊重，不去妄加评判的好。或许是因为自己也是少数派的缘故，当我听到别的少数派倾诉自己的烦恼或苦衷，会觉得多少有一点感同身受，而不会因为不了解而觉得不理解，这大概是缺陷带给我的意义吧。</p>
<p>今天下午收拾房间的时候，我翻出了曾经买过的几本色盲检测本，上面已经积了一层细密的灰尘，我翻开了一页，仔细盯着看了看，盯久了，感觉那些五彩斑斓的色块，好像似乎浮现出了一些数字的样子，但我眨了眨眼睛，数字又悄声跑开了，我望了望窗外，我的眼睛可以望到很远，我可以看到远处连绵的西山，还有山脚下低矮的楼房，浓郁的白色蒸汽，正从高耸的烟囱里爬出来，天空是纯净的蓝色，这个季节这座城市难得有这么蓝的天空，我知道那是只有我能体会到的蓝色，很好，我可以享受这独一无二的美景。我从检测本上撕下一页，叠成了一架小飞机，从窗户扔出去，它就像一只五彩斑斓的鸟儿，在空中优雅地打转，一点点飞向了远处，再也没有回来。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>清明</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/%E6%B8%85%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>清明</p>
<p>哩哩老了，不大愿意动弹。更多的时候，它会趴在炉子旁边，享受着惬意的暖热。当我轻轻摸一下它的时候，它会咕哝地喵一下，好像在说，我在这里呢，之后便继续眯着眼睛，做着一只猫的梦。</p>
<a id="more"></a>
<p>我记得哩哩刚到院子里来的时候，那时我还小，它还是一只小猫，被装在一个纸箱子里带了过来。进了老房的客厅里，它搜的一下窜了出来，惊恐地看着这个陌生的环境，然后窜进了沙发下面。我好奇地趴在地上，朝沙发下面看去，两个圆圆的小灯泡正盯着我。它挑好时机，从沙发下面窜了出来，跑到了客厅外面。眼看就要爬上土墙逃走了，却被正在墙边干活的爷爷一把摁住。<br>小猫崽儿逃跑失败了，只好留在了这个小院里。一开始它被绳子拴着，后来它习惯了这里，终于把这里当成了家，绳子便不需要了。乡下的猫没什么正儿八经的名字，唤它吃饭的声音，就做了它的名。它也不似城中猫那般娇惯，每天吃的是残羹剩饭，也从来没有什么怨言。白天的时候，它会趴在墙边的砖垛或者石榴树下那片阴凉地里，舒服地把脑袋埋在身体里，缩成了一个花色的毛茸茸的肉球。傍晚时分，它会轻盈而娴熟地飘上老房子的屋顶，在长着杂草的石瓦间轻轻踱步，带着猫族的尊严审视着自己的领地，或是赶跑前来进犯的鸟雀们，再不急不忙地下来享用自己的晚餐，结束自己心满意足的一天，乡下猫咪们的生活大概都如此的单纯吧。<br>那时我一年回老家两次，我想它是记得我的。我回来的时候，它会轻轻地扫一扫自己的尾巴，绕着我转一圈，仿佛再说，你回来了。它表达自己感情的方式永远都很含蓄，却没有给人距离感，像是一个真诚又缄默的朋友。不过有时候它也会冲我喵喵地叫唤，希望我今天能悄悄地从冰箱里给它拿两根火腿肠，毕竟作为一只猫，偶尔也要改善一下生活。<br>在我那渐渐飘远的童年记忆里，我始终记得哩哩的模样。岁月似乎没有在它的身上留下苍老的痕迹，它随我一同长大，却永远都是一只长相高贵的猫。它身上有着随意却自然的三色花纹，毛发光滑而柔顺，身体修长而匀称，圆圆的小脑袋上带着猫的优雅与机警，却也带着几分若隐若现的温柔。当它伫立在屋顶静静地眺望远方的时候，我很难想象，它也曾经经历过幼年时的天真与活泼。<br>它终究还是慢慢变老了，曾经悠闲散步的屋顶，此刻也变得遥不可及。它的毛发也不再像年轻时那样光滑，开始变得毛躁而干枯。一天之中大多数时间里，它都蜷缩在一个温暖的角落，安静地做着梦，在梦中，它大概又回到了年轻时候的屋顶上吧，在那里跳跃，奔跑，望着日落，和屋顶一同化为夕阳下的剪影。<br>后来哩哩走了，大概是因为年老体衰，它陪我走过了十一个年头。我在电话里听奶奶说，咱们家猫娃儿死了。那一年的冬天，午后的阳光温柔地弥散在清澈的空气里，石榴树下的泥土铺满着细碎而枯黄的叶子，只不过我再也没有见到过那个温柔而安静的毛球了。我曾经陪伴过它，在一只猫短暂的生命里。风轻轻拂动着瓦片间的枯草，我仿佛看到哩哩的身影，它在屋顶上轻盈地跳跃着。我看着它一点点远去，消失在了远方，那里有石榴树，还有一望无际的田野。</p>
<p>夏天的时候，柿子树有肥厚而浓密的叶片，树枝上点缀着密密麻麻的青涩的柿果，枝杈被压成了弯曲的形状，几乎要延伸进泥土里。当你走在乡间小路上，你会和柿子树们擦肩而过，枝条慵懒而随意地拂过你的肩膀，然后带着柿果和叶片轻轻颤动。午后的乡村是安静的，鸟雀们燥热的没有了力气，变得沉默了。只是偶尔有一两个不安分的柿子，挣脱了枝杈的束缚，想要去寻找自由了，却随即摔在了地上，在安静的午后发出一声突兀的闷响。过往的行人如果不留意，轻轻踩碎了滚落在地上的柿子，还会溅出青涩的汁水。夏天的乡间小路，带着一点粘稠而清香的气息，我总觉得那是柿子们悲愤的眼泪。</p>
<p>田野里是热闹的，高瘦的玉米杆们挥舞着细长的叶片，拥挤在一起高谈阔论。梨树已经过了收获的季节，没有了雪白的花和淡黄而肥硕的梨子，但是叶片正是茂密的时候，夏日的阳光有一些浓烈，梨树弯曲的叶子们开始肆意生长。田垄的间隙是另一番风景，茄子成熟了，羞涩地躲在叶子后面，深紫色的皮肤细腻而光滑，反射着灼热的光，竟有了一种淡淡的透明的质感。肥胖的西瓜蹲坐在地上，气喘吁吁地抱怨着夏日的热情。花生们安静地不说话，它们朴素而低调，看上去像是偶然路过的一株株杂草，此刻只是闭目养神，安心地哺育着泥土里的花生果们，等待着收获的日子。<br>傍晚的时候，炎热终于退却了一分，大爸开着三轮车，带着一大桶刚从水塔里喷涌而出的清凉的水，去给田野里的居民带来一天的期盼。植物们欢呼起来了，玉米们暂停了争吵，开始大口而贪婪的吮吸着可口的水分，西瓜也不再抱怨了，舒服地浸泡在了这醉人的冰凉里。茄子上沾着晶莹的水珠，阳光透过的时候，仿佛变得更加透明。水是美好，是希望，它慢慢地渗透到土地里，再被密密麻麻的根系吸收，变成了植物的血液，化作了生命的一部分。<br>我坐在田间的地头上，享受着泥土的芬芳和傍晚田野里的清凉。太阳一点点地隐没在了细密交织的树杈里，在天空中留下了一片深沉的紫色，那紫色愈发的浓稠，最后大地终于笼罩在了夜幕之下。</p>
<p>我回想起了我的小时候，我的童年是故乡夏日的星空和冬日纷飞的雪花。夏天的夜晚是恬静而温柔的，小村里少有光亮，只能看到一座座小院里飘散出的昏黄的灯火。夏夜是捉知了的时节，那个时候，我时常带着一个手电筒，游荡在进村的公路上，那是一条细长而笔直的路，两旁种着高大的白杨，夜晚安静的时候，知了们开始了自己的旅程，它们从泥土里悄悄地探出头来，再笨拙地向杨树上爬去。手电光照在了杨树上，我顺着光亮细细寻找，每找到一只知了，便多了一分欣喜。直到夜深了，星空开始变得清晰起来，我才带着自己的猎获回到了家中。爷爷坐在小院里摇着扇子乘凉，奶奶在他的身边，安静地陪伴着他。我躺在小院的摇椅上，望着头顶那片星空。乡下的星空是干净而透亮的，像一张点缀着钻石的黑布。它们是那么近，又那么遥远。我望着星星出了神，那一刻，世界只剩下了头顶这一方小小的宇宙，还有这个悄然去睡的院子。</p>
<p>冬天的故乡是一种单纯而浅淡的色调，一种偏灰色的白。树们经历了夏日的深绿和秋季的金黄，终于褪去了颜色，在冬天安静地睡去，只剩下光秃秃的树枝在空气中轻轻摇曳。田野里的喧嚣也结束了，土地开始休养生息，等待着来年的新生。飘雪的时候，一切又都变成了纯白色，故乡的雪一片片飘落着，像是天鹅的羽毛一般，屋顶的瓦片被轻轻裹在雪花里，柿子树的枝丫上堆着拥挤的雪花，轻轻一吹，雪花们欢快地飞走了。推开那扇斑驳的木门，小院的生活又扑面而来了，爷爷在墙角收拾着柴火，奶奶正在炉灶前搭火烧饭，哩哩安静地在炉火边酣睡，还是那熟悉的一切，平淡而温暖，这大概就是生活吧。</p>
<p>后来我渐渐长大，开始离家越来越远，一年之中留在故乡的日子变得屈指可数。院子里的石榴花盛开又凋谢，凋谢又盛开，一年年的日子就这样平静地流逝了，我一点点成长，故乡和故乡的人们，在花开花落间，一点点老去。</p>
<p>爷爷去世的时候，我正在外地求学，当我再一次回到家乡，迎接我的是一方矮矮的坟墓了。我回忆着他在世的时候，他从不多言语，却深谙着土地和植物的哲学。他真正过着海子笔下诗意的生活，耕种，砍柴，关心粮食和蔬菜。只是这种诗意是劳累而辛勤的，他的皮肤因为长久的风吹日晒，变得粗砾而黝黑，像是老树粗糙的表皮。手掌是宽厚的，带着久握农具留下的粗大的指节。他和奶奶两个人，靠着辛勤的劳作和朴实的智慧，支撑着一个家庭，把他们的几个孩子抚养成人，供他们上学，再教给他们踏实而勤劳的做人哲学。爷爷的一生朴实无华，却又厚重而深沉，他日复一日地用双手与土地交流，直到最后，他的身体和灵魂，都一同沉睡在了他曾经躬耕过的土地里。</p>
<p>乡下的老房子在爷爷离开之后翻修了，曾经混合着杂草和秸秆的土墙被推倒，哩哩散步的屋顶，那些枯黄的茅草和残破的瓦片也消失了，还有被岁月刻蚀的伤痕累累的灰砖们，此刻也分崩离析。动工的时候经历了雨季，老屋的皮肉被一点点剥蚀，最后只剩下了木质的骨架形单影只，默默浸泡在夏季急促的大雨里。<br>当我再一次回到家乡的时候，气派的新房子耸立着，红砖和水泥取代了曾经的土墙，大门是阔气的金红色，院子里铺着平整的地板，还有陶瓷的屏风。我有一些疑惑，我对于老房的记忆，竟然有一些恍惚，我甚至有一点忘记了它曾经的模样。不过触觉是深刻而清醒的，我记得触摸着那扇斑驳的木门的感觉，那个锈迹斑斑的门环，还有那个吱吱作响的门栓，我记得那一块块脱落的墙皮，里面露出粗糙的混合着干草的土墙，我记得里屋里面清凉的空气，还有空气中弥漫着的果香，这些稀松琐碎的事情，此刻却都翻涌在我的身体里。<br>那扇厚实的大门后面，依旧是乡下平淡的生活，奶奶正搭着柴火烧着饭，锅里蒸着热气腾腾的包子，见到自己的孙儿回来了，她很是开心，赶忙唤她的孙儿来休息，品尝一下新鲜出炉的包子。我坐在火灶旁，灶里的柴火烧的撩人，火光轻轻摇曳着，燃烧的树枝不时发出一声噼啪的脆响。柴是冬天砍下的梨枝，被折下的梨枝纷乱地堆在了田野里，聚成了一座座小山，爷爷会开着三轮车，把干透的柴火们带回来，细枝条堆在砖垛旁，粗大的便用锯子锯开，齐整地码在墙边。我看着墙下那一摞摞齐整的圆木，它们正闭着眼睛，安静地呼吸，拥挤在一起沉睡着。还是熟悉的场景，只不过少了那个在墙边默默劳作的身影。</p>
<p>爷爷走后，大爸接手了耕种的工作，他曾经是中学教师，当他放下粉笔离开讲台后，他最终也成为了一个朴实的农民。又是一年的春天，梨树上的梨花开了，大爸大妈给我录了视频，我看到一片片干净的一尘不染的花瓣，温柔地栖息在梨树的枝头，像洁白的雪，远远望去，白色的花瓣连成一片，微风拂过的时候，就像一只只蝴蝶在空气中轻柔地起舞，真美。<br>我从来没有在春天回到过我的家乡，记忆里的故乡，只有冬夏的样子。我第一次看到春天的田野，大爸在田野里慢慢地小心翼翼地走着，给娇嫩的梨花一朵朵地蘸着花粉，不过多久，雪白的梨花会飘落，融化在泥土里，梨子会出生，会长大，会成熟，在它香甜的汁液里，流动着的是土地慷慨的馈赠，和一个农人的期盼与心血。有一瞬间，我仿佛看到了爷爷的背影，他望着树上雪白的梨花，露出了朴实而欣慰的笑容，最后他的身影渐渐模糊了，一点点隐去，和梨花淡淡的芬芳，一同弥散在了四月的田野里。</p>
<p>人间清明时，陌上梨花开。<br>青垄今犹在，焉得故人来？</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>致谢</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/%E8%87%B4%E8%B0%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>合肥的春天多雨，那雨是细碎的，残留着一丝冬日的清凉，像是拂面而来的雾，在我的身上笼罩着一层湿润的茧。早樱被这雨水滋润，在一夜之间拥簇着开了，花骨朵细密地拥挤在枝头，成了一片淡红的轻云。我曾经在北方生活，习惯了那里的干燥，初来南城，总觉得潮气很重。后来也渐渐适应了，觉得这气候就像是也西湖里的水，温润平淡，让人一点点放松起来。</p>
<a id="more"></a>
<p>我住在学校东南角的一隅，楼下通往系楼的小道上，齐整地栽种着两排银杏，我便每日顺着这银杏小路走去实验室。夏天的时候，叶子变成了浓郁的绿色，正午太阳浓烈，我走在路上，被银杏的叶子遮蔽着，总算在焦热的气氛里获得了一丝清凉。那一阵是写论文的日子，丛老师的办公室在二楼，窗外是一片厚实的绿荫，平日里她便一个人在这里办公。她会把要写的内容交代给我，然后每个星期给她看一回。我交出去的论文她看过后，过几日便叫我过去，她已将论文从头到末细细地添加了许多批注，再一一给我讲解订正。现在回想起来，我们平素之间的交流大多都是这样的形式吧。</p>
<p>其余的时间我基本在实验室中度过，汪涛师弟向来比我早到，等我推门进来，他已经开始了一天的工作，随后其他人便也陆陆续续来了。平日里实验室是安静的，偶尔能听到一阵敲击键盘的清脆的噼啪声，又或者角落里隐隐约约的风扇响动，窗外不时传来一两声悠远的鸟鸣。夏日的暴雨来得急促，这时周围便淹没在喧嚣的雨声里，我便停下手里的工作，看着楼下那一方浅浅的池塘，在大雨中激起层层碧波。</p>
<p>银杏在秋天里结满了白果，起初果皮是光滑圆润的，待果子熟透了，那表面便皱缩起来。一阵风过去，果子便掉落下来，若被人不小心踩上了，就会散发出白果特有的青涩的味道。桂花也开了，空气中弥散着桂花淡淡的清甜的香气，如果凑近了闻，那芬芳萦绕在了肺腑里，让人一天都觉得清爽。正是吃蟹的季节，丁娇总会给我和张坤带上几只自家鱼塘养的螃蟹，蟹黄浓郁地如同融化了一般，轻抿一口，鲜味便久久地弥留在唇齿之间。蟹膏金黄时，最宜饮美酒。这便是秋天里一份值得留恋的味道了。</p>
<p>十月过后，天气渐渐冷了下来，合肥的冬天少不了连绵的阴雨，寒意沾着雨水透过衣服，渗入了身体的最深处。这个季节，妈妈在电话里便多了几分叮嘱，总是提醒我记得多穿一些。听着她的声音，我想念起在家里的感觉了。我想起厨房里明亮的灯，还有锅里沸滚的粥，一家人坐在餐桌前，吃着热腾腾的饭菜，讲讲今天的趣事。求学在外，曾经稀松平常的日子，此刻却也成为一心一意的期待。冬季难得的晴日里，天空是清澈而冷冽的，夜晚来临，几分透亮的星辰开始点缀在这浓黑的苍穹下。送晓敏回宿舍的时候，我总是指着天上的星星问她，“你知道那是什么星星吗？”“我知道，你都问过我好多次了，是木星！”她笑着说。我看着她的眼睛，路灯的光倒映在她的眼眸里，像是有一条星河在缓缓流淌。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Riccati equation</title>
    <url>/2024/10/13/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/Riccati_equation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>This article will gives out a brief introduction about Riccati euqation<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>
<a id="more"></a>
<h2 id="Mathematical-form-of-Riccati-equation"><a href="#Mathematical-form-of-Riccati-equation" class="headerlink" title="Mathematical form of Riccati equation"></a>Mathematical form of Riccati equation</h2><p>Consider a first order ($\frac{d y}{d x}$) quadratic ($y^2$) equation:</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{d y}{d x}=A(x) y^{2}+B(x) y+C(x)
\end{equation}</script><p>we are going to look at a solution which form is:</p>
<script type="math/tex; mode=display">
\begin{equation}
y=y_1+\frac{1}{v(x)}
\end{equation}
\label{solution11}</script><p>where $y_1$ can be represent a particular solution and $v(x)$ is a function of $x$ which we don’t know what that function is. </p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Step-1-rewrite-the-quadratic-first-order-problem-to-a-linear-first-order-problem"><a href="#Step-1-rewrite-the-quadratic-first-order-problem-to-a-linear-first-order-problem" class="headerlink" title="Step 1: rewrite the quadratic first order problem to a linear first order problem"></a>Step 1: rewrite the quadratic first order problem to a linear first order problem</h3><p>Now differentiate the above formula, we get:</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{d y}{d x}=\frac{d y_1}{d x}-\frac{1}{v^2}\frac{d v}{d x}
\end{equation}</script><p>thus we get</p>
<script type="math/tex; mode=display">
\begin{equation}
A(x) y^{2}+B(x) y+C(x)=A(x) y_1^{2}+B(x) y_1+C(x)-\frac{1}{v^2}\frac{d v}{d x}
\end{equation}</script><p>bring $\eqref{solution11}$ to above equation:</p>
<script type="math/tex; mode=display">
\begin{equation}
A(y+\frac{1}{v})^2 +B(y+\frac{1}{v}) +C=A y_1^{2}+B y_1+C-\frac{1}{v^2}\frac{d v}{d x}
\end{equation}</script><p>expend we get:</p>
<script type="math/tex; mode=display">
\begin{equation}
Ay_1^2 +2\frac{Ay_1}{v} +\frac{A}{v^2} +By_1+\frac{B}{v} +C=A y_1^{2}+B y_1+C-\frac{1}{v^2}\frac{d v}{d x}
\end{equation}</script><p>simplification</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{dv}{dx}+(2Ay_1+B)v=-A
\end{equation}</script><p>From the equation above we find that we write the problem to a linear first-order problem</p>
<h3 id="step-2-Solve-the-rewritten-problem"><a href="#step-2-Solve-the-rewritten-problem" class="headerlink" title="step 2: Solve the rewritten problem"></a>step 2: Solve the rewritten problem</h3><p>Now we solve the rewritten problem</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{dv}{dx}+P(x)v=Q(x)
\end{equation}</script><p>First introduce a $\rho=e^{\int P(x)dx}$ and multiply the above equation:</p>
<script type="math/tex; mode=display">
\begin{equation}
e^{\int P(x)dx}\frac{dv}{dx}+P(x)e^{\int P(x)dx}v=Q(x)e^{\int P(x)dx}
\end{equation}</script><p>thus (wow it’s really amazing)</p>
<script type="math/tex; mode=display">
\begin{equation}
D_x(ve^{\int P(x)dx})=Q(x)e^{\int P(x)dx}
\end{equation}</script><p>integrate both sides with respect to $x$ and solve for $v$</p>
<script type="math/tex; mode=display">
\begin{equation}
v=\frac{\int{Q(x)e^{\int P(x)}}dx}{e^{\int P(x)dx}}
\end{equation}</script><p>Now we get our v.</p>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>Solve $\begin{equation}<br>y^{\prime}+2 x y=1+x^{2}+y^{2}<br>\end{equation}$ where $y_1=x$ is a solution.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=3heIoKDhN3E">A course about Riccati equation</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>数学</category>
        <category>微分方程</category>
      </categories>
  </entry>
  <entry>
    <title>花不语</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/%E8%8A%B1%E4%B8%8D%E8%AF%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我第一次看到茉莉花时是在一个炎热的午后，路旁的花农在地上摆放着几十盆姿态各异的花，错落有致。路过的时候一股淡淡的香气便飘进了我的鼻孔里，一瞬间仿佛夏日的炎热也被消去大半。我俯下身去，看到几抹素雅的纯白点缀在青翠的叶片间，还有几芽尚未绽放的骨朵，仿佛用手轻轻一碰，就会漫不经心地爆出一朵白花一样。于是霎时间动了养花的心，选了一盆长势最美好的带了回去。</p>
<a id="more"></a>
<p>那时尚无太多养花的经验，不知这开花的植物是渴求水分的，只是等想起来了便去浇一些水，毫无规律，于是眼见着那翠绿的叶渐渐干枯，褪去了生命的颜色，用手轻轻一揉，便在指尖碎裂开来；白花也渐渐失去了生命力，起初是那香味渐渐消退，最后花骨朵无力地垂了下来，边缘开始蔓延出腐朽的枯黄，就像被火烧了一半的纸。于是颓势渐渐无法挽回，每日看她，总能在花盆下扫出一小把枯落的叶子，一些日子后，终于只剩下了光秃的茎杆，彻底没了气息。</p>
<p>第一盆茉莉死于缺水。</p>
<p>第一次把花养死了，终究还是有些不甘心的，于是没过多久，我又抱回了一株茉莉，这一次吸取了上次的教训，在养花前做足了功课：茉莉喜阳喜水，需每日见光，浇水也不能吝啬，每天都要把土壤浇透的。我白天的时候把她放到阳光下，再接满一杯水，顺着叶片轻轻灌下去，水珠在叶片上轻盈地滚动着，叶片被洗去浮尘，露出了一股晶莹剔透的色泽，在阳光下熠熠生辉。傍晚时分我再把她抱回楼上，免得夜里的冷风伤害她娇嫩的叶片。我精心照料着她，就像照顾自己的女儿，于是花骨朵也一颗一颗地绽放了，绿叶衬着白花，那个时候房间里总是充盈着一股淡淡的香气。</p>
<p>可惜好景不长，尽管照料有加，过了些日子，那花朵又不知染上了什么怪疾，那叶子虽然还是柔软而充满水分的，但却从根部开始，渐渐褪去了绿色，黄色的斑点爬满了叶面，用手轻轻一碰，那叶子便毫不费力地挣脱了花枝，掉落在了地上。我开始有些迷茫了，起初以为是缺了营养，便买来肥料，满怀期待地播撒下去，然而无济于事，于是眼见她的叶片一点点变黄，一点点死去，最后那不祥的黄色侵染了整盆花朵，她最终还是难逃枯萎的命运。</p>
<p>第二盆花最后也死去了，死的不明不白，我到最后都不曾清楚到底是哪个环节出了差池。现在回想起来，可能是中午气候湿热，我却任由她暴露在外，茉莉虽然喜光，但耐不得高温，夏季午后闷湿而炎热的空气，对于娇嫩的鲜花无疑是致命的，可惜我那时不懂，只能眼睁睁地看着她一点点失去了生机。</p>
<p>养死了两盆花，我变得有些许伤感了，不是感慨自己养花水平之低劣，而是不忍看着两盆鲜活的生命，经由我这笨拙的双手，最终退化成了毫无生气的枯枝，或许换一个人，这两盆鲜花会是不一样的命运吧，一想到这里我便感到十分自责。</p>
<p>我一向喜欢小动物，小猫小狗什么的，每每遇到这些小可爱，便总是驻足不前，想着上去逗弄逗弄，若它们不惧人，任我轻轻抚摸，那我一天的心情都将无比灿烂。我十分渴望能拥有一只自己的宠物，生活里也能多一分乐趣，可惜住在城市中，饲养猫狗，诸多不便，而父母又对能动的活物多有抵触，所以一直未能如愿，只能退而求其次，养育几盆花草，虽不能像猫狗那般与人亲密互动，但是当她在桌上静静地陪伴着你，当学习累了，看一看她那青翠的叶片，轻轻碰一碰花骨朵，空气中也充满着生命的气息。花草不能言语，只是静默地伫立在那里，看不出她是悲伤还是高兴，也不像动物，会用语言表达自己的需求，不论是渴了、需要阳光了、亦或是被昆虫叮咬，都只能默默忍受。这给养花人带来了诸多不便，你只能通过花草的颜色气味等隐晦的信息，判断出花草的需求。而我不是一个称职的养花人，时常未能读懂花朵所需，经由我手的花大多难逃枯萎的命运。有时候我在想，幸亏自己未曾养猫养狗，如果自己的宠物在自己面前不幸死去，我应该会难受的说不出话来吧。</p>
<p>我妈也喜欢养花，和我这种养花苦手不同，她是极擅长养花的，客厅里摆放着十几盆她的作品，无一不是生机勃勃，惹人喜爱。绿萝在墙角边肆意蔓延，像一条蜿蜒的蛇，几乎要延伸到了椅子腿上；文竹顺着插在花盆的竹片笃定地向上生长，如果不加管控，似乎就要长到了天花板上；金钱草在水盆里惬意地酣睡着，滚圆的叶片顺着玻璃缸的边缘低垂下来；和金钱草居住在一起的水竹，挺着高瘦笔直而细长的茎干，顶端尖细的叶像四面八方延伸，有时候一个花盆里水竹长势过于旺盛了，她便揪下一枝，扔进另一个水瓶中，过不了些许时日，另一盆也一定会变得热闹非凡了。还有几盆我叫不上名字的花朵，也都安心地暴露在客厅的阳光下，美好地生长着。</p>
<p>客厅的花长势喜人，看着这些茂盛的充满生命力的花草，人的心情也不由得舒畅起来了。我十分羡慕我妈的养花能力，可是讨教过后，发现她并没有什么特别的技巧，甚至可以说是有些随意了，只是扔在角落里，浇上足够的水，便任由它们自己生长去吧。难道养花也需要天赋么？我心里想着，感叹人和人之间做什么都会有差距啊。不过转念一想，家里的花十分皮实，是那种无心插柳都能成活的品种，和茉莉这种娇贵的公主不一样，这样想着我终于有了些许安慰。</p>
<p>自从第二盆茉莉死后，我便未曾再动过养花的念头，于是日子就这么波澜不惊地流逝着，我读了研，去了一个新的城市，过上了新的生活，这种新生活大体上是单调而无趣的，除了吃饭睡觉这些维系生命的必须的琐事，大多数的时间我都在实验室中度过了，坐在实验室前，做着一些不明所以的事情，美其名曰搞研究，时间久了，难免感到些许寂寞，于是便又动了养花的念头，我固执地又选择了茉莉花，心想着有了以前的经验，这次总归能把花照顾的像样一点了吧。</p>
<p>于是我的书桌上又多了一份陪伴，白天的时候，我依旧把她带出去，放在窗台上，看着她享受早间柔和的阳光，等正午太阳变得毒辣了，再把她挪一个地方，避免高温侵蚀她那娇嫩的身躯，我甚至严格控制水温，用冷热水勾兑的温水浇花，以免温度的突然变化对她的伤害。这一次她用绽放的花朵回馈着我，白色的花抽芽、绽放、枯萎，又不断地有新的花冒了出来。我想起了那句诗，草在结它的种子，风在摇它的叶子，我们站着,我们站着，不说话，就十分美好。</p>
<p>我的茉莉平安地度过了花期，后来秋天也过去了，窗外银杏的叶子变得金黄，落在地上，堆叠成了金色的地毯。空气开始变得湿冷，时不时下起一场连绵的阴雨，那种寒意穿透了衣服，一直浸入到人的骨肉里。光照时间也变短了，更多的时候，茉莉花陪我在屋子里一起度过。有时候盯着屏幕太久了，眼睛被晃得生疼，便停下手中的活计，静静地看一看旁边的茉莉，用手轻轻碰一碰她深绿色的叶，花沉默着，没有言语，但我似乎能感受到她的心情，窗外是昏暗而阴郁的天空，房间里有明亮的灯光，此刻她应该在惬意地酣睡吧。</p>
<p>有一个晚上，离开实验室的时候忘记了关窗户，冷风倒灌进了屋子里，第二天去实验室，开了门，一股刺骨的寒意却扑面而来，窗帘正被风有规律地吹起，张扬地飞舞着，我心里一抖，赶紧过去关了窗，走到书桌前，发现茉莉的叶片经过寒冷一整晚的摧残，已经全部低垂了下来，失去了生气。</p>
<p>我心里一阵短促的绞痛，伤心之余，懊恼自己怎么能如此疏漏，明明这次养花初见良好势态，却功亏一篑。我赶紧补救，把她挪到暖气旁温度最高的地方，祈祷着迟来的温热能拯救她的性命，无奈伤寒过重，几天之后，叶子终于不可挽回地掉光了。于是我的第三盆茉莉，最后孤独地死在了饥寒交迫的长夜里。</p>
<p>第四盆花是被邮寄来的，经过了长途颠簸，叶子已经开始发蔫，快递的盒子已经变形，枝叶都被挤压在了一起，许多叶片经过粗暴的快递分拣工序，已经变得伤痕累累，看着眼前这番略带凄惨的场景，我便不再抱任何希望了，给她移栽到盆中，便扔到了角落里，任由她自生自灭了，果不其然，过了几日，叶子便如意料之中纷纷掉落，最后也变成了一棵秃枝。我只是例行公事一般地给她浇水，也不曾过问她的死活，想着到来时便如此悲惨，是死是活听天由命吧。</p>
<p>又过了些日子，当我给她浇水时，却蓦地发现，在她羸弱的枯枝下方，竟然倔强地生长出一颗新鲜的小芽，虽然极不起眼，却散发着生命的气息。我又惊又喜，像是看到了一个刚出生的小生命一般，便手忙脚乱地学习新生植物的养护方法，照着教程给她缠上了布遮光，又用塑料袋套起来给她保暖。接下来的日子里，我每天最期盼的事情，就是看着她的新芽一点点长大。起初只有一颗，后来在枝杈的末端，又显出了几分星星点点的嫩绿色，实验室里又一次充盈着生命的气息了。</p>
<p>后来起先的那一枝新芽抽了枝条，那枝条是鲜脆的绿色，仿佛吹弹可断，我悉心照料着她，掀开塑料袋浇水时也蹑手蹑脚，生怕稍微多施加了一些力气，就会把她折下来，后来那株新枝越长越长，自己也有了新鲜的叶子。那一阵子我经常陷入莫名的焦虑，觉得许多事情失去了希望，但是看到她努力生长的样子，便不由得感动起来，觉得心里又有了前进的支持。</p>
<p>转眼一个学期便已结束，我迎来了一个短暂的寒假，临走之前，我给她接了一盆水，用一个布条浸到水里，另一端再埋入土中，保证她的土壤总是温和而湿润的，随后便安心地回到了家中。</p>
<p>再后来，武汉爆发了莫名的疫情，那疫病来势汹汹，让人措手不及，数字一点点上涨，有人染病，有人逝去，生命大抵原本就是如此的脆弱吧。幸免于难的人们惶恐的躲在家中，起初充盈着恐惧，后来也渐渐习惯了这样的日常，整个社会都慢了下来。我像千千万万其他学生一样，一起被困在了家中，等待着开学的消息。而两个月过去了，我依旧待在家中，只是心里还挂念着我的那盆茉莉，临走时留下的水并不多，现在恐怕已经干涸了。我的第四盆茉莉已经在漫长而绝望的焦渴之中无奈地死去了吧，我这样悲观地想着。我仿佛能看到水汽从她的身体里一点点逸散出去，生命被干燥的空气一点点剥离，最后，她终于变得没有了生气。</p>
<p>不知不觉已经是春天了，我好像很久没有在家中度过春季，某种程度上这也算是因祸得福。疫情被控制住了，春天也来了，人们久违地走出了房子，见到了阳光，灾难过后，最终还是要回归平日的生活。我在楼下慢慢走着，感受着春日的暖意与生机。桃树开花了，淡粉色的花瓣绽放着，桃花花期短促，一夜间绽放，然后又一夜间飘落，像是一场温柔而简短的梦，我站在桃花树下，抚摸着桃树粗砺的树干，感受着树皮那凹凸不平的触感。有花瓣轻轻落下，飘荡到我的肩头。不经意间，我突然想起了远方的那盆茉莉，心里涌上了些许的惆怅。桃树大概听到了我的心事，细碎的花瓣顺着微风轻轻摇曳，只是她依旧安静地站在风中，沉默着不曾言语。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>钢的城</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/%E9%92%A2%E7%9A%84%E5%9F%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>龙盛钢材市场已经快要被建材公司占领了，它现在不应该叫钢材市场，改名叫龙盛建材市场更加合适一些。</p>
<p>我能看到各种卖线材的，卖灯具的，卖水电暖设备的，只有寥寥几家钢材公司还顽强而徒劳地蜗居于此，低调地和一堆跟钢材没什么关系的公司生活在一起，等待着被搬迁的命运。</p>
<a id="more"></a>
<p>我跟爸说，你干脆别干钢材生意了，开个建材公司，你看这么多做建材的，多红火。</p>
<p>“没那个精力了，而且这么多年一直做钢材生意，熟络的客户都在这里。”</p>
<p>这确实不是说换就能换的东西，别看建材和钢材就一字之差，可毕竟隔行如隔山，况且谁知道建材生意过两年行情如何，没准这两年红火，过几年也得苟延残喘地艰难生存着。</p>
<p>就像现在的钢材市场一样。</p>
<p>一</p>
<p>太原是一座钢的城。</p>
<p>在太原的心脏部位，雄踞着中国最大的钢铁企业之一——太原钢铁集团。很难说明到底是先有了现在的太原市，还是先有了太钢，某种意义上来说，太钢就是太原市的一个重要器官，自打太钢建厂的那一刻，这一座庞大的钢铁企业，就注定要与这座城市一同生长并见证历史。</p>
<p>每一个太原人，或多或少，都与太钢有着联系，就像是一个文化烙印，印在了一个人的成长史中。从我有了记忆开始，我记得我的生活中就不曾离开过太钢，我在太钢二幼上完了幼儿园，在太钢二校读完了小学，在太钢二中度过了一段中学岁月，我甚至一度怀疑在我没有记忆的襁褓岁月，我是不是在太钢第二托儿所度过的。</p>
<p>我记得在我小的时候，太钢还是开放型厂区，想进就进，那时的建筑许多还是八十年代的风格，灰砖搭建的厂房，再用那种七八十年代风格的字体写上一些类似于安全生产之类的标语。妈妈有时候带着我去上班，她去工作的时候，我就在厂区的楼里玩耍，把报废的三点五寸软盘当成飞镖玩，也没什么人来阻拦我这个熊孩子。那时的太钢在我的印象里是一座超大型的游乐场，我时常能看到那种让男孩子心潮澎湃的超大型吊车，总想上去玩一玩，不过我妈总是让我离它们远一点。</p>
<p>有很多的孩子，像我一样，父母在太钢上班，自己在太钢长大，幼年的记忆充斥着这个到处扬着煤渣的地方。</p>
<p>后来太钢实行封闭式管理，只有太钢员工能够进入，我关于太钢内部的记忆，就截断在幼年的那几栋灰暗的厂房里了。</p>
<p>二</p>
<p>我爸今天去太钢办事，我说我想进太钢看看，让他带我一起去。从钢材市场出来，他办理了一张两人的临时事务通行证，于是时隔十五年，我又有了进太钢看一看的机会。</p>
<p>路上，我再也不能找回关于童年的一点记忆了，到底是经过了翻天覆地的变化，现在，我在这个庞大的钢铁巨人体内穿行，经过了粗重的高炉以及林林总总的管道线。太钢号称是花园式厂区，今天亲眼所见，名副其实，像是建在密林中的一座工厂，竟然还有几分魔幻的即视感。</p>
<p>这些恐怕是前任太钢董事长平叔的遗产，平叔在太钢人眼里曾经是个英雄，对于其人我也有所耳闻，他一手壮大了太钢，让它盛极一时，声名远扬。</p>
<p>然而现实是很复杂的，能左右人的命运的，从来都不是功绩，而是过失，平叔发达之后平步青云，然而谁能想到后面就是世人喜闻乐见的政坛风云，各种原因，平叔一箭落马，锒铛入狱。</p>
<p>这种转折令人猝不及防，我还记得那时关注新闻，平叔前一秒还在开着不知什么重要会议，后一秒就被检察机关带走，于是他华丽地完成了从太钢英雄到阶下囚的迅速转变，沦为了人们茶余饭后的谈资。</p>
<p>一辆辆重型运输机驶过，带着成百上千吨的成型卷材。还有运输钢水的火车在厂区里驶过，热气从灌顶溢出，扭曲了周围的空气。我穿行于钢铁堆砌而成的厂区，从臃肿的管道下驶过，重工业给人的印象永远都是坚硬的，粗犷的，庞大而粗线条。身着蓝色工作服的太钢员工在路上穿梭，那是一种偏灰暗的蓝色，这套衣服由来已久，太钢经历了多次变迁，唯独不曾改变的就是那深蓝色的工作服，一个个工人就像是一个个零件，在这里全速运转，为了自己的温饱，也为了火热的中国梦。</p>
<p>三</p>
<p>钢铁是伴随人类历史发展的悠久产业，几千年过去了，变的是炼制工艺，不变的是钢铁的核心。从古至今，钢铁似乎就只有一个单纯的命运，踏踏实实地成为原材料，服务于各式各样的衍生品，上至高楼大厦，下至锅碗瓢盆，没有一样能够离开钢铁。我听到一台台冶炼炉低吼着吞下一车厢一车厢的矿石与焦炭，再喷涌出太阳般灼眼的钢水，沸腾的钢水与冷水相遇，就像是一曲冰与火之歌，巨大的蒸汽团咆哮着冲上天空，成型的板材被细腻的高压水流切割，终于成为了能够使用的板材，它们安安静静地躺在库房里，等待着被运走，等待着被加工成铁轨，加工成管道，再或者是高压锅。</p>
<p>重工业是一种近乎狂热的行为，我从没见过这座巨大的工厂有过喘息的机会，这座巨人无时无刻不在吞噬着来自巴西或者澳大利亚的铁矿石与产自山西的煤炭，吐出一卷卷作为次级原料的板材，成群的火车从厂区驶入驶出，带着工业的血与肉，三百六十五天，每天二十四个小时，高炉是没有机会停止运作的，听说仅仅是启动一下，就需要砸十个亿。</p>
<p>这是一种生机勃勃的假象，一旦跑起来，停不停可不是你能说了算的。</p>
<p>05到10年，这可以说是太钢鼎盛时期，这段日子里，房地产成为了中国的重要经济支柱，在不断虚高的房价中，中国钢铁企业迎来了一波欣欣向荣，基础设施建设的需求，近乎无限制地带动了钢铁企业的发展，太钢是那个时候开始迎来了鼎盛，盈利，扩张，再盈利，那时每一个太钢人脸上都带着发自内心的笑容，那时就像是在做一场永不停歇的美好幻梦。</p>
<p>四</p>
<p>我妈问我将来想不想到太钢上班，我十分坦诚地说不想。</p>
<p>我妈和她的同事聊天的时候，总有几个绕不开的话题，谁谁谁家的姑娘今年高考，谁谁谁家的儿子今年到太钢工作了。</p>
<p>太钢对于员工子女来说，其实算是一个比较好的归宿，大型国企，五险一金，生活是有保障的。我妈当然希望自己的孩子能有一个安稳的归宿，只可惜自己的儿子跟她的想法合不来，一方面我毕竟还是一个青年，还没有体会过生活的艰辛，对于国企还有一种青年独有的偏见，另外，太钢的衰落，许多太原人都深有体会。</p>
<p>无限制的扩张，过剩的产量，最终的结局必然是供求关系的严重不平衡，13年前后，钢铁行业开始步入寒冬。</p>
<p>钢厂表面上依然繁荣，钢卷依旧是成吨向外输出，可惜等待它们的却是尴尬的命运，价格急剧下降，钢材滞销，便宜而没有销路。</p>
<p>于是，当第一波下岗来临的时候，凝重取代了太钢人往年的笑容，人们忧虑着，生怕下岗的帽子突然就扣到了自己头上</p>
<p>我听说太钢去年第三季度的营业目标是亏损23个亿，听起来颇具有讽刺的意味。</p>
<p>它依旧是那个高喊着做全球最具竞争力的不锈钢企业的钢铁巨人，只是这一次有一点力不从心。</p>
<p>五</p>
<p>我爸是一个钢材商人，生活轨迹也和钢材息息相关，早年他在太钢做技术工人，后来辞职不干，凭借对于钢材的熟悉，开始做起了钢材生意。</p>
<p>别人眼中他也许是有自己业务的老板，或者是一个投机的小商贩，在我看来，他是一个靠着钢材养活一个家庭的父亲。</p>
<p>在那段钢材市场的黄金时期，我们家的生活质量得到了明显的改善，总算是步入了小康，那时候我爸经常为了调运钢材忙的不可开交，几百吨几百吨往外运，再不断买入，这就叫物流，我爸赚取那个差价。钢材不像萝卜白菜，钢材是按吨来卖的，一吨能挣十块，比起一吨动辄几千的原价，这个赚取的差价其实少的可怜。</p>
<p>但是没有关系，那个时候人们打了鸡屎一样地购买钢材，为了能够抢到货源，甚至自行加价，养肥了不少中间商。在我爸所在的那个钢材市场里，有许多财大气粗的商户，年收入按千万或者亿计，相比之下，我爸只赚一个零头。</p>
<p>我家的商户旁边有一个北京五钢贸易，听说一年赚了一点五个亿。</p>
<p>那是最好的年代。</p>
<p>六</p>
<p>有时候我去我爸的公司帮他做点杂务，对于钢材生意，多少有一点了解，钢材生意受季节影响有较大波动，冬季是淡季。</p>
<p>冬天放寒假，我会在公司待几天，李伯有时候会过来串门，他是我爸的朋友兼生意伙伴，见了我他就开始给我讲他丰富的经历。</p>
<p>“钢材生意啊，那是外表风光，表面沧桑，你看着成吨成吨地往出卖，实际赚不了几个屁钱，如果再碰上几个无赖，欠着你的钱，卷着你的钢，拍屁股走人了，给你留个白条，遇上这种王八蛋算是踩了屎了，跟他要帐比从公鸡屁股里抠蛋还难。”</p>
<p>我只好点头应喝着李伯十分恰当的比喻。</p>
<p>还有当年李伯的要帐经历，写出来堪比黑道小说，带着一车五大三粗满身纹身的人，扛着甩棍，掖着弹簧刀，直奔赖账人家里，然后在人家家里搞破坏，直到还钱为止，警察来了都不好使，谁让你欠人钱。</p>
<p>生意不是那么好做的，既有行情，又有人心。</p>
<p>这两年行情变差的时候，钢材市场里有难熬的冷清，我去年回来，看到曾经风光的北京五钢已经人去楼空了，听说经营的父子俩欠了一屁股债，还判了刑。</p>
<p>活脱脱一出大宅门式的悲剧。</p>
<p>七</p>
<p>我有一年多没去我爸的市场了。</p>
<p>这次去了，变化大的出人意料，钢贸公司搬的没剩几家，倒是一大批建材公司寄生在了这里，有卖水管的，卖灯泡的，卖油漆的，就是没找到几家卖钢材的。</p>
<p>“下半年我也要再另找地方了，这里要改成建材城了”，我爸无不苦恼地说。</p>
<p>“今天去给人家太钢的一家公司装货，得进太钢一趟，我带你进去转转”</p>
<p>办理了一个临时进出手续，时隔十五年，我又一次进入了太钢。</p>
<p>这是太钢的冬季，是全国钢材市场的冬季，集体式的狂热意淫已经过去了，这里已经迎来了后钢材时代，人们从幻梦中被打醒，开始直面钢材产量过剩价格急剧暴跌的问题，就像是一个疲惫不堪的老人，强撑着两条腿颤颤巍巍地缓慢前行。</p>
<p>太原是一座钢的城，在这里，太钢成为了城市灵魂的一部分，没有人能够否认，它依然是太原的核心支柱产业，如果离开了太钢，太原恐怕最后一点为人称道的资本也没有了。</p>
<p>钢铁企业向来就是一种很尴尬的行业，就算亏损，也不能停产，因为它又冠以国家支柱型产业之名，是国家工业的基础，所以即使目前亏损，也只能一直往下走，停下，就是死。</p>
<p>于是我看到高炉依旧在嘶吼，一列列火车轰鸣着驶入太钢，再驶出去。厂区内依旧是一派和谐的生机勃勃的景象，就像刚出锅的钢水一样富有活力。</p>
<p>只是这繁荣的景象里，掺杂着些许迷茫。</p>
<p>后记</p>
<p>“前面就是钢研所，你妈在这里上班，你要不要去看看”，我爸跟我说。</p>
<p>我说不了，我车上看看就好。</p>
<p>我妈是老太钢人了，二十年的岁月都给了这里，她见证了太钢的繁荣与衰落。</p>
<p>跟我不一样，她对于太钢的感情是实实在在的，她说太钢还是好，养活了多少家人，太钢开始亏损后，她的工资就基本没有再有任何起色，但是她也没什么怨言。</p>
<p>我看了看钢研所的门口，一片茂密的草丛，遮盖着太钢技术中心的牌子，后面是一栋别致的小楼，负责有关钢铁方面的研究。</p>
<p>楼是后来才有的，我没有什么印象，但我不确定我小时候有没有这一片草坪，我的印象里是有的，我记得午后我在那片草坪上玩耍。</p>
<p>那里记录着我的童年。</p>
<p>（2016年8月于太钢厂区内）</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>酒，酒，酒</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/%E9%85%92%EF%BC%8C%E9%85%92%EF%BC%8C%E9%85%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“他们说那一炉钢水格外地红，就像湛江的晚霞一样。”</p>
<p>“They said that batch of molten steel was unusually red, just like the evening glow of Zhanjiang.”</p>
</blockquote>
<a id="more"></a>
<p>我再见到洪泩时，是在日照的夏天。那时距离我失业已经过去了两个月，我到处找不到活可以做，存款日渐稀少，房租也难以为继，终于到了不得不离开的地步。洪泩知道了我的窘境，在电话里让我去日照找他。</p>
<p>When I saw Hongsheng again, it was in the summer of Sunshine City, two months since I lost my job. I couldn’t find any work anywhere, my savings were dwindling. I couldn’t afford the rent, and finally reached the point where I had no choice but to leave. Hongsheng heard about my predicament and asked me to come to Sunshine City to see him.</p>
<p>“我在这边出长差，要待几个月。住在公司附近的酒店，能报销，不行你就过来，反正你都是网上找工作。”</p>
<p>“I am on a long business trip here for several months and living in a hotel near the company, and it’s reimbursable. You can come over here since you’re looking for jobs online anyway.”</p>
<p>临走前我卖掉了自己大部分的东西，卖不出去的就送给了房东，只留下一个小行李箱装了必需品和几身夏天的衣服，还塞进去两本书。不知怎的，我心想放两本书进去，自己就不算是一个十分落魄的人。我最后看了看租住的房子，房间里空荡荡的。几年前，我来到上海讨生活，独自一人蜗在这狭小的砖墙里，现在终于还是狼狈地离开了，除了书柜里几本实在卖不出去的旧杂志，什么也没有剩下。我的目光不由得低垂了下来。</p>
<p>I sold most of my belongings before leaving, and left the unsold things to my landlord. I kept noting but a small suitcase with essential items, a few summer clothes, and two books. Somehow, I thought that I wouldn’t feel completely destitute if I bring two books with me. I took a last look at the rented room, which now seemed empty and hollow. Several years ago, I came to Shanghai to make a living, and I had been living alone in this small room with brick walls. Now, I was leaving in a sorry state, with nothing left except a few old magazines that couldn’t be sold in the bookshelf. My gaze involuntarily dropped down.</p>
<p>日照的夏天爽朗的正如这座城市的名字，看不见分毫的云，天是一整块纯粹的蓝色，突然从凉爽的车厢置身在这慷慨的阳光下，我感到皮肤传来一阵瘙痒，忍不住眯起眼睛。洪泩站在高铁站出口的广场上，穿着一条短裤，踩着人字拖，见到了他，我远远地挥起了手。</p>
<p>The summer in Sunshine City was refreshing, just like its name. Not a single trace of clouds could be seen in the sky; it was a pure expanse of blue. Leaving from the cool train compartment to bask under this generous sunshine. I felt a tingling sensation on my skin and couldn’t help but squint my eyes. Hongsheng stood on the square outside the high-speed rail station, wearing shorts and slippers. I waved my hand from afar when I saw him.</p>
<p>“路上咋样？”他从我手里接过了行李箱。</p>
<p>“How’s the journey?” He took the suitcase from my hands.</p>
<p>“还好。过来挺快的，昨天收拾了一天，我现在只想躺着。”我说，听到老友略带渝北乡音的普通话，我突然感到一阵踏实的宽慰。“日照真热。”我又补充了一句。</p>
<p>“Not bad. It’s quite fast to come here. I spent the whole day packing yesterday and now I just want to lie down,” I said. Hearing my old friend’s voice in a standard Mandarin with a slight Chongqing accent, I suddenly felt a comforting sense of relief. “It’s really hot here” I added.</p>
<p>窗体顶端</p>
<p>“最近是挺热，一点雨都没下。你回去躺会儿，晚上咱整个冰啤酒。”</p>
<p>“Yeah, it has been quite hot recently, without a drop of rain. Take a rest for a while, let’s  have some ice-cold beers tonight.”</p>
<p>“要的。”</p>
<p>“Agree.”</p>
<p>洪泩还是两年前的模样，没什么变化，只是经常在外出差，脸被晒的黑了。去酒店的路上，他问起了我在上海租的那间屋子。</p>
<p>He still looks the same as he did two years ago without much change, except that his face has become tanned from the sun since he often goes on business trips. On the way to the hotel, he asked about the room I rented in Shanghai.</p>
<p>“东西都卖了？”</p>
<p>“Sold all your belongings?”</p>
<p>“差不多吧，有一些留给了房东，他人挺好，听我失业了，没问我要违约金。”我点了点头。</p>
<p>“Pretty much. I left some things to my landlord. A good guy. He didn’t ask me for any breach of contract fees when he heard that I lost my job.” I nodded.</p>
<p>“可惜了，以后再买还得重新花钱，你该先留着。”</p>
<p>“Pity. One day you will buy them again. You should have kept them for now,” he said.</p>
<p>“没啥子值钱的，寄出去都不够邮费。也不能往家里寄，我妈就要知道我没得工作。”车子渐渐驶向海边，不远处的海散发着清淡的蓝色，被沥青马路升起的热气扭曲了。我看着窗外的风景，漫不经心地说。</p>
<p>“There’s nothing valuable. It even won’t cover the shipping cost if I send them away. And I can’t send them home neither, or my mom will know I’m out of a job,” I said absentmindedly as the car gradually approached the seaside. The sea emitted a faint blue color, distorted by the heat rising from the road. I looked at the scenery outside the window, said casually.</p>
<p>酒店离洪泩上班的地方隔了一条街，房间里可以看到远处的日照钢厂，红白相间的烟囱耸立着，流淌出浓稠的白雾。交错的钢支撑起巨大的冶炼炉，深沉如高塔。</p>
<p>The hotel was separated from Hongsheng’s workplace by a street. From the room, I could see the steel plant in the distance. The red and white chimneys stood tall, emitting thick white smoke. Those interlaced steel structures supported huge smelting furnaces, like towering towers.</p>
<p>“你睡会儿，我一会儿叫你，还有点活得搞。”</p>
<p>“Go rest for a while, I’ll call you later. There’s some work to be done,” he said.</p>
<p>洪泩坐在桌前，打开了电脑。我躺在床上，身边传来细碎的键盘声响，偶尔有一辆车从窗外驶过，带着呼啸声远远离去。倦怠渐渐爬满身体，经过几日疲惫的劳动，我很快睡着了。我睡的很专心，只做了一个简洁的梦。在梦里，我又回到那间租的屋子。客厅空无一物，我看到自己躺在出租屋的地板上，发出沉稳而均匀的呼吸声。窗外下着雨，雨滴敲打着窗户，飞溅起一朵朵水花。我便这样平躺着，一动也不动。不久，门外传来几声均匀的敲门声，有人呼唤着我的名字。</p>
<p>Hongsheng sat at the desk and opened the computer. I lay on the bed, surrounded by the faint sound of keyboard typing. Occasionally, a car passed by the window, carrying the sound of its engine as it drifted away. Fatigue gradually crept over my body after a few days of hard work. Soon, I fell asleep. I slept soundly and had a simple dream. In the dream, I returned to that rented room. It was empty, and I saw myself lying on the floor, breathing steadily and evenly. It was raining outside, and raindrops tapped against the window, splashing water droplets. I lay there motionless. Soon, I heard a few steady knocks on the door outside, and someone called my name.</p>
<p>“睡着了吗？”</p>
<p>“Are you asleep?”</p>
<p>“嗯，是的。”我注视着头顶的那盏灯，它正散发着白色的光。“已经睡着了。”</p>
<p>“Yes,” I replied, gazing at the light above my head, which is emitting white light. “I’m already asleep.”</p>
<p>“外面下雨了。”</p>
<p> “It’s raining outside.”</p>
<p>“我知道。”我看到自己的嘴唇动了动。“要我开门吗？”</p>
<p>“I know,” I saw my lips move. “Do you want me to open the door?”</p>
<p>我想起身开门，但是身体已经睡着，只剩眼睛还醒着，能清晰地看到头顶的灯，那灯光纯净而一丝不苟，像是一个空洞。敲门声依旧均匀地传来，我索性不再理会。</p>
<p>I tried to get up and open the door, but my body was already asleep. Only my eyes remained awake, and I could see the light above my head clearly. The light was pure and impeccable, resembling an empty void. The knocking on the door continued steadily, I decided to ignore it altogether.</p>
<p>后来那声音渐渐熄灭了，门外的人不见踪影，雨也停了。只剩下白色的光，无穷无尽的白光从头顶的洞中倾倒出来，包裹着我，我开始一点点下沉，淹没在这纯净的白夜里。</p>
<p>Later, the sound gradually faded away, and the person outside the door disappeared. The rain also stopped, leaving only the white light. Endless white light poured down from the hole above my head, enveloping me. I started to sink little by little, being submerged in this pure white night.</p>
<p>等我醒来的时候，太阳几乎已经斜了下去，天空变成了一抹黯淡的粉色。我从床上坐起来，口中感到干涸的苦涩味，心脏发出一阵仓促的跳动。</p>
<p>When I woke up, the sun had almost set, and the sky turned into a faint pink hue. I sat up in bed, feeling a dry and bitter taste in my mouth, and my heart raced with a sudden urgency.</p>
<p>“醒了？”洪泩目不转睛地看着电脑屏幕，问我。</p>
<p>“Awake?” Hongsheng asked without taking his eyes off the screen.</p>
<p>“嗯。”我拧开一瓶矿泉水，猛吞了几口，苦涩的味道被冲淡了，心跳渐渐平息。“你刚才有没有叫我？”</p>
<p>“Yeah,” I opened a bottle of mineral water, gulped down a few sips, the bitter taste is diluted, and my heartbeat gradually calmed down. “Did you call me just now?” I asked.</p>
<p>“没有，刚刚这破会开了半天，你睡的像条死狗。咋了？”</p>
<p>“I didn’t. This damn conference took quite a long time, and you were sleeping like a log. What’s wrong?” Hongsheng replied.</p>
<p>“没什么，做梦了，好像有人叫我。”我看着洪泩，他的工作似乎做完了，正翘着二郎腿打着麻将。</p>
<p>“Nothing. I had a dream, someone was calling me,” I said, looking at Hongsheng. It seemed like he had finished his work and was now playing mahjong with his legs crossed.</p>
<p>“八成睡多了。走，出去转转，一会儿海边整个烧烤。”他把电脑合上，站起身来。</p>
<p>“You sleep too much. Come on, let’s take a walk. We’ll have a barbecue by the seaside later,” he said, closing his computer and getting up.</p>
<p>“巴适。”</p>
<p>“Nice.”</p>
<p>我们踩着拖鞋，在人行道上慢悠悠地走着，夕阳已经隐没在远处的楼宇间。只有几片稀薄的晚霞在天空舒展着，细碎如鱼鳞。走到一个十字路口，洪泩指了指斜对面的一座楼。</p>
<p>We strolled slowly along the sidewalk, and the evening sun had already disappeared behind the distant buildings. Only a few thin streaks of evening glow extended across the sky, looking like fish scales. As we reached an intersection, Hongsheng pointed to a building diagonally across from us.</p>
<p>“那就是我们公司，临时在这边租了几间。”</p>
<p>“That’s our company. We’ve rented a few rooms over there temporarily,” he said.</p>
<p>我看到一座方方正正的楼，粗劣地模仿着欧洲城堡的模样。楼顶凹进去的露台上，稀稀拉拉地立着几尊大理石雕塑，历经风吹日晒，已经变成一种锈蚀般的黑色。临街的栅栏被人撅开一个豁口，洪泩挪开禁止翻越的牌子，我跟着从那个豁口间挤了进去。</p>
<p>I saw a square-shaped building, crudely imitating the appearance of European castles. There were a few sparsely spaced marble sculptures on the sunken terrace on the rooftop, which had turned into a rust-like black color after enduring wind and sun. The railing along the street was pushed aside, and Hongsheng moved away the “No Trespassing” sign. I followed and squeezed in through the gap.</p>
<p>“正门啷个远，我懒得绕，每天钻狗洞上班。”</p>
<p>“The main entrance is quite far, and I’m too lazy to go around. I squeeze this little shortcut every day,” Hongsheng said.</p>
<p>“挺好，我连狗洞都没得钻。”</p>
<p>“That’s nice. I don’t even have a little shortcut to go through,” I replied.</p>
<p>“会有的。”洪泩叉着腰，瞅着自己上班的地方说。暖色的光晕正从这座楼的背后辐射出去，渐渐消散在空中。</p>
<p>“You will.” Hongsheng said, standing with hands on his hips, looking at his workplace. A warm halo was radiating from behind the building, gradually dissipating into the air.</p>
<p>我们穿过公司园区，来到了他经常光顾的那家烧烤店。外边红色的招牌已经亮起，门口狭小的玻璃水箱里，虾蛄们密密麻麻地拥挤在一起，呆呆地浮着不动弹。只有几只像是受到了莫名的惊惧，在水里横竖乱窜，搅起一丝浑浊。</p>
<p>We walked through the company’s campus and arrived at the barbecue bistro he frequented. The red sign outside was already lit up, and in the small glass water tank at the entrance, the crayfish crowded together motionlessly. Only a few seemed to be inexplicably panicked, darting around in the water, stirring up a bit of turbidity.</p>
<p>“吃啥自己点。”洪泩看着水箱里的虾和我说。“老板！来三斤虾爬子！”</p>
<p>“Take yourself,” Hongsheng said, looking at the crayfish in the water tank. “Waiter! Please give us three pounds of crayfish!” he called out to the owner.</p>
<p>我们点了烧烤和海鲜，拜托老板一会儿送到海滩上。他又从墙角收着的折叠椅中搬了两个出来。“老板！拿你两个躺椅，一会儿给你送回来！”</p>
<p>We ordered barbecue and seafood, asking the owner to deliver them to the beach later. Hongsheng then brought out two folding chairs from the corner of the wall. “Borrow your two lounge chairs, we’ll return them later!” he said.</p>
<p>“好嘞！”店主按着手里的计算器，头也不抬地说。</p>
<p>“OK!” The bistro owner responded without looking up, pressing the calculator in his hand.</p>
<p>远处终于只剩下深紫色的余晖，楼房连成了一片朦胧的黑色剪影，月亮的轮廓开始变得明晰。海边景色正好，人不多，也没有风，潮水懒散地漫过沙滩，留下湿漉漉的深色印记。我们选了一个离海不远不近的位置，撑起了躺椅。洪泩将身体彻底瘫在椅子上，发出一声舒服的轻哼，躺椅随即深陷下去。我也平躺下来，燥热的空气没有了踪影，但是沙滩还残留着午后的余温，我的脚半埋在沙子里，只露出脚趾，像两只蛰伏的螃蟹。</p>
<p>In the distance, only the deep purple afterglow remained, and the buildings merged into a vague black silhouette. The moon’s outline became clear. The beach scenery was perfect with few people and no wind. The tide lazily washed over the sand, leaving damp dark imprints. We chose a spot not too far or too close to the sea, and set up the lounge chairs. Hongsheng collapsed into the chair, letting out a comfortable hum as the chair sank. I also lay down. Hot air disappeared, but the beach still retained the warmth from the afternoon. My feet were half-buried in the sand, only the toes exposed, like two hiding crabs.</p>
<p>“上个锤子的班哦。”他望着远处的海，突然叹出一句感慨。“不如躺着。”</p>
<p>“Why do we have to work” he gazed at the distant sea, sighed. “It’s better to just lie down.”</p>
<p>“确实。”我陷在躺椅里，附和着说。</p>
<p>“Indeed,” I sank into the lounge chair and agreed.</p>
<p>没过多久，不远处走来一个人影，烧烤店的店员来了，右手提着一个红色的塑料桶，左手拎着一个大塑料袋，竹签从里面穿透出来，胳膊下还夹着一张小桌板。我站起了身，接过他手里的东西，铺开桌板，把烧烤放在上面。塑料桶就埋在脚边的沙子里，里面的冰水散发出诱人的寒意。洪泩从桶里抽出一瓶啤酒，水珠顺着瓶身滴落下来。</p>
<p>A figure approached from afar. The waiter in the bistro cames. Carrying a red plastic bucket in his right hand, and a large plastic bag with bamboo skewers sticking out of it in his right hand. Under his arm, he held a small folding table. I stood up and took the things from him, laid out the table, and placed the food on it. The plastic bucket was buried in the sand beside my feet, and the ice-cold water inside emitted an inviting chill. Hongsheng took out a bottle of beer from the bucket, and water droplets dripped down the bottle’s surface.</p>
<p>“泰山原浆，只有七天保质期，出了山东省都不咋能喝到，尝尝？”</p>
<p>“Taishan real ale, only seven days shelf life. You won’t find it outside Shandon. Try it?” </p>
<p>洪泩晃了晃酒瓶，撬开了瓶盖，仰起头来咕咚咕咚灌了几口，随即喷射出一个悠远而绵长的嗝，迎着翻涌上岸的海浪。“爽。”他满足地拍了拍肚子，发出几声清脆的响声。我也打开了一瓶，几口酒下去，嘴里开始充盈着麦芽的香气。</p>
<p>He shook the beer bottle, popped the cap open, and gulped down a few mouthfuls, followed by a long and distant burp, facing the waves surging onto the shore. “Really Refreshing,” he patted his belly contentedly, making a few crisp sounds. I also opened a bottle, took a few sips, and felt the aroma of malt filling my mouth.</p>
<p>“你来的有点晚。”洪泩侧过身去，从锡纸盘里摸起一只虾爬子，轻轻一掰，露出里面嫩白的虾肉。“再早一半个月来，虾爬子里还有黄。”</p>
<p>“You arrived a bit late,” Hongsheng turned to the side and picked up a crayfish from the aluminum foil tray, gently cracked it open, revealing the tender white crayfish meat inside. “If you came half a month earlier, the crayfish would have had roe inside,” he said.</p>
<p>“可惜了，应该早点被裁掉。”我捏着一只虾子说。</p>
<p>“It’s a pity, I should have been laid off earlier,” I said, pinching a crayfish.</p>
<p>他笑出了声，“你就当休息几个月。再说上班又能怎样？每天跟这些个国企里的老混子打交道，浪费生命，我早就想跑路了。”他一边咬着虾子一边和我说。“屁事不会做，抢功跑的比看见骨头的狗都快。”</p>
<p>He laughed, “Just consider it a few months of rest. Besides, what’s the use of going back to work? Dealing with those old foxes in state-owned enterprises? Totally a waste of life. I’ve been wanting to run away for a long time.” He continued while munching on the crayfish, “They do nothing except taking credit, like dogs seeing bones.”</p>
<p>“是这么个道理，不过你总归还有钱能赚。不像我，惨兮兮的，混到最后房租都交不起。”我学着洪泩的样子掰着虾，只是不够熟练，虾壳的倒刺扎的我生疼，虾肉也被掰的稀碎。“好久没吃这玩意儿了，好像离开学校之后再没怎么吃过。”我嗦了一口被掰碎的虾肉，说道。</p>
<p>“Here’s the thing, though, you still have money to earn. Unlike me, I’m miserable, struggling to even afford the rent in the end.” I tried to imitate Hongsheng’s way of peeling the crayfish, but I wasn’t as skilled, and the sharp edges of the crayfish shells made me wince in pain. The crayfish meat also ended up in bits and pieces. “It’s been a long time since I’ve had this stuff. It feels like I haven’t really eaten much of this since leaving school,” I said, sipping on the shredded crayfish meat.</p>
<p>“都毕业快八年了。”他呷了一口啤酒，看着远处的海浪，“真快。”</p>
<p>“It has been eight years since graduation,” he took a sip of beer and looked at the waves in the distance. “Time flies.”</p>
<p>在大海边上，一对夫妻慢悠悠地散着步，一只欢脱的小狗在前面奔跑，他们的女儿在小狗身后撒开脚丫追着，他们拉着手，温柔地看着嬉闹的孩子。“是啊，真快。”我的目光跟着这温馨的场景缓慢游移。</p>
<p>At the seaside, a couple strolled leisurely with a playful little dog ran ahead, followed by their daughter, running and playing. They held hands, watching the playful child tenderly. “Yes, time flies,” I said, my gaze lingering on this heartwarming scene.</p>
<p>“我在这边也工作五年多了。”洪泩挥了挥手里啃了一半的虾爬子，和我说。“是时候挪个地方。”</p>
<p>“I’ve been working here for over five years,” Hongsheng waved the half-eaten crayfish in his hand and said, “It’s time to move on.”</p>
<p>“现在哪里都不好，有份工作不错了，别瞎整。” 那对夫妻渐渐走远，我的视线重归大海。“话说你那个船怎么样了，你来这边不是要造什么船来着？”</p>
<p>“Nowhere is good. You should be grateful having a job, don’t mess it up,” I said. As the couple gradually walked away, my gaze returned to the sea. “By the way, how’s that ship of yours? Weren’t you coming here to build a ship or something?”</p>
<p>“是卸船机，就那玩意儿。”他用手指了指远处，我顺着他手指的方向望去，远处隐约能看到一片港口，一个个钢铁的巨人在夜幕下伫立，缄默地凝视着空中的月亮。</p>
<p>“Ship unloader, that thing over there,” he pointed with his finger. I followed his direction and looked into the distance, where I could faintly see a harbor. Giant iron giants stood in silence under the night sky, gazing at the moon.</p>
<p>“给钢厂卸矿料用，小日本搞的，一小时能挖两千五百吨矿石。那玩意儿最前面是一条长长的链斗，伸进船舱里，一斗一斗的料就上来了。”</p>
<p>“It’s used for unloading ore for the steel plant, made by the Japanese. It can excavate 2,500 tons of ore per hour. The front of that thing is a long chain bucket, extending into the cargo hold, and the material is brought up bucket by bucket.”</p>
<p>他掏出手机，给我看前几天录的视频，高耸的吊臂垂荡着深进幽暗的船舱里，钢铁的传送带爆发出有节律的轰鸣，矿料被一斗一斗地铲起，仿佛流动的沙。“你站在吊桥的上面，才能感受到这玩意儿有多大，下面的铲车就像是玩具。我有一个同事爬了一半，吓软了腿，被我扶了下来。”</p>
<p>He took out his phone and showed me a video he recorded a few days ago. The towering crane arm swung deep into the dark cargo hold, and the steel conveyor belt emitted a rhythmic roar as the ore was scooped up bucket by bucket, flowing like sand. “You have to stand on the gantry to truly feel how massive it is. The excavators below look like toys. One of my colleagues climbed halfway up, frightened with legs went weak, I helped him down.”</p>
<p>“你不怕么？”我看着手机里粗犷的机器问他，洪泩摇了摇头。“没啥子感觉，就是风大，感觉要把我吹飞了。”</p>
<p>“Are you not afraid?” I looked at the rugged machine on his phone, asked him. Hongsheng shook his head. “Not really, it’s just windy up there. Feels like I might get blown away.”</p>
<p>“那你厉害，我可能都不如你同事。”</p>
<p> “That’s impressive. I might even not be as good as your colleague.”</p>
<p>“两边都是栏杆，没啥怕的，是他太怂。不过我也就上去过一回，我们也不搞卸船机，我们搞的是下边那个。”他探过身来，用手指了指下面那个小小的铲车。“船舱里的料挖的差不多了，要用一个铲车把余料堆起来，否则卸船机挖不到。现在都是工人操作，我们要搞成自动驾驶。”</p>
<p>“There are railings on both sides, nothing to be afraid of. He’s just too timid. But I’ve only been up there once too. We don’t deal with the unloader; we work on the one below.” He leaned over and pointed down to the small shovel below. “When the cargo in the hold is almost excavated, we use a shovel to pile up the remaining materials; otherwise, the unloader can’t reach them. Currently, workers handle it, but we want to make it automated.”</p>
<p>“高科技哦，自动驾驶。”</p>
<p> “Impressive, autonomous driving.”</p>
<p>“锤子的高科技，瞎搞。来，吃串！”洪泩抓起一根烤串吃了起来。“这个不错，你尝尝，他家这个牛油小串最好吃。”他递过一串给我，我咬了一口下来，牛油在我嘴里融化开来，带着醇厚的奶香味。</p>
<p>“Garbage thing. Come, have a skewer!” Hongsheng grabbed a skewer and started eating. “This one is good, try it. Their beef butter skewer is the best.” He handed me a skewer, and I took a bite. The butter melted in my mouth, leaving a rich milky flavor.”</p>
<p>“确实。”我说。</p>
<p>“Indeed”, I said</p>
<p>今天的月光很好，我许久没见过这般纯粹的月亮，背景是了无遮拦的黑色，淡黄的柔光从月轮四周扩散开来，形成一片模糊的光晕。明黄色的月影在深邃的海面随着波浪摇曳。我感到潮汐渐渐苏醒，海浪似乎离我们近了。不远处有人对着大海高声歌唱，飘渺的歌声断断续续传进我的耳中。</p>
<p>The moonlight tonight is exquisite. It has been a long time since I last saw such a pure moon. Against the unobstructed black background, the soft yellow light radiates from the moon, creating a blurry halo. The bright yellow moonlight sways on the deep sea surface with the waves. I feel the tides gradually awakening, and the waves seem to be getting closer to us. Not far away, someone is singing loudly towards the sea, and the ethereal singing intermittently reaches my ears.</p>
<p>“跟我讲讲钢厂里的事情。”我咽下一口啤酒，带着些许苦味的清香涌上我的脑袋，我似乎泛起些微醉意。“我最近在写小说，你给我整点素材。”</p>
<p>“Tell me about the things at the steel mill,” I swallowed a sip of beer, feeling a slightly bitter fragrance surging to my head, as if I was getting a bit tipsy. “I’ve been writing a novel lately, so give me some material.”</p>
<p>“没啥可说的，都是些无聊的琐事。”</p>
<p>“Nothing but boring trivial matters.” </p>
<p>“比如说？”</p>
<p> “Like what?”</p>
<p>“比如那些每天混日子的员工，每天下午三点多集体去洗澡，洗完澡直接下班。那些个狗屁领导，做事情的时候人不知道在哪儿，汇报的时候就属他最积极，恨不得连螺丝都是他拧的。再就是数不清的酒局，国企传统，大事儿小事儿的，先喝了再说。”洪泩摸了摸自己圆润的肚皮。“这几年没少喝酒，肚子都喝大了。”他摇了摇头。“没得意思。”</p>
<p>“Like those employees who slack off every day, they gather around at three in the afternoon to take a shower and then directly leave work. And those useless managers, you can’t find them when there’s work to be done, but they are the most enthusiastic when it comes to reporting, as if they did everything themselves. Not to mention the countless drinking sessions, a tradition in state-owned enterprises, celebrating big and small events, and drinking before discussing anything.” Hongsheng patted his round belly. “I’ve been drinking a lot these years, my belly has grown bigger,” he shook his head. “Meaningless.”</p>
<p>“没得意思，干杯！”我把啤酒瓶伸过去，玻璃碰撞在一起，发出一声脆响。洪泩扬起脑袋，将瓶中的残酒一饮而尽，我听到他呼出一丝不易察觉的叹息。“我们的工作也不好做。从我们项目开始，就一直有工人背地里搞破坏，想着法子阻挠我们。”</p>
<p>“Really meaningless, cheers!” I extended my beer bottle, and the glasses clinked, producing a crisp sound. Hongsheng lifted his head and finished the remaining beer in one gulp. I heard him exhale a barely noticeable sigh. “Our job is not easy either. Since our project started, there have been workers trying to sabotage us behind the scenes, trying to obstruct us in any way they can.”</p>
<p>“为啥？”</p>
<p>“Why?”</p>
<p>“还能为啥，都搞成自动化，他们就得下岗喝西北风。” 他把玩着手中的空酒瓶和我说。“来这边不到两个月，我们设备上的电缆被剪了三次。其实我们都直到是谁干的。”</p>
<p>“Once everything is automated, they’ll be out of a job and left with nothing.” He played with the empty beer bottle in his hand as he spoke. “I’ve been here for less than two months, and our equipment’s cables have been cut three times. We all know who’s behind it, though.”</p>
<p>“那怎么整？”</p>
<p>“Then what to do?”</p>
<p>“没啥子好办法，没证据你也不好抓人家，他们都是一伙的。后来没辙了，厂里领导说匿名举报破坏供应商设备行为，奖励两万块钱，他们这才消停点。”洪泩把酒瓶扔到了脚边。“这群人也不团结。”</p>
<p>“There’s not much we can do. Without evidence, it’s hard to catch them, and they are all in cahoots. Later, we had no choice but to encourage reporting anonymously about the sabotage of the supplier’s equipment, and the company offered a reward of twenty thousand yuan for reporting. That’s when they quieted down a bit.” He threw the bottle to the ground. “These people are not united either.”</p>
<p>“挺好，从敌人内部分裂他们。”我说。</p>
<p>“Great idea, divide them from within the enemy.” I said.</p>
<p>“每天就这点儿烂事。搞得我心力交瘁的。”他皱着眉，捏了捏自己的太阳穴。“早晚得跑路。”</p>
<p> “Dealing with these shit every day, really exhausting.” He frowned and rubbed his temples. “Sooner or later, I’ll have to leave.”</p>
<p>“哪里不是一样的呢？”我说。</p>
<p> “It’s the same everywhere,” I said.</p>
<p>那个放声高歌的人似乎走了，又或者停止了歌唱。周围的空气重归寂静，只能听到海浪清澈的鸣响，洪泩拿起一根鸡翅啃了起来“怎么样，是不是很没意思。”</p>
<p>The person who was singing loudly seemed to have left, or maybe he stopped singing. The surrounding air returned to silence, and only the clear sound of the waves could be heard. I picked up a chicken wing and started munching on it. “Quite boring, right?” said Hongsheng.</p>
<p>“也没有，我以前只是听说国企怎样怎样的，没有你讲的那么生动。”我看着他说。“我觉得我能写出一篇小说来。”</p>
<p>“Not really. I’ve only heard about how state-owned enterprises are like, but not in such vivid detail as you’ve described,” I said while looking at him. “I think I can write a story.”</p>
<p>“写好了给我看看。”他专心致志地啃着鸡翅，吃的满嘴流油。“工厂里也就这些事情，没别的。要不就是各种事故，最近跟钢厂里的人吃饭，有几个保卫科的，没少听他们讲这些，你要不要听。”</p>
<p>“Let me take a look once you finish writing,” he said, fully engrossed in eating the chicken wings with oily mouth. “There’s nothing much in the factory besides these things. Either that or various accidents. I had dinner with some security personnel from the steel plant, and they told me a lot about these incidents recently. Want to hear?”</p>
<p>“整两个。”我说，“我想听一听。那谁不是说过吗，死亡和毁灭才是小说最高级的养料。”</p>
<p>“Say some.”I said. “I would like to hear. After all, hasn’t someone said before that death and destruction are the highest-grade nourishment for novels?”</p>
<p>“行，给你整两个。”他把吃剩的鸡骨头扔在桌上，抓起一把沙子擦了擦手。“就半个月前吧，饭桌上有个保卫科长跟我讲的，好几年前的事情了。有一对夫妻职工，下班了骑自行车回家，男的骑得快些，经过一个铁路道口，眼见铁道的道闸就要放下来了，他催他老婆赶紧骑过来，他老婆慌了神，车子卡在了道闸上。”</p>
<p>“Okay, I’ll tell you some,” he said, tossing the leftover chicken bones on the table and wiping his hands with sand. “Last month, during a meal, a security chief told me about something that happened several years ago. There was a couple of workers, riding bicycles home after work. The man was cycling faster and as they approached a railway crossing, the railway gate was about to come down. He urged his wife to hurry up and cross, but she panicked, and her bicycle got stuck on the gate.”</p>
<p>“然后火车就过来了？”</p>
<p>“Then the train came over?”</p>
<p>他点了点头，“那个保卫科科长赶过去的时候，铁道边上围了一圈人，他说他第一次看到那种场景，内脏散落一地。”</p>
<p> He nodded, “When the security chief rushed over, there was a crowd gathered near the railway track. He said it was the first time he saw such a scene, with internal organs scattered all over the ground.”</p>
<p>我的脑中勾勒起一副怪诞而血腥的景色：在夕阳斜照的铁路道口，远远地围着一群人，一个男人站在铁路道口旁，半仰着头，发出一声空洞的啸叫，像是失了神的野兽。一颗鲜红的心脏滚落在他的脚边，蘸着铁道旁的尘土，仿佛巢中跌落的雏鸟。</p>
<p>“A bizarre and bloody scene emerged in my mind: at the railway crossing bathed in the slanting rays of the setting sun, a crowd stood at a distance, while a man stood by the railway tracks, half tilting his head, emitting a hollow howl like a dazed wild beast. A bright red heart rolled to his feet, dipping into the dust by the railway, resembling a fallen nestling.</p>
<p>我沉默了几秒，不知该说什么。“太惨了。”</p>
<p>“Too tragic.” I replied after a few seconds of silence, not knowing what else to say.</p>
<p>“太惨了。”</p>
<p>“Too tragic.”</p>
<p>我侧过头，眺望了一眼夜色下的日照钢厂，城市沉睡了，我知道钢厂还醒着。轻盈的白雾依旧在烟囱顶端流淌，在深邃的夜色里显得愈发白皙而浓稠。卸船机的上面，巨人红色的眼睛在闪烁。</p>
<p>I turned my head to gaze at the Steel Plant in the night’s darkness. While the city slept, I knew the steel plant remained awake. Gentle white mist still flowed from the top of the chimneys, appearing even more pure and thick in the deep night. On top of the unloading machine, the giant red eyes flickered in the darkness.</p>
<p>“你看过炼钢的场景么？”洪泩问我。</p>
<p>“Have you ever seen the scene of steelmaking?” Hongsheng asked.</p>
<p>我摇了摇头。“没有，那是什么样子。”</p>
<p>I shook my head. “No, what does it look like?”</p>
<p>“我在湛江那边见过，火车拉着一车一车的鱼雷罐，开进厂房里。”</p>
<p> “I’ve seen it in Zhanjiang. The trains pulled in with carriages full of torpedo-shaped containers into the plant.”</p>
<p>“鱼雷罐？”</p>
<p>“Torpedo-shaped containers. “</p>
<p>“就是装钢水的罐子，能装几十吨钢水。”他比划了一个夸张的圆。“像个鱼雷。”我看到一辆火车从远方缓缓驶来，载着炽热的铁水，汽笛发出一声悠远的长鸣。</p>
<p>“The containers which hold tens of tons of molten iron. Just like torpedoes.” He gestured with an exaggerated circular motion. “Resembling a torpedo.” I saw a train slowly approaching from the distance, carrying the glowing hot molten iron, and the whistle let out a long, distant cry.</p>
<p>“我从吊桥上向下看，鱼雷罐开着口，里面就是满满一罐子铁水，上面飘着一些矿渣。你知道那是什么感觉么，我站在吊桥上，能感觉到热气从我脚下传上来。”洪泩说着自己在湛江时的情形。“我感觉我会融化掉，真热啊。”</p>
<p>“I looked down from the suspension bridge, and the torpedo-like containers were open, filled with molten iron, and there were some slag floating on top. Do you know how it feels? I stood on the suspension bridge, and I could feel the heat coming up from under my feet,” Hongsheng recounted his experience in Zhanjiang. “I felt like I was going to melt, it was really hot.”</p>
<p>他像是想到了什么，停顿了一下，继续和我讲。“大概就在我站的那个吊桥上，一年前死了个工人。”</p>
<p>He seemed to recall something, paused for a while, and continued telling me, “Around the same position I was on that suspension bridge, a worker died here about a year ago. “</p>
<p>“掉进钢水里了？”</p>
<p> “He fell into the molten steel?”</p>
<p>“掉进钢水里了。”他点了点头。“自己跳下去的，我也是听那边的同事说的，当时他们都呆在那里。”</p>
<p>“He fell into the molten steel.” He nodded. “He jumped in himself. I heard it from my colleagues over there. They were all stunned at that moment.”</p>
<p>“是个什么样的人？”这个跳进钢水的男人勾起了我的兴趣。</p>
<p>“What kind of person was that man?” The man who jumped into the molten steel piqued my curiosity.</p>
<p>“不清楚，只知道他是一个测温的操作工，好像四十多，挺年轻的。钢包进入炉子工位前，要先去测量温度，这些测温工就拿着一根长长的测温枪，插进钢水里取样。”他的手伸进塑料桶里摸索着。“最后一瓶酒了，咱俩把他分了就回去吧，潮水过来了。”</p>
<p>“Not sure, only heard that he was a temperature measurement operator, around forty years old, quite young. Before the ladle enters the furnace, they have to measure the temperature, and these temperature measurement workers use a long measurement gun to take samples from the molten steel.” He reached into the plastic bucket, feeling around. “This is the last bottle of beer, let’s finish it and head back, the tide is coming in.”</p>
<p>夜里的潮水翻涌着白色的泡沫，离我们更靠近了些。</p>
<p>The night tide surged with white foam, coming closer to us.</p>
<p>“好。”我回应道。</p>
<p>“OK.” I said.</p>
<p>“那是他们那个车间改造之后的事情，工厂引进了一批机械臂，测温都搞成了自动的。”洪泩将瓶中的酒倒给我一些，继续说着。“他们每天站在旁边看着就行。然后有一天，那个人爬上了吊桥，看着那一炉钢水，就那么直勾勾地跳了进去。”</p>
<p>“That happened after they renovated their workshop. The plant introduced a batch of robotic arms, and even temperature measurements became automated,” said Hongsheng as he poured some of the alcohol from the bottle into mine. “They just have to stand by and watch every day. Then one day, that man climbed onto the bridge, looked at the ladle of molten steel, and jumped straight into it.”</p>
<p>我站在那个吊桥上，远处是一个工人宽厚的背影，他正目不转睛地注视着那个测温口，里面散发出钢水炽红的火焰。</p>
<p> Standing on the suspension bridge, I saw a worker’s broad back in the distance, his eyes fixed on the temperature measurement port, from which emanated the fiery glow of molten steel.</p>
<p>我开始虚构他的身世。零几年的时候，那时他高中毕业，想成为一个画家，也许。他考了两年美院，但是都没考上，第三年的时候，家里人托关系把他搞进了钢厂里。从那以后，他就一直做着这样的工作：一根长长的测温枪从那焦灼的口中伸进去，浸没在钢水里。不远处，钢包里的钢水顺着炉口倾倒进去，划成一道黏稠而火热的红色晚霞。他觉得那个炉口像一个光芒万丈的黑洞，贪婪地吮吸着煤炭，铁矿石，还有他的青春和梦想。那些东西在咆哮的炉身里燃烧，烧的干干净净，化作一缕青烟飘散，什么也没有剩下。</p>
<p>I started to imagine his background. It was around the early 2000s when he graduated from high school, with dreams of becoming an artist, perhaps. He tried to get into art school for two years but didn’t succeed. In the third year, his family used connections to secure him a position in the steel plant. Since then, he had been doing the same job - inserting a long temperature probe into the blazing mouth of the furnace, immersed in the searing molten steel.</p>
<p>Not far away, the melten steel in the ladle poured into the furnace, forming a sticky and fiery red sunset. He felt the furnace mouth was like a brilliant black hole, greedily devouring coal, iron ore, and also his youth and dreams. These things burned inside the roaring furnace, leaving nothing behind but a wisp of smoke, as if everything had been completely consumed.</p>
<p>有一天之后，铁的庞然大物占领工厂，冷峻的机械臂迎着沸腾的火焰，漠然而精准地将测温枪伸进去，然后再拔出来，他搬着一个小马扎坐在一旁，看着机械臂在轨道上来来回回。</p>
<p>After one day, the massive presence of steel machines took over the factory. The cold and stern robotic arms faced the boiling flames, inserting the temperature probe into the molten steel and then pulling it back out, impassively and precisely. He sat on a small stool, watching the robotic arms move back and forth on their tracks.</p>
<p>我看到他站在吊桥上，在离我不远处的地方侧身对着我，他的脸被钢水映的通红，我从桥上向下看，看到了一个个鱼雷罐，太阳浓缩在里面。他就那样长久地站着，半张开口，似乎想要说什么，但是发不出声音。随即，像是决绝一般，他翻身跨过栏杆，跳了下去。</p>
<p>I saw him standing on the suspension bridge, not far from me, facing sideways. His face was reddened by the reflection of the molten steel. I looked down from the bridge and saw rows of torpedo-shaped containers with the Sun intensely concentrated inside. He stood there for a long time, mouth half open, as if trying to say something, but unable to make a sound. Then, as if determined, he turned around, straddled the railing, and jumped down.</p>
<p>他的身躯在空中划过一道优美的弧线，如一只飞鸟，张开双翅拥抱着太阳。我看到鱼雷罐里绽开一朵金色的花，荡起一阵波澜，然后迅速恢复平静。</p>
<p> His body traced a graceful arc in the air, like a soaring bird, spreading its wings to embrace the sun. I saw a golden flower bloom inside the torpedo-shaped container, causing ripples to spread and then quickly settling into calmness again.</p>
<p>“他们说那一炉钢水格外地红，就像湛江的晚霞一样。”</p>
<p>“They said that batch of molten steel was unusually red, just like the evening glow of Zhanjiang.”</p>
<p>潮水几乎要没过我的脚边，酒精在我的身体里荡漾，我感到一阵眩晕，但是感官却愈加清醒，我的眼睛似乎能觉察到海浪的差异。我摇摇晃晃地站起身来，向前走了几步，冰冷的海水浸没了我的脚，我发出一声咆哮，声音被浪潮吞没。</p>
<p>The tide was almost reaching my feet, and the alcohol was surging in my body. I felt a moment of dizziness, but my senses became even clearer. My eyes seemed to sense the differences in the waves. I staggered to my feet, took a few steps forward, and the cold seawater soaked my feet. I let out a roar, but the sound was swallowed by the waves.</p>
<p>“你喝醉了。”洪泩看着我。“回去吧。”</p>
<p>“You’re drunk,” Hongsheng looked at me. “Let’s go back.”</p>
<p>“我喝醉了”我说。</p>
<p>“I am drunk,” I said.</p>
<p>我们顺着原来的路回去，洪泩一只手夹着躺椅，一只肩膀搀着我，我踩在松软的沙滩上，像是踏着轻浮的云。</p>
<p>We walked back along the same path. Hong Bo carried a beach chair in one hand and supported me with his shoulder. I stepped on the soft sand, as if walking on floating clouds.</p>
<p>“今后有什么想法，还回上海吗？”</p>
<p>“Any plans for the future? Are you going back to Shanghai?” Hongsheng asked.</p>
<p>我摇了摇头。“不知道，应该不了，可是又能去哪里呢？”</p>
<p>I shook my head. “I don’t know, probably not. But where else can I go?”</p>
<p>“走一步算一步吧，明天我去工作，你去找工作。”他努力地让我走在直线上。“我们都有光明的未来。”</p>
<p>“Let’s take it one step at a time. Tomorrow, I’ll go to work, and you look for a work,” he said, trying to keep me walking in a straight line. “We both have a bright future ahead.”</p>
<p>我回过头去，月亮在空中孤立，此刻发出青白色的光。波涛彻底苏醒，拥挤着咆哮着涌过来，将我们来过的痕迹顺手抹消。我看着那潮水，如冷峻的铁一般洗刷着岸边，一遍遍地。</p>
<p>I turned my head back, and the moon stood alone in the sky, emitting a faint bluish-white light. The waves fully awakened, roaring and crowding as they washed away the traces of our presence. I watched the tide, like cold, stern iron, scrubbing the shore over and over again.</p>
<p>像是一首空洞而干枯的长歌。</p>
<p>Just like an empty and desolate long song.</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>求方程数值解</title>
    <url>/2024/10/13/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对求解方程数值解的方法进行总结。</p>
<a id="more"></a>
<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>  <img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/450px-NewtonIteration_Ani.gif" width = "300" alt="图片名称" align=center />  </p>
<p>选择一个接近函数$f(x)$零点的$x_0$，计算相应的$f(x_0)$和切线斜率$f’(x_0)$。然后我们计算穿过点$(x_0,f(x_0))$且斜率为$f’(x_0)$的直线和$x$轴交点的$x$坐标，也就是求如下方程解：</p>
<script type="math/tex; mode=display">
\begin{equation}
0=\left(x-x_{0}\right) \cdot f^{\prime}\left(x_{0}\right)+f\left(x_{0}\right)
\end{equation}</script><p>然后开始下列迭代公式进行迭代，求解$f(x)=0$的解：</p>
<script type="math/tex; mode=display">
\begin{equation}
x_{n+1}=x_{n}-\frac{f\left(x_{n}\right)}{f^{\prime}\left(x_{n}\right)}
\end{equation}</script><h3 id="二次收敛条件"><a href="#二次收敛条件" class="headerlink" title="二次收敛条件"></a>二次收敛条件</h3><ol>
<li>$f’(x)\neq 0$</li>
<li>$f’’(x)$连续</li>
<li>$x_0$足够接近解</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>使用牛顿法求解开普勒方程$f(E)=E-M-e\sin E=0$。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">E = M;</span><br><span class="line"><span class="built_in">i</span> = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> ( <span class="built_in">abs</span>(E-E_ref)&gt; <span class="number">1e-10</span> )</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    E = E - (E-e*<span class="built_in">sin</span>(E)-M)/(<span class="number">1</span>-e*<span class="built_in">cos</span>(E)); </span><br><span class="line">    fprintf(<span class="string">'%3d '</span>, <span class="built_in">i</span>);</span><br><span class="line">    fprintf(<span class="string">'%16.11f '</span>, E);</span><br><span class="line">    fprintf(<span class="string">'%11.2e '</span>, <span class="built_in">abs</span>(E-E_ref));</span><br><span class="line">    fprintf(<span class="string">'%6d \n'</span>, <span class="number">2</span>*<span class="built_in">i</span>);          </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">Wiki about Newton method</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>数学</category>
        <category>数值分析</category>
      </categories>
  </entry>
  <entry>
    <title>极大似然估计</title>
    <url>/2024/10/13/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>根据已知的样本结果信息，反推最有可能导致该结果的模型参数。</p>
<a id="more"></a>
<h2 id="什么是极大似然估计"><a href="#什么是极大似然估计" class="headerlink" title="什么是极大似然估计"></a>什么是极大似然估计</h2><p>一句话，一个参数估计方法，就是确定了模型（比如正态分布），但是参数未知（正态分布的均值和方差未知），有了数据，我需要计算均值$\mu$和方差$\theta$。为了求极大似然估计，我们先要了解似然函数</p>
<h3 id="似然（likelihood）函数"><a href="#似然（likelihood）函数" class="headerlink" title="似然（likelihood）函数"></a>似然（likelihood）函数</h3><p>考虑函数$P(x|\theta)$，这个函数有两个输入，$x$表示具体样本，$\theta$表示模型参数，那么</p>
<ul>
<li>当$\theta$已知，该函数退化为概率函数，即样本$x$出现的概率</li>
<li>当$x$已知，该函数退化为似然函数，即对于不同模型参数，出现$x$这个样本的概率</li>
</ul>
<p>最大似然估计就是第二个问题，已知$x$，求$\theta$，使$P(x|\theta)$最大</p>
<h3 id="极大似然估计的特点"><a href="#极大似然估计的特点" class="headerlink" title="极大似然估计的特点"></a>极大似然估计的特点</h3><h2 id="极大似然估计的例子"><a href="#极大似然估计的例子" class="headerlink" title="极大似然估计的例子"></a>极大似然估计的例子</h2><p>假设一个袋子里有黑球和白球，现在往出放回地摸球，一共摸了十次，有7次黑球3次白球，问黑球所占比例最有可能是多少？如果我们将这个事件视为二项分布，且假设黑球出现的概率为$\theta$，那么现在模型已知（二项分布）、样本已知（10次里7次黑球），求模型参数（$\theta$的值）。假设样本$x_0={1,1,1,0,1,1,0,1,0,1}$。那么似然函数可以写为：</p>
<script type="math/tex; mode=display">
f(x_0|\theta)=\theta^3(1-\theta)\theta^2(1-\theta)\theta(1-\theta)\theta=\theta^7(1-\theta)^3=f(\theta)</script><p>上面的$f(\theta)$就是我们的似然函数，最大似然估计就是求这个函数的最大值，即$\frac{\textrm{d}f(\theta)}{\textrm{d}\theta}=0$。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>STL——常用算法</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/STL/STL%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对C++中STL库的常用算法操作进行总结。</p>
<a id="more"></a>
<h2 id="常用算法API"><a href="#常用算法API" class="headerlink" title="常用算法API"></a>常用算法API</h2><h3 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">count_if(grid[i].begin(),grid[i].end(),[](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span>;&#125;); <span class="comment">//统计x小于0的个数</span></span><br></pre></td></tr></table></figure>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(satisfaction.begin(),  satisfaction.end()); <span class="comment">//正向</span></span><br><span class="line">sort(satisfaction.rbegin(), satisfaction.rend()); <span class="comment">//逆向</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title>STL——顺序容器操作</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/STL/STL%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对顺序容器的操作进行总结。</p>
<a id="more"></a>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="大小和容量"><a href="#大小和容量" class="headerlink" title="大小和容量"></a>大小和容量</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>当我们使用顺序容器时，要注意区分其size和capacity，size表示的是vector中元素的个数即真实占用的大小，而capacity表示的是vector在realloc前允许的最大元素数目，二者之间的关系为：</p>
<script type="math/tex; mode=display">
size \le capacity</script><p>当我们初始化一个vector时，其size和capacity是相等的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(<span class="number">20</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test.size() &lt;&lt; <span class="string">" "</span> &lt;&lt; test.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//20 20</span></span><br></pre></td></tr></table></figure>
<p>当我们添加或删除元素时，不仅size会变动，capacity也会。具体的增长策略详见插入删除元素的操作</p>
<h4 id="修改size-amp-capacity"><a href="#修改size-amp-capacity" class="headerlink" title="修改size &amp; capacity"></a>修改size &amp; capacity</h4><p>size和capacity的修改方法分别为<code>resize</code>和<code>reserve</code>，这里需要注意，reserve后多出的空间是不能直接进行访问的，属于非法空间。另外reserve只能往大修改，不能往小修改，如果当前capacity是四十，那么reserve只能比40大，不能比40小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a test vector which capacity is 40</span></span><br><span class="line"></span><br><span class="line">test.reserve(<span class="number">39</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test.size() &lt;&lt; <span class="string">" "</span> &lt;&lt; test.capacity() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 20 40 reserve只能往大修改，不能往小</span></span><br></pre></td></tr></table></figure>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>插入元素的方式有insert和push_back，insert是在任意位置插入，而push_back是在末尾插入。</p>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">infoVec.insert(infoVec.begin() + index[i], nums[i]);</span><br></pre></td></tr></table></figure>
<p>insert函数第一项为插入位置，输入类型为迭代器，第二项为插入值。<strong>插入完成后，被插入元素就处于index[i]所在位置</strong>，例如有vector [1,2,3,4,5]，调用insert(infoVec.begin() + 1)，vector变为[1,0,2,3,4,5]，0在1的位置处。<strong>尽量不要在vector中使用insert，效率不高</strong>。时间复杂度为$O(n)$。</p>
<h4 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h4><p>push_back直接在末尾进行元素插入，时间复杂度为$O(1)$，更加高效。</p>
<h4 id="增长策略"><a href="#增长策略" class="headerlink" title="增长策略"></a>增长策略</h4><p>如果当前size比capacity小，那么直接将元素插入，否则capacity按照指数型递增，具体的幂次看不同编译器的实现</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>vector中涉及三种删除操作，即clear，erase和pop_back。</p>
<h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><p>clear直接清空元素，但保持vector容量不变，即将size设为0，capacity不变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个size和capacity都为20的vector</span></span><br><span class="line">test.clear();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test.size() &lt;&lt; <span class="string">" "</span> &lt;&lt; test.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 20</span></span><br></pre></td></tr></table></figure>
<h4 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h4><p>erase可以删除单个或指定范围内的元素，但保持容量不变，其时间复杂度为$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">    test.erase(test.begin()); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test.size() &lt;&lt; <span class="string">" "</span> &lt;&lt; test.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="number">20</span> <span class="number">20</span></span><br><span class="line"><span class="number">19</span> <span class="number">20</span></span><br><span class="line">......</span><br><span class="line"><span class="number">2</span> <span class="number">20</span></span><br><span class="line"><span class="number">1</span> <span class="number">20</span></span><br><span class="line"><span class="number">0</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h4 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h4><p>pop_back用于删除尾部元素，容量也不变。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>尽量用clear或pop_back，别用erase，此外删除操作不改变容量的大小。</p>
<h2 id="queue-amp-deque"><a href="#queue-amp-deque" class="headerlink" title="queue &amp; deque"></a>queue &amp; deque</h2><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><h3 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque(双端队列)"></a>deque(双端队列)</h3><p>双端队列本质上是栈和队列的集合，如果需要 FIFO （先进先出）的顺序，则将新元素添加到队列尾部，后插入的元素就可以排在后面。如果需要 FILO （先进后出）的顺序，则将新元素添加到队列首部，后插入的元素就可以排在前面。</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>在C++STL中，优先队列通过二叉堆实现，且为大根堆，即最大的元素总在最上面。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title>STL——关联容器操作</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/STL/STL%E2%80%94%E2%80%94%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对关联容器的操作进行总结。</p>
<a id="more"></a>
<p>关联容器有两大类，map和set，一个用于索引，一个用于判断存在性。在C++中常用四个关联容器，map &amp; unordered_map, set &amp; unordered_set, 其中unordered表示不排序，如果没有排序需求，尽量使用unordered提升效率。</p>
<h2 id="map-amp-unordered-map"><a href="#map-amp-unordered-map" class="headerlink" title="map &amp; unordered_map"></a>map &amp; unordered_map</h2><p>map和multimap的底层是通过红黑树实现的，而unordered_map底层为哈希表</p>
<h3 id="map相关操作"><a href="#map相关操作" class="headerlink" title="map相关操作"></a>map相关操作</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>map的插入共有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">accountMap.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">100</span>,<span class="number">100</span>));     <span class="comment">//插入键值对，不能覆盖</span></span><br><span class="line">accountMap.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(<span class="number">100</span>, <span class="number">100</span>)); <span class="comment">//同上</span></span><br><span class="line">accountMap[<span class="number">100</span>] = <span class="number">100</span>;            <span class="comment">//array 方式插入，可覆盖</span></span><br></pre></td></tr></table></figure>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>通过<strong>键是否存在，查找键值对是否在map中</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = accountMap.find(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(iter != accountMap.end())</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"the item is found and value is"</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"the item isn't found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">iter = accountMap.find(<span class="number">100</span>);</span><br><span class="line">accountMap.erase(iter);                  <span class="comment">//迭代器刪除</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> isDeleted = accountMap.erase(<span class="number">100</span>);         <span class="comment">// 用关键字刪除,删除返回1，否则返回0</span></span><br></pre></td></tr></table></figure>
<h2 id="Set-amp-unordered-set"><a href="#Set-amp-unordered-set" class="headerlink" title="Set &amp; unordered_set"></a>Set &amp; unordered_set</h2><p>set和multiset底层采用红黑树实现，而unordered_set采用哈希表。</p>
<h3 id="Set相关操作"><a href="#Set相关操作" class="headerlink" title="Set相关操作"></a>Set相关操作</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(ivec.cbegin(), ivec.cend())</span></span>;   <span class="comment">// 利用vector初始化set</span></span><br></pre></td></tr></table></figure>
<h5 id="增删查"><a href="#增删查" class="headerlink" title="增删查"></a>增删查</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span>(iset.find(<span class="number">5</span>) == iset.end())  <span class="comment">// 没找到</span></span><br></pre></td></tr></table></figure>
<h4 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h4><ul>
<li>判断两个集合交集<code>set_intersection</code>函数</li>
</ul>
<p>函数模板为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">OutputIterator</span> <span class="title">set_intersection</span> (<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">OutputIterator</span> <span class="title">result</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1!=last1 &amp;&amp; first2!=last2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first1&lt;*first2) ++first1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*first2&lt;*first1) ++first2;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *result = *first1;</span><br><span class="line">      ++result; ++first1; ++first2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用注意事项：待比较的两个集合必须先排序，才能正确判断交集。</p>
<p>例题：LeetCode 350</p>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="built_in">std</span>::sort(nums1.begin(), nums1.end());</span><br><span class="line">    <span class="built_in">std</span>::sort(nums2.begin(), nums2.end());</span><br><span class="line">    <span class="built_in">std</span>::set_intersection(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), <span class="built_in">std</span>::back_inserter(ret)); <span class="comment">// back_inserter, 使用push_back()添加相应元素</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h2><h3 id="自定义哈希函数"><a href="#自定义哈希函数" class="headerlink" title="自定义哈希函数"></a>自定义哈希函数</h3><p>在使用unordered_set和unordered_map时，我们可以使用自定义哈希函数，一个自定义哈希函数编写方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyHash</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(k.first) ^</span><br><span class="line">            (<span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(k.second) &lt;&lt; <span class="number">1</span>);  <span class="comment">//采用stl库创建hash函数 ，前面的括号代表创建一个临时对象，尽量不要这么写，应当改为std::hash&lt;std::string&gt;&#123;&#125;(k.first);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title>如何成为一名优秀的软件工程师</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E8%A7%84%E8%8C%83/%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>普天之下，哪怕有一个也好，必须寻找出能俘获自己这颗心的伟大的东西，美丽的东西，或是慈祥的东西。</p>
</blockquote>
<a id="more"></a>
<h2 id="重构的作用"><a href="#重构的作用" class="headerlink" title="重构的作用"></a>重构的作用</h2><p>绝大多数的人，都无法做到一下就写出漂亮、完美的代码，因此我们才需要重构，重构使得我们能够逐步地对代码进行反省，从而令其更加简洁，逐渐趋于完美。可以把代码创造比作雕刻的过程，如果第一次的编写是开模，那么后续的重构就是一点点地精细化，最终创造出精美的艺术品。</p>
<h2 id="优秀特质"><a href="#优秀特质" class="headerlink" title="优秀特质"></a>优秀特质</h2><h3 id="良好习惯"><a href="#良好习惯" class="headerlink" title="良好习惯"></a>良好习惯</h3><p>作为一个工程师，我们需要保持如下良好的习惯：</p>
<ul>
<li>专注可用性：以代码功能作为终极追求，最终软件是给用户使用的，一定要将用户放在心中</li>
<li>善用现有的好代码，一个好的工程师，会专注于三种基本重用，不要重复造轮子，除非以学习为目的<ul>
<li>内部基础架构重用</li>
<li>第三方函数库</li>
<li>大型软件服务商提供的服务</li>
</ul>
</li>
<li>代码高可维护性，代码每一行都必须恰如其分地展现其目的，不要写糟糕的代码，哪怕时间再紧张</li>
<li>编写测试：测试的目的就是为了创建能够正常工作的系统</li>
</ul>
<h3 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h3><p>愿意学习新语言、新函数库和新方法，用最新的武器武装自己。</p>
<h3 id="如何变得优秀"><a href="#如何变得优秀" class="headerlink" title="如何变得优秀"></a>如何变得优秀</h3><ul>
<li>精益求精：不要妥协，写烂代码</li>
<li>甘于磨练：自己解决一个问题，不要一开始就求助别人，反复磨练，不断提升自己的能力</li>
<li>不断学习：</li>
<li>分享知识：</li>
<li>乐于助人：</li>
<li>从容耐心：欲速则不达，成神之路是一条漫长的路</li>
</ul>
<h2 id="扩展学习资料"><a href="#扩展学习资料" class="headerlink" title="扩展学习资料"></a>扩展学习资料</h2><p>C++程序设计语言</p>
<p>C++ primer</p>
<p>C++语言的设计和演化</p>
<p>C++编程思想</p>
<p>More Effective C++</p>
<p>C++编程艺术</p>
<p>A philosophy of software design</p>
<p>设计原则&amp;设计模式</p>
<p>重构：改善既有代码的设计</p>
<p>零信任架构</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
        <category>规范</category>
      </categories>
  </entry>
  <entry>
    <title>C++注释规范</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E8%A7%84%E8%8C%83/C++%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>良好的文档及注释对于程序开发理解有举足轻重的作用，它应当帮助人们理解如下问题<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>
<ul>
<li>类间继承关系</li>
<li>全局变量</li>
<li>不同的用户定义类型</li>
<li>函数使用</li>
</ul>
<p>本文将以文档生成工具doxygen为例，对C++的注释规范进行总结。</p>
<a id="more"></a>
<h2 id="QT下自动注释生成"><a href="#QT下自动注释生成" class="headerlink" title="QT下自动注释生成"></a>QT下自动注释生成</h2><p>在类、函数或变量的前面写<code>/**</code>，然后回车，会自动生成doxygen风格的注释。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief The lambertian class    </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="基于doxygen的代码注释风格"><a href="#基于doxygen的代码注释风格" class="headerlink" title="基于doxygen的代码注释风格"></a>基于doxygen的代码注释风格</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/∗! \file globaldecls.h</span><br><span class="line">    \brief Place to look <span class="keyword">for</span> global variables, enums, functions <span class="keyword">and</span> macro definitions</span><br><span class="line">∗/</span><br><span class="line"></span><br><span class="line">/∗∗ \var <span class="keyword">const</span> <span class="keyword">int</span> fileSize</span><br><span class="line">    \brief Default size of the file on disk</span><br><span class="line">∗/</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fileSize = <span class="number">1048576</span>;</span><br><span class="line"></span><br><span class="line">/∗∗ \<span class="function">def <span class="title">SHIFT</span><span class="params">(value, length)</span></span></span><br><span class="line">      \brief Left shift value by length in bits</span><br><span class="line">  ∗/</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT(value, length) ((value) &lt;&lt; (length))</span></span><br><span class="line"></span><br><span class="line">/∗∗ \<span class="function">fn <span class="keyword">bool</span> <span class="title">check_for_io_errors</span><span class="params">(FILE∗ fp)</span></span></span><br><span class="line">      \brief Checks if a file is corrupted or not</span><br><span class="line">      \param fp Pointer to an already opened file</span><br><span class="line">      \warning Not thread safe!</span><br><span class="line">  ∗/</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_for_io_errors</span><span class="params">(FILE∗ fp)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://developer.ibm.com/articles/au-learningdoxygen/">Learning doxygen</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
        <category>规范</category>
      </categories>
  </entry>
  <entry>
    <title>sharepool介绍</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OpenEuler/sharepool%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将对sharepool进行概述</p>
<a id="more"></a>
<h2 id="接口列表"><a href="#接口列表" class="headerlink" title="接口列表"></a>接口列表</h2><div class="table-container">
<table>
<thead>
<tr>
<th>接口名</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>sp_group_add_task</td>
<td>向sharepool中添加一个进程</td>
<td>不能用于中断上下文</td>
</tr>
<tr>
<td>sp_group_drop</td>
<td>丢弃一个spg</td>
<td>每次使用一个spg后调用</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="sp-group-add-task"><a href="#sp-group-add-task" class="headerlink" title="sp_group_add_task"></a>sp_group_add_task</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p><code>sp_group_add_task</code>声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sp_group_add_task() - Add a process to an share group (sp_group).</span></span><br><span class="line"><span class="comment"> * @pid: the pid of the task to be added.</span></span><br><span class="line"><span class="comment"> * @spg_id: the ID of the sp_group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A thread group can't be added to more than one sp_group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: A postive group number for success, -errno on failure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The manually specified ID is between [SPG_ID_MIN, SPG_ID_MAX].</span></span><br><span class="line"><span class="comment"> * The automatically allocated ID is between [SPG_ID_AUTO_MIN, SPG_ID_AUTO_MAX].</span></span><br><span class="line"><span class="comment"> * When negative, the return value is -errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sp_group_add_task</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> spg_id)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>向sharepool组中添加一个进程的整体流程图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/addtask.svg" width = "150" alt="图片名称" align=center /></p>
<h3 id="spg-id检查"><a href="#spg-id检查" class="headerlink" title="spg id检查"></a>spg id检查</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mdc scene hack */</span></span><br><span class="line"><span class="keyword">if</span> (enable_mdc_default_group)</span><br><span class="line">    spg_id = mdc_default_group_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Valid spg id */</span></span><br><span class="line"><span class="keyword">if</span> ((spg_id &lt; SPG_ID_MIN || spg_id &gt; SPG_ID_AUTO)</span><br><span class="line">    &amp;&amp; spg_id != SPG_ID_DVPP_PASS_THROUGH) &#123;</span><br><span class="line">    pr_err_ratelimited(<span class="string">"share pool: task add group failed, invalid group id %d\n"</span>, spg_id);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In auto spg range, find a usable spg. Here we just find and </span></span><br><span class="line"><span class="comment"> * test the validation of the spg, we do not use it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (spg_id &gt;= SPG_ID_AUTO_MIN &amp;&amp; spg_id &lt;= SPG_ID_AUTO_MAX) &#123;</span><br><span class="line">    spg = __sp_find_spg(pid, spg_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!spg) &#123;</span><br><span class="line">        pr_err_ratelimited(<span class="string">"share pool: spg %d hasn't been created\n"</span>, spg_id);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    down_read(&amp;spg-&gt;rw_lock);</span><br><span class="line">    <span class="keyword">if</span> (!spg_valid(spg)) &#123;</span><br><span class="line">        up_read(&amp;spg-&gt;rw_lock);</span><br><span class="line">        pr_err_ratelimited(<span class="string">"share pool: task add group failed, group id %d is dead\n"</span>, spg_id);</span><br><span class="line">        sp_group_drop(spg);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    up_read(&amp;spg-&gt;rw_lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* We need to drop the spg, see __sp_find_spg, we regard finding </span></span><br><span class="line"><span class="comment">     * of spg as an occupation action to spg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sp_group_drop(spg);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Auto alloc a new spg between [SPG_ID_AUTO_MAX, SPG_ID_AUTO_MIN]  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (spg_id == SPG_ID_AUTO) &#123;</span><br><span class="line">    spg_id = ida_alloc_range(&amp;sp_group_id_ida, SPG_ID_AUTO_MIN,</span><br><span class="line">                             SPG_ID_AUTO_MAX, GFP_ATOMIC);</span><br><span class="line">    <span class="keyword">if</span> (spg_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err_ratelimited(<span class="string">"share pool: task add group failed, auto generate group id failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> spg_id;</span><br><span class="line">    &#125;</span><br><span class="line">    id_newly_generated = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DVPP type spg, we will discuss this later */</span></span><br><span class="line"><span class="keyword">if</span> (spg_id == SPG_ID_DVPP_PASS_THROUGH) &#123;</span><br><span class="line">    spg_id = ida_alloc_range(&amp;sp_group_id_ida,</span><br><span class="line">                             SPG_ID_DVPP_PASS_THROUGH_MIN,</span><br><span class="line">                             SPG_ID_DVPP_PASS_THROUGH_MAX, GFP_ATOMIC);</span><br><span class="line">    <span class="keyword">if</span> (spg_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err_ratelimited(<span class="string">"share pool: task add group failed, DVPP auto generate group id failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> spg_id;</span><br><span class="line">    &#125;</span><br><span class="line">    id_newly_generated = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找对应进程"><a href="#寻找对应进程" class="headerlink" title="寻找对应进程"></a>寻找对应进程</h3>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>OpenEuler</category>
      </categories>
  </entry>
  <entry>
    <title>C++命名规范</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E8%A7%84%E8%8C%83/C++%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>如果脏了还用，就莫不如一开始就用带颜色的。白的就要纯白才行。</p>
</blockquote>
<a id="more"></a>
<p>本文根据<a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a>，对其中相关命名规范进行总结。</p>
<p>基本的命名规则为：</p>
<ul>
<li>尽量不要用缩写，除非人尽皆知</li>
<li>变量和类型用名词，函数用动词</li>
<li>尽量使用描述性词语，做到见名知意</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>子项目</th>
<th>命名方式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>头文件宏定义</td>
<td>全部大写，PROJECT<em>PATH_FILE_H</em></td>
<td>JOS<em>KERN_ENV_H</em></td>
</tr>
<tr>
<td></td>
<td>命名空间</td>
<td>用小写，且基于项目进行命名</td>
<td></td>
</tr>
<tr>
<td></td>
<td>文件</td>
<td>文件名全部小写，且用_分割</td>
<td>url_table</td>
</tr>
<tr>
<td></td>
<td>类型</td>
<td>类名采用每个单词首字母大写的方式</td>
<td>MyClass</td>
</tr>
<tr>
<td>变量</td>
<td>普通变量</td>
<td>变量名全部小写，且用_分割</td>
<td>table_name</td>
</tr>
<tr>
<td></td>
<td>类成员变量</td>
<td>变量名全部小写，且用_分割，最后加一个下划线</td>
<td>table<em>name</em></td>
</tr>
<tr>
<td></td>
<td>全局变量</td>
<td>在变量名前加<code>g_</code></td>
<td>g_table_name</td>
</tr>
<tr>
<td></td>
<td>常量</td>
<td>k起头，后面为每个单词首字母大写</td>
<td>kDaysInAWeek</td>
</tr>
<tr>
<td>函数</td>
<td>普通函数</td>
<td>每个单词首字母大写</td>
<td>AddTableEntry()</td>
</tr>
<tr>
<td></td>
<td>getter/setter函数</td>
<td>与要获得的变量名相匹配</td>
<td>get_num_entries/set_num_entries</td>
</tr>
</tbody>
</table>
</div>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++代码范例</title>
    <url>/2024/10/13/%E5%B7%A5%E5%85%B7/C++/%E8%A7%84%E8%8C%83/C++%E4%BB%A3%E7%A0%81%E8%8C%83%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>红警源代码中的头文件，写的非常规范，建议模仿。</p>
<a id="more"></a>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ul>
<li>如果是内部函数，那么要加下划线加以提示</li>
</ul>
<h2 id="头文件范例"><a href="#头文件范例" class="headerlink" title="头文件范例"></a>头文件范例</h2><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************************************</span></span><br><span class="line"><span class="comment"> ***              C O N F I D E N T I A L  ---  W E S T W O O D  S T U D I O S               ***</span></span><br><span class="line"><span class="comment"> ***********************************************************************************************</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                 Project Name : Command &amp; Conquer                                            *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                    File Name : AIRCRAFT.H                                                   *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                   Programmer : Joe L. Bostic                                                *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                   Start Date : July 22, 1994                                                *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                  Last Update : November 28, 1994 [JLB]                                      *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *---------------------------------------------------------------------------------------------*</span></span><br><span class="line"><span class="comment"> * Functions:                                                                                  *</span></span><br><span class="line"><span class="comment"> * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> AIRCRAFT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AIRCRAFT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">"radio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">"fly.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">"target.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**	This aircraft class is used for all flying sentient objects. This includes fixed wing</span></span><br><span class="line"><span class="comment">**	aircraft as well as helicopters. It excludes bullets even though some bullets might</span></span><br><span class="line"><span class="comment">**	be considered to be "flying" in a loose interpretatin of the word.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AircraftClass</span> :</span> <span class="keyword">public</span> FootClass, <span class="keyword">public</span> FlyClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	This is a pointer to the class control structure for the aircraft.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        CCPtr&lt;AircraftTypeClass&gt; Class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-----------------------------------------------------------------------------</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span> * ptr)</span> </span>&#123;<span class="keyword">return</span>(ptr);&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">AircraftType</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> Class-&gt;Type;&#125;;</span><br><span class="line">        AircraftClass(AircraftType classid, HousesType house);</span><br><span class="line">        AircraftClass(NoInitClass <span class="keyword">const</span> &amp; x) : FootClass(x), FlyClass(x), Class(x), SecondaryFacing(x), SightTimer(x) &#123;&#125;;</span><br><span class="line">        <span class="keyword">virtual</span> ~AircraftClass(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Mission_Attack</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Mission_Unload</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Mission_Hunt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Mission_Retreat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Mission_Move</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Mission_Enter</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Mission_Guard</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Mission_Guard_Area</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Assign_Destination</span><span class="params">(TARGET target)</span></span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	State machine support routines.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Process_Take_Off</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Process_Landing</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Process_Fly_To</span><span class="params">(<span class="keyword">bool</span> slowdown, TARGET dest)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Query functions.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> LayerType <span class="title">In_Which_Layer</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DirType <span class="title">Turret_Facing</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span>(SecondaryFacing.Current());&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Shape_Number</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> MoveType <span class="title">Can_Enter_Cell</span><span class="params">(CELL cell, FacingType facing=FACING_NONE)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> ObjectTypeClass <span class="keyword">const</span> &amp; <span class="title">Class_Of</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> *Class;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> ActionType <span class="title">What_Action</span><span class="params">(ObjectClass <span class="keyword">const</span> * target)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> ActionType <span class="title">What_Action</span><span class="params">(CELL cell)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DirType <span class="title">Desired_Load_Dir</span><span class="params">(ObjectClass * passenger, CELL &amp; moveto)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Pip_Count</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function">TARGET <span class="title">Good_Fire_Location</span><span class="params">(TARGET target)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Cell_Seems_Ok</span><span class="params">(CELL cell, <span class="keyword">bool</span> landing=<span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function">DirType <span class="title">Pose_Dir</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function">TARGET <span class="title">Good_LZ</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DirType <span class="title">Fire_Direction</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> FireErrorType <span class="title">Can_Fire</span><span class="params">(TARGET target, <span class="keyword">int</span> which)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Landing zone support functionality.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Per_Cell_Process</span><span class="params">(PCPType why)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Is_LZ_Clear</span><span class="params">(TARGET target)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function">TARGET <span class="title">New_LZ</span><span class="params">(TARGET oldlz)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Coordinate inquiry functions. These are used for both display and</span></span><br><span class="line"><span class="comment">		**	combat purposes.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> COORDINATE <span class="title">Sort_Y</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Object entry and exit from the game system.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Unlimbo</span><span class="params">(COORDINATE , DirType facing = DIR_N)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Display and rendering support functionality. Supports imagery and how</span></span><br><span class="line"><span class="comment">		**	object interacts with the map and thus indirectly controls rendering.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Look</span><span class="params">(<span class="keyword">bool</span> incremental=<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Draw_Rotors</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, WindowNumberType window)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Exit_Object</span><span class="params">(TechnoClass *)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> short <span class="keyword">const</span> * <span class="title">Overlap_List</span><span class="params">(<span class="keyword">bool</span> redraw=<span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw_It</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, WindowNumberType window)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Set_Speed</span><span class="params">(<span class="keyword">int</span> speed)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	User I/O.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Active_Click_With</span><span class="params">(ActionType action, ObjectClass * object)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Active_Click_With</span><span class="params">(ActionType action, CELL cell)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Player_Assign_Mission</span><span class="params">(MissionType mission, TARGET target=TARGET_NONE, TARGET destination=TARGET_NONE)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Response_Select</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Response_Move</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Response_Attack</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Combat related.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> ResultType <span class="title">Take_Damage</span><span class="params">(<span class="keyword">int</span> &amp; damage, <span class="keyword">int</span> distance, WarheadType warhead, TechnoClass * source, <span class="keyword">bool</span> forced=<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> BulletClass * <span class="title">Fire_At</span><span class="params">(TARGET target, <span class="keyword">int</span> which)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	AI.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Landing_Takeoff_AI</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Edge_Of_World_AI</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Movement_AI</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Rotation_AI</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Paradrop_Cargo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AI</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Enter_Idle_Mode</span><span class="params">(<span class="keyword">bool</span> initial = <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> RadioMessageType <span class="title">Receive_Message</span><span class="params">(RadioClass * from, RadioMessageType message, <span class="keyword">long</span> &amp; param)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Scatter</span><span class="params">(COORDINATE threat, <span class="keyword">bool</span> forced=<span class="literal">false</span>, <span class="keyword">bool</span> nokidding=<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Scenario and debug support.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CHEAT_KEYS</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Debug_Dump</span><span class="params">(MonoClass *mono)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	File I/O.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Read_INI</span><span class="params">(CCINIClass &amp; ini)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">char</span> * <span class="title">INI_Name</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;<span class="keyword">return</span> <span class="string">"AIRCRAFT"</span>;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Load</span><span class="params">(Straw &amp; file)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Save</span><span class="params">(Pipe &amp; file)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">Spied_By</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	This is the facing used for the body of the aircraft. Typically, this is the same</span></span><br><span class="line"><span class="comment">		**	as the PrimaryFacing, but in the case of helicopters, it can be different.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        FacingClass SecondaryFacing;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	If this is a passenger carrying aircraft then this flag will be set. This is</span></span><br><span class="line"><span class="comment">		**	necessary because once the passengers are unloaded, the fact that it was a</span></span><br><span class="line"><span class="comment">		**	passenger carrier must still be known.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">bool</span> Passenger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Aircraft can be in either state of landing, taking off, or in steady altitude.</span></span><br><span class="line"><span class="comment">		**	These flags are used to control transition between flying and landing. It is</span></span><br><span class="line"><span class="comment">		**	necessary to handle the transition in this manner so that it occurs smoothly</span></span><br><span class="line"><span class="comment">		**	during the graphic processing section.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> IsLanding:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> IsTakingOff:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	It is very common for aircraft to be homing in on a target. When this flag is</span></span><br><span class="line"><span class="comment">		**	true, the aircraft will constantly adjust its facing toward the TarCom. When the</span></span><br><span class="line"><span class="comment">		**	target is very close (one cell away or less), then this flag is automatically cleared.</span></span><br><span class="line"><span class="comment">		**	This is because the homing algorithm is designed to get the aircraft to the destination</span></span><br><span class="line"><span class="comment">		**	but no more. Checking when this flag is cleared is a way of flagging transition into</span></span><br><span class="line"><span class="comment">		**	a new mode. Example: Transport helicopters go into a hovering into correct position</span></span><br><span class="line"><span class="comment">		**	mode when the target is reached.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> IsHoming:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Helicopters that are about to land must hover into a position exactly above the landing</span></span><br><span class="line"><span class="comment">		**	zone. When this flag is true, the aircraft will be adjusted so that it is exactly over</span></span><br><span class="line"><span class="comment">		**	the TarCom. The facing of the aircraft is not altered by this movement. The affect</span></span><br><span class="line"><span class="comment">		**	like the helicopter is hovering and shifting sideways to position over the landing</span></span><br><span class="line"><span class="comment">		**	zone. When the position is over the landing zone, then this flag is set to false.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> IsHovering:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	This is the jitter tracker to be used when the aircraft is a helicopter and</span></span><br><span class="line"><span class="comment">		**	is flying. It is most noticeable when the helicopter is hovering.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> Jitter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	This timer controls when the aircraft will reveal the terrain around itself.</span></span><br><span class="line"><span class="comment">		**	When this timer expires and this aircraft has a sight range, then the</span></span><br><span class="line"><span class="comment">		**	look around process will occur.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        CDTimerClass&lt;FrameTimerClass&gt; SightTimer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		**	Most attack aircraft can make several attack runs. This value contains the</span></span><br><span class="line"><span class="comment">		**	number of attack runs the aircraft has left. When this value reaches</span></span><br><span class="line"><span class="comment">		**	zero then the aircraft is technically out of ammo.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">char</span> AttacksRemaining;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		** Some additional padding in case we need to add data to the class and maintain backwards compatibility for save/load</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> SaveLoadPadding[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</div></div>
<h2 id="CPP文件范例"><a href="#CPP文件范例" class="headerlink" title="CPP文件范例"></a>CPP文件范例</h2><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************************************</span></span><br><span class="line"><span class="comment"> ***              C O N F I D E N T I A L  ---  W E S T W O O D  S T U D I O S               ***</span></span><br><span class="line"><span class="comment"> ***********************************************************************************************</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                 Project Name : Command &amp; Conquer                                            *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                    File Name : AIRCRAFT.CPP                                                 *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                   Programmer : Joe L. Bostic                                                *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                   Start Date : July 22, 1994                                                *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *                  Last Update : November 2, 1996 [JLB]                                       *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *---------------------------------------------------------------------------------------------*</span></span><br><span class="line"><span class="comment"> * Functions:                                                                                  *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::AI -- Processes the normal non-graphic AI for the aircraft.                *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Active_Click_With -- Handles clicking over specified cell.                 *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Active_Click_With -- Handles clicking over specified object.               *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::AircraftClass -- The constructor for aircraft objects.                     *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Can_Enter_Cell -- Determines if the aircraft can land at this location.    *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Can_Fire -- Checks to see if the aircraft can fire.                        *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Cell_Seems_Ok -- Checks to see if a cell is good to enter.                 *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Desired_Load_Dir -- Determines where passengers should line up.            *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Draw_It -- Renders an aircraft object at the location specified.           *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Draw_Rotors -- Draw rotor blades on the aircraft.                          *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Edge_Of_World_AI -- Detect if aircraft has exited the map.                 *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Enter_Idle_Mode -- Gives the aircraft an appropriate mission.              *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Exit_Object -- Unloads passenger from aircraft.                            *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Fire_At -- Handles firing a projectile from an aircraft.                   *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Fire_Direction -- Determines the direction of fire.                        *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Good_Fire_Location -- Searches for and finds a good spot to fire from.     *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Good_LZ -- Locates a good spot ot land.                                    *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::In_Which_Layer -- Calculates the display layer of the aircraft.            *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Init -- Initialize the aircraft system to an empty state.                  *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Is_LZ_Clear -- Determines if landing zone is free for landing.             *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Landing_Takeoff_AI -- Handle aircraft take off and landing processing.     *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Look -- Aircraft will look if they are on the ground always.               *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Mission_Attack -- Handles the attack mission for aircraft.                 *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Mission_Enter -- Control aircraft to fly to the helipad or repair center.  *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Mission_Guard -- Handles aircraft in guard mode.                           *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Mission_Guard_Area -- Handles the aircraft guard area logic.               *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Mission_Hunt -- Maintains hunt AI for the aircraft.                        *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Mission_Move -- Handles movement mission.                                  *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Mission_Retreat -- Handles the aircraft logic for leaving the battlefield. *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Mission_Unload -- Handles unloading cargo.                                 *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Movement_AI -- Handles aircraft physical movement logic.                   *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::New_LZ -- Find a good landing zone.                                        *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Overlap_List -- Returns with list of cells the aircraft overlaps.          *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Paradrop_Cargo -- Drop a passenger by parachute.                           *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Per_Cell_Process -- Handle the aircraft per cell process.                  *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Pip_Count -- Returns the number of "objects" in aircraft.                  *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Player_Assign_Mission -- Handles player input to assign a mission.         *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Pose_Dir -- Fetches the natural landing facing.                            *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Process_Fly_To -- Handles state machine for flying to destination.         *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Process_Landing -- Landing process state machine handler.                  *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Process_Take_Off -- State machine support for taking off.                  *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Read_INI -- Reads aircraft object data from an INI file.                   *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Receive_Message -- Handles receipt of radio messages.                      *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Response_Attack -- Gives audio response to attack order.                   *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Response_Move -- Gives audio response to move request.                     *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Response_Select -- Gives audio response when selected.                     *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Rotation_AI -- Handle aircraft body and flight rotation.                   *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Scatter -- Causes the aircraft to move away a bit.                         *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Set_Speed -- Sets the speed for the aircraft.                              *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Shape_Number -- Fetch the shape number to use for the aircraft.            *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Sort_Y -- Figures the sorting coordinate.                                  *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Take_Damage -- Applies damage to the aircraft.                             *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::Unlimbo -- Removes an aircraft from the limbo state.                       *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::What_Action -- Determines what action to perform.                          *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::What_Action -- Determines what action to perform.                          *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::operator delete -- Deletes the aircraft object.                            *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::operator new -- Allocates a new aircraft object from the pool              *</span></span><br><span class="line"><span class="comment"> *   AircraftClass::~AircraftClass -- Destructor for aircraft object.                          *</span></span><br><span class="line"><span class="comment"> *   _Counts_As_Civ_Evac -- Is the specified object a candidate for civilian evac logic?       *</span></span><br><span class="line"><span class="comment"> * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************************************</span></span><br><span class="line"><span class="comment"> * _Counts_As_Civ_Evac -- Is the specified object a candidate for civilian evac logic?         *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *    Examines the specified object to see if it qualifies to be a civilian evacuation. This   *</span></span><br><span class="line"><span class="comment"> *    can only occur if it is a civilian (or Tanya) and the special evacuation flag has been   *</span></span><br><span class="line"><span class="comment"> *    set in the scenario control structure.                                                   *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * INPUT:   candidate   -- Candidate object to examine for civilian evacuation legality.       *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * OUTPUT:  bool; Is the specified object considered a civilian that must be auto-evacuated?   *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * WARNINGS:   none                                                                            *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * HISTORY:                                                                                    *</span></span><br><span class="line"><span class="comment"> *   06/24/1996 JLB : Created.                                                                 *</span></span><br><span class="line"><span class="comment"> *=============================================================================================*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span>    <span class="comment">//将返回类型和函数名分行，可以更清晰，因为有的返回类型非常离谱 </span></span><br><span class="line">_Counts_As_Civ_Evac(ObjectClass <span class="keyword">const</span> * candidate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	**	If the candidate pointer is missing, then return with failure code.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (candidate == <span class="literal">NULL</span>) <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	**	Only infantry objects can be considered for civilian evacuation action.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (candidate-&gt;What_Am_I() != RTTI_INFANTRY) <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	**	Working infantry object pointer.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    InfantryClass <span class="keyword">const</span> * inf = (InfantryClass <span class="keyword">const</span> *)candidate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	**	Certain infantry types will always be considered a civilian evacuation candidate. These</span></span><br><span class="line"><span class="comment">	**	include the special one-time infantry that appear in some missions.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (*inf == INFANTRY_EINSTEIN || *inf == INFANTRY_GENERAL || *inf == INFANTRY_DELPHI || *inf == INFANTRY_CHAN) <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	**	Consider Tanya to be part of the civilian evacuation logic if the scenario is</span></span><br><span class="line"><span class="comment">	**	specially flagged for this.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (Scen.IsTanyaEvac &amp;&amp; *inf == INFANTRY_TANYA) <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	**	If the infantry is not a civilian, then it isn't allowed to be a civilian evacuation.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!inf-&gt;Class-&gt;IsCivilian) <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	**	Technicians look like civilians, but are not considered a legal evacuation candidate.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (inf-&gt;IsTechnician) <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	**	All tests pass, so return the success of the infantry as a civilian evacuation candidate.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************************************</span></span><br><span class="line"><span class="comment"> * AircraftClass::operator new -- Allocates a new aircraft object from the pool                *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *    This routine will allocate an aircraft object from the free aircraft object pool. If     *</span></span><br><span class="line"><span class="comment"> *    there are no free object available, then this routine will fail (return NULL).           *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * INPUT:   none                                                                               *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * OUTPUT:  Returns with a pointer to the allocate aircraft object or NULL if none were        *</span></span><br><span class="line"><span class="comment"> *          available.                                                                         *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * WARNINGS:   none                                                                            *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * HISTORY:                                                                                    *</span></span><br><span class="line"><span class="comment"> *   07/26/1994 JLB : Created.                                                                 *</span></span><br><span class="line"><span class="comment"> *=============================================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * AircraftClass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * ptr = Aircraft.Allocate();</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        ((AircraftClass *)ptr)-&gt;Set_Active();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************************************</span></span><br><span class="line"><span class="comment"> * AircraftClass::operator delete -- Deletes the aircraft object.                              *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *    This routine will return the aircraft object back to the free aircraft object pool.      *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * INPUT:   ptr   -- Pointer to the aircraft object to delete.                                 *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * OUTPUT:  none                                                                               *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * WARNINGS:   none                                                                            *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * HISTORY:                                                                                    *</span></span><br><span class="line"><span class="comment"> *   07/26/1994 JLB : Created.                                                                 *</span></span><br><span class="line"><span class="comment"> *=============================================================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> AircraftClass::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        ((AircraftClass *)ptr)-&gt;IsActive = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Aircraft.Free((AircraftClass *)ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************************************</span></span><br><span class="line"><span class="comment"> * AircraftClass::AircraftClass -- The constructor for aircraft objects.                       *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *    This routine is the constructor for aircraft objects. An aircraft object can be          *</span></span><br><span class="line"><span class="comment"> *    created and possibly placed into the game system by this routine.                        *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * INPUT:   classid  -- The type of aircraft to create.                                        *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> *          house    -- The owner of this aircraft.                                            *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * OUTPUT:  none                                                                               *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * WARNINGS:   none                                                                            *</span></span><br><span class="line"><span class="comment"> *                                                                                             *</span></span><br><span class="line"><span class="comment"> * HISTORY:                                                                                    *</span></span><br><span class="line"><span class="comment"> *   07/26/1994 JLB : Created.                                                                 *</span></span><br><span class="line"><span class="comment"> *=============================================================================================*/</span></span><br><span class="line">AircraftClass::AircraftClass(AircraftType classid, HousesType house) :</span><br><span class="line">    FootClass(RTTI_AIRCRAFT, Aircraft.ID(<span class="keyword">this</span>), house),</span><br><span class="line">    Class(AircraftTypes.Ptr((<span class="keyword">int</span>)classid)),</span><br><span class="line">    SecondaryFacing(PrimaryFacing),</span><br><span class="line">    Passenger(<span class="literal">false</span>),</span><br><span class="line">    IsLanding(<span class="literal">false</span>),</span><br><span class="line">    IsTakingOff(<span class="literal">false</span>),</span><br><span class="line">    IsHovering(<span class="literal">false</span>),</span><br><span class="line">    Jitter(<span class="number">0</span>),</span><br><span class="line">    SightTimer(<span class="number">0</span>),</span><br><span class="line">    AttacksRemaining(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	**	For two shooters, clear out the second shot flag -- it will be set the first time</span></span><br><span class="line"><span class="comment">	**	the object fires. For non two shooters, set the flag since it will never be cleared</span></span><br><span class="line"><span class="comment">	**	and the second shot flag tells the system that normal rearm times apply -- this is</span></span><br><span class="line"><span class="comment">	**	what is desired for non two shooters.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    IsSecondShot = !Class-&gt;Is_Two_Shooter();</span><br><span class="line">    House-&gt;Tracking_Add(<span class="keyword">this</span>);</span><br><span class="line">    Ammo = Class-&gt;MaxAmmo;</span><br><span class="line">    Height = FLIGHT_LEVEL;</span><br><span class="line">    Strength = Class-&gt;MaxStrength;</span><br><span class="line">    NavCom = TARGET_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	** Keep count of the number of units created. Dont track cargo planes as they are created</span></span><br><span class="line"><span class="comment">	** automatically, not bought.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="comment">//	if (/*classid != AIRCRAFT_CARGO &amp;&amp; */ Session.Type == GAME_INTERNET) &#123;</span></span><br><span class="line"><span class="comment">//		House-&gt;AircraftTotals-&gt;Increment_Unit_Total((int)classid);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>]]></content>
      <categories>
        <category>工具</category>
        <category>C++</category>
        <category>规范</category>
      </categories>
  </entry>
  <entry>
    <title>sharepool相关接口</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OpenEuler/sharepool%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将对sharepool相关接口进行总结</p>
<a id="more"></a>
<h2 id="接口列表"><a href="#接口列表" class="headerlink" title="接口列表"></a>接口列表</h2><div class="table-container">
<table>
<thead>
<tr>
<th>接口名</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>sp_group_add_task</td>
<td>向sharepool中添加一个进程</td>
<td>不能用于中断上下文</td>
</tr>
<tr>
<td>sp_group_drop</td>
<td>丢弃一个spg</td>
<td>每次使用一个spg后调用</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="sp-group-add-task"><a href="#sp-group-add-task" class="headerlink" title="sp_group_add_task"></a>sp_group_add_task</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p><code>sp_group_add_task</code>声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sp_group_add_task() - Add a process to an share group (sp_group).</span></span><br><span class="line"><span class="comment"> * @pid: the pid of the task to be added.</span></span><br><span class="line"><span class="comment"> * @spg_id: the ID of the sp_group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A thread group can't be added to more than one sp_group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: A postive group number for success, -errno on failure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The manually specified ID is between [SPG_ID_MIN, SPG_ID_MAX].</span></span><br><span class="line"><span class="comment"> * The automatically allocated ID is between [SPG_ID_AUTO_MIN, SPG_ID_AUTO_MAX].</span></span><br><span class="line"><span class="comment"> * When negative, the return value is -errno.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sp_group_add_task</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> spg_id)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>向sharepool组中添加一个进程的整体流程图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/addtask.svg" width = "150" alt="图片名称" align=center /></p>
<h3 id="spg-id检查"><a href="#spg-id检查" class="headerlink" title="spg id检查"></a>spg id检查</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mdc scene hack */</span></span><br><span class="line"><span class="keyword">if</span> (enable_mdc_default_group)</span><br><span class="line">    spg_id = mdc_default_group_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Valid spg id */</span></span><br><span class="line"><span class="keyword">if</span> ((spg_id &lt; SPG_ID_MIN || spg_id &gt; SPG_ID_AUTO)</span><br><span class="line">    &amp;&amp; spg_id != SPG_ID_DVPP_PASS_THROUGH) &#123;</span><br><span class="line">    pr_err_ratelimited(<span class="string">"share pool: task add group failed, invalid group id %d\n"</span>, spg_id);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In auto spg range, find a usable spg. Here we just find and </span></span><br><span class="line"><span class="comment"> * test the validation of the spg, we do not use it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (spg_id &gt;= SPG_ID_AUTO_MIN &amp;&amp; spg_id &lt;= SPG_ID_AUTO_MAX) &#123;</span><br><span class="line">    spg = __sp_find_spg(pid, spg_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!spg) &#123;</span><br><span class="line">        pr_err_ratelimited(<span class="string">"share pool: spg %d hasn't been created\n"</span>, spg_id);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    down_read(&amp;spg-&gt;rw_lock);</span><br><span class="line">    <span class="keyword">if</span> (!spg_valid(spg)) &#123;</span><br><span class="line">        up_read(&amp;spg-&gt;rw_lock);</span><br><span class="line">        pr_err_ratelimited(<span class="string">"share pool: task add group failed, group id %d is dead\n"</span>, spg_id);</span><br><span class="line">        sp_group_drop(spg);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    up_read(&amp;spg-&gt;rw_lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* We need to drop the spg, see __sp_find_spg, we regard finding </span></span><br><span class="line"><span class="comment">     * of spg as an occupation action to spg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sp_group_drop(spg);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Auto alloc a new spg between [SPG_ID_AUTO_MAX, SPG_ID_AUTO_MIN]  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (spg_id == SPG_ID_AUTO) &#123;</span><br><span class="line">    spg_id = ida_alloc_range(&amp;sp_group_id_ida, SPG_ID_AUTO_MIN,</span><br><span class="line">                             SPG_ID_AUTO_MAX, GFP_ATOMIC);</span><br><span class="line">    <span class="keyword">if</span> (spg_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err_ratelimited(<span class="string">"share pool: task add group failed, auto generate group id failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> spg_id;</span><br><span class="line">    &#125;</span><br><span class="line">    id_newly_generated = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DVPP type spg, we will discuss this later */</span></span><br><span class="line"><span class="keyword">if</span> (spg_id == SPG_ID_DVPP_PASS_THROUGH) &#123;</span><br><span class="line">    spg_id = ida_alloc_range(&amp;sp_group_id_ida,</span><br><span class="line">                             SPG_ID_DVPP_PASS_THROUGH_MIN,</span><br><span class="line">                             SPG_ID_DVPP_PASS_THROUGH_MAX, GFP_ATOMIC);</span><br><span class="line">    <span class="keyword">if</span> (spg_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err_ratelimited(<span class="string">"share pool: task add group failed, DVPP auto generate group id failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> spg_id;</span><br><span class="line">    &#125;</span><br><span class="line">    id_newly_generated = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找对应进程"><a href="#寻找对应进程" class="headerlink" title="寻找对应进程"></a>寻找对应进程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">down_write(&amp;sp_group_sem);</span><br><span class="line"></span><br><span class="line">rcu_read_lock();    <span class="comment">// tash switch is not allowed</span></span><br><span class="line"></span><br><span class="line">tsk = find_task_by_vpid(pid);</span><br><span class="line"><span class="keyword">if</span> (!tsk || (tsk-&gt;flags &amp; PF_EXITING))</span><br><span class="line">    ret = -ESRCH;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    get_task_struct(tsk);</span><br><span class="line"></span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    up_write(&amp;sp_group_sem);</span><br><span class="line">    free_new_spg_id(id_newly_generated, spg_id);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找进程对应的mm"><a href="#寻找进程对应的mm" class="headerlink" title="寻找进程对应的mm"></a>寻找进程对应的mm</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mm = get_task_mm(tsk-&gt;group_leader);</span><br><span class="line"><span class="keyword">if</span> (!mm) &#123;</span><br><span class="line">    up_write(&amp;sp_group_sem);</span><br><span class="line">    ret = -ESRCH;</span><br><span class="line">    free_new_spg_id(id_newly_generated, spg_id);</span><br><span class="line">    <span class="keyword">goto</span> out_put_task;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mm-&gt;sp_group) &#123;    <span class="comment">// The task has already joined a group</span></span><br><span class="line">    up_write(&amp;sp_group_sem);</span><br><span class="line">    ret = -EEXIST;</span><br><span class="line">    free_new_spg_id(id_newly_generated, spg_id);</span><br><span class="line">    <span class="keyword">goto</span> out_put_mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找或者分配一个spg"><a href="#寻找或者分配一个spg" class="headerlink" title="寻找或者分配一个spg"></a>寻找或者分配一个spg</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">spg = find_or_alloc_sp_group(spg_id);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(spg)) &#123;</span><br><span class="line">    up_write(&amp;sp_group_sem);</span><br><span class="line">    ret = PTR_ERR(spg);</span><br><span class="line">    free_new_spg_id(id_newly_generated, spg_id);</span><br><span class="line">    <span class="keyword">goto</span> out_put_mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新spa"><a href="#更新spa" class="headerlink" title="更新spa"></a>更新spa</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_for_each_entry(spa, &amp;spg-&gt;spa_list, link) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> populate = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">spa_file</span>(<span class="title">spa</span>);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line"></span><br><span class="line">    __sp_area_drop_locked(prev);</span><br><span class="line">    prev = spa;</span><br><span class="line"></span><br><span class="line">    atomic_inc(&amp;spa-&gt;use_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (spa-&gt;is_dead == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;sp_area_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (spa-&gt;type == SPA_TYPE_K2SPG &amp;&amp; spa-&gt;kva) &#123;</span><br><span class="line">        addr = sp_remap_kva_to_vma(spa-&gt;kva, spa, mm);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR_VALUE(addr))</span><br><span class="line">            pr_warn(<span class="string">"share pool: task add group remap k2u failed, ret %ld\n"</span>, addr);</span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;sp_area_lock);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(mm-&gt;core_state)) &#123;</span><br><span class="line">        sp_munmap_task_areas(mm, &amp;spa-&gt;link);</span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        pr_err(<span class="string">"share pool: task add group: encountered coredump, abort\n"</span>);</span><br><span class="line">        spin_lock(&amp;sp_area_lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = sp_mmap(mm, file, spa, &amp;populate);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR_VALUE(addr)) &#123;</span><br><span class="line">        sp_munmap_task_areas(mm, &amp;spa-&gt;link);</span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        ret = addr;</span><br><span class="line">        pr_err(<span class="string">"share pool: task add group sp mmap failed, ret %d\n"</span>, ret);</span><br><span class="line">        spin_lock(&amp;sp_area_lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (populate) &#123;</span><br><span class="line">        ret = do_mm_populate(mm, spa-&gt;va_start, populate, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unlikely(fatal_signal_pending(current)))</span><br><span class="line">                pr_warn_ratelimited(<span class="string">"share pool: task add group failed, current thread is killed\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pr_warn_ratelimited(<span class="string">"share pool: task add group failed, mm populate failed "</span></span><br><span class="line">                                    <span class="string">"(potential no enough memory when -12): %d, spa type is %d\n"</span>,</span><br><span class="line">                                    ret, spa-&gt;type);</span><br><span class="line">            down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">            sp_munmap_task_areas(mm, spa-&gt;link.next);</span><br><span class="line">            up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">            spin_lock(&amp;sp_area_lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;sp_area_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>OpenEuler</category>
      </categories>
  </entry>
  <entry>
    <title>bootloader</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/YuOS/bootloader/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>不出生在这世上，也许是最完美的结果</p>
</blockquote>
<a id="more"></a>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>课程</category>
        <category>YuOS</category>
      </categories>
  </entry>
  <entry>
    <title>outline</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/YuOS/outline/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我看清了，我们所有活着的人，都只不过是空幻的影子，虚无的梦</p>
</blockquote>
<a id="more"></a>
<h2 id="项目大纲"><a href="#项目大纲" class="headerlink" title="项目大纲"></a>项目大纲</h2><div class="table-container">
<table>
<thead>
<tr>
<th>项目名称</th>
<th>内容</th>
<th>预计完成时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>环境搭建</td>
<td>搭建YuOS的相关开发环境</td>
<td>1d</td>
</tr>
<tr>
<td>一个简单的bootloader</td>
<td>编写一个简单的bootloader，能够搜索文件系统中的loader.bin，搜索不到后打印错误日志</td>
<td>2d</td>
</tr>
<tr>
<td>一个简单的loader</td>
<td>编写一个简单的loader，添加到磁盘中，为后续操作系统加载做准备</td>
<td>2d</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>课程</category>
        <category>YuOS</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-HW1-boot xv6</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-HW1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>HumanCore - CP/M-17 Version 1.0, Date: January 08, 1996</p>
</blockquote>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>作业准备请参考文献<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>和文献<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p>
<h2 id="启动xv6"><a href="#启动xv6" class="headerlink" title="启动xv6"></a>启动xv6</h2><h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><p>进入<code>xv6-public</code>文件夹后，修改一些脚本的执行权限，然后make一下，即可编译内核。</p>
<h3 id="设置断点调试"><a href="#设置断点调试" class="headerlink" title="设置断点调试"></a>设置断点调试</h3><p>使用nm命令在可执行文件kernel中寻找_start地址。执行下列命令，抓取_start关键字，得到如下结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nm kernel | grep _start</span></span><br><span class="line">8010a48c D _binary_entryother_start</span><br><span class="line">8010a460 D _binary_initcode_start</span><br><span class="line">0010000c T _start</span><br></pre></td></tr></table></figure>
<p>在这个内核中，_start地址为0x0010000c。在该位置设置断点，然后继续执行，程序会在此处停下（但是我的gdb不行，不知道是哪里的问题，程序停不下来，会一直执行）。这里总结一下解决方案：</p>
<h4 id="断点不停止BUG解决"><a href="#断点不停止BUG解决" class="headerlink" title="断点不停止BUG解决"></a>断点不停止BUG解决</h4><h5 id="更换GDB版本（没用）"><a href="#更换GDB版本（没用）" class="headerlink" title="更换GDB版本（没用）"></a>更换GDB版本（没用）</h5><p>下载该课程指定的GDB版本，<a href="http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2">点击此处下载gdb-7.3.1</a>。</p>
<h5 id="安装指定版本的binutils（没用）"><a href="#安装指定版本的binutils（没用）" class="headerlink" title="安装指定版本的binutils（没用）"></a>安装指定版本的binutils（没用）</h5><p>下载该课程指定的binutils版本，<a href="http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2">点击此处下载binutils-2.21.1</a>。</p>
<h5 id="更换GCC版本（没用）"><a href="#更换GCC版本（没用）" class="headerlink" title="更换GCC版本（没用）"></a>更换GCC版本（没用）</h5><p>下载该课程指定的GCC版本，<a href="http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2">点击此处下载GCC4.6.4</a>。</p>
<h5 id="更换QEMU"><a href="#更换QEMU" class="headerlink" title="更换QEMU"></a>更换QEMU</h5><p>下载该课程指定的QEMU版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/mit-pdos/6.828-qemu.git qemu</span><br></pre></td></tr></table></figure>
<h5 id="下载最新版本xv6-public（问题已解决）"><a href="#下载最新版本xv6-public（问题已解决）" class="headerlink" title="下载最新版本xv6-public（问题已解决）"></a>下载最新版本xv6-public（问题已解决）</h5><p>粗略看了下好像是链接文件出了问题，导致链接后实际物理地址错误，总之前面的都没用，就下载最新的xv6即可。下载地址为：<a href="https://github.com/mit-pdos/xv6-public.git">xv6-public</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题1：栈中有什么？"><a href="#问题1：栈中有什么？" class="headerlink" title="问题1：栈中有什么？"></a>问题1：栈中有什么？</h3><p>现在我们处在程序执行的开始阶段，我们需要看一下寄存器和栈中的内容，在gdb界面执行如下命令查看寄存器的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) info reg</span><br><span class="line">eax            0x0                 0</span><br><span class="line">ecx            0x0                 0</span><br><span class="line">edx            0x663               1635</span><br><span class="line">ebx            0x0                 0</span><br><span class="line">esp            0x0                 0x0</span><br><span class="line">ebp            0x0                 0x0</span><br><span class="line">esi            0x0                 0</span><br><span class="line">edi            0x0                 0</span><br><span class="line">eip            0xfff0              0xfff0</span><br><span class="line">eflags         0x2                 [ IOPL=0 ]</span><br><span class="line">cs             0xf000              61440</span><br><span class="line">ss             0x0                 0</span><br><span class="line">ds             0x0                 0</span><br><span class="line">es             0x0                 0</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x0                 0</span><br><span class="line">fs_base        0x0                 0</span><br><span class="line">gs_base        0x0                 0</span><br><span class="line">k_gs_base      0x0                 0</span><br><span class="line">cr0            0x60000010          [ CD NW ET ]</span><br><span class="line">cr2            0x0                 0</span><br><span class="line">cr3            0x0                 [ PDBR=0 PCID=0 ]</span><br><span class="line">cr4            0x0                 [ ]</span><br><span class="line">cr8            0x0                 0</span><br><span class="line">efer           0x0                 [ ]</span><br></pre></td></tr></table></figure>
<p>kongzhitai我们得到了各个寄存器中的值。然后执行下列命令查看esp寄存器中的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/24x $esp</span><br><span class="line">0x0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x10:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x20:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x30:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x40:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x50:	0x00000000	0x00000000	0x00000000	0x00000000</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.bilibili.com/video/av15896196/">MIT6828课程视频链接</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/labs/MIT6_828F12_lab1.pdf">Lab1介绍</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-boot.html">homework1: boot xv6</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-HW2-shell</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-HW2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>$ ls</p>
</blockquote>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>阅读文献<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>第0章，完成作业<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，下载<a href="https://pdos.csail.mit.edu/6.828/2018/homework/sh.c">sh.c</a>，然后编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc sh.c</span></span><br></pre></td></tr></table></figure>
<p>产生<code>a.out</code>文件，写一个脚本<code>t.sh</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &gt; y</span><br><span class="line">cat &lt; y | sort | uniq | wc &gt; y1</span><br><span class="line">cat y1</span><br><span class="line">rm y1</span><br><span class="line">ls |  sort | uniq | wc</span><br><span class="line">rm y</span><br></pre></td></tr></table></figure>
<p>执行命令：<code>./a.out &lt; t.sh</code>，得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redir not implemented</span><br><span class="line">exec not implemented</span><br><span class="line">pipe not implemented</span><br><span class="line">exec not implemented</span><br><span class="line">exec not implemented</span><br><span class="line">pipe not implemented</span><br><span class="line">exec not implemented</span><br></pre></td></tr></table></figure>
<p>有一些函数尚未实现，所以会打印错误信息。</p>
<h2 id="执行简单的命令"><a href="#执行简单的命令" class="headerlink" title="执行简单的命令"></a>执行简单的命令</h2><p>命令解析的代码文件已经提供了，我们要做的事情就是根据解析的命令，调用exec函数，从而执行特定的命令。这里需要对exec函数有一些了解，输入命令<code>man 3 exec</code>查看execv相关的描述，函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int execv(const char *path, char *constargv[]);</span><br></pre></td></tr></table></figure>
<p>具体使用方法参考手册，总之我们只需要在runcmd对应的<code>case &#39; &#39;</code>处添加如下代码即可;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">  ecmd = (struct execcmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// Your code here ...</span></span><br><span class="line">  execv(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);      <span class="comment">//如果命令执行正确，exec会从另一个入口退出，因此后面的语句不应该被打印</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"cmd not find!\n"</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>编译并执行<code>sh.c</code>，输入命令<code>ls</code>，会提示<code>cmd not find!</code>，这是因为<code>exec</code>会在当前文件夹下寻找可执行文件<code>ls</code>，然而并找不到这个文件，所以我们要输入绝对路径<code>/bin/ls</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6.828$ /bin/ls</span><br><span class="line">a.out  sh.c  t.sh  test_execv  test_execv.c</span><br></pre></td></tr></table></figure>
<h3 id="改进：添加环境变量"><a href="#改进：添加环境变量" class="headerlink" title="改进：添加环境变量"></a>改进：添加环境变量</h3><p>从上面的程序中我们可以看到，必须在<code>sh</code>中输入绝对路径，才能找到文件名，那么我们能不能设计环境变量机制，只需要输入命令就能找到特定的文件？</p>
<p>TODO：为sh添加环境变量</p>
<h2 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h2><p>现在我们进行IO重定向，使我们的shell可以执行如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;6.828 is cool&quot; &gt; x.txt</span><br><span class="line">cat &lt; x.txt</span><br></pre></td></tr></table></figure>
<p>即将IO重定向至一个文件。这里我们需要对文件进行操作，所以需要<code>open</code>和<code>close</code>操作；此外，为了将文件描述符进行重定向，我们还需要用到<code>dup2</code>函数</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ul>
<li><code>dup2</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup2(int oldfd, int newfd);  //将oldfd重定向到newfd</span><br></pre></td></tr></table></figure>
<ul>
<li>open</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int open (const char* Path, int flags [, int mode ]);   // flags表示了文件处理方式</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>命令解析已经帮帮我们做好了，我们只需要做下面几件事：</p>
<ul>
<li>以特定的<code>cmd-&gt;flags</code>打开文件</li>
<li>对文件进行重定向</li>
<li>关闭文件</li>
<li>exec()</li>
</ul>
<p>所以我们的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    rcmd = (struct redircmd*)cmd;</span><br><span class="line">    <span class="comment">// fprintf(stderr, "redir not implemented\n");</span></span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(rcmd-&gt;file, rcmd-&gt;flags, <span class="number">0666</span>);    <span class="comment">//修改文件权限，否则打不开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">"open %s failed\n"</span>, rcmd-&gt;file);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    dup2(fd,rcmd-&gt;fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>现在当我们执行下面语句是，就会将给定文件重定向至标准输入/输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6.828$ /bin/echo &quot;Helloworld&quot; &gt; result  </span><br><span class="line">6.828$ /bin/cat &lt; result</span><br><span class="line">&quot;Helloworld&quot;</span><br></pre></td></tr></table></figure>
<h2 id="执行管道命令"><a href="#执行管道命令" class="headerlink" title="执行管道命令"></a>执行管道命令</h2><p>在执行管道命令前，我们先要明确管道的机制</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 book</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="http://web.mit.edu/6.033/2004/wwwdocs/handouts/handson/unix.html">6.033: Hands-on Assignment (UNIX) (mit.edu)</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://pdos.csail.mit.edu/6.828/2018/homework/sh.c">sh.c</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-shell.html">HW2</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-HW4-xv6 lazy page allocation</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-HW4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>懒分配是物理内存管理的一种策略，其基本思想是直到进程真正使用内存时，才进行内存的分配。本文将对xv6中懒分配的实现进行总结。</p>
<a id="more"></a>
<p>xv6的应用通过<code>sbrk()</code>系统调用来获取堆上分配的内存，有些进程申请了内存，但是一直没用，如果给他们分配了内存，就会导致有一部分内存一直被站着不用（占着茅坑不拉*），所以机智的内核就想出了一个策略，直到内存真正被使用，才进行分配。</p>
<h2 id="第一部分：删除sbrk中分配内存的部分"><a href="#第一部分：删除sbrk中分配内存的部分" class="headerlink" title="第一部分：删除sbrk中分配内存的部分"></a>第一部分：删除<code>sbrk</code>中分配内存的部分</h2><p>首先我们要修改<code>sbrk</code>系统调用，即<code>sysproc.c</code>下的<code>sys_sbrk()</code>函数，删除其中的内存分配部分。<code>sbrk</code>的功能如下：首先，它将进程的内存大小增长<code>n</code>字节，然后返回新分配的空间的起始地址（即进程原来的内存大小）。改进后的<code>sbrk</code>只增加进程的大小，不分配内存。改进后的<code>sbrk</code>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_sbrk(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)    <span class="comment">//分配内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  myproc()-&gt;sz += n;       <span class="comment">// 修改进程size大小</span></span><br><span class="line">  <span class="keyword">return</span> addr;             <span class="comment">// 返回起始地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后会发生什么现象呢？进程如果试图获取堆内存，那么其大小会增加，但是并没有真的给它分配内存，如果试图去写入新内存，会触发page fault</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hi</span></span><br><span class="line">pid 3 sh: trap 14 err 6 on cpu 0 eip 0x111c addr 0x4004--kill proc</span><br></pre></td></tr></table></figure>
<p>运行操作系统，输入上面的命令，弹出提示，这个提示来自<code>trap.c</code>中的trap handler，表示捕获到了页错误（trap 14 T_PGFLT），0x4004表示造成PGFLT的虚拟地址为4004</p>
<h2 id="第二部分：Lazy-allocation"><a href="#第二部分：Lazy-allocation" class="headerlink" title="第二部分：Lazy allocation"></a>第二部分：Lazy allocation</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>修改<code>trap.c</code>，当用户空间发生缺页错误后，分配一块新内存，然后让用户进程继续执行，暂时不需要考虑临界情况。这里给了若干个提示，分别如下：</p>
<ol>
<li>查看打印语句中的参数，看看如何找到触发页错误的虚拟地址：使用<code>rcr2()</code>函数</li>
<li>从<code>allocuvm()</code>函数中找到分配空间的方法</li>
<li>使用<code>PGROUNDDOWN(va)</code>这个宏函数，从引发页错误的地址<code>va</code>找到一个页边界</li>
<li>分配内存后记得使用<code>return</code>返回，要不然会错误执行杀死进程的指令</li>
<li>使用<code>mappages</code>完成地址的映射，在<code>trap.c</code>中调用<code>mappages</code>之前添加如下声明：</li>
<li><code>int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)</code></li>
<li>通过<code>tf-&gt;trapno==T_PGFLT</code>检查是否为页面错误</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="找到触发页错误的虚拟地址"><a href="#找到触发页错误的虚拟地址" class="headerlink" title="找到触发页错误的虚拟地址"></a>找到触发页错误的虚拟地址</h4><p>首先我们看看<code>trap</code>是如何找到虚拟地址的，在<code>trap.c</code>中的<code>trap()</code>函数内，如果触发了缺页中断，会打印错误信息，打印语句为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cprintf(<span class="string">"pid %d %s: trap %d err %d on cpu %d"</span></span><br><span class="line">        <span class="string">"eip 0x%x addr 0x%x--kill proc\n"</span>, myproc()-&gt;pid, myproc()-&gt;name, tf-&gt;trapno, tf-&gt;err, cpuid(), tf-&gt;eip, rcr2());</span><br></pre></td></tr></table></figure>
<p>从上面的语句中可以看到，出发页错误的虚拟地址是通过<code>rcr2</code>函数找到的。实际上是<code>cr2</code>控制寄存器</p>
<h4 id="从allocuvm-函数找到分配空间的方法"><a href="#从allocuvm-函数找到分配空间的方法" class="headerlink" title="从allocuvm()函数找到分配空间的方法"></a>从allocuvm()函数找到分配空间的方法</h4><p><code>allocuvm()</code>在<code>vm.c</code>中，<code>sbrk</code>通过<code>growproc()</code>这个函数调用了<code>allocuvm()</code>，函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate page tables and physical memory to grow process from oldsz to</span></span><br><span class="line"><span class="comment">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span></span><br><span class="line"><span class="comment">// 将进程内存空间进行扩展，从oldsz扩展至newsz</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">allocuvm(<span class="keyword">pde_t</span> *pgdir, uint oldsz, uint newsz)&#123;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  uint a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= KERNBASE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDUP(oldsz);   <span class="comment">//这里直接将对应大小作为了虚拟地址，很巧妙</span></span><br><span class="line">  <span class="keyword">for</span>(; a &lt; newsz; a += PGSIZE)&#123;  <span class="comment">//没有对齐，因此实际分配的内存是比需要的内存小的</span></span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      cprintf(<span class="string">"allocuvm out of memory\n"</span>);</span><br><span class="line">      deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(pgdir, (<span class="keyword">char</span>*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      cprintf(<span class="string">"allocuvm out of memory (2)\n"</span>);</span><br><span class="line">      deallocuvm(pgdir, newsz, oldsz);</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过tf-gt-trapno-T-PGFLT检查是否为页面错误"><a href="#通过tf-gt-trapno-T-PGFLT检查是否为页面错误" class="headerlink" title="通过tf-&gt;trapno==T_PGFLT检查是否为页面错误"></a>通过<code>tf-&gt;trapno==T_PGFLT</code>检查是否为页面错误</h4><p>通过上述语句判断是否为页面错误，然后将内存分配语句写在上面的判断框中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(tf-&gt;trapno==T_PGFLT)&#123;</span><br><span class="line">    <span class="comment">// Allocate mem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>为了实现分配过程，我们还需要解决如下问题：</p>
<ul>
<li>需要分配多少空间？根据提示，我们需要分配一页，一页如果不够用了，就触发中断再分配一页（这样不会导致效率低下吗？）</li>
<li>从哪里开始分配？</li>
<li>分配到哪里</li>
</ul>
<h4 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h4><p>根据上面的分析，我们可以得到改进后的部分如下，改进的部分就放在下面这条语句之前：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cprintf(<span class="string">"pid %d %s: trap %d err %d on cpu %d"</span></span><br><span class="line">        <span class="string">"eip 0x%x addr 0x%x--kill proc\n"</span>, myproc()-&gt;pid, myproc()-&gt;name, tf-&gt;trapno, tf-&gt;err, cpuid(), tf-&gt;eip, rcr2());</span><br></pre></td></tr></table></figure>
<p>需要注意的是完成内存分配后，要及时<code>break</code>，否则会导致这句错误提示又显示出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(tf-&gt;trapno==T_PGFLT)&#123;</span><br><span class="line">    <span class="comment">// Allocate mem</span></span><br><span class="line">    uint va = PGROUNDDOWN(rcr2());</span><br><span class="line">    <span class="keyword">char</span> *mem;</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">"trap:allocate new memory failed!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(myproc()-&gt;pgdir, (<span class="keyword">char</span>*)va, PGSIZE, V2P(mem), PTE_W | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">"trap:allocate new memory failed!(1)\n"</span>);</span><br><span class="line">        kfree(mem);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于懒分配，可以参考<a href="/2024/10/13/计算机/操作系统/缺页异常/" title="内核关于缺页异常的处理">内核关于缺页异常的处理</a>。至此，我们实现了一个非常简陋的懒分配器，对进程进行内存分配。</p>
<h3 id="挑战任务"><a href="#挑战任务" class="headerlink" title="挑战任务"></a>挑战任务</h3><p>这个lazy allocation机制实际上是不完善的，还需要解决如下问题：</p>
<ul>
<li>分配内存如果是负数怎么办？</li>
<li>如果太大了怎么办？</li>
<li>确保<code>fork</code>和<code>exit</code>在没有被分配内存的情况下也能正确工作（写时复制）</li>
<li>如果堆覆盖栈该怎么办？</li>
<li>如果内核要使用<code>sbrk()</code>分配的空内存该怎么办？</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 book</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">Homework: xv6 system calls (mit.edu)</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-HW3-xv6 system calls</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-HW3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>系统调用是内核中的一系列实现系统功能的子函数，本文将针对XV6中的一些系统调用进行管理。本章的配置过程如：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-boot.html">作业1：XV6启动</a></p>
<a id="more"></a>
<h2 id="第一部分：系统调用追踪"><a href="#第一部分：系统调用追踪" class="headerlink" title="第一部分：系统调用追踪"></a>第一部分：系统调用追踪</h2><p>修改xv6内核，对于每一个系统调用，打印函数名和返回值以及参数，当xv6启动时，可以看到如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">fork -&gt; 2</span><br><span class="line">exec -&gt; 0</span><br><span class="line">open -&gt; 3</span><br><span class="line">close -&gt; 0</span><br><span class="line">$write -&gt; 1</span><br><span class="line"> write -&gt; 1</span><br></pre></td></tr></table></figure>
<p>这个是init fork，并执行了sh，sh确保只有两个文件描述符被打开，然后sh写了<code>$</code>，修改<code>syscall.c</code>下的<code>syscall()</code>，如下功能：</p>
<ul>
<li>打印系统调用名称</li>
<li>打印返回值</li>
<li>打印系统调用参数</li>
</ul>
<p><code>syscall()</code>原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  num = curproc-&gt;tf-&gt;eax;    <span class="comment">// 系统调用的序号被保存在eax寄存器中</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    curproc-&gt;tf-&gt;eax = syscalls[num]();     <span class="comment">//系统调用返回值保存在这里</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cprintf(<span class="string">"%d %s: unknown sys call %d\n"</span>,</span><br><span class="line">            curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">    curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要打印系统调用名称、返回值及参数，<code>struct proc</code>结构体描述了进程的信息，具体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  uint sz;                     <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pde_t</span>* pgdir;                <span class="comment">// Page table</span></span><br><span class="line">  <span class="keyword">char</span> *kstack;                <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">  <span class="keyword">enum</span> procstate state;        <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>        <span class="comment">// Trap frame for current syscall</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span>     <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从这个结构体中，我们能够得到进程的名称，但是只知道进程名称是不行的，我们需要知道函数名称。我们可以看到，在syscall中有一个比较重要的结构体tf，即trapframe，这个结构体保存了CPU寄存器中的值，内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">// registers as pushed by pusha</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint oesp;      <span class="comment">// useless &amp; ignored</span></span><br><span class="line">  uint ebx;</span><br><span class="line">  uint edx;</span><br><span class="line">  uint ecx;</span><br><span class="line">  uint eax;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rest of trap frame</span></span><br><span class="line">  ushort gs;</span><br><span class="line">  ushort padding1;</span><br><span class="line">  ushort fs;</span><br><span class="line">  ushort padding2;</span><br><span class="line">  ushort es;</span><br><span class="line">  ushort padding3;</span><br><span class="line">  ushort ds;</span><br><span class="line">  ushort padding4;</span><br><span class="line">  uint trapno;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// below here defined by x86 hardware</span></span><br><span class="line">  uint err;</span><br><span class="line">  uint eip;</span><br><span class="line">  ushort cs;</span><br><span class="line">  ushort padding5;</span><br><span class="line">  uint eflags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// below here only when crossing rings, such as from user to kernel</span></span><br><span class="line">  uint esp;</span><br><span class="line">  ushort ss;</span><br><span class="line">  ushort padding6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>记得在Lab1里有过使用eip寄存器函数追踪的方法，但是那个过于复杂，由于系统调用比较固定，我们直接写一个函数表用查表法实现即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *syacall_name[] = &#123;</span><br><span class="line">    [SYS_fork] = <span class="string">"fork"</span>,</span><br><span class="line">    [SYS_exit] = <span class="string">"exit"</span>,</span><br><span class="line">    [SYS_wait] = <span class="string">"wait"</span>,</span><br><span class="line">    [SYS_pipe] = <span class="string">"pipe"</span>,</span><br><span class="line">    [SYS_read] = <span class="string">"read"</span>,</span><br><span class="line">    [SYS_kill] = <span class="string">"kill"</span>,</span><br><span class="line">    [SYS_exec] = <span class="string">"exec"</span>,</span><br><span class="line">    [SYS_fstat] = <span class="string">"fstat"</span>,</span><br><span class="line">    [SYS_chdir] = <span class="string">"chdir"</span>,</span><br><span class="line">    [SYS_dup] = <span class="string">"dup"</span>,</span><br><span class="line">    [SYS_getpid] = <span class="string">"getpid"</span>,</span><br><span class="line">    [SYS_sbrk] = <span class="string">"sbrk"</span>,</span><br><span class="line">    [SYS_sleep] = <span class="string">"sleep"</span>,</span><br><span class="line">    [SYS_uptime] = <span class="string">"uptime"</span>,</span><br><span class="line">    [SYS_open] = <span class="string">"open"</span>,</span><br><span class="line">    [SYS_write] = <span class="string">"write"</span>,</span><br><span class="line">    [SYS_mknod] = <span class="string">"mknod"</span>,</span><br><span class="line">    [SYS_unlink] = <span class="string">"unlink"</span>,</span><br><span class="line">    [SYS_link] = <span class="string">"link"</span>,</span><br><span class="line">    [SYS_mkdir] = <span class="string">"mkdir"</span>,</span><br><span class="line">    [SYS_close] = <span class="string">"close"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>syscall()</code>中添加下面一句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cprintf(<span class="string">"%s-&gt;%d\n"</span>,syacall_name[num],curproc-&gt;tf-&gt;eax);</span><br></pre></td></tr></table></figure>
<h2 id="第二部分：date-System-Call"><a href="#第二部分：date-System-Call" class="headerlink" title="第二部分：date System Call"></a>第二部分：date System Call</h2><p>第二部分要求我们完成一个date 系统调用，获取当前UTC时间并返回。</p>
<h3 id="实现准备"><a href="#实现准备" class="headerlink" title="实现准备"></a>实现准备</h3><p>首先，我们需要一个读取硬件时间的函数，<code>cmostime()</code>，这个函数定义在<code>lapic.c</code>。其次我们需要一个描述时间的结构体<code>struct rtcdate</code>（位于<code>date.h</code>），我们需要将一个<code>rtcdate</code>对象指针传递给<code>cmostime()</code>。我们可以参考其他系统调用的实现，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -n uptime *.[chS]</span><br></pre></td></tr></table></figure>
<p>查看和uptime系统调用有关的所有内容，并参考其完成<code>date</code>系统调用。根据<code>grep -n uptime *.[chS]</code>的结果，将该添加的函数声明及宏定义添加了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syscall.c:106:extern int sys_date(void);</span><br><span class="line">syscall.c:130:[SYS_date]    sys_date,</span><br><span class="line">syscall.c:156:  [SYS_date] = &quot;date&quot;, </span><br><span class="line">syscall.h:23:#define SYS_date   22</span><br><span class="line">user.h:26:int date(struct rtcdate*);</span><br><span class="line">usys.S:32:SYSCALL(date)</span><br></pre></td></tr></table></figure>
<p>其次，我们创建一个<code>date.c</code>文件，这个文件中包含两部分，第一，这个文件包含一个main函数，即我们编译后可以产生可执行二进制文件<code>date</code>，输入命令<code>date</code>后，就会调用这个文件；第二，这个文件包含了<code>date</code>的实现（这个是错误的）。</p>
<p>然而，当我在<code>date.c</code>中添加了<code>date</code>函数定义后，我遇到了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/duan/Code/OS/xv6-public/usys.S:32: multiple definition of `date&apos;</span><br><span class="line">date.o:/home/duan/Code/OS/xv6-public/date.c:6: first defined here</span><br></pre></td></tr></table></figure>
<p>提示我在文件<code>usys.S</code>中，<code>date</code>已经定义过了，打开<code>usys.S</code>，里面内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define SYSCALL(name) \</span><br><span class="line">  .globl name; \</span><br><span class="line">  name: \</span><br><span class="line">    movl $SYS_ ## name, %eax; \</span><br><span class="line">    int $T_SYSCALL; \</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">SYSCALL(fork)</span><br><span class="line">SYSCALL(exit)</span><br><span class="line">...</span><br><span class="line">SYSCALL(date)</span><br></pre></td></tr></table></figure>
<p>将<code>date</code>带入宏定义并展开，得到结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl date;</span><br><span class="line">date:</span><br><span class="line">    movl $SYS_date, %eax;</span><br><span class="line">    int $T_SYSCALL;</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>说明我们在<code>usys.S</code>中，已经通过汇编的方式，定义了<code>date</code>这个函数，这个函数的内容是将<code>SYS_date</code>移到<code>eax</code>，然后通过中断的方式调用<code>sys_date</code>，因此我们不需要再定义<code>date</code>，只需要编写好<code>sys_date</code>即可。但是这个时候我又疑惑了，我们的<code>date()</code>是有参数的，输入的是<code>struct rtcdate*</code>，但是<code>sys_</code>开头的系统调用函数都是没有参数的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_link</span><span class="params">(<span class="keyword">void</span>)</span></span>;     <span class="comment">// 系统调用全都没有参数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_mkdir</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_mknod</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_open</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>那么该如何处理输入参数呢？</p>
<h3 id="解决输入参数的问题"><a href="#解决输入参数的问题" class="headerlink" title="解决输入参数的问题"></a>解决输入参数的问题</h3><p>后来我经过了一番寻找，终于找到了一个类似的需要输入参数的系统调用，即<code>sys_mkdir</code>。而<code>mkdir.c</code>中对<code>mkdir</code></p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="sys-date实现"><a href="#sys-date实现" class="headerlink" title="sys_date实现"></a>sys_date实现</h4><p>在<code>sysproc.c</code>中实现<code>sys_date()</code>函数，练习系统调用的编写过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> </span><br><span class="line">sys_date(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Your code</span></span><br><span class="line">  <span class="keyword">char</span> *r;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  <span class="keyword">if</span>(argptr(<span class="number">0</span>, &amp;r, <span class="keyword">sizeof</span>(struct rtcdate)) &lt; <span class="number">0</span> )&#123;    <span class="comment">// 如果输入的第一个参数有误，那么释放锁，然后返回</span></span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cmostime((struct rtcdate*)r);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在Makefile中添加调用"><a href="#在Makefile中添加调用" class="headerlink" title="在Makefile中添加调用"></a>在Makefile中添加调用</h4><p>为了使date命令能够在xv6的shell中使用，需要在<code>Makefile</code>的<code>UPROGS</code>定义中添加<code>_date</code>。</p>
<h4 id="date可执行程序实现"><a href="#date可执行程序实现" class="headerlink" title="date可执行程序实现"></a>date可执行程序实现</h4><p>在<code>date.c</code>中加入如下程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"date.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (date(&amp;r)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">"date failed\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// your code to print the time in any format you like...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>最后实现的结果如下，运行<code>make qemu</code>打开操作系统后，输入<code>date</code>，将显示系统时间（命令行中的777不知道是啥，好像是在qemu和shell切换时会产生）</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/1615813640(1).png" width = "350" alt="图片名称" align=center /></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 book</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">Homework: xv6 system calls (mit.edu)</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-HW5-xv6 CPU alarm</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-HW5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本作业将实现对使用CPU的进程进行周期性提醒，通过该练习，我们可以实现一个基础的用户层面的中断/错误处理机制。</p>
<a id="more"></a>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>添加一个新的<code>alarm(interval, handler)</code>系统调用。如果某个程序调用了<code>alarm(n, fn)</code>，那么经过$n$个CPU时钟周期后，内核调用函数<code>fn</code>，当<code>fn</code>返回后，应用会从其被中断的地方继续运行。创建一个<code>alarmtest.c</code>程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">periodic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">"alarmtest starting\n"</span>);</span><br><span class="line">  alarm(<span class="number">10</span>, periodic);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">25</span>*<span class="number">500000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((i % <span class="number">250000</span>) == <span class="number">0</span>)</span><br><span class="line">      write(<span class="number">2</span>, <span class="string">"."</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">periodic()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">"alarm!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序调用了<code>alarm(10, periodic);</code>系统调用，每10个ticks调用一次<code>periodic</code>函数，这个函数的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ alarmtest</span><br><span class="line">alarmtest starting</span><br><span class="line">.....alarm!</span><br><span class="line">....alarm!</span><br><span class="line">.....alarm!</span><br><span class="line">......alarm!</span><br><span class="line">.....alarm!</span><br><span class="line">....alarm!</span><br><span class="line">....alarm!</span><br><span class="line">......alarm!</span><br><span class="line">.....alarm!</span><br><span class="line">...alarm!</span><br><span class="line">...$</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>本文需要对CPU的执行时间进行精确跟踪，因此这里只考虑单个CPU的情况，因此调试时执行下面的语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make CPUS=<span class="number">1</span> qemu  # 设置CPU数为<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这样内核会以单CPU启动</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h3><h4 id="将alarmtest-c添加为用户程序"><a href="#将alarmtest-c添加为用户程序" class="headerlink" title="将alarmtest.c添加为用户程序"></a>将alarmtest.c添加为用户程序</h4><p>在<code>Makefile</code>中的<code>UPROGS</code>字段添加<code>_alarmtest</code></p>
<h4 id="系统调用框架编写"><a href="#系统调用框架编写" class="headerlink" title="系统调用框架编写"></a>系统调用框架编写</h4><p>在<code>user.h</code>中添加系统调用声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">int</span> ticks, <span class="keyword">void</span> (*handler)())</span></span>;</span><br></pre></td></tr></table></figure>
<p>更新<code>syscall.h</code>和<code>usys.S</code>，添加对<code>alarm</code>的支持字段。</p>
<h4 id="更改进程描述符"><a href="#更改进程描述符" class="headerlink" title="更改进程描述符"></a>更改进程描述符</h4><p>在<code>proc.h</code>中更改进程描述符，添加用于保存<code>alarm</code>的<code>interval</code>和<code>handler</code>字段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> alarmticks;          <span class="comment">// 定时中断时长</span></span><br><span class="line"><span class="keyword">int</span> passedticks;         <span class="comment">// 自alarmhandler上次调用后经过的时间</span></span><br><span class="line"><span class="keyword">void</span> (*alarmhandler)();  <span class="comment">// 中断服务函数</span></span><br></pre></td></tr></table></figure>
<h4 id="编写系统调用"><a href="#编写系统调用" class="headerlink" title="编写系统调用"></a>编写系统调用</h4><p>系统调用作业中给我们提供了，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_alarm(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ticks;</span><br><span class="line">    <span class="keyword">void</span> (*handler)();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(argptr(<span class="number">1</span>, (<span class="keyword">char</span>**)&amp;handler, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;alarmticks = ticks;</span><br><span class="line">    myproc()-&gt;alarmhandler = handler;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能很简单，就是设置定时中断时长和中断服务函数。至此我们已经搭建好了框架，现在我们要修改<code>trap</code>，实现定时中断。我们先编译程序，现在程序能够使用<code>sys_alarm</code>系统调用，但是这个调用目前只是修改了进程结构体，没有实际地触发中断。执行<code>make qemu-gdb</code>打开调试，在<code>sys_alarm</code>处设置断点，然后继续运行至系统调用。系统调用是根据系统调用号触发的，这个序号保存在<code>eax</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print myproc()-&gt;tf-&gt;eax</span><br><span class="line">23   # 系统调用入口为23</span><br></pre></td></tr></table></figure>
<p>在<code>gdb</code>中执行如下命令，可以查看进程的栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x/4x myproc()-&gt;tf-&gt;esp</span><br><span class="line">0x2fac: 0x00000034  0x0000000a  0x00000090 0x00000000</span><br></pre></td></tr></table></figure>
<p>用户栈地址为<code>0x2fac</code>，其中保存了系统调用的参数<code>ticks</code>和<code>handler</code>，分别为<code>10</code>和<code>0x00000090</code>。</p>
<h3 id="需要解决的问题："><a href="#需要解决的问题：" class="headerlink" title="需要解决的问题："></a>需要解决的问题：</h3><p>为了实现这个系统调用，我们还需要考虑如下问题：</p>
<ul>
<li>由系统调用触发中断后，在哪里执行中断服务函数，在<code>trap()</code>中不太好，那么是不是得换个地方</li>
<li>如何执行中断服务函数？</li>
<li>中断后如何保护现场，如何恢复现场？</li>
</ul>
<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><h4 id="中断是如何进入的"><a href="#中断是如何进入的" class="headerlink" title="中断是如何进入的"></a>中断是如何进入的</h4><p>中断是从<code>vector.S</code>进入的，启动内核后，我们可以在vector32处设置断点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break vector32</span><br><span class="line"></span><br><span class="line">.globl vector32</span><br><span class="line">vector32:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $32</span><br><span class="line">  jmp alltraps</span><br></pre></td></tr></table></figure>
<p>32即对应定时器，在跳转到<code>alltraps</code>后，内核会进入<code>trapasm.S</code>，最终跳转至<code>trap</code>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  #include &quot;mmu.h&quot;</span><br><span class="line"></span><br><span class="line">  # vectors.S sends all traps here.</span><br><span class="line">.globl alltraps</span><br><span class="line">alltraps:</span><br><span class="line">  # Build trap frame.  将现场保存至内核堆栈中</span><br><span class="line">  pushl %ds</span><br><span class="line">  pushl %es</span><br><span class="line">  pushl %fs</span><br><span class="line">  pushl %gs</span><br><span class="line">  pushal</span><br><span class="line">  </span><br><span class="line">  # Set up data and per-cpu segments.</span><br><span class="line">  movw $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class="line">  movw %ax, %ds</span><br><span class="line">  movw %ax, %es</span><br><span class="line">  movw $(SEG_KCPU&lt;&lt;3), %ax</span><br><span class="line">  movw %ax, %fs</span><br><span class="line">  movw %ax, %gs</span><br><span class="line"></span><br><span class="line">  # Call trap(tf), where tf=%esp</span><br><span class="line">  pushl %esp</span><br><span class="line">  call trap     # 进入trap中</span><br><span class="line">  addl $4, %esp</span><br></pre></td></tr></table></figure>
<h4 id="tick中断处理"><a href="#tick中断处理" class="headerlink" title="tick中断处理"></a>tick中断处理</h4><p>在每一次时钟中断后，应当更新进程计时器，判断是否达到了计时数，如果达到了，执行中断服务函数，并将计时器置0。在进程描述符中，我们使用<code>passedticks</code>记录已经经过的时间，所以我们在定时中断中的框架如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">    <span class="keyword">if</span>(cpu-&gt;id == <span class="number">0</span>)&#123;</span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      ticks++;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// You code here</span></span><br><span class="line">      <span class="comment">/**********************************************************/</span></span><br><span class="line">      <span class="keyword">if</span>(myproc() != <span class="number">0</span> &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;   <span class="comment">// 进程有效且来自用户空间</span></span><br><span class="line">          myproc() -&gt; passedticks++;</span><br><span class="line">          <span class="keyword">if</span>(myproc() -&gt; passedticks &gt;= myproc() -&gt; alarmticks)&#123; <span class="comment">//超时</span></span><br><span class="line">              <span class="comment">//执行handler函数</span></span><br><span class="line">              tf-&gt;eip = myproc()-&gt;alarmhandler();  <span class="comment">//这样对吗</span></span><br><span class="line">              <span class="comment">//更新计时器</span></span><br><span class="line">              myproc() -&gt; passedticks = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**********************************************************/</span></span><br><span class="line">        </span><br><span class="line">      wakeup(&amp;ticks);</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">    &#125;</span><br><span class="line">    lapiceoi();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 book</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-alarm.html">In-class: xv6 CPU alarm (mit.edu)</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-HW7-locking</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-HW7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在这个作业中，我们将探究中断和锁之间的一些关系。</p>
<a id="more"></a>
<h2 id="Don’t-do-this"><a href="#Don’t-do-this" class="headerlink" title="Don’t do this"></a>Don’t do this</h2><p>当<code>xv6</code>执行下面的代码时，会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct spinlock lk;</span><br><span class="line">initlock(&amp;lk, &quot;test lock&quot;);</span><br><span class="line">acquire(&amp;lk);</span><br><span class="line">acquire(&amp;lk);</span><br></pre></td></tr></table></figure>
<p>重复上锁，第二个锁会panic。acquire的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="comment">// Holding a lock for a long time may cause</span></span><br><span class="line"><span class="comment">// other CPUs to waste time spinning to acquire it.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  pushcli(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk)) <span class="comment">// 如果锁已经被holding了，那么会panic</span></span><br><span class="line">    panic(<span class="string">"acquire"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The xchg is atomic.</span></span><br><span class="line">  <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section's memory</span></span><br><span class="line">  <span class="comment">// references happen after the lock is acquired.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">  getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ide-c中的中断"><a href="#ide-c中的中断" class="headerlink" title="ide.c中的中断"></a>ide.c中的中断</h2><p>An <code>acquire</code> ensures that interrupts are off on the local processor using the <code>cli</code> instruction (via <code>pushcli()</code>), and that interrupts remain off until the <code>release</code> of the last lock held by that processor (at which point they are enabled using <code>sti</code>).</p>
<p>Let’s see what happens if we turn on interrupts while holding the <code>ide</code> lock. In <code>iderw</code> in <code>ide.c</code>, add a call to <code>sti()</code> after the <code>acquire()</code>, and a call to <code>cli()</code> just before the <code>release()</code>. Rebuild the kernel and boot it in QEMU. Chances are the kernel will panic soon after boot; try booting QEMU a few times if it doesn’t.</p>
<h3 id="在iderw中加锁和释放锁部分开启中断"><a href="#在iderw中加锁和释放锁部分开启中断" class="headerlink" title="在iderw中加锁和释放锁部分开启中断"></a>在iderw中加锁和释放锁部分开启中断</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">iderw(struct buf *b)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  acquire(&amp;idelock);  <span class="comment">//DOC:acquire-lock</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// HW7: Add sti </span></span><br><span class="line">  sti();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// HW7: add cli just before releasing the lock</span></span><br><span class="line">  cli();</span><br><span class="line">  release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在添加了<code>sti</code>和<code>cli</code>后，如果编译并启动内核，系统会panic。</p>
<h3 id="sti和cli的作用"><a href="#sti和cli的作用" class="headerlink" title="sti和cli的作用"></a><code>sti</code>和<code>cli</code>的作用</h3><p><code>sti</code>开启中断，<code>cli</code>关闭中断，也就是说我们在<code>acquire</code>和<code>release</code>之间开启了中断。</p>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>系统提示的错误信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58</span><br><span class="line">lapicid 1: panic: acquire</span><br><span class="line">801043ed 80102053 80105985 801056fc 80100183 80102ae5 801036c0 801056ff 0 0</span><br></pre></td></tr></table></figure>
<p>最下方一行数字为系统调用栈情况，根据调用栈，</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 book</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-lock.html">Homework: xv6 locking (mit.edu)</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-HW6-Threads and Locking</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-HW6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在这个作业中，我们将使用一个Hash Table实现多线程编程，首先<a href="https://pdos.csail.mit.edu/6.828/2018/homework/ph.c">下载这个文件</a>。</p>
<a id="more"></a>
<h2 id="作业内容"><a href="#作业内容" class="headerlink" title="作业内容"></a>作业内容</h2><p>下载文件后进行编译并运行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc -g -O2 ph.c -pthread</span><br><span class="line">$ ./a.out <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>2表示启动的线程数，运行一段时间后，程序应该有如下输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: put time = <span class="number">0.003338</span></span><br><span class="line"><span class="number">0</span>: put time = <span class="number">0.003389</span></span><br><span class="line"><span class="number">0</span>: get time = <span class="number">7.684335</span></span><br><span class="line"><span class="number">0</span>: <span class="number">17480</span> keys missing</span><br><span class="line"><span class="number">1</span>: get time = <span class="number">7.684335</span></span><br><span class="line"><span class="number">1</span>: <span class="number">17480</span> keys missing</span><br><span class="line">completion time = <span class="number">7.687856</span></span><br></pre></td></tr></table></figure>
<p>每个线程运行在两个阶段，put和get，每个阶段大约7.7秒，现在使用一个线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./a.out 1</span><br><span class="line">0: put time = 0.004073</span><br><span class="line">0: get time = 6.929189</span><br><span class="line">0: 0 keys missing</span><br><span class="line">completion time = 6.933433</span><br></pre></td></tr></table></figure>
<p>可以发现总用时为6.9秒，貌似一个线程速度还快一些，但是多线程做了其两倍的工作，用时只多了不到1秒，还是效率高了一些，但是可以看到，使用两个线程会有很多次哈希miss的情况，画一个图思考一下为何会出现哈希miss。（本质上是因为两个线程对同一个空间进行写操作，第一个线程写了之后，被第二个线程擦除，所以真正有用的是第二个线程的操作）</p>
<p>为了避免哈希miss，我们需要在对hash table访问时加锁保护，使用下列语句对put和get进行加锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pthread_mutex_t lock;     // declare a lock</span><br><span class="line">pthread_mutex_init(&amp;lock, NULL);   // initialize the lock</span><br><span class="line">pthread_mutex_lock(&amp;lock);  // acquire lock</span><br><span class="line">pthread_mutex_unlock(&amp;lock);  // release lock</span><br></pre></td></tr></table></figure>
<p>由于get只是读取，因此我们只需要对put进行加锁，即可避免hash miss</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><h3 id="粗粒锁与细粒锁"><a href="#粗粒锁与细粒锁" class="headerlink" title="粗粒锁与细粒锁"></a>粗粒锁与细粒锁</h3><p>我们可以使用一个锁锁住整个哈希表，也可以对哈希表中的每一个链表单独上一把锁，代码分别如下：</p>
<h4 id="粗颗粒锁"><a href="#粗颗粒锁" class="headerlink" title="粗颗粒锁"></a>粗颗粒锁</h4><p>粗颗粒锁对整个哈希表上锁，比较简单，但是控制颗粒度很粗，访问不同列的线程也会导致相互阻塞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pthread_mutex_t lock;     // declare a lock</span><br><span class="line">pthread_mutex_init(&amp;lock, NULL);   // initialize the lock</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;lock);    // acquire lock</span><br><span class="line">    ...                       // 临界区</span><br><span class="line">pthread_mutex_unlock(&amp;lock);  // release lock</span><br></pre></td></tr></table></figure>
<h4 id="细颗粒锁"><a href="#细颗粒锁" class="headerlink" title="细颗粒锁"></a>细颗粒锁</h4><p>细颗粒锁针对哈希表每一列单独上锁，因此访问不同列的线程不会因为争抢锁而陷入等待，效率高一些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> locks[NBUCKET];     <span class="comment">// declare a lock</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NBUCKET; i++)</span><br><span class="line">    pthread_mutex_init(&amp;locks[i], <span class="literal">NULL</span>);   <span class="comment">// initialize the lock</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;locks[i]);    <span class="comment">// acquire lock</span></span><br><span class="line">    ...                       <span class="comment">// 临界区</span></span><br><span class="line">pthread_mutex_unlock(&amp;locks[i]);  <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure>
<h4 id="两种不同锁对比"><a href="#两种不同锁对比" class="headerlink" title="两种不同锁对比"></a>两种不同锁对比</h4><p>总的来说粗颗粒锁更简单，细颗粒锁更快一些，但是需要锁的数量会上升，如果对象很多的话，使用细颗粒锁并不方便。（其实就我个人的实验，并没有看出两者之间有何差别）</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Headers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBUCKET 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NKEYS 100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node of a hash table </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash value is the array index, and make linear search </span></span><br><span class="line"><span class="comment">// inside the list</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">table</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line"><span class="comment">// Average list length = NKEYS / NBUCKET</span></span><br><span class="line"><span class="keyword">int</span> keys[NKEYS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nthread = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> done;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get current time </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">now</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// Print the hash table</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert at beginning</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value, struct entry **p, struct entry *n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">entry</span>));</span></span><br><span class="line">    e-&gt;key = key;</span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">    e-&gt;next = n;</span><br><span class="line">    *p = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct entry* <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (e = table[key % NBUCKET]; e != <span class="number">0</span>; e = e-&gt;next) &#123;  <span class="comment">// 进入对应哈希列，然后顺序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (e-&gt;key == key) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// e == NULL: 搜索到末尾，哈希不命中</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *xa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = (<span class="keyword">long</span>) xa;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> b = NKEYS/nthread;    <span class="comment">// 每个线程处理的索引数</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> t1, t0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  printf("b = %d\n", b);</span></span><br><span class="line">    t0 = now();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">        <span class="comment">// printf("%d: put %d\n", n, b*n+i);</span></span><br><span class="line">        put(keys[b*n + i], n);</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = now();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld: put time = %f\n"</span>, n, t1-t0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should use pthread_barrier, but MacOS doesn't support it ...</span></span><br><span class="line">    __sync_fetch_and_add(&amp;done, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (done &lt; nthread) ;</span><br><span class="line"></span><br><span class="line">    t0 = now();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NKEYS; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> = <span class="title">get</span>(<span class="title">keys</span>[<span class="title">i</span>]);</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">0</span>) k++;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = now();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld: get time = %f\n"</span>, n, t1-t0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld: %d keys missing\n"</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> *tha;</span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">double</span> t1, t0;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数处理</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: %s nthread\n"</span>, argv[<span class="number">0</span>], argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建线程，分配n个线程所需的空间</span></span><br><span class="line">    nthread = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    tha = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>) * nthread);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置随机数种子，初始化索引</span></span><br><span class="line">    srandom(<span class="number">0</span>);</span><br><span class="line">    assert(NKEYS % nthread == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NKEYS; i++) &#123;</span><br><span class="line">        keys[i] = random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    t0 = now();</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">        assert(pthread_create(&amp;tha[i], <span class="literal">NULL</span>, thread, (<span class="keyword">void</span> *) i) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待线程执行结束</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nthread; i++) &#123;</span><br><span class="line">        assert(pthread_join(tha[i], &amp;value) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = now();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"completion time = %f\n"</span>, t1-t0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-HW8-User level threads</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-HW8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在这个作业中，我们将实现一个用户层线程包，实现线程间切换。</p>
<a id="more"></a>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 book</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">Homework: xv6 system calls (mit.edu)</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-Lab2-内存管理</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-Lab2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>计算机社会学基本公理：第一，内存是进程的第一需要；第二，进程不断增长和扩张，但计算机中的内存总量保持不变。</p>
</blockquote>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="内存管理的组成"><a href="#内存管理的组成" class="headerlink" title="内存管理的组成"></a>内存管理的组成</h3><p>内存管理可以分为物理内存分配和虚拟内存映射。</p>
<h4 id="内核的物理内存分配器"><a href="#内核的物理内存分配器" class="headerlink" title="内核的物理内存分配器"></a>内核的物理内存分配器</h4><p>在内存管理中，我们需要为内核提供物理内存分配器，使内核能够分配和释放内存。分配的单元为页，大小一般为4KB。为了实现分配器，我们需要维护一个数据结构记录哪些内存是已经被分配的，哪些是空闲的，多少个进程在使用已经分配的内存。同时，我们还需要一套用于分配和释放的调度策略。</p>
<h4 id="虚拟内存机制"><a href="#虚拟内存机制" class="headerlink" title="虚拟内存机制"></a>虚拟内存机制</h4><p>为了将内核和用户软件的虚拟内存地址映射到实际物理地址，我们需要一个虚拟内存映射机制。当指令使用内存时，x86的内存管理单元（MMU）通过一个页表完成映射过程。为了实现JOS，我们需要去调整相应的页表。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>首先创建一个分支lab2，然后将我们在lab1中写的代码合并到lab2中，这一部分请参考lab2中的提示，不再赘述。需要注意的是可能会需要手动处理一些合并过程中的冲突。在本次实验中我们需要关注的新文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inc/memlayout.h         </span><br><span class="line">kern/pmap.c            </span><br><span class="line">kern/pmap.h</span><br><span class="line">kern/kclock.h</span><br><span class="line">kern/kclock.c</span><br></pre></td></tr></table></figure>
<p><code>memlayout.h</code>描述了虚拟地址空间的布局，你需要通过修改<code>pmap.h</code>实现。<code>memlayout.h</code>和<code>pmap.h</code>定义了<code>PageInfo</code>结构体，根据这个结构体可以查看内存的alloc/free情况。<code>kclock</code>用于操作PC的电池时钟以及RAM，RAM中保存了物理地址的容量及其他相关信息。<code>pmap.c</code>通过读取RAM来确定有多少物理内存可用。</p>
<p>这里重点注意<code>memlayout.h</code>和<code>pmap.h</code>，并复习一下<code>inc/mmu.h</code></p>
<h2 id="第一部分：物理页管理"><a href="#第一部分：物理页管理" class="headerlink" title="第一部分：物理页管理"></a>第一部分：物理页管理</h2><p>操作系统必须跟踪物理内存的使用情况，包括哪些内存被分配了，哪些是空闲的。JOS使用页粒度对内存管理，从而可以使用MMU对已经分配的内存进行保护和映射。</p>
<p>在这一部分，我们需要实现一个物理页分配器，它使用一个链表连接的PageInfo对象对空闲页进行跟踪，每一个PageInfo代表一个物理页。在此基础上，我们会实现一个页表管理器分配物理内存，从而保存页表。（与xv6不同，xv6直接将PageInfo保存在指向的空闲页中）</p>
<h3 id="练习1：一个物理页分配器"><a href="#练习1：一个物理页分配器" class="headerlink" title="练习1：一个物理页分配器"></a>练习1：一个物理页分配器</h3><p>在<code>kern/pmap.c</code>中，你需要按顺序实现下列函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init() //只做到check_page_free_list(1)之前</span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure>
<p><code>check_page_free_list()</code>和<code>check_page_alloc()</code>将会测试你的物理页分配器。</p>
<h4 id="boot-alloc"><a href="#boot-alloc" class="headerlink" title="boot_alloc"></a>boot_alloc</h4><p>lab2中给出的<code>boot_alloc</code>如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This simple physical memory allocator is used only while JOS is setting</span></span><br><span class="line"><span class="comment">// up its virtual memory system.  page_alloc() is the real allocator.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n&gt;0, allocates enough pages of contiguous physical memory to hold 'n'</span></span><br><span class="line"><span class="comment">// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n==0, returns the address of the next free page without allocating</span></span><br><span class="line"><span class="comment">// anything.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If we're out of memory, boot_alloc should panic.</span></span><br><span class="line"><span class="comment">// This function may ONLY be used during initialization,</span></span><br><span class="line"><span class="comment">// before the page_free_list list has been set up.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">boot_alloc(<span class="keyword">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nextfree;	<span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line">    <span class="comment">// 使用First Fit实现</span></span><br><span class="line">    <span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">    <span class="comment">// 'end' is a magic symbol automatically generated by the linker,</span></span><br><span class="line">    <span class="comment">// which points to the end of the kernel's bss segment:</span></span><br><span class="line">    <span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">    <span class="comment">// to any kernel code or global variables.</span></span><br><span class="line">    <span class="comment">// Find the address which is the first one larger than end and can divide PGSIZE</span></span><br><span class="line">    <span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">        nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE);   <span class="comment">//PGSIZE表示一个页大小为4096bytes</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></span><br><span class="line">    <span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">    <span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// LAB 2: Your code here.</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    nextfree = ROUNDUP((<span class="keyword">char</span> *) nextfree, PGSIZE);</span><br><span class="line">    <span class="keyword">return</span> nextfree;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h5><p>根据注释中的提示，我们可以得知这个函数功能如下：</p>
<ul>
<li>当<code>n &gt; 0</code>时，分配足以容纳<code>n</code>bytes的物理内存页，并返回内核虚拟地址，不需要初始化；如果不够了，系统调用panic打印错误信息。</li>
<li>当<code>n == 0</code>时，直接返回下一个空闲页的地址</li>
</ul>
<h5 id="实现准备"><a href="#实现准备" class="headerlink" title="实现准备"></a>实现准备</h5><p>为了实现上面的功能，我们需要思考如下问题：</p>
<ol>
<li>如何确定nextfree的位置在哪里？</li>
<li>如何确定是否有足够的内存用于分配</li>
</ol>
<p>首先，我们来回顾一下我们的内存模型：忽略底部的用于BIOS、硬件以及bootloader的部分，内核实际是加载到0x00100000中的，linker会自动为内核镜像分配内存，所以内存的使用是从0x00100000这个地址向上增长的。那么最大内存是多少呢？这取决于硬件中实际内存的容量，在<code>pmap.c</code>中，我们有一个<code>i386_detect_memory()</code>函数，用于检测内存的大小，其中有一个<code>npages</code>全局变量保存了以页为单位的可用内存的数目。实际实验中<code>npages</code>为32768</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)：这个内存根据实际大小会发生变化</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br></pre></td></tr></table></figure>
<p>下面解决第一个问题，如何确定下一个空闲页的位置在哪里，这里我们先来回顾一下一个程序的虚拟内存模型：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20210112220925.png" width = "550" alt="图片名称" align=center /></p>
<p>我们需要注意的是：<strong>千万不要把操作系统想的太复杂，它就是一个比较特殊的可执行文件</strong>，这个可执行文件一定是符合一般的可执行文件的内存分布的，所以肯定也符合上面的虚拟内存模型。我们可以看到，bss段之后就是堆段，也就是我们需要分配的内存所在的位置，而栈段是从内存高地址开始的，并向下增长，所以最后堆段会和栈段发生碰撞，产生stackoverflow等问题，不过这里不是我们需要关注的，我们只需要知道bss段后是heap段即可。所以程序中nextfree第一次被创建并赋值时，其位置在bss段之后。而我们的程序也体现了这一点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line"><span class="comment">// 'end' is a magic symbol automatically generated by the linker,</span></span><br><span class="line"><span class="comment">// which points to the end of the kernel's bss segment:</span></span><br><span class="line"><span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line"><span class="comment">// to any kernel code or global variables.</span></span><br><span class="line"><span class="comment">// Find the address which is the first one larger than end and can divide PGSIZE</span></span><br><span class="line"><span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">    nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE);   <span class="comment">//PGSIZE表示一个页大小为4096bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到<code>nextfree</code>是一个static类型的变量，其生命周期是整个内核的生命周期，而<code>end</code>为bss段的结束，这个是由linker决定的，寻找bss段后第一个nextfree的语句为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE);</span><br></pre></td></tr></table></figure>
<p>ROUNDUP根据注释的提示，可以知道是对齐的作用，所以实际上bss段和堆段之间有一小片（小于一个PGSIZE大小）的内存碎片被浪费掉了。</p>
<p>当我们再次进入boot_alloc，此时<code>nextfree</code>已经不再为空，那么该如何寻找呢？我们现在有需要分配的字节数<code>n</code>和当前地址<code>nextfree</code>，那么下一个空闲的地址的计算如下：</p>
<script type="math/tex; mode=display">
\textrm{nextfree} = \textrm{nextfree}+\textrm{size}</script><p>具体计算原理详见：<a href="/2024/10/13/计算机/组成原理/内存/" title="关于内存计算的讲解">关于内存计算的讲解</a>。所以我们计算<code>nextfree</code>的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nextfree = ROUNDUP((<span class="keyword">char</span>*)(nextfree + n), PGSIZE);</span><br></pre></td></tr></table></figure>
<p>可以看到，如果nextfree+n不能整除PGSIZE，就会产生内存碎片。</p>
<p>下面我们解决第二个问题，如何确定是否有足够的内存空间。我们现在有<code>npages</code>代表最大可用内存页数，那么<code>npages*PGSIZE</code>就是最大内存容量。而我们现在知道nextfree，由于内存是向上增长的，所以我们只需要用<code>nextfree</code>减去内存起始地址，即可判断是否超过最大可用内存。那么现在的问题是，如何找到起始内存地址。根据<code>i386_detect_memory()</code>我们知道，<code>npages</code>代表的是总内存大小，即从地址0x0开始，到最大的物理内存地址。所以起始地址即为0x0。另外nextfree是虚拟地址，我们还需要转换为物理地址。现在我们可以写出计算是否超过内存容量的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(PADDR(nextfree) &gt; npages*PGSIZE)  <span class="comment">// 分配后的内存地址超过了总内存地址</span></span><br><span class="line">        panic(<span class="string">"boot_alloc: Run out of memory! Total memory: %u, needed memory: %u"</span>, npages * PGSIZE, PADDR(nextfree));</span><br></pre></td></tr></table></figure>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p><code>boot_alloc</code>实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">boot_alloc(<span class="keyword">uint32_t</span> n)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nextfree;	<span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">    <span class="comment">// 'end' is a magic symbol automatically generated by the linker,</span></span><br><span class="line">    <span class="comment">// which points to the end of the kernel's bss segment:</span></span><br><span class="line">    <span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">    <span class="comment">// to any kernel code or global variables.</span></span><br><span class="line">    <span class="comment">// Find the address which is the first one larger than end and can divide PGSIZE</span></span><br><span class="line">    <span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> end[];   <span class="comment">// end 是指向内核bss段的末尾的指针</span></span><br><span class="line">        nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE);   <span class="comment">//PGSIZE表示一个页大小为4096bytes</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></span><br><span class="line">    <span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">    <span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// LAB 2: Your code here.</span></span><br><span class="line">    <span class="comment">// 情况1: n为0</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">void</span> *)nextfree;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算下一个内存地址位置</span></span><br><span class="line">    result = nextfree;</span><br><span class="line">    nextfree = ROUNDUP((<span class="keyword">char</span> *) (n + nextfree), PGSIZE); <span class="comment">//对齐操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况2.1：超过内存大小</span></span><br><span class="line">    <span class="keyword">if</span>(PADDR(nextfree) &gt; npages*PGSIZE)</span><br><span class="line">        panic(<span class="string">"boot_alloc: Run out of memory! Total memory: %u, needed memory: %u"</span>, npages * PGSIZE, PADDR(nextfree));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况2.2：正常分配</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mem-init-的第一部分"><a href="#mem-init-的第一部分" class="headerlink" title="mem_init()的第一部分"></a>mem_init()的第一部分</h4><p>lab2中给出的<code>mem_init</code>（）如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">mem_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cr0;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">    <span class="comment">// 首先进行内存检测，弄清楚到底多少内存</span></span><br><span class="line">    i386_detect_memory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this line when you're ready to test this function.</span></span><br><span class="line">    <span class="comment">// panic("mem_init: This function is not finished\n");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// 然后创建一个页，用于保存页表</span></span><br><span class="line">    <span class="comment">// create initial page directory.</span></span><br><span class="line">    kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">    <span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Recursively insert PD (Page Dictionary) in itself as a page table, to form</span></span><br><span class="line">    <span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">    <span class="comment">// (For now, you don't have understand the greater purpose of the</span></span><br><span class="line">    <span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span></span><br><span class="line">    <span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">    <span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">    <span class="comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span></span><br><span class="line">    <span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// 第一件事情，分配能够容纳npages的struct PageInfo的空间，然后保存在pages中，内核利用</span></span><br><span class="line">    <span class="comment">// 这个pages跟踪每一个物理页</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now that we've allocated the initial kernel data structures, we set</span></span><br><span class="line">    <span class="comment">// up the list of free physical pages. Once we've done so, all further</span></span><br><span class="line">    <span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">    <span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">    <span class="comment">// or page_insert</span></span><br><span class="line">    page_init();</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h5 id="函数功能-1"><a href="#函数功能-1" class="headerlink" title="函数功能"></a>函数功能</h5><p><code>mem_init()</code>第一部分功能如下：</p>
<ol>
<li>检测物理内存大小</li>
<li>创建一个用于保存页表的页</li>
<li>分配能容纳npages * struct PageInfo的空间</li>
<li>将分配的PageInfo根据内存实际使用情况进行初始化</li>
</ol>
<p>其中需要我们完成的是第三部分</p>
<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><p>首先我们计算所需的空间大小，为<code>npages * sizeof(struct PageInfo);</code>，然后利用boot_alloc函数分配空间，最后memset初始化，代码比较简单，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span></span><br><span class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line"><span class="comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span></span><br><span class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">n = npages * <span class="keyword">sizeof</span>(struct PageInfo);</span><br><span class="line">pages = (struct PageInfo*) boot_alloc(n);</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, n);</span><br></pre></td></tr></table></figure>
<h4 id="page-init-：形成物理内存链表"><a href="#page-init-：形成物理内存链表" class="headerlink" title="page_init()：形成物理内存链表"></a>page_init()：形成物理内存链表</h4><p>在分配好了物理内存页表后，我们需要根据内存的实际情况对这些页表进行初始化，标识出空闲的内存，该函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">    <span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">    <span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">    <span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">    <span class="comment">//     in case we ever need them.  (Currently we don't, but...)</span></span><br><span class="line">    <span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">    <span class="comment">//     is free.</span></span><br><span class="line">    <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">    <span class="comment">//     never be allocated.</span></span><br><span class="line">    <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">    <span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">    <span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">    <span class="comment">//     page tables and other data structures?</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Change the code to reflect this.</span></span><br><span class="line">    <span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">    <span class="comment">// free pages! 不要使用空闲的物理内存</span></span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;     <span class="comment">// 此处注意i的范围是[0, npages-1]，所以要使用&lt;号，</span></span><br><span class="line">                                       <span class="comment">// 一开始我写成了&lt;=，导致内存越界，直观表现是系统一直重启</span></span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数功能-2"><a href="#函数功能-2" class="headerlink" title="函数功能"></a>函数功能</h5><p>上面的函数将所有的物理内存页都初始化为了空闲，但实际上这是不对的，我们需要根据内存的实际使用情况，将其进行初始化，规则如下：</p>
<ol>
<li>将物理页0标注为正在使用</li>
<li>将物理页1-npages_basemem标注为空闲</li>
<li>物理页IOPHYSMEM/PGSIZE - EXTPHYSMEM/PGSIZE标注为正在使用</li>
<li>EXTPHYSMEM/PGSIZE之后有一些内存是空闲的，一些是正在使用的</li>
</ol>
<p>其中，所以我们最后得到的内存页链表如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/mempage.svg" width = "750" alt="图片名称" align=center /></p>
<p>我们通过<code>page_free_list</code>，就可以以倒序的形式，遍历所有的空闲内存页。根据内存使用规则，我们可以得到<code>page_init</code>具体实现。</p>
<h5 id="实现准备-1"><a href="#实现准备-1" class="headerlink" title="实现准备"></a>实现准备</h5><p>为了实现上面的功能，我们需要思考如下问题：</p>
<ol>
<li>非空闲的内存如何处理？</li>
<li>在extened memory中，从何处开始是空闲内存？</li>
</ol>
<p>首先回答第一个问题，非空闲的内存页我们就不将其连接到链表当中了，这些内存有其特定作用，一般不用来作为free mem，所以我们采用一种冷处理的方式。</p>
<p>第二个问题，在扩展内存中，哪些是内核使用的内存？空闲内存是何处开始的？考虑我们写过的函数<code>boot_alloc</code>，当输入为0时，返回下一个空闲页的地址，所以我们可以利用这个函数找到空闲页地址，假设为$p_f$，那么$[p_f/\textrm{PGSIZE},\textrm{npages}]$这一段内存我们都需要进行初始化。这里还有一个问题，<code>boot_alloc</code>返回的是一个指针值，即对应的逻辑地址，我们还需要将这个逻辑地址转换为实际的物理地址。从<code>mem_init</code>中有一个宏函数PADDR，专门完成这个工作，至此，我们的两个任务已经完成。</p>
<h5 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h5><p><code>page_free_list</code>实际是一个链表，所以<code>page_init</code>实际就是一个链表初始化的过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize page structure and memory free list.</span></span><br><span class="line"><span class="comment">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span></span><br><span class="line"><span class="comment">// allocator functions below to allocate and deallocate physical</span></span><br><span class="line"><span class="comment">// memory via the page_free_list. 在这个函数完成后，不要在使用boot_alloc,</span></span><br><span class="line"><span class="comment">// 只是用下方提供的分配器对物理内存进行分配</span></span><br><span class="line"><span class="comment">// pages和物理内存是一一对应的</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Change the code to reflect this.</span></span><br><span class="line">    <span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">    <span class="comment">// free pages! 不要使用空闲的物理内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">    <span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">    <span class="comment">//     in case we ever need them.  (Currently we don't, but...)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">    <span class="comment">//     is free.</span></span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; ++i) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">    <span class="comment">//     never be allocated.</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">    <span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">    <span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">    <span class="comment">//     page tables and other data structures?</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">char</span> *pf = boot_alloc(<span class="number">0</span>);</span><br><span class="line">    i = PADDR(pf)/PGSIZE;</span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; npages; ++i)&#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="page-alloc：分配一个物理页"><a href="#page-alloc：分配一个物理页" class="headerlink" title="page_alloc：分配一个物理页"></a>page_alloc：分配一个物理页</h4><p>在对所有的可用<code>pages</code>进行初始化后，下一步是写一个分配和释放器，由于<code>page_free_list</code>是一个链表，所以我们的分配和释放器也要有链表的行为。我们先来完成<code>page_alloc</code>，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span></span><br><span class="line"><span class="comment">// returned physical page with '\0' bytes.  Does NOT increment the reference</span></span><br><span class="line"><span class="comment">// count of the page - the caller must do these if necessary (either explicitly</span></span><br><span class="line"><span class="comment">// or via page_insert).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to set the pp_link field of the allocated page to NULL so</span></span><br><span class="line"><span class="comment">// page_free can check for double-free bugs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns NULL if out of free memory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use page2kva and memset</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数功能-3"><a href="#函数功能-3" class="headerlink" title="函数功能"></a>函数功能</h5><p><code>page_alloc</code>的函数功能为分配一个物理页，并返回这个物理页对应<code>PageInfo</code>的地址。在<code>page_alloc</code>中我们将所有的空闲内存都用<code>PageInfo</code>一一对应，并构造了一个<code>page_free_list</code>，所以我们的分配操作是针对这个链表进行的。我们先具体定义<code>page_alloc</code>的流程：</p>
<ul>
<li>如果内存耗尽，返回<code>NULL</code></li>
<li>如果<code>(alloc_flags &amp; ALLOC_ZERO)</code>，将<code>PageInfo</code>对应的物理页清空</li>
<li>返回的指针中的<code>pp_link</code>应当设置为<code>NULL</code></li>
<li>不要修改<code>pp_ref</code>，这个工作交给调用者完成</li>
<li>调整<code>page_free_list</code>的值</li>
</ul>
<p>针对上面几个功能我们逐一完成。首先第三个和第四个功能很好实现，我们先解决第一个，如何判断内存耗尽？既然<code>page_free_list</code>是一个链表，那么当链表为空时，代表所有的物理页均已分配，所以判断内存耗尽的代码为<code>page_free_list == NULL</code>。</p>
<p>第二个问题，如何将<code>PageInfo</code>对应的物理页清空？为了实现该功能，我们要利用到<code>memset</code>函数，问题是如何找到<code>PageInfo</code>对应的物理页的地址。根据提示，可以使用<code>page2kva</code>实现，清空的大小为一个物理页的大小，第二个问题也解决了。</p>
<p>最后一个问题，如何调整<code>page_free_list</code>的值，这个过程是一个链表删除头节点的过程，先用一个节点保存头节点，然后<code>head</code>指向<code>head-&gt;next</code>即可。</p>
<h5 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h5><p>根据我们总结的函数功能，可以得到<code>page_alloc</code>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(page_free_list == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">"page_alloc: out of memory!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> (struct PageInfo*) <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">    page_free_list = pp-&gt;pp_link;</span><br><span class="line">    <span class="keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(page2kva(pp), <span class="string">'\0'</span>, PGSIZE);  <span class="comment">//将对应的物理页清空</span></span><br><span class="line">    &#125;</span><br><span class="line">    pp-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="page-free：释放物理页"><a href="#page-free：释放物理页" class="headerlink" title="page_free：释放物理页"></a>page_free：释放物理页</h4><p>一旦一个物理页用完，我们应当重新将其添加至<code>page_free_list</code>中，所以<code>page_free</code>的过程本质上是一个在链表头插入节点的过程。物理页用完的标准是<code>pp_ref == 0 &amp;&amp; pp_link == NULL</code>。如果<code>pp_ref</code>不为0，代表还有对象在使用这块内存，就不应该释放；如果<code>pp_link != NULL</code>，说明这个物理页后面还有其他页，一旦将这个页释放，后面的页也会连带着找不到，会造成内存泄漏。所以也不能释放。<code>page_free</code>比较简单，这里直接给出实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">    <span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">    <span class="keyword">if</span> (pp-&gt;pp_ref != <span class="number">0</span> ) &#123;</span><br><span class="line">        panic(<span class="string">"page_free: page is still in use!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pp-&gt;pp_link != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        panic(<span class="string">"page_free: Try to free a page which has link to other page, may cause memory leak"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pp-&gt;pp_link = page_free_list;</span><br><span class="line">    page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们完成了Part1的全部内容，运行<code>make grade</code>可以拿到10分。</p>
<h2 id="第二部分：虚拟地址"><a href="#第二部分：虚拟地址" class="headerlink" title="第二部分：虚拟地址"></a>第二部分：虚拟地址</h2><h3 id="虚拟、线性以及物理地址"><a href="#虚拟、线性以及物理地址" class="headerlink" title="虚拟、线性以及物理地址"></a>虚拟、线性以及物理地址</h3><p>这一部分的实验文档阅读总结详见<a href="/2024/10/13/计算机/操作系统/内存管理/" title="关于地址的讲解">关于地址的讲解</a></p>
<h4 id="练习3：使用QEMU查看物理内存"><a href="#练习3：使用QEMU查看物理内存" class="headerlink" title="练习3：使用QEMU查看物理内存"></a>练习3：使用QEMU查看物理内存</h4><p>GDB只能访问虚拟内存，如果我们想要访问物理内存，可以使用QEMU的<code>monitor commands</code>。进入和退出monitor的方法为在QEMU界面为在运行QEMU的shell中按下<code>ctrl-a c</code>。使用<code>xp</code>命令可以查看对应的物理内存。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(qemu) xp 0x0010000c</span><br><span class="line">000000000010000c: 0x7205c766</span><br></pre></td></tr></table></figure>
<p>使用gdb查看对应的虚拟内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/x 0xf010000c</span><br><span class="line">0xf010000c &lt;entry&gt;:    0x7205c766</span><br></pre></td></tr></table></figure>
<p>课程提供的QEMU有一个<code>info pg</code>命令，可以打印当前页表的信息。但是我用的是原生的QEMU，没有此命令，有一个<code>info mem</code>命令能够查看当前物理地址到虚拟地址的映射情况以及读写权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(qemu) info mem</span><br><span class="line">0000000000000000-0000000000400000 0000000000400000 -r-   # 大小为0000000000400000</span><br><span class="line">00000000f0000000-00000000f0400000 0000000000400000 -rw</span><br></pre></td></tr></table></figure>
<h4 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h4><p>由于JOS经常需要将地址视为整数进行操作，为了区分物理和虚拟地址，JOS提供了两种类型，分别是<code>uintptr_t</code>和<code>physaddr_t</code>，实际都是<code>uint32_t</code>。JOS能够将<code>uintptr_t</code>转换为指针类型然后解引用，但是不能解引用一个物理地址，因为保护模式下只能访问虚拟地址。如果试图解引用一个物理地址，MMU也会把这个物理地址作为虚拟地址来处理。</p>
<p>在有些情况下，如果只知道物理地址，例如想要添加一个页表映射，此时需要分配一块物理内存存放页字典。但是kernel不能进行虚拟地址的转换，因此无法直接加载物理地址。JOS之所以将物理地址0x00000000映射至0xf0000000，就是为了解决内核只知道物理地址的情况。为了将物理地址转换为虚拟地址，内核需要将物理地址加上0xf0000000，然后对虚拟地址进行操作。JOS提供了函数<code>KADDR(pa)</code>实现转换过程。同样的，<code>PADDR(va)</code>实现了物理地址到虚拟地址的转换。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在接下来的实验中，我们会遇到一个物理地址同时映射到多个虚拟地址的情况（或者说是一个物理地址处于多个不同环境的地址空间）。此时我们需要一个计数器记录一个物理页的被使用情况。这个计数器是PageInfo结构体下的<code>pp_ref</code>。当<code>pp_ref</code>为0时，这个内存可以释放。一般情况下，<code>pp_ref</code>应当等于低于<code>UTOP</code>的物理页出现在页表中的次数（高于UTOP的物理内存在boot期间被kernel设置，并且永不释放，所以不需要对其计数）。注意，<code>page_alloc</code>并不会修改引用计数，该函数返回的页引用总是0。</p>
<h3 id="页表管理"><a href="#页表管理" class="headerlink" title="页表管理"></a>页表管理</h3><p>现在写一些关于页表管理的函数：插入和移出线性地址到物理地址的映射，同时在需要的情况下创建页表页。</p>
<h4 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h4><p>完成如下函数的代码，check_page()将会检查函数的正确性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pgdir_walk()：页目录中查找</span><br><span class="line">boot_map_region()：启动阶段建立映射</span><br><span class="line">page_lookup()：查找页</span><br><span class="line">page_remove()：移出页</span><br><span class="line">page_insert()：插入页</span><br></pre></td></tr></table></figure>
<h5 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk()"></a>pgdir_walk()</h5><h6 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h6><h6 id="函数功能-4"><a href="#函数功能-4" class="headerlink" title="函数功能"></a>函数功能</h6><p>根据虚拟地址找到对应的<code>pte</code>的指针，用图来描述就是下面这张</p>
<h6 id="具体实现-4"><a href="#具体实现-4" class="headerlink" title="具体实现"></a>具体实现</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pde = &amp;pgdir[PDX(va)];</span><br><span class="line">    <span class="keyword">pte_t</span> *pgtable = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(*pde &amp; PTE_P) )&#123;</span><br><span class="line">        <span class="keyword">if</span>( !create ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ++pp-&gt;pp_ref;</span><br><span class="line">        *pde = page2pa(pp) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">    &#125;</span><br><span class="line">    pgtable = (<span class="keyword">pte_t</span>*)P2V(PTE_ADDR(*pde));   <span class="comment">//物理地址 -&gt; 虚拟地址</span></span><br><span class="line">    <span class="keyword">return</span> &amp;pgtable[PTX(va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="boot-map-region"><a href="#boot-map-region" class="headerlink" title="boot_map_region()"></a>boot_map_region()</h5><h6 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span></span><br><span class="line"><span class="comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span></span><br><span class="line"><span class="comment">// va and pa are both page-aligned.</span></span><br><span class="line"><span class="comment">// Use permission bits perm|PTE_P for the entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is only intended to set up the ``static'' mappings</span></span><br><span class="line"><span class="comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span></span><br><span class="line"><span class="comment">// mapped pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="函数功能-5"><a href="#函数功能-5" class="headerlink" title="函数功能"></a>函数功能</h6><p>这个函数的功能是将虚拟地址<code>[va, va+size)</code>映射至物理地址<code>[pa, pa+size)</code>，pte的权限设置为perm|PTE_P。本质上是多叉树的范围赋值。</p>
<h6 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; (size&gt;&gt;PGSHIFT); ++i)&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, (<span class="keyword">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pte == <span class="literal">NULL</span>) panic(<span class="string">"boot_map_region: allocation failure"</span>);</span><br><span class="line">        </span><br><span class="line">        *pte = pa | perm | PTE_P;</span><br><span class="line">        va += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup()"></a>page_lookup()</h5><h6 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return the page mapped at virtual address 'va'.</span></span><br><span class="line"><span class="comment">// If pte_store is not zero, then we store in it the address</span></span><br><span class="line"><span class="comment">// of the pte for this page.  This is used by page_remove and</span></span><br><span class="line"><span class="comment">// can be used to verify page permissions for syscall arguments,</span></span><br><span class="line"><span class="comment">// but should not be used by most callers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return NULL if there is no page mapped at va.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk and pa2page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="函数功能-6"><a href="#函数功能-6" class="headerlink" title="函数功能"></a>函数功能</h6><p>返回<code>va</code>对应的物理页</p>
<h6 id="函数实现-1"><a href="#函数实现-1" class="headerlink" title="函数实现"></a>函数实现</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, (<span class="keyword">void</span> *)va, <span class="number">0</span>);    </span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(pte_store != <span class="literal">NULL</span>) *pte_store = pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> = <span class="title">pa2page</span>(<span class="title">PTE_ADDR</span>(*<span class="title">pte</span>));</span></span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h6><p>上面的函数有两个问题：</p>
<ul>
<li>仅判断<code>pte</code>为空是不行的，还要判断<code>*pte</code>是否为0</li>
<li>要判断<code>pte</code>是否在合适的范围之内，即<code>PPN(*pte) &lt;= npage</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, (<span class="keyword">void</span> *)va, <span class="number">0</span>);    </span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="literal">NULL</span> || *pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(PPN(*pte) &gt; npage) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pte_store != <span class="literal">NULL</span>) *pte_store = pte;</span><br><span class="line">    	<span class="keyword">return</span> pa2page(PTE_ADDR(*pte));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove()"></a>page_remove()</h5><h6 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unmaps the physical page at virtual address 'va'.</span></span><br><span class="line"><span class="comment">// If there is no physical page at that address, silently does nothing.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Details:</span></span><br><span class="line"><span class="comment">//   - The ref count on the physical page should decrement.</span></span><br><span class="line"><span class="comment">//   - The physical page should be freed if the refcount reaches 0.</span></span><br><span class="line"><span class="comment">//   - The pg table entry corresponding to 'va' should be set to 0.</span></span><br><span class="line"><span class="comment">//     (if such a PTE exists)</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if you remove an entry from</span></span><br><span class="line"><span class="comment">//     the page table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using page_lookup,</span></span><br><span class="line"><span class="comment">// 	tlb_invalidate, and page_decref.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="函数功能-7"><a href="#函数功能-7" class="headerlink" title="函数功能"></a>函数功能</h6><p>解除物理页和虚拟地址的映射关系</p>
<h6 id="函数实现-2"><a href="#函数实现-2" class="headerlink" title="函数实现"></a>函数实现</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pte</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    page_decref(pp);</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">    tlb_invalidate(pgdir, va);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="page-insert"><a href="#page-insert" class="headerlink" title="page_insert()"></a>page_insert()</h5><h6 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map the physical page 'pp' at virtual address 'va'.</span></span><br><span class="line"><span class="comment">// The permissions (the low 12 bits) of the page table entry</span></span><br><span class="line"><span class="comment">// should be set to 'perm|PTE_P'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requirements</span></span><br><span class="line"><span class="comment">//   - If there is already a page mapped at 'va', it should be page_remove()d.</span></span><br><span class="line"><span class="comment">//   - If necessary, on demand, a page table should be allocated and inserted</span></span><br><span class="line"><span class="comment">//     into 'pgdir'.</span></span><br><span class="line"><span class="comment">//   - pp-&gt;pp_ref should be incremented if the insertion succeeds.</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if a page was formerly present at 'va'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Corner-case hint: Make sure to consider what happens when the same</span></span><br><span class="line"><span class="comment">// pp is re-inserted at the same virtual address in the same pgdir.</span></span><br><span class="line"><span class="comment">// However, try not to distinguish this case in your code, as this</span></span><br><span class="line"><span class="comment">// frequently leads to subtle bugs; there's an elegant way to handle</span></span><br><span class="line"><span class="comment">// everything in one code path.</span></span><br><span class="line"><span class="comment">// 不要通过判断的方式解决这个边界条件的问题，有一种很巧妙的实现方式</span></span><br><span class="line"><span class="comment">// RETURNS:</span></span><br><span class="line"><span class="comment">//   0 on success</span></span><br><span class="line"><span class="comment">//   -E_NO_MEM, if page table couldn't be allocated</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using pgdir_walk, page_remove,</span></span><br><span class="line"><span class="comment">// and page2pa.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="函数功能-8"><a href="#函数功能-8" class="headerlink" title="函数功能"></a>函数功能</h6><p>将物理页<code>pp</code>映射至虚拟地址<code>va</code>，实际上是在多叉树中插入</p>
<h6 id="函数实现-3"><a href="#函数实现-3" class="headerlink" title="函数实现"></a>函数实现</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="literal">NULL</span>) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    pp-&gt;pp_ref++;   <span class="comment">// 这一句需要特别注意其位置</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_P) page_remove(pgdir, va);</span><br><span class="line">    *pte = page2pa(pp) | prem | PTE_P;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="细节：关于边界条件的处理"><a href="#细节：关于边界条件的处理" class="headerlink" title="细节：关于边界条件的处理"></a>细节：关于边界条件的处理</h6><p>当同一个<code>pp</code>被重新插入至相同<code>pgdir</code>的相同<code>pte</code>，会发生什么事情？按照上面的代码，首先，<code>pp</code>会被<code>remove</code>，当被<code>remove</code>之后，<code>pp</code>会被回收，而下面的代码又回去利用被回收的<code>pp</code>，因此会造成访问非法内存的问题。正确的方法是将pp-&gt;pp_ref++放置在回收语句之前，这样一增一减正好抵消，<code>pp</code>不会被回收掉。而如果是不同的<code>pp</code>，则不受影响。</p>
<h2 id="第三部分：内核地址空间"><a href="#第三部分：内核地址空间" class="headerlink" title="第三部分：内核地址空间"></a>第三部分：内核地址空间</h2><p>JOS对内存进行了划分，虚拟地址低部分为用户空间，高部分为内核（约256MB），分界线是<code>ULIM: 0xef800000</code>，给操作系统留下了大约256MB的空间。在ULIM往上，用户没有访问权限。</p>
<h3 id="权限和错误处理"><a href="#权限和错误处理" class="headerlink" title="权限和错误处理"></a>权限和错误处理</h3><p>由于内核和用户代码都在地址空间中，因此我们需要权限管理，使用户只能访问自己的地址空间。首先，我们先进行一个划分：</p>
<ul>
<li>高于<code>ULIM</code>：用户无权访问</li>
<li><code>[UTOP, ULIM)</code>：用户和内核只能读，这一段用于保存向用户开放的内核只读数据</li>
<li>低于<code>UTOP</code>：用户可用空间</li>
</ul>
<h3 id="内核地址空间初始化"><a href="#内核地址空间初始化" class="headerlink" title="内核地址空间初始化"></a>内核地址空间初始化</h3><h4 id="练习5：完成mem-init-中check-page-之前的代码"><a href="#练习5：完成mem-init-中check-page-之前的代码" class="headerlink" title="练习5：完成mem_init()中check_page()之前的代码"></a>练习5：完成mem_init()中check_page()之前的代码</h4><p>在这个练习中，我们需要建立内核代码中相关的物理地址和虚拟地址之间的映射，建立过程使用上一节实现的<code>boot_map_region</code>函数即可。映射过程已经由注释给出了提示，相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map 'pages' read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a "guard page".</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)   //这里需要注意一下 2^32 相当于1&lt;&lt;32，已经超过了32位系统，结果是0</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, -KERNBASE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>
<p>上述三行分别完成了页表、内核栈和内核的映射，可以看到低物理地址的内核被映射至了高虚拟地址上。需要注意的是，在建立内核栈时，创建了一段未映射的缓冲区，大小是<code>PTSIZE-KSTKSIZE</code>，内核栈如果访问了这段区域，会导致错误。完成之后本次实验的基础部分已经完成，<code>make grade</code>命令会显示全部通过。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="整理内存映射表"><a href="#整理内存映射表" class="headerlink" title="整理内存映射表"></a>整理内存映射表</h5><p>我们已经在内核中部分建立起虚拟地址到物理地址的映射，现在，根据已经建立的映射关系尽可能填写下面的表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Entry</th>
<th>Base Virtual Address</th>
<th>Points to (logically):</th>
</tr>
</thead>
<tbody>
<tr>
<td>1023</td>
<td>?</td>
<td>Page table for top 4MB of phys memory</td>
</tr>
<tr>
<td>1022</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>0xf0000000(KERNBASE)</td>
<td></td>
</tr>
<tr>
<td>958</td>
<td>0xef800000(ULIM)</td>
<td>limit between user and kernel</td>
</tr>
<tr>
<td>957</td>
<td></td>
<td>?</td>
</tr>
<tr>
<td>956</td>
<td>0xef000000(UPAGES)</td>
<td>Read Only pages</td>
</tr>
<tr>
<td>2</td>
<td>0x00800000</td>
<td>?</td>
</tr>
<tr>
<td>1</td>
<td>0x00400000</td>
<td>?</td>
</tr>
<tr>
<td>0</td>
<td>0x00000000</td>
<td>[see next question]</td>
</tr>
</tbody>
</table>
</div>
<h5 id="内存保护机制"><a href="#内存保护机制" class="headerlink" title="内存保护机制"></a>内存保护机制</h5><p>Q：我们将内核和用户进程放在同一个地址空间中，为何用户进程无法读写内核内存。为何用户无权访问</p>
<p>A：因为我们对虚拟内存也进行了划分，按照ULIM为分界线，向上为内核区域，用户无权限访问。这一机制是靠Current Privilege Level实现的，cs寄存器的两位描述了当前程序的权限，linux使用了两位，分别是内核态(0)和用户态(3)。</p>
<h5 id="操作系统能支持的最大内存是多少？"><a href="#操作系统能支持的最大内存是多少？" class="headerlink" title="操作系统能支持的最大内存是多少？"></a>操作系统能支持的最大内存是多少？</h5><p>这个问题问的有歧义，应该问内核占用的物理地址最大为多少。由于内核虚拟地址范围是[0xF0000000, 0xFFFFFFFF]，所以大小为0x0FFFFFFF，共256MB，操作系统理论上最大为256MB，超了的话32位地址无法映射。</p>
<h5 id="用于管理内存的空间开销是多少？如何降低这个开销？"><a href="#用于管理内存的空间开销是多少？如何降低这个开销？" class="headerlink" title="用于管理内存的空间开销是多少？如何降低这个开销？"></a>用于管理内存的空间开销是多少？如何降低这个开销？</h5><p>首先，我们有一个页目录，大小是一个页。</p>
<p>其次，我们使用了一个<code>pages</code>结构体数组，用于对页进行保存，这个数组的大小是<code>npages * sizeof(struct PageInfo)</code>，具体值为32768*8B /PGSIZE=64个页。总共65个页，当然在后续加入用户进程后，维护页表还需要额外的内存空间。</p>
<p>我能想到的降低开销的方法是加大页的空间，例如使用2MB或4MB的页，这样可以降低页表数量，节约一部分开销。</p>
<h5 id="地址切换问题"><a href="#地址切换问题" class="headerlink" title="地址切换问题"></a>地址切换问题</h5><p>再次查看<code>kern/entry.S</code> 和<code>kern/entrypgdir.c</code>两个文件，当我们开启页映射后，EIP仍处于低地址空间。那么什么时候开始EIP位于高地址空间呢？</p>
<p>为了解决这个问题，我们开启gdb对内核启动的初始阶段进行调试，设置断点<code>br *0x0010000c</code>，然后跳转到entry，这一段的汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x100015        mov    $0x118000,%eax         # 加载页目录，entrypgdir 位于0x11800，保存在了cr3寄存器中</span><br><span class="line">0x10001a        mov    %eax,%cr3                                                       </span><br><span class="line">0x10001d        mov    %cr0,%eax              # 开启分页                                           </span><br><span class="line">0x100020        or     $0x80010001,%eax                                                   </span><br><span class="line">0x100025        mov    %eax,%cr0                                                         </span><br><span class="line">0x100028        mov    $0xf010002f,%eax            </span><br><span class="line">0x10002d        jmp    *%eax                  # 跳转至0xf010002f，此时发生了地址切换，eip变成 $0xf0118000         </span><br><span class="line">0x10002f        mov    $0x0,%ebp                                                         </span><br><span class="line">0x100034        mov    $0xf0118000,%esp                                                   </span><br><span class="line">0x100039        call   0x100040                                                            </span><br><span class="line">0x10003e        jmp    0x10003e                                                            </span><br><span class="line">0x100040        push   %ebp                                                               </span><br><span class="line">0x100041        mov    %esp,%ebp                                                         </span><br><span class="line">0x100043        sub    $0xc,%esp                                                          </span><br><span class="line">0x100046        mov    $0xf017cb00,%eax</span><br></pre></td></tr></table></figure>
<p>是什么机制使得我们在开启页映射到跳转至高地址这段区间内，仍然能够执行位于低地址的指令？</p>
<p>为了解决这个问题，我们需要查看CR0寄存器，开启分页后CR0寄存器的值为0x80010001，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cr0 = 1000, 0000, 0000, 0001, 0000, 0000, 0000, 0001</span><br></pre></td></tr></table></figure>
<p>翻译过来就是，使能页映射；使用CR3寄存器；不禁用cache，不禁用write-through cache；位于保护模式；开启写保护。没什么特别的，然后我们看下<code>kern/entrypgdir.c</code>。在这个文件中 ，我们找到了如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pde_t</span> entry_pgdir[NPDENTRIES] = &#123;</span><br><span class="line">    <span class="comment">// Map VA's [0, 4MB) to PA's [0, 4MB)</span></span><br><span class="line">    [<span class="number">0</span>]</span><br><span class="line">        = ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line">    <span class="comment">// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)</span></span><br><span class="line">    [KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">        = ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到这里应该就明白了，实际上我们是进行了一个双重映射，将虚拟地址的[0, 4MB)和[KERNBASE, KERNBASE+4MB)都映射到了物理地址的[0, 4MB)，所以我们能够在开启页映射后，依然在低地址空间执行，但是实际上这里的低地址空间是虚拟地址的低地址空间。VA’[0, 4MB) to PA [0, 4MB)这个映射只使用了这一次，算是做的一点小小的妥协吧。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="物理内存布局"><a href="#物理内存布局" class="headerlink" title="物理内存布局"></a>物理内存布局</h3><p>在经过实验一和实验二后，我们对于操作系统物理内存的布局已经有了一些基本了解，现在我们总结一下已经确定的物理内存布局图：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/physicalMemLayout.svg" width = "750" alt="图片名称" align=center /></p>
<p>绿色的就是几个比较关键部分的内存布局。</p>
<h3 id="内存映射关系"><a href="#内存映射关系" class="headerlink" title="内存映射关系"></a>内存映射关系</h3><p>现在我们来总结一下内存映射关系：</p>
<h3 id="一些重要的函数及计算"><a href="#一些重要的函数及计算" class="headerlink" title="一些重要的函数及计算"></a>一些重要的函数及计算</h3><h4 id="i386-detect-memory"><a href="#i386-detect-memory" class="headerlink" title="i386_detect_memory"></a>i386_detect_memory</h4><p>这个函数负责获取实际的内存大小，里面定义了<code>totalmem</code>、<code>basemem</code>两个变量分别表示总内存及基本内存，在实验中，这些变量的值如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">totalmem = 131072(KB)      //0x08000000</span><br><span class="line">basemem = 640(KB)</span><br></pre></td></tr></table></figure>
<p>所以总的物理页计算为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">npages = totalmem/(PGSIZE/<span class="number">1024</span>);    <span class="comment">// npages = 32768</span></span><br></pre></td></tr></table></figure>
<p>共有32768个物理页。</p>
<h4 id="check-page-free-list-bool-only-low-memory"><a href="#check-page-free-list-bool-only-low-memory" class="headerlink" title="check_page_free_list(bool only_low_memory)"></a>check_page_free_list(bool only_low_memory)</h4><p>这个函数的作用是检查<code>page_free_list</code>所指向的页面都是有效的，进入后首先判断<code>page_free_list</code>是否为空，为空则无效，随后进入下面一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (only_low_memory) &#123;</span><br><span class="line">    <span class="comment">// Move pages with lower addresses first in the free</span></span><br><span class="line">    <span class="comment">// list, since entry_pgdir does not map all pages.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> **<span class="title">tp</span>[2] = &#123;</span> &amp;pp1, &amp;pp2 &#125;;</span><br><span class="line">    <span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) &#123;</span><br><span class="line">        <span class="keyword">int</span> pagetype = PDX(page2pa(pp)) &gt;= pdx_limit;</span><br><span class="line">        *tp[pagetype] = pp;</span><br><span class="line">        tp[pagetype] = &amp;pp-&gt;pp_link;</span><br><span class="line">    &#125;						<span class="comment">//执行该for循环后，pp1指向（0~4M）中地址最大的那个页的PageInfo结构。pp2指向所有页中地址最大的那个PageInfo结构</span></span><br><span class="line">    *tp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    *tp[<span class="number">0</span>] = pp2;</span><br><span class="line">    page_free_list = pp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码比较迷惑，为了解释其功能，我们先要明确PDX以及page2pa的作用，先看page2pa，其函数原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">page2pa(struct PageInfo *pp)&#123;</span><br><span class="line">    <span class="keyword">return</span> (pp-pages) &lt;&lt; PGSHIFT;  <span class="comment">// PGSHIFT = log2(PGSIZE) = 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是找到pp所对应的PageInfo指向的具体的物理页，由于一个物理页的大小为4096，所以由页序号转到物理地址的计算公式为$(page1 - start_page)\times PGSIZE=(page1 - start_page)&lt;&lt;PGSHIFT$。</p>
<p>PDX的作用是获得线性地址的一部分，这里不展开说了。  </p>
<h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><h4 id="boot-alloc-调试过程"><a href="#boot-alloc-调试过程" class="headerlink" title="boot_alloc 调试过程"></a>boot_alloc 调试过程</h4><p>使用GDB进入boot_alloc后，得到nextfree的起始地址为0xf0115000，根据内存大小，可以知道内存最大物理地址为<code>0x08000000</code>，所以总可用空间为<code>0x7EEB000</code>。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 book</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab2/">Lab2</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.cs.utexas.edu/~lorenzo/corsi/cs372/06F/hw/3sol.html">内存计算问题</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828课程大纲</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>HumanCore - CP/M-17 Version 1.0, Date: January 08, 1996</p>
</blockquote>
<a id="more"></a>
<h2 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Mon</th>
<th style="text-align:left">Tue</th>
<th style="text-align:left">Wed</th>
<th>Thur</th>
<th>Fri</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Binary search trees, BST sort</td>
<td style="text-align:left"></td>
<td style="text-align:left">AVL trees, AVL sort</td>
<td><strong>LEC 2 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-x86.pdf">PC hardware and x86 programming slides</a>, <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-x86.html">notes</a> <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Bootstrap/PC hardware appendices and the related xv6 source files</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-boot.html">HW: Boot xv6</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Counting sort, radix sort, lower bounds for sorting and searching</td>
<td style="text-align:left"><strong>LEC 3 (TAs):</strong> C and <a href="https://pdos.csail.mit.edu/6.828/2018/lec/gdb_slides.pdf">gdb</a> (<a href="https://pdos.csail.mit.edu/6.828/2018/lec/pointers.c">pointers example</a>) <strong>Homework 1 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-boot.html">Boot xv6</a> <strong>Preparation</strong>: Read 2.9 (Bitwise operators), 5.1 (Pointers and Addresses) through 5.5(Character Pointers and Functions) and 6.4 (pointers to structures) in K&amp;R <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-shell.html">HW: shell</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab2/">Lab 2: Memory management</a></td>
<td style="text-align:left">Hashing with chaining</td>
<td><strong>DUE</strong>: Lab 1<strong>LEC 4 (fk):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-shell.txt">Shell &amp; OS organization</a> <strong>Preparation</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Read chapter 0 of the xv6 book</a>. <strong>Homework 2 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-shell.html">shell</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Table doubling, Karp-Rabin</td>
<td style="text-align:left"><strong>LEC 5 (fk):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-internal.txt">Isolation mechanisms</a> <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Chapter 1: Operating system organization” and the related xv6 source files</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">HW: system calls</a></td>
<td style="text-align:left">Open addressing, cryptographic hashing</td>
<td><strong>LEC 6 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm.md">Virtual memory (1)</a> (handouts: <a href="https://pdos.csail.mit.edu/6.828/2018/lec/x86_translation_and_registers.pdf">page table translation and registers</a>) (<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm.pdf">slides</a>) <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Chapter 2: Page Tables”</a> <strong>Homework 3 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">system calls</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">HW lazy page allocation</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Quiz 1</td>
<td style="text-align:left"><strong>LEC 7 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-usevm.md">Virtual memory (2)</a> (handout: <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-josmem.html">JOS virtual memory layout</a>) (<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-usingvm.pdf">slides</a>) <strong>Homework 4 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">HW lazy page allocation</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-alarm.html">HW xv6 CPU alarm</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab3/">Lab 3: User-Level Environments</a></td>
<td style="text-align:left">Integer arithmetic, Karatsuba multiplication</td>
<td><strong>DUE</strong>: Lab 2 <strong>LEC 8 (fk):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-interrupt.txt">System calls, interrupts, exceptions</a> (handouts: <a href="https://pdos.csail.mit.edu/6.828/2018/lec/x86_idt.pdf">IDT</a>) <strong>Prep  aration</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Traps, interrupts, and drivers” and the related xv6 source files</a> <strong>Homework 5 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-alarm.html">HW xv6 CPU alarm</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/lock.html">HW multithreaded programming</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Square roots, Newton’s method</td>
<td style="text-align:left"><strong>LEC 9 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-lockv2.txt">Multiprocessors and locking</a> (<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-locks.pdf">slides</a>) <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Locking”</a> with spinlock.c and skim mp.c <strong>Homework 6 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/lock.html">HW multithreaded programming</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-lock.html">HW xv6 locks</a></td>
<td style="text-align:left">Breadth-first search (BFS)</td>
<td><strong>DUE</strong>: Lab 3 (Part A)oct 10 Hacking day <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab4/">Lab 4: Preemptive Multitasking</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Depth-first search (DFS), topological sorting</td>
<td style="text-align:left"><strong>LEC 10 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-threads.txt">Processes and switching</a> <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Scheduling”</a> up to “Sleep and wakeup” and proc.c, swtch.S <strong>Homework 7 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-lock.html">HW xv6 locks</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-uthread.html">HW uthreads</a></td>
<td style="text-align:left">Single-source shortest paths problem</td>
<td><strong>LEC 11 (fk):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-coordination.txt">sleep&amp;wakeup</a> <strong>Preparation</strong>: Read remainder of <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Scheduling”</a>, and corresponding parts of proc.c <strong>Homework 8 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-uthread.html">HW uthreads</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/barrier.html">HW barrier</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Dijkstra</td>
<td style="text-align:left"><strong>LEC 12 (fk):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-fs.txt">File systems</a> <strong>Preparation</strong>: Read bio.c, fs.c, sysfile.c, file.c and “File system” except for the logging sections <strong>Homework 9 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/barrier.html">HW barrier</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-big-files.html">HW big files</a></td>
<td style="text-align:left">Bellman-Ford</td>
<td><strong>DUE</strong>: Lab 4 (Part A)oct 24 <strong>LEC 13 (fk):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-crash.txt">Crash recovery</a> <strong>Preparation</strong>: Read log.c and the logging sections of “File system” <strong>Homework 10 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-big-files.html">HW big files</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-new-log.html">HW crash</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab6/">Lab 6: Networking</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab7/">Lab 7: Final project</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Speeding up Dijkstra</td>
<td style="text-align:left"><strong>Quiz #1</strong> <strong>open book and notes</strong> <strong>scope</strong>: Lectures 1 through 13, HW 1 through 10, labs 1 through 3 <strong>practice:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/quiz.html">previous years’ quizzes</a>.</td>
<td style="text-align:left">Quiz 2</td>
<td><strong>DUE</strong>: Lab 4 (Part B)oct 31 Hacking day <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab5/">Lab 5: File system, spawn, and sh</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Memoization, subproblems, guessing, bottom-up; Fibonacci, shortest paths</td>
<td style="text-align:left"><strong>LEC 14 (fk):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-journal.txt">File system performance and fast crash recovery</a> <strong>Homework 11 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-new-log.html">HW crash</a> <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/homework/journal-ext2fs.html">Journaling the Linux ext2fs Filesystem (1998)</a> <strong>Assignment</strong>: <a href="https://pdos.csail.mit.edu/6.828/2018/homework/mmap.html">mmap()</a></td>
<td style="text-align:left">Parent pointers; text justification, perfect-information blackjack</td>
<td><strong>DUE</strong>: Lab 4 (Part C)nov 7 <strong>LEC 15 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm-again.txt">Virtual Memory (3)</a> (<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm-again.pdf">slides</a>) <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/appel-li.pdf">Virtual Memory Primitives for User Programs (1991)</a> <strong>Homework 12 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/mmap.html">mmap</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">String subproblems, psuedopolynomial time; parenthesization, edit distance, knapsack</td>
<td style="text-align:left"><strong>LEC 16 (fk):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-organization.txt">OS Organization</a> <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/engler95exokernel.pdf">Exokernel (1995)</a> <strong>Homework 13 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/exok.html">HW exokernel question</a></td>
<td style="text-align:left">Two kinds of guessing; piano/guitar fingering, Tetris training, Super Mario Bros.</td>
<td><strong>DUE</strong>: Final project proposal (if doing project)nov 19 <strong>LEC 17 (cc):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-biscuit.txt">Kernels and HLL</a> <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/biscuit.pdf">the Biscuit paper (2018)</a> <strong>Homework 14 due:</strong> [HW Biscuit question</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Computational complexity</td>
<td style="text-align:left"><strong>DROP DATE</strong> <strong>LEC 18 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-scalable-lock.md">Scalable locks</a> (<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-mcs.pdf">slides</a>) (<a href="https://pdos.csail.mit.edu/6.828/2018/lec/scalable-lock-code.c">code</a>) <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/linux-lock.pdf">Non-scalable locks paper (2012)</a> <strong>Homework 15 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/ticketlock.html">ticket lock question</a></td>
<td style="text-align:left">Algorithms research topics</td>
<td><strong>DUE</strong>: Lab 5nov 26 <strong>LEC 19 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-rcu.pdf">Scaling OSes slides</a> <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/rcu-decade-later.pdf">RCU (2013)</a> <strong>Homework 16 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/rcu.html">RCU question</a> <strong>DUE</strong>: Email us a status update on your final project (a paragraph)</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><strong>LEC 20 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vmware.txt">Virtual Machines (1)</a> (<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vmware.pdf">slides</a>) <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/adams06vmware.pdf">Software vs Hardware Virtualization (2006)</a> <strong>Homework 17 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/vmware.html">VM question</a></td>
<td style="text-align:left"></td>
<td><strong>LEC 21 (ab):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vmm.md">Virtual Machines (2)</a> (<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-virt2.pdf">slides</a>) <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/belay-dune.pdf">Dune: Safe User-level Access to Privileged CPU Features (2012)</a> <strong>Homework 18 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/dune.html">Dune question</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><strong>LEC 22 (fk):</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-net.txt">High-performance networking</a> <strong>Preparation</strong>: Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/osdi14-paper-belay.pdf">IX: A Protected Dataplane Operating System for High Throughput and Low Latency (2014)</a> <strong>Homework 19 due:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/homework/ix.html">IX question</a></td>
<td style="text-align:left"></td>
<td><strong>Quiz #2</strong> <strong>DUPONT-Gym, 9am-11pm</strong> <strong>open book, notes, and papers.</strong> <strong>scope</strong>: Lectures 14 through last lecture (dec 12), labs 4 and 5. <strong>practice:</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/quiz.html">previous years’ quizzes</a>.</td>
</tr>
</tbody>
</table>
</div>
<h2 id="课程阅读"><a href="#课程阅读" class="headerlink" title="课程阅读"></a>课程阅读</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">课程</th>
<th style="text-align:left">内容</th>
<th style="text-align:center">完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LEC1</td>
<td style="text-align:left">阅读：课程大纲</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">观看：Unix系统介绍</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">LEC2</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-x86.pdf">PC hardware and x86 programming slides</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-x86.html">notes</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Bootstrap/PC hardware appendices and the related xv6 source files</a></td>
<td style="text-align:center">完成，但是剩下三个题目不会</td>
</tr>
<tr>
<td style="text-align:left">LEC3</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/gdb_slides.pdf">gdb (mit.edu)</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：K&amp;R2.9、5.1-5.5、6.4章节</td>
<td style="text-align:center">完成，2.9节三个练习没做</td>
</tr>
<tr>
<td style="text-align:left">LEC4</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-shell.txt">Shell &amp; OS organization</a></td>
<td style="text-align:center">剩下三个挑战问题和两个问答题没做</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">chapter 0 of the xv6 book</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">LEC5</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-internal.txt">Isolation mechanisms</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Chapter 1: Operating system organization” and the related xv6 source files</a></td>
<td style="text-align:center">读到了22页</td>
</tr>
<tr>
<td style="text-align:left">LEC6</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm.md">Virtual memory (1)</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/x86_translation_and_registers.pdf">page table translation and registers</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm.pdf">slides</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Chapter 2: Page Tables</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">LEC7</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-usevm.md">Virtual memory (2)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-josmem.html">JOS virtual memory layout</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-usingvm.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC8</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-interrupt.txt">System calls, interrupts, exceptions</a></td>
<td style="text-align:center">基本上看完了</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/x86_idt.pdf">IDT</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Traps, interrupts, and drivers” and the related xv6 source files</a></td>
<td style="text-align:center">大致浏览了一遍，代码还没看，这个很重要，多看几遍</td>
</tr>
<tr>
<td style="text-align:left">LEC9</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-lockv2.txt">Multiprocessors and locking (mit.edu)</a></td>
<td style="text-align:center">前两页读完了</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-locks.pdf">slides (mit.edu)</a></td>
<td style="text-align:center">锁的实现没有读完</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读： <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Locking”</a> with spinlock.c and skim mp.c</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC10</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-threads.txt">Processes and switching</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Scheduling”</a> up to “Sleep and wakeup” and proc.c, swtch.S</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC11</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-coordination.txt">sleep&amp;wakeup</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：remainder of <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Scheduling”</a>, and corresponding parts of proc.c</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC12</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-fs.txt">File systems</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：bio.c, fs.c, sysfile.c, file.c and “File system” except for the logging sections</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC13</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-crash.txt">Crash recovery</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：log.c and the logging sections of “File system”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC14</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-journal.txt">File system performance and fast crash recovery</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/journal-ext2fs.html">Journaling the Linux ext2fs Filesystem (1998)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC15</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm-again.txt">Virtual Memory (3)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm-again.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/appel-li.pdf">Virtual Memory Primitives for User Programs (1991)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC16</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-organization.txt">OS Organization</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/engler95exokernel.pdf">Exokernel (1995)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC17</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-biscuit.txt">Kernels and HLL</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/biscuit.pdf">Biscuit paper (2018)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC18</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-scalable-lock.md">Scalable locks</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-mcs.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/scalable-lock-code.c">code</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/linux-lock.pdf">Non-scalable locks paper (2012)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC19</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-rcu.pdf">Scaling OSes slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/rcu-decade-later.pdf">RCU (2013)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC20</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vmware.txt">Virtual Machines (1)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vmware.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC21</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/adams06vmware.pdf"><a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vmm.md">Virtual Machines (2)</a></a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-virt2.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/belay-dune.pdf">Dune: Safe User-level Access to Privileged CPU Features (2012)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC22</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-net.txt">High-performance networking</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/osdi14-paper-belay.pdf">IX: A Protected Dataplane Operating System for High Throughput and Low Latency (2014)</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="阅读练习"><a href="#阅读练习" class="headerlink" title="阅读练习"></a>阅读练习</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">章节</th>
<th style="text-align:left">内容</th>
<th style="text-align:center">完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Chapter1</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">Chapter2</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">Chapter3</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">Chapter4</td>
<td style="text-align:left">练习1：触发竞态</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">Chapter5</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">Chapter6</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="课程视频"><a href="#课程视频" class="headerlink" title="课程视频"></a>课程视频</h2><p>由于本课程视频较为模糊，因此我们以其他的视频进行替代</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">课程</th>
<th style="text-align:left">内容</th>
<th style="text-align:center">完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">第一讲</td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173324">为何学习操作系统</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">第三讲</td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173340">操作系统启动流程</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173341">中断、异常和系统调用比较</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/exercise/9173345">中断、异常和系统调用题目</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173342">系统调用及题目</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">第四讲</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">第五讲：物理内存管理</td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173356">计算机体系结构和内存层次</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173357">地址空间和地址生成</a></td>
<td style="text-align:center">完成：笔记记录在内存管理章节</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173358">连续内存分配</a></td>
<td style="text-align:center">完成：笔记记录在内存管理章节</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173359">碎片整理</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">第六讲：非连续内存分配</td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173362">非连续分配需求背景 </a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173363">段式管理</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="ttps://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173364">页式管理</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">第十一讲：进程和线程</td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173407">进程的概念</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173408">进程控制块</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173409">进程状态</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173410">进程三状态模型</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173411">进程挂起</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173412">线程</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">第十二讲：进程控制</td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173422">进程切换</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173423">进程创建</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/exercise/9173428">进程加载</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">第十三讲：内核线程管理</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><div class="table-container">
<table>
<thead>
<tr>
<th>作业</th>
<th>内容</th>
<th style="text-align:center">完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-boot.html">作业1：boot xv6 (Lecture2)</a></td>
<td>Boot xv6</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>Finding and breaking at an address</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>Exercise: What is on the stack?</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-shell.html">作业2：shell (Lecture3)</a></td>
<td>完成：<a href="http://web.mit.edu/6.033/2004/wwwdocs/handouts/handson/unix.html">6.033: Hands-on Assignment (UNIX) (mit.edu)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td></td>
<td>阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">chapter 0 of the xv6 book</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/sh.c">6.828 shell</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：实验环境搭建</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：执行简单命令</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：IO重定向</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：实施管道</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：挑战练习</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">作业3：xv6 system calls (Lecture5)</a></td>
<td>完成：syscall函数</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：date函数</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">作业4：lazy page allocation(Lecture6)</a></td>
<td>完成：修改sbrk函数</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：lazy allocation</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：挑战任务</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-alarm.html">作业5：CPU Alarm(Lecture7)</a></td>
<td>阅读：作业内容</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/lock.html">作业6：Threads and Locking</a></td>
<td>完成：对put进行加锁保护</td>
<td style="text-align:center">完成，但是Hash表原理不太懂，复习了一下，基本懂了</td>
</tr>
<tr>
<td></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="实-验"><a href="#实-验" class="headerlink" title="实     验"></a>实     验</h2><div class="table-container">
<table>
<thead>
<tr>
<th>实验</th>
<th>内容</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">Lab1</a></td>
<td></td>
<td>完成</td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab2/">Lab2</a></td>
<td>阅读：Introduction</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>完成：实验环境搭建</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>阅读：第一部分，物理页管理</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>阅读：第二部分，虚拟内存</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>阅读：第三部分，内核地址空间</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>编程：编写一个物理内存分配 boot_alloc</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第一部分：编写mem_init()</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第一部分：编写page_init</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第一部分：编写page_alloc和page_free</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第二部分：编写pgdir_walk</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>编写boot_map_region</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>编写page_lookup</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>编写page_insert</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>编写page_delete</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第三部分：内核地址空间</td>
<td>完成</td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab3/">Lab3</a></td>
<td>源码阅读</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>阅读进程状态章节</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>进程创建及运行章节代码</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual 第五章</a></td>
<td>读到了5.10节</td>
</tr>
<tr>
<td></td>
<td>阅读”Basics of Protected Control Transfer”</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>练习4，编写trapentry</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>练习5，编写trap_dispatch</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>练习6，编写断点异常</td>
<td>完成</td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab4/">Lab 4</a></td>
<td>课程准备</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td><strong>第一部分</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td>练习1：编写<code>mmio_map_region</code>函数</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>练习2：阅读boot_aps、mp_main以及<code>mpentry.S</code></td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>练习2：修改<code>page_init</code>，删除特定内存</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>阅读CPU状态</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>练习3：初始化每个CPU的内核栈</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>练习4：编写<code>trap_init_percpu</code></td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>练习5：对内核进行锁保护</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>挑战1：使用细颗粒锁</td>
<td></td>
</tr>
<tr>
<td></td>
<td>练习6：完成Round-robin调度</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>挑战2：添加优先级调度</td>
<td></td>
</tr>
<tr>
<td></td>
<td>挑战3：浮点单元支持</td>
<td></td>
</tr>
<tr>
<td></td>
<td>完成用于支持进程创建的系统调用</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>练习7：<code>sys_exofork</code>实现</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td><strong>第二部分</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>测试一：<a href="https://pdos.csail.mit.edu/6.828/2018/quiz.html">previous years’ quizzes</a>.</li>
<li>测试二：<a href="https://pdos.csail.mit.edu/6.828/2018/quiz.html">previous years’ quizzes</a>.</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.bilibili.com/video/av15896196/">MIT6828课程视频链接</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">6.828 / Fall 2018 (mit.edu)</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.xuetangx.com/learn/THU08091000267/THU08091000267/5883104/video/9173325">清华操作系统课程</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://pdos.csail.mit.edu/6.828/2020/labs/">Index of /2020/labs (mit.edu)</a><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><a href="https://zhuanlan.zhihu.com/p/74028717">MIT6.828全系列</a><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828实验环境配置指南</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对MIT6828的实验环境配置进行讲解。</p>
<a id="more"></a>
<p>首先，建议使用32位ubuntu虚拟机作为实验环境，不建议自己配置，因为会遇到各种坑。我们的主要目的是学习操作系统，不是安装各种环境及工具，下载一个32位的ubuntu桌面镜像，然后配置一个虚拟机即可。我这里使用的是16.04版本的32位ubuntu镜像，使用的虚拟机是vmware。</p>
<h2 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h2><p>在安装完成后，执行下面两个命令</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 book</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT 6006 Lecture 1——算法思维，峰值寻找</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%AF%BE%E7%A8%8B/MIT6006-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>一个人思虑太多，就会失去做人的乐趣。</p>
</blockquote>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本课程中我们将考虑大规模问题的高效解法，即考虑<strong>规模性</strong>。本课程的结构如下：</p>
<ul>
<li>算法思想</li>
<li>排序/树</li>
<li>哈希</li>
<li>数论：加密解密算法</li>
<li>图</li>
<li>最短路径</li>
<li>动态规划：图像压缩</li>
<li>高级话题</li>
</ul>
<h2 id="峰值算法"><a href="#峰值算法" class="headerlink" title="峰值算法"></a>峰值算法</h2><h3 id="一维峰值算法"><a href="#一维峰值算法" class="headerlink" title="一维峰值算法"></a>一维峰值算法</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>考虑下面的一维数组，其中$a-i$为数字：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/1dimdatastructure.JPG?raw=true" width = "380" alt="" align=center /></p>
<p>极值点的定义为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\textrm{if}\ \ \ \ b\ge a\ \ \ \ \textrm{and}\ \ \ \ b\ge c \\
\textrm{then}\ b\ \textrm{is the peak point}
\end{equation}</script><p>当然，如果在边界上，那么只需要大于一侧即可。我们的问题是：<strong>如果峰值点存在，找到峰值点</strong>。</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>最直接的解法就是遍历每一个元素，然后根据定义看一下是否为峰值，其复杂度为$O(n)$，现在我们来看看一个更高效的解法：分治法。</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/2020917.JPG?raw=true" width = "380" alt="" align=center /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a[n/<span class="number">2</span>] &lt; a[n/<span class="number">2</span><span class="number">-1</span>] </span><br><span class="line">    在 <span class="number">1.</span>..n/<span class="number">2</span><span class="number">-1</span> 中寻找peak，一定会有</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> a[n/<span class="number">2</span>] &lt; a[n/<span class="number">2</span>+<span class="number">1</span>] </span><br><span class="line">    在 n/<span class="number">2</span>+<span class="number">1.</span>..n 中寻找peak</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    a[n/<span class="number">2</span>] 是极值点</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p>假设我们的算法是正确的，那么其时间复杂度为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(n) =& T(n/2)+\Theta(1)\\
T(1) =& \Theta(1)
\end{aligned}
\end{equation}</script><p>故：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(n) =& T(n/2)+\Theta(1)\\
 =& T(n/4)+2\Theta(1)\\
 ...&\\
 =&T(n/2^{\log_2n})+(\log_2n)\Theta(1)\\
 =&\Theta(\log _2n)
\end{aligned}
\end{equation}</script><h3 id="二维峰值算法"><a href="#二维峰值算法" class="headerlink" title="二维峰值算法"></a>二维峰值算法</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>考虑下面的二维数组：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/20209171535.JPG?raw=true" width = "280" alt="" align=center /></p>
<p>假定$a$为峰值点，那么$a\ge b, a\ge c, a\ge d,a\ge e$。</p>
<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><h5 id="解法1：贪心"><a href="#解法1：贪心" class="headerlink" title="解法1：贪心"></a>解法1：贪心</h5><p>我们使用贪心算法解决这个问题，假设我们的矩阵为：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/20209171544.JPG?raw=true" width = "240" alt="" align=center /></p>
<p>我们的策略是，总是沿着最大的路径走，例如从12开始，我们向13搜索，依次走过14-&gt;15-&gt;16…直到20为止。该算法的时间复杂度为$\Theta(nm)$。</p>
<h5 id="解法2：分治法"><a href="#解法2：分治法" class="headerlink" title="解法2：分治法"></a>解法2：分治法</h5><p>考虑这样的解法：我们先选取中间列，令$j=m/2$，找到一个位于$(i,j)$的一维峰值点，然后以$(i,j)$为基准，再找到这一行的一维峰值点，这样能找到二维的峰值点吗？</p>
<p>答案是不行，这个解法是错误的，以我们上面的图为例，假设12是该列的一个峰值点，而当我们搜索12所在的行时，最终找到的峰值点是14，但是14并不是一个二维峰值点，所以该算法是错的。我们给出正确的贪心规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选取中间列 j=m/2</span><br><span class="line">找到该列的全局最大值 (i,j)</span><br><span class="line">比较(i,j-1), (i,j), (i,j+1)</span><br><span class="line">if (i,j-1) &gt; (i,j)</span><br><span class="line">    选择左半列</span><br><span class="line">if (i,j+1) &gt; (i,j)</span><br><span class="line">    选择右半列</span><br><span class="line">else </span><br><span class="line">    选择(i,j)</span><br></pre></td></tr></table></figure>
<p>在上面的伪代码中，else部分可以直接返回极值点，是因为$(i,j)$为该列的最大值，所以比$(i-1,j),(i+1,j)$都要大，而该点又比$(i,j-1),(i,j+1)$大，故符合峰值定义，可以直接返回。当只有一列时，最大值即峰值，这个是基例。</p>
<h6 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h6><p>上面的算法时间复杂度计算如下：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(n,m) &= T(n,m/2)+\Theta(n)\\
T(n,1) &=\Theta(n)\\
T(n,m) &=\Theta(n)+...+\Theta(n) = \Theta(n\log_2m)
\end{aligned}
\end{equation}</script><h2 id="题目及题解"><a href="#题目及题解" class="headerlink" title="题目及题解"></a>题目及题解</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="一：将下列函数根据时间复杂度进行排序"><a href="#一：将下列函数根据时间复杂度进行排序" class="headerlink" title="一：将下列函数根据时间复杂度进行排序"></a>一：将下列函数根据时间复杂度进行排序</h4><h5 id="第一组"><a href="#第一组" class="headerlink" title="第一组"></a>第一组</h5><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
f_1(n)&=n^{0.999999}\log n\\
f_2(n)&=10000000n\\
f_3(n)&=1.000001^n\\
f_4(n)&=n^2\\
\end{aligned}
\end{equation}</script><h6 id="解"><a href="#解" class="headerlink" title="解"></a>解</h6><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
\frac{f_1}{f_2}&=\frac{n^{1-0.0000001}\log n}{10000000n}\\
&=C_1\frac{\log n}{n^{0.0000001}}\\
\end{aligned}
\end{equation}</script><p>由于$n\rightarrow \infin$时$\log n$与$n^{0.0000001}$趋近于无穷大，所以对上式使用洛必达法则：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
\underset{n\rightarrow \infin}{\lim}\frac{f_1}{f_2}&=\underset{n\rightarrow \infin}{\lim}\frac{f_1'}{f_2'}\\
&=\underset{n\rightarrow \infin}{\lim}\frac{1}{n^{0.0000001}}\\
&=0
\end{aligned}
\end{equation}</script><p>故$\Theta(f_1)\le\Theta(f_2)$。同理易得$\Theta(f_2)\le\Theta(f_3)$，$\Theta(f_2)\le\Theta(f_4)$，而$\Theta(f_4)\le\Theta(f_3)$，故上述公式时间复杂度排序为：$\Theta(f_1)\le\Theta(f_2)\le\Theta(f_4)\le\Theta(f3)$</p>
<h5 id="第二组"><a href="#第二组" class="headerlink" title="第二组"></a>第二组</h5><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
f_1(n)&=2^{2^{1000000}}\\
f_2(n)&=2^{100000n}\\
f_3(n)&=C_n^2\\
f_4(n)&=n\sqrt n\\
\end{aligned}
\end{equation}</script><h6 id="解-1"><a href="#解-1" class="headerlink" title="解"></a>解</h6><p>常数时间复杂度为$\Theta(1)$为最小，$f_2$时间复杂度最高，为$\Theta(2^n)$，现比较$f_3$和$f_4$，$f_3=\frac{n(n-1)}{2}$，故</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
\underset{n\rightarrow \infin}{\lim}\frac{f_3}{f_4}&=\underset{n\rightarrow \infin}{\lim}\frac{n(n-1)}
{2n\sqrt n}\\
&=\frac{\sqrt n}{2}-\frac{1}{2\sqrt n}\\
&=\infin
\end{aligned}
\end{equation}</script><p>所以排序结果为$\Theta(f_1)\le\Theta(f_4)\le\Theta(f_3)\le\Theta(f2)$.</p>
<h5 id="第三组"><a href="#第三组" class="headerlink" title="第三组"></a>第三组</h5><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
f_1(n)&=n^{\sqrt n}\\
f_2(n)&=2^{n}\\
f_3(n)&=n^{10}2^{n/2}\\
f_4(n)&=\sum_{i=1}^{n}(i+1)\\
\end{aligned}
\end{equation}</script><p>这个算极限比较麻烦，采用matlab求两两之间的极限，代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">syms n</span><br><span class="line">f1 = n^<span class="built_in">sqrt</span>(n)</span><br><span class="line">f2 = <span class="number">2</span>^n</span><br><span class="line">f3 = n^<span class="number">10</span>*<span class="number">2</span>^(n/<span class="number">2</span>)</span><br><span class="line">f4 = (<span class="number">1</span>+n)*n/<span class="number">2</span>+n</span><br><span class="line"></span><br><span class="line">f1_f2 = f1/f2</span><br><span class="line">f1_f3 = f1/f3</span><br><span class="line">f1_f4 = f1/f4</span><br><span class="line">f2_f3 = f2/f3</span><br><span class="line">f2_f4 = f2/f4</span><br><span class="line">f3_f4 = f3/f4</span><br><span class="line">limit(f1_f2, n, inf)   #对f1/f2求极限，结果为0，即O(f1) &lt;= O(f2)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最终结果为：$\Theta(f_4)\le\Theta(f_1)\le\Theta(f_3)\le\Theta(f_2)$</p>
<h4 id="二：递归复杂度求解"><a href="#二：递归复杂度求解" class="headerlink" title="二：递归复杂度求解"></a>二：递归复杂度求解</h4><h5 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h5><p>已知：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(x,c) &= \Theta(x)\ \ \ \ \ \ \ \ \ \textrm{for}\ \ c\le2\\
T(c,y) &= \Theta(y)\ \ \ \ \ \ \ \ \ \textrm{for}\ \ c\le2\\
T(x,y) &=\Theta(x+y)+T(x/2,y/2)
\end{aligned}
\end{equation}</script><p>求$T(n,n)$的时间复杂度</p>
<h6 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h6><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(x,y)&=\Theta(x+y)+T(x/2,y/2)\\
&=\Theta(x+y)+\Theta(x/2+y/2)+T(x/4,y/4)\\
&=\Theta(x+y)+\Theta(x/2+y/2)+\Theta(x/4+y/4)+...\\
&=\Theta(2x+2y)
\end{aligned}
\end{equation}</script><p>故$T(n,n)=\Theta(n)$。</p>
<h5 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h5><p>已知：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(x,c) &= \Theta(x)\ \ \ \ \ \ \ \ \ \textrm{for}\ \ c\le2\\
T(c,y) &= \Theta(y)\ \ \ \ \ \ \ \ \ \textrm{for}\ \ c\le2\\
T(x,y) &=\Theta(x)+T(x,y/2)
\end{aligned}
\end{equation}</script><h6 id="解：-1"><a href="#解：-1" class="headerlink" title="解："></a>解：</h6><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(x,y)&=\Theta(x)+T(x,y/2)\\
&=\Theta(x)+\Theta(x)+T(x,y/4)\\
&=\underset{\log y个\Theta(x)}{\underbrace{\Theta(x)+\Theta(x)+...+\Theta(x)}}\\
&=\Theta(x\log y)
\end{aligned}
\end{equation}</script><p>故$T(n,n)=\Theta(n\log n)$。</p>
<h5 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h5><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(x,c) &= \Theta(x)\ \ \ \ \ \ \ \ \ \textrm{for}\ \ c\le2\\
T(x,y) &= \Theta(x)+S(x,y/2)\\
S(c,y) &= \Theta(y)\ \ \ \ \ \ \ \ \ \textrm{for}\ \ c\le2\\
S(x,y) &= \Theta(y)+T(x/2,y)
\end{aligned}
\end{equation}</script><h6 id="解-2"><a href="#解-2" class="headerlink" title="解"></a>解</h6><script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(x,y)&=\Theta(x)+\Theta(y/2)+T(x/2,y/2)\\
&=\Theta(x)+\Theta(y/2)+\Theta(x/2)+\Theta(y/4)+...\\
&\le\Theta(2x+y)
\end{aligned}
\end{equation}</script><p>故$T(n,n)=\Theta(n)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="向量峰值搜索代码"><a href="#向量峰值搜索代码" class="headerlink" title="向量峰值搜索代码"></a>向量峰值搜索代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>])     <span class="comment">//由于除法是向下取整，这意味着我们得到的mid都是左mid</span></span><br><span class="line">                                               <span class="comment">//因此mid+1一定是存在的</span></span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵峰值搜索代码"><a href="#矩阵峰值搜索代码" class="headerlink" title="矩阵峰值搜索代码"></a>矩阵峰值搜索代码</h3><h4 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>根据上面的分治法，我们可以写出如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">algorithm1</span><span class="params">(problem, trace = None)</span>:</span></span><br><span class="line">    <span class="comment"># if it's empty, we're done </span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># the recursive subproblem will involve half the number of columns</span></span><br><span class="line">    mid = problem.numCol // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># information about the two subproblems</span></span><br><span class="line">    (subStartR, subNumR) = (<span class="number">0</span>, problem.numRow)</span><br><span class="line">    (subStartC1, subNumC1) = (<span class="number">0</span>, mid)</span><br><span class="line">    (subStartC2, subNumC2) = (mid + <span class="number">1</span>, problem.numCol - (mid + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    subproblems = []</span><br><span class="line">    subproblems.append((subStartR, subStartC1, subNumR, subNumC1))   <span class="comment"># 子问题一：左侧部分</span></span><br><span class="line">    subproblems.append((subStartR, subStartC2, subNumR, subNumC2))   <span class="comment"># 子问题二：右侧部分</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">    divider = crossProduct(range(problem.numRow), [mid])   <span class="comment"># 利用笛卡尔积针对一列进行划分，得到该列元素所有坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># find the maximum in the dividing column</span></span><br><span class="line">    bestLoc = problem.getMaximum(divider, trace)           <span class="comment"># 获得该列的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># see if the maximum value we found on the dividing line has a better</span></span><br><span class="line">    <span class="comment"># neighbor (which cannot be on the dividing line, because we know that</span></span><br><span class="line">    <span class="comment"># this location is the best on the dividing line)</span></span><br><span class="line">    neighbor = problem.getBetterNeighbor(bestLoc, trace)   <span class="comment"># 找到更大的左右邻居</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is a peak, so return it                         左右邻居不存在，当前点即为峰值点</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == bestLoc:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(bestLoc)</span><br><span class="line">        <span class="keyword">return</span> bestLoc</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># otherwise, figure out which subproblem contains the neighbor, and</span></span><br><span class="line">    <span class="comment"># recurse in that half</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, neighbor)  <span class="comment"># 判断向左还是向右搜索</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm1(sub, trace)                         <span class="comment"># 解决子问题</span></span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br></pre></td></tr></table></figure>
<h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>为了证明算法总是能找到峰值，我们需要证明如下两条陈述：</p>
<ol>
<li><p>如果矩阵非空，那么算法1总能返回一个位置</p>
</li>
<li><p>如果算法1返回了一个位置，那么这个位置一定是峰值点</p>
</li>
</ol>
<p><strong>证明第一点：</strong></p>
<p>假设矩阵为$n\times n$，那么递归子问题的规模为$m \times\left \lfloor n/2 \right \rfloor$，所以递归子问题中列数随着递归过程是严格递减的。所以算法最终会返回一个点，或者最后进入一个列为0的子问题而不返回任何一个位置，故如果算法1存在不返回位置的情况，那么一定有子问题列数为0，下面我们证明这种情况不可能发生。如果算法确实处理了一个空的子问题，那么该问题的上一步子问题规模一定为$m\times 1$或者$m\times2$，下面分类讨论</p>
<p>(1) 如果为$m\times1$，那么计算中心列的最大值即为计算整个子数组的最大值，而子数组的最大值是一定存在的，所以一定会返回一个峰值点。</p>
<p>(2) 如果为$m\times2$，那么又存在两种情况，第一，中心列的最大值即为峰值点，那么会返回峰值的位置；第二，中心列的最大值不是峰值点，那么算法又会进一步递归，处理一个$m\times1$的子问题，一定会返回一个峰值点。</p>
<p>综上，算法一定会返回一个点。</p>
<p><strong>证明第二点：</strong></p>
<p>假设我们返回的点为$(r_1,c_1)$，那么该点一定是$c_1$列上最大的，如果该点不是峰值点，那么算法会以$(r_1,c_1)$为起点进入下一个递归中，同时，根据算法的规则，存在与$c_1$相邻的$c_2$（$|c1-c2|= 1$），满足$val(r_1,c_1) &lt; val(r_1,c_2)$，令$(r_2,c_2)$为$c_2$列上的最大值，有$val(r_1,c_2)\le val(r_2,c_2)$。因为算法执行到了包含$(r_1,c_1)$的一侧，所以一定有$val(r_2,c_2)&lt;val(r_2,c_1)$，所以</p>
<script type="math/tex; mode=display">
val(r_1,c_1)<val(r_1,c_2)\le val(r_2,c_2)<val(r_2,c_1)</script><p>但是$(r_1,c_1)$又是该列最大的，所以产生了矛盾，所以$(r_1,c_1)$一定是峰值点。</p>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>根据前面的结果，分治法的时间复杂度为$\Theta(n\log n)$</p>
<h4 id="方法二：贪心上升法"><a href="#方法二：贪心上升法" class="headerlink" title="方法二：贪心上升法"></a>方法二：贪心上升法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">algorithm2</span><span class="params">(problem, location = <span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span>, trace = None)</span>:</span></span><br><span class="line">    <span class="comment"># if it's empty, we're done </span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    nextLocation = problem.getBetterNeighbor(location, trace)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nextLocation == location:</span><br><span class="line">        <span class="comment"># there is no better neighbor, so return this peak</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(location)</span><br><span class="line">        <span class="keyword">return</span> location</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># there is a better neighbor, so move to the neighbor and recurse</span></span><br><span class="line">        <span class="keyword">return</span> algorithm2(problem, nextLocation, trace)</span><br></pre></td></tr></table></figure>
<p>方法二的逻辑很简单，一直找比当前节点更大的相邻节点，直到找不到为止。</p>
<h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><p>在贪心算法中，我们的搜索过程是单调递增的，由于数组的大小是有限的，那么数组中的数存在上界，我们一定能够找到一个位置，且该位置一定是一个峰值点。</p>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>设二维矩阵大小为$n\times n$，假设$a(i,j)$为当前搜索位置，那么下一个搜索位置$a_{next}$的完整递归定义为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
a_{next} = \left\{\begin{matrix}
a(i,j) & a(i,j)\ \textrm{is the peak}\\ 
\max(a(i-1,j),a(i+1,j),a(i,j-1),a(i,j+1)) & a(i,j)\ \textrm{is not the peak}
\end{matrix}\right.
\end{aligned}
\end{equation}</script><p>从递归中可知，最坏的情况下，需要遍历所有的网格，所以时间复杂度为$\Theta(n^2)$。</p>
<h4 id="方法三：改进的分治法（错误）"><a href="#方法三：改进的分治法（错误）" class="headerlink" title="方法三：改进的分治法（错误）"></a>方法三：改进的分治法（错误）</h4><p>在分治法中，我们将矩阵分为了左右两个部分，寻找极值点，那么我们能不能进一步分割呢？比如不再是二分割，而是将矩阵四分割，横纵坐标各切一刀，将矩阵分为四个部分，依次在四个部分中寻找极值点？代码如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">algorithm3</span><span class="params">(problem, bestSeen = None, trace = None)</span>:</span></span><br><span class="line">    <span class="comment"># if it's empty, we're done </span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    midRow = problem.numRow // <span class="number">2</span></span><br><span class="line">    midCol = problem.numCol // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># first, get the list of all subproblems</span></span><br><span class="line">    subproblems = []</span><br><span class="line"></span><br><span class="line">    (subStartR1, subNumR1) = (<span class="number">0</span>, midRow)</span><br><span class="line">    (subStartR2, subNumR2) = (midRow + <span class="number">1</span>, problem.numRow - (midRow + <span class="number">1</span>))</span><br><span class="line">    (subStartC1, subNumC1) = (<span class="number">0</span>, midCol)</span><br><span class="line">    (subStartC2, subNumC2) = (midCol + <span class="number">1</span>, problem.numCol - (midCol + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    subproblems.append((subStartR1, subStartC1, subNumR1, subNumC1))</span><br><span class="line">    subproblems.append((subStartR1, subStartC2, subNumR1, subNumC2))</span><br><span class="line">    subproblems.append((subStartR2, subStartC1, subNumR2, subNumC1))</span><br><span class="line">    subproblems.append((subStartR2, subStartC2, subNumR2, subNumC2))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find the best location on the cross (the middle row combined with the</span></span><br><span class="line">    <span class="comment"># middle column)</span></span><br><span class="line">    cross = []</span><br><span class="line"></span><br><span class="line">    cross.extend(crossProduct([midRow], range(problem.numCol)))</span><br><span class="line">    cross.extend(crossProduct(range(problem.numRow), [midCol]))</span><br><span class="line"></span><br><span class="line">    crossLoc = problem.getMaximum(cross, trace)</span><br><span class="line">    neighbor = problem.getBetterNeighbor(crossLoc, trace)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update the best we've seen so far based on this new maximum</span></span><br><span class="line">    <span class="keyword">if</span> bestSeen <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> problem.get(neighbor) &gt; problem.get(bestSeen):</span><br><span class="line">        bestSeen = neighbor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setBestSeen(bestSeen)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return if we can't see any better neighbors</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == crossLoc:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(crossLoc)</span><br><span class="line">        <span class="keyword">return</span> crossLoc</span><br><span class="line"></span><br><span class="line">    <span class="comment"># figure out which subproblem contains the largest number we've seen so</span></span><br><span class="line">    <span class="comment"># far, and recurse</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, bestSeen)</span><br><span class="line">    newBest = sub.getLocationInSelf(problem, bestSeen)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm3(sub, newBest, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br></pre></td></tr></table></figure>

</div></div>
<p>代码逻辑如下，每次在<code>midRow</code>和<code>midCol</code>中找到最大值，然后找到最大值的四邻域中的最大值，如果上下左右四格都比找到的最大值小，那么最大值即为峰值；如果存在临近的位置比找到的最大值大，那么就到该位置所在的子问题中寻找峰值点。通过将问题分为四个子问题，我们似乎能够递归地找到峰值点结果。但是很遗憾，这个代码是错误的，一个反例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">          [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">          [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">          [<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">          [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">          [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">          [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们先在中间行和列找到了最大值8，然后8的邻居中最大的是9，选择左上子矩阵作为子问题，中心十字最大值为1，而在这个子问题中，1是子矩阵的极值点，但并不是全局极值点。这个解法的根本问题在于，在解决子问题的过程中，子问题边界值的比较是不充分的，在上面的例子中，1是子问题的边界值，但是这个边界值并没有和2进行比较，所以比较不充分，找到了错误的解。</p>
<h3 id="方法四：另一个改进的分治法"><a href="#方法四：另一个改进的分治法" class="headerlink" title="方法四：另一个改进的分治法"></a>方法四：另一个改进的分治法</h3><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">algorithm4</span><span class="params">(problem, bestSeen = None, rowSplit = True, trace = None)</span>:</span></span><br><span class="line">    <span class="comment"># if it's empty, we're done </span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    subproblems = []</span><br><span class="line">    divider = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rowSplit:</span><br><span class="line">        <span class="comment"># the recursive subproblem will involve half the number of rows</span></span><br><span class="line">        mid = problem.numRow // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># information about the two subproblems</span></span><br><span class="line">        (subStartR1, subNumR1) = (<span class="number">0</span>, mid)</span><br><span class="line">        (subStartR2, subNumR2) = (mid + <span class="number">1</span>, problem.numRow - (mid + <span class="number">1</span>))</span><br><span class="line">        (subStartC, subNumC) = (<span class="number">0</span>, problem.numCol)</span><br><span class="line"></span><br><span class="line">        subproblems.append((subStartR1, subStartC, subNumR1, subNumC))</span><br><span class="line">        subproblems.append((subStartR2, subStartC, subNumR2, subNumC))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">        divider = crossProduct([mid], range(problem.numCol))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># the recursive subproblem will involve half the number of columns</span></span><br><span class="line">        mid = problem.numCol // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># information about the two subproblems</span></span><br><span class="line">        (subStartR, subNumR) = (<span class="number">0</span>, problem.numRow)</span><br><span class="line">        (subStartC1, subNumC1) = (<span class="number">0</span>, mid)</span><br><span class="line">        (subStartC2, subNumC2) = (mid + <span class="number">1</span>, problem.numCol - (mid + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        subproblems.append((subStartR, subStartC1, subNumR, subNumC1))</span><br><span class="line">        subproblems.append((subStartR, subStartC2, subNumR, subNumC2))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">        divider = crossProduct(range(problem.numRow), [mid])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find the maximum in the dividing row or column</span></span><br><span class="line">    bestLoc = problem.getMaximum(divider, trace)</span><br><span class="line">    neighbor = problem.getBetterNeighbor(bestLoc, trace)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update the best we've seen so far based on this new maximum</span></span><br><span class="line">    <span class="keyword">if</span> bestSeen <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> problem.get(neighbor) &gt; problem.get(bestSeen):</span><br><span class="line">        bestSeen = neighbor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setBestSeen(bestSeen)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return when we know we've found a peak</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == bestLoc <span class="keyword">and</span> problem.get(bestLoc) &gt;= problem.get(bestSeen):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(bestLoc)</span><br><span class="line">        <span class="keyword">return</span> bestLoc</span><br><span class="line"></span><br><span class="line">    <span class="comment"># figure out which subproblem contains the largest number we've seen so</span></span><br><span class="line">    <span class="comment"># far, and recurse, alternating between splitting on rows and splitting</span></span><br><span class="line">    <span class="comment"># on columns</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, bestSeen)</span><br><span class="line">    newBest = sub.getLocationInSelf(problem, bestSeen)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm4(sub, newBest, <span class="keyword">not</span> rowSplit, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br></pre></td></tr></table></figure>

</div></div>
<p>方法四在方法一的基础上添加了一个bestSeen变量，用于记录上一步操作中最大的值，下面我们对这个方法进行证明。证明过程参考方法一，也是分为两步，第一步证明如果矩阵不为空，那么返回值存在，第二步证明返回值一定是峰值。这里直接证明第二步。</p>
<p>假设我们的返回值为$(r_1,c_1)$，且该点不是峰值点，那么存在$(r_3,c_3)$与$(r_1,c_1)$相邻，且$val(r_3,c_3)&gt;val(r_1,c_1)$，又因为$(r_1,c_1)$为返回值，故存在$(r_2,c_2)\rightarrow (r_1,c_1)$的转换，且$val(r_2,c_2) &lt; val(r_1,c_1)$。但是我们的返回值是$(r_1,c_1)$，所以递归到$(r_3,c_3)$后，又会经过某个递归链从$(r_3,c_3)$到达$(r_2,c_2)$，所以$val(r_3,c_3)&lt;val(r_2,c_2)&lt;val(r_1,c_1)&lt;val(r_3,c_3)$，产生矛盾，故$(r_1,c_1)$一定是峰值点。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-1-algorithmic-thinking-peak-finding/">第一课视频</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps1.pdf">第一课作业</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT 6006 Lecture 2——计算模型，文本距离</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%AF%BE%E7%A8%8B/MIT6006-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>穹苍之上，一片寂寥，群星慢慢地闭上了眼睛。</p>
</blockquote>
<a id="more"></a>
<h2 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h2><h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><ul>
<li>算法是解决问题的计算步骤：通过对<strong>输入</strong>进行<strong>处理</strong>，得到<strong>输出</strong>。</li>
<li>算法是对于程序的数学化分析</li>
</ul>
<p>下面我们构造一个实际程序和算法的对应模型：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/20209201547.JPG?raw=true" width = "370" alt="" align=center /></p>
<h3 id="什么是计算模型"><a href="#什么是计算模型" class="headerlink" title="什么是计算模型"></a>什么是计算模型</h3><p>计算模型决定以下两点：</p>
<ul>
<li>算法能执行哪些操作</li>
<li>每一个操作的代价（时间、空间）是怎样的，这里我们重点关注时间</li>
</ul>
<h3 id="不同的计算模型"><a href="#不同的计算模型" class="headerlink" title="不同的计算模型"></a>不同的计算模型</h3><h4 id="随机存取机（Random-access-machine-RAM）"><a href="#随机存取机（Random-access-machine-RAM）" class="headerlink" title="随机存取机（Random access machine, RAM）"></a>随机存取机（Random access machine, RAM）</h4><p>记得和随机存储器进行区分，这里的随机存储机是一种计算模型，它有如下特点：</p>
<ul>
<li>$\Theta(1)$的寄存器读取和写入一个word</li>
<li>可以进行$\Theta(1)$时间的计算</li>
</ul>
<p>RAM的可视化表示如下图所示：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/20209221724.JPG?raw=true" width = "200" alt="" align=center /></p>
<p>那么这里的word是什么呢？是64位还是32位？这里其实是一个抽象的大小，我们令其为$w$ size，其中$w\ge \lg(\mathrm{memory\ size})$，确保可以在内存空间中确定其位置。我们这里不考虑大数问题，即word长度很长的问题。我们常用的vector就是一个随机存取机下的模型。</p>
<h4 id="指针机（pointer-machine）"><a href="#指针机（pointer-machine）" class="headerlink" title="指针机（pointer machine）"></a>指针机（pointer machine）</h4><ul>
<li>动态分配对象</li>
<li>对象拥有$\Theta(1)$的区域（字段）</li>
<li>一个区域（字段）可以为：<ul>
<li>一个word（例如一个<code>int</code>）</li>
<li>一个指向另一个对象的或者为空的指针</li>
</ul>
</li>
</ul>
<p>我们常用的list就是一个指针机下的一个模型，当然，也可以用RAM实现一个list，此时list的指针就成了内存中的某个位置的索引，指向下一个节点。Pointer机的示意图如下：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/20209221726.JPG?raw=true" width = "150" alt="" align=center /></p>
<h4 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h4><p>python下RAM的数据结构为list，一些操作的时间复杂度如下：</p>
<ul>
<li>append：$\Theta(1)$时间复杂度</li>
<li>连接字符串：$\Theta(l_1)+\Theta(l_2)=\Theta(l_1+l_2)$</li>
<li>查找：$\Theta(n)$</li>
<li>排序：$\Theta(n\lg n)$</li>
</ul>
<p>python下的大数为long，假设两个操作数长度为$x$和$y$，一些操作的时间复杂度如下：</p>
<ul>
<li>$x+y$：$\Theta(x+y)$</li>
<li>$x\times y$：$\Theta(x+y)^{\lg 3}$</li>
</ul>
<h2 id="文本距离问题"><a href="#文本距离问题" class="headerlink" title="文本距离问题"></a>文本距离问题</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>文本距离问题定义为，给定两个文本$D_1$和$D_2$，求两个文本之间的距离$d(D_1,D_2)$或者说相似度。这个很常用，例如搜索引擎，或者文本查重等。其中文本的定义即为一个单词（word）序列，而一个单词即若干字母的组合（<code>char</code>）。</p>
<h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><h4 id="方法一：使用内积定义相似度"><a href="#方法一：使用内积定义相似度" class="headerlink" title="方法一：使用内积定义相似度"></a>方法一：使用内积定义相似度</h4><p>一个简单的思路是考虑相同的words在两个文本中出现的次数，令$D[w]$为单词$w$在$D$中出现的次数，$D[w]$为非负整数。给定$D_1,D_2$如下：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
D_1&=\textrm{"the cat"}\\
D_2&=\textrm{"the dog"}
\end{aligned}
\end{equation}</script><p>那么可以画出如下坐标系</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/20209201640.JPG?raw=true" width = "370" alt="" align=center /></p>
<p>实际上，我们可以将一个文本$D$视为单词空间中的一个向量，单词空间中每一个单词即为一个空间中一个维度，那么我们计算两个向量的距离实际上就是求内积的过程，当两个文本完全相同，其内积达到最大，说明相似度最高：</p>
<script type="math/tex; mode=display">
d(D_1,D_2)=D_1\cdot D_2=\sum_{w}^{}D_1[w]D_2[w]</script><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>这个问题的缺陷在于，这个距离并不能实质性反映出文本间差异的大小，例如我有两个文本，都是百万量级的长度，其中有百分之50的单词相同，那么两个文本间的内积可能非常大；而另外两个文本长度为100，且长度均相同，但是内积反而没有前面的文本大。但实际上第二种情况的文本相似程度应当比第一个大。</p>
<h4 id="方法二：使用向量夹角定义内积相似度"><a href="#方法二：使用向量夹角定义内积相似度" class="headerlink" title="方法二：使用向量夹角定义内积相似度"></a>方法二：使用向量夹角定义内积相似度</h4><p>我们对方法一进行改进，使用两个文本向量的夹角定义相似度，那么得到的距离为：</p>
<script type="math/tex; mode=display">
d(D_1,D_2)=\arccos{\frac{D_1\cdot D_2}{|D_1||D_2|}}</script><p>如果夹角为0，那么很相似；如果夹角为180，说明根本不相似。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>我们根据方法二，写一下文本距离的算法：</p>
<ol>
<li>将文本分割为独立的单词：线性时间</li>
<li>计算单词频率：线性时间</li>
<li>进行内积，求夹角</li>
</ol>
<p>课程中提供了8种算法，针对一个大型的文本，其处理时间分别为：</p>
<ol>
<li>228.1秒</li>
<li>164.7秒</li>
<li>123.1秒</li>
<li>71.7秒</li>
<li>18.3秒</li>
<li>11.5秒</li>
<li>1.8秒</li>
<li>0.2秒</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-2-models-of-computation-document-distance/">第二课视频</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps1.pdf">第二课作业</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT 6006 Lecture 3——插入排序，归并排序</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%AF%BE%E7%A8%8B/MIT6006-3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我们依赖秩序，而反感混乱</p>
</blockquote>
<a id="more"></a>
<h2 id="为什么要排序"><a href="#为什么要排序" class="headerlink" title="为什么要排序"></a>为什么要排序</h2><p>有许多直接的应用需要我们进行排序，例如按照人名首字母的顺序对班上的人进行排序；字典的索引需要排序等。此外许多问题通过排序可以得到化简，例如寻找中位数的问题、文件压缩以及视频渲染等。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理及算法"><a href="#原理及算法" class="headerlink" title="原理及算法"></a>原理及算法</h3><p>插入排序的算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For i = 1,2,3,...,n</span><br><span class="line">    insert A[i] into sorted array A[0:i-1] by pair swaps down to the correct position</span><br></pre></td></tr></table></figure>
<p>算法的可视化过程如下所示：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/InsertSort.gif?raw=true" width = "370" alt="" align=center /></p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>这个算法可以分为：</p>
<ul>
<li>移动key：一共移动了$n$步，复杂度为$\Theta(n)$</li>
<li>交换相邻元素：每一步最大可能比较并交换$n$次，复杂度为$\Theta(n)$</li>
</ul>
<p><strong>由于底层操作的缘由，比较操作相对于交换来说，更加耗时</strong>，所以一个改进就是降低比较的次数，我们可以对已经比较好的部分$A[0:i-1]$进行二分查找，从而将比较操作的时间复杂度降低为$\Theta(\log i)$，不过由于需要整体移动，所以总时间复杂度还是没有变化，只是比较次数变少了。改进后的时间复杂度为：</p>
<ul>
<li>$\Theta(n\log n)$次比较</li>
<li>$\Theta(n^2)$次交换</li>
</ul>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>插入排序的空间复杂度为$\Theta(1)$，不需要额外的空间</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>归并排序的思想是先将长度为$n$的大数组$A$转换为长度为$n/2$的小数组$L$和$R$，然后分别对其进行排序，之后再将数组进行合并，最后得到排序后的数组$A’$</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/MergeSort.gif?raw=true" width = "170" alt="" align=center /></p>
<p>所谓归并，就是将两个排序好的数组作为输入。下面结合具体例子对归并过程进行讲解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个已经排序的数组l&apos;和R’，两个指针分别指向L&apos;和R&apos;的最小元素位置，每次选择两个数组中最小的数，然后移动指针</span><br><span class="line">L&apos;      R&apos;          L&apos;       R&apos;</span><br><span class="line">----------          -----------</span><br><span class="line">20      12   ---&gt;   20       12</span><br><span class="line">13      11          13       11</span><br><span class="line"> 7       9           7        9&lt;-p2</span><br><span class="line"> 2&lt;-p1   1&lt;-p2       2&lt;-p1    1</span><br><span class="line"></span><br><span class="line">最后合并的结果为：1 2 7 9 11 12 13 20</span><br></pre></td></tr></table></figure>
<p>归并的复杂度为$\Theta(n)$。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>根据归并排序的原理，我们可以写出归并排序的时间复杂度为：</p>
<script type="math/tex; mode=display">
T(n) = C_1+2T(n/2)+C\cdot n</script><p>其中$C_1$为分割数组的时间复杂度，$C\cdot n$为归并数组的复杂度，$C$和$C_1$是一个常数，$T(n/2)$为递归过程时间复杂度。下面我们构造一个二叉树对这个过程进行分析：</p>
<pre class="mermaid">graph TB
    node((Cn))
    node1((Cn/2))
    node2((Cn/2))
    node --> node1
    node --> node2
    node3((Cn/4))
    node4((Cn/4))
    node5((Cn/4))
    node6((Cn/4))

    node1-->node3
    node1-->node4
    node2-->node5
    node2-->node6</pre>

<p>这个递归树有$n$个树叶，每一层和都为$C\cdot n$，叶子节点值都为$C$，这个满二叉树层数为$1+\log n$，故</p>
<script type="math/tex; mode=display">
T(n) = (1+\log n)\times C\cdot n=\Theta(n\lg n)</script><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度为$\Theta(n)$，因为需要有拆分数组的过程，为了改进这个算法，人们提出了原地归并排序算法</p>
<h4 id="两种排序方法的比较"><a href="#两种排序方法的比较" class="headerlink" title="两种排序方法的比较"></a>两种排序方法的比较</h4><p>归并排序相对于插入排序更快，但是需要额外的空间以及拷贝动作。在python中，归并排序时间为$(2.2n\lg n)\mu s$，而插入排序时间为$0.2n^2$</p>
<h2 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h2><p>本节一个重要的点就是复杂度的计算，仿照归并排序的复杂度分析过程，我们这里给出一道例题：</p>
<blockquote>
<p>求$T(n)=2T(n/2)+C\cdot n$的时间复杂度</p>
</blockquote>
<p>构造二叉树如下：</p>
<pre class="mermaid">graph TB
    node((Cn^2))
    node1((Cn^2/4))
    node2((Cn^2/4))
    node --> node1
    node --> node2
    node3((Cn^2/8))
    node4((Cn^2/8))
    node5((Cn^2/8))
    node6((Cn^2/8))

    node1-->node3
    node1-->node4
    node2-->node5
    node2-->node6</pre>



<p>树深度为$\lg n+1$，最后一层叶子节点数为$n$，值为$C$，故总时间复杂度为：</p>
<script type="math/tex; mode=display">
T(n)=Cn^2+Cn^2/2+Cn^2/4+\cdots+Cn\le2Cn^2</script><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="分形渲染"><a href="#分形渲染" class="headerlink" title="分形渲染"></a>分形渲染</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>我们首先来直观了解一下分形问题：</p>
<p>    
    <div style="width:100%; height:640px;border:none;text-align:center">        
        <iframe allowtransparency="yes" frameborder="0" width="600" height="640" src="/webs/fractal/fractal.html"/>   
    </div>
</p>


<p>上面这个分型就是经典的$Koch$雪花，一开始有一个初始三角形，然后三角形的边上会长出新的三角形，由于CPU和GPU精度限制，分形的过程是有限的，令$n$为分形的深度（或者细节，Level of detail, LoD），我们规定：当$n=0$时，为初始三角形。分形的算法可以由如下伪代码表示：</p>
<blockquote>
<p>${\rm S{\small NOW}{\small FLAKE}}(n)$</p>
<p>​    $e_1,e_2,e_3=\textrm{edges of an equilateral triangle with side length 1}$</p>
<p>​    ${\rm S{\small NOW}{\small FLAKE}}-{\rm E{\small DGE}}(e_1,n)$</p>
<p>​    ${\rm S{\small NOW}{\small FLAKE}}-{\rm E{\small DGE}}(e_2,n)$</p>
<p>​    ${\rm S{\small NOW}{\small FLAKE}}-{\rm E{\small DGE}}(e_3,n)$</p>
<p>${\rm S{\small NOW}{\small FLAKE}}-{\rm E{\small DGE}}(e,n)$</p>
<p>​    $\mathbf{if}\ n==0$</p>
<p>​        $e\ \textrm{is an edge on the snowflake}$ </p>
<p>​    $\mathbf{else}$</p>
<p>​        $e_1,e_2,e_3=\textrm{split edge in 3 equal parts}$</p>
<p>​        ${\rm S{\small NOW}{\small FLAKE}}-{\rm E{\small DGE}}(e_1,n-1)$</p>
<p>​        $f_2,g_2=\textrm{edges of an equilateral triangle whose 3rd edge is }e_2$</p>
<p>​        $\textrm{pointing outside the snowflake }\Delta(f_2,g_2,e_2)\textrm{ is a triangle on the snowflake’s surface}$</p>
<p>​        ${\rm S{\small NOW}{\small FLAKE}}-{\rm E{\small DGE}}(f_2,n-1)$</p>
<p>​        ${\rm S{\small NOW}{\small FLAKE}}-{\rm E{\small DGE}}(g_2,n-1)$</p>
<p>​        ${\rm S{\small NOW}{\small FLAKE}}-{\rm E{\small DGE}}(e_3,n-1)$</p>
</blockquote>
<p>这里我们提供了四种方法实现SnowflakeEdge，我们需要判定这些方法的时间复杂度。在${\rm S{\small NOW}{\small FLAKE}}(n)$函数中，我们实际上是构建了三棵树，构成了一个森林，但我们出于统一的考虑，将这个森林视作一个树。</p>
<h4 id="第一组"><a href="#第一组" class="headerlink" title="第一组"></a>第一组</h4><p><strong>1)</strong> 根据上面的SnowflakeEdge算法，渲染一个深度为$n$的雪花，其迭代树深度为多少？</p>
<p>上面的算法时间复杂度可以写为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(n)&=4T(n-1)+\Theta(1)\\
T(0)&=\Theta(1)
\end{aligned}
\end{equation}</script><p>绘制其递归树，得到一个深度为$n$的四叉树，层数为$n+1$。</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/20209231645.JPG?raw=true" width = "570" alt="" align=center /></p>
<p><strong>2)</strong> 求第$i$层（$0\le i\le n$）节点数$f(i)$</p>
<p>我们先考虑一棵树，再推广到整个森林：第$i$层有$4^i$个节点，我们采用数学归纳法进行证明：当$i=0$时，有一个节点，显然成立；假设算法在第$j$层（$0\le j&lt; i$）均成立，那么第$j$层有$4^j$个节点，当$j=i-1$时，该层有$4^{i-1}$个节点，现证明当$j=i$时算法依然成立，根据递归过程可知，该递归树每个节点度为4，那么下一层节点数为当前层的4倍，则第$i$层节点数$f(i)=4f(i-1)=4\times 4^{i-1}=4^{i}$。</p>
<p>由于森林中有三棵相同的树，所以最终第$i$层节点数为$3\cdot4^i$。</p>
<p><strong>3)</strong> 在递归树的第$i$层，渲染一个节点的时间复杂度是多少？其中$0\le i&lt;n$。</p>
<p>根据算法的时间复杂度：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
T(n)&=4T(n-1)+\Theta(1)\\
&=4(4T(n-2)+\Theta(1))+\Theta(1)\\
&=\cdots\\
&=4^{i+1}T(n-i-1)+4^{i}\Theta(1)
\end{aligned}
\end{equation}</script><p>对于一颗递归树，渲染第$i$层的时间复杂度为$\Theta(4^{i})$。而第$i$层节点数为$4^i$，故渲染第$i$层一个节点的时间复杂度为$\Theta(1)$。</p>
<p><strong>4)</strong> 求第$i$层的时间复杂度</p>
<p>根据<strong>2)</strong>和<strong>3)</strong>可知时间复杂度为$\Theta(4^i)$。</p>
<p><strong>5) </strong>求总时间复杂度</p>
<p>因为递归树第$i$层时间复杂度为$\Theta(4^i)$，故总时间复杂度$T(n)=\Theta(4^0)+\Theta(4^1)+\cdots+\Theta(4^n)$，根据极限定理可知，总时间复杂度$T(n)$满足$\Theta(4^n)\le T(n)\le \Theta(4^{n+1})$。所以时间复杂度为$T(n)=\Theta(4^n)$。</p>
<h4 id="第二组"><a href="#第二组" class="headerlink" title="第二组"></a>第二组</h4><p>为了提高分形效率，我们采用GPU对程序进行加速，将雪花图案视为一个闭合的直线路径，通过CPU计算路径的端点，最后将深度为$n$的路径点交给GPU进行渲染。当$n=0$时，需要绘制三条边，当LoD增加后，每增加一层，那么原先的每一条边会被更新为4条边。请回答如下问题：</p>
<p><strong>1)</strong> 根据硬件加速的SnowflakeEdge算法，渲染一个深度为$n$的雪花，其迭代树深度为多少？</p>
<p>硬件加速的时间复杂度为：</p>
<script type="math/tex; mode=display">
\begin{equation}\begin{aligned}T(n)&=4T(n-1)+\Theta(1)\\T(0)&=\Theta(1)\end{aligned}\end{equation}</script><p>同样也是一个四叉树，深度为$n$。第$i$层节点数为$3\cdot4^i$，这里一个节点代表构造一条边，</p>
<p><strong>2)</strong> 渲染第$i$层一个节点的时间复杂度为？</p>
<p>当$0\le i&lt;n$时，只构造边但是不渲染，故时间复杂度为0，而当$i=n$时，进行一次渲染，渲染一条边的时间复杂度为$\Theta(1)$.</p>
<p><strong>3)</strong> 渲染第$i$层的所有节点时间复杂度为？</p>
<p>由于中间层不进行渲染，因此时间复杂度为0，最后一层渲染时时间复杂度为$\Theta(4^n)$，总的时间复杂度为$\Theta(4^n)$。</p>
<p>所以硬件加速省略了中间的渲染过程，最后待分形图案的点完成后，统一进行渲染，节约了渲染时间，但是构造分形的复杂度没有降低。</p>
<h4 id="第三组"><a href="#第三组" class="headerlink" title="第三组"></a>第三组</h4><p>继续改进算法，我们依旧将雪花图案保存为闭合直线路径，但是我们不使用硬件加速，而是根据起点和端点，对线条进行绘制，绘制时间是线性的，即如果线长为1，那么绘制时间为1，如果线长为$1/3$，相应地绘制时间也会变为原来的三分之一。渲染依旧是在最后一步进行，回答下面的问题：</p>
<p><strong>1)</strong> 求Lod为$n$时树的深度以及第$i$层的节点数</p>
<p>这个树是一个四叉树，高度为$n$，第$i$层节点数为$3\times4^i$。</p>
<p><strong>2)</strong> 渲染第$i$层的一个节点时间为？</p>
<p>第$i$层不渲染，所以时间为0</p>
<p><strong>3) </strong>渲染第$n$层的一个节点和所有节点时间为？</p>
<p>第$n$层节点数为$3\times4^n$，而渲染一个节点（即一条边）的过程和边长有关，第$n$层边长为$(1/3)^n$，所以渲染一个节点的时间为$(1/3)^n$，那么总的时间复杂度为$(\frac{4}{3})^n$。</p>
<p><strong>4) </strong>总渲染时间为？</p>
<p>虽然每一层不用渲染了，但是依然需要做保存端点的操作，因此每一层每个节点时间复杂度为$\Theta(1)$，最后一层渲染的总时间复杂度为$(\frac{4}{3})^n$。所以总时间为：</p>
<script type="math/tex; mode=display">
T(n)=\sum_{i=0}^{n-1}4^i+(\frac{4}{3})^n</script><p>占主要部分的是前半部分，所以时间复杂度为$\Theta(4^n)$，不过如果只看渲染时间，那么就是$(\frac{4}{3})^n$。</p>
<h4 id="第四组"><a href="#第四组" class="headerlink" title="第四组"></a>第四组</h4><p>不使用硬件加速渲染3d的雪花图，CPU保存一系列的三角形，渲染时间和三角形面积成正比。如果边长为1，那么面积为$\sqrt{3}/4$；如果边长为1/2，那么面积为$\sqrt{3}/16$。是指数关系。首先，不变的是树的高度和每层节点数，由于最后渲染，所以第$i$层（$0\le i&lt;n$）的渲染时间为0，最后一层节点数为$3\times 4^n$，第$n$层边长为$(1/3)^n$，出于简单考虑，令面积为$(1/3)^{2n}$，所以总时间为$(\frac{4}{9})^n$，即$\Theta(1)$。</p>
<h5 id="更正"><a href="#更正" class="headerlink" title="更正"></a>更正</h5><p>这里有一个理解错误，渲染形状和渲染线段是不一样的，渲染形状不能只看最后一层的顶点和线段，要将每一层三角形的形状都考虑进来，因此每一层都要考虑，第$i$层边长为$(1/3)^{i+1}$，面积为$(1/9)^{i+1}$，所以每一层的渲染时间为$3\times 4^i\times (1/9)^{i+1}$，总时间为：</p>
<script type="math/tex; mode=display">
T(n)=\sum_{i=0}^{n}3\cdot\frac{1}{9}\cdot (\frac{4}{9})^i=\Theta(1)</script><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><iframe src="https://www.youtube.com/v/Kg4bqzAqRBM" height=325 width=545 frameborder=0></iframe>

<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-3-insertion-sort-merge-sort">第三课视频</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps2_sol.pdf">第三课作业</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT 6006 Lecture 4——堆与堆排序</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%AF%BE%E7%A8%8B/MIT6006-4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>堆：一种特殊的完全二叉树，其中父节点恒小于等于（大于等于）子节点的值，此堆称为小顶堆（大顶堆）。</p>
</blockquote>
<a id="more"></a>
<h2 id="优先队列（Priority-Queue）"><a href="#优先队列（Priority-Queue）" class="headerlink" title="优先队列（Priority Queue）"></a>优先队列（Priority Queue）</h2><p>堆的一个很重要的应用就是作为优先队列的数据结构，所以本节我们以优先队列为引子，看一看堆的一些特性和使用方法。</p>
<h3 id="优先队列的定义及基本操作"><a href="#优先队列的定义及基本操作" class="headerlink" title="优先队列的定义及基本操作"></a>优先队列的定义及基本操作</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>给定一个集合$S$，集合中的每一个元素都与一个索引键值key对应，其中每个元素都有一个优先级，在优先队列中，我们希望能够快速找到最高优先级的对象。</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>这里我们定义一些基本操作：</p>
<ul>
<li>$\textrm{insert}(S,x)$：将$x$插入$S$中</li>
<li>$\max(S)$：返回$S$中key最大的元素</li>
<li>$\textrm{extract_max}(S)$：返回key最大的元素并将其移除</li>
<li>$\textrm{increase_key}(S,x,k)$：将$x$的key的优先级更新为$k$</li>
</ul>
<h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>堆是一个完全二叉树，我们可以用数组对其进行表示，一个示意图如下，注意数组下标是从1开始的，这样比较好记：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/e0935e68daece9ece9fe078e9ad65a80338fa2ba/20201091609.svg" width = "570" alt="" align=center /></p>
<h3 id="将树堆化"><a href="#将树堆化" class="headerlink" title="将树堆化"></a>将树堆化</h3><ul>
<li>root：第一个元素(i=1)</li>
<li>父节点：i/2的节点</li>
<li>左子节点：2i</li>
<li>右子节点：2i+1</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/7da9f289ce229391f5cc595870006b8fb3e1daa4/202010162212.svg" width = "570" alt="" align=center /></p>
<h3 id="大（小）顶堆"><a href="#大（小）顶堆" class="headerlink" title="大（小）顶堆"></a>大（小）顶堆</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>父节点的值比子节点大（小），所以寻找最大元素是很方便的，只要返回堆顶元素即可。</p>
<h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><h4 id="建大顶堆"><a href="#建大顶堆" class="headerlink" title="建大顶堆"></a>建大顶堆</h4><h5 id="大顶堆化"><a href="#大顶堆化" class="headerlink" title="大顶堆化"></a>大顶堆化</h5><p>将一个无序的数组转换成为一个大顶堆，为了实现这个过程，我们需要将数组“大顶堆化”：将一个不是大顶堆的树，通过某种变换，转换为一个大顶堆树，我们通过自下而上的递归方式进行（因为叶子节点一定是大顶堆），令大顶堆化的操作为$\textrm{max_heapify}(A,i)$，即对数组$A$在节点$i$处执行大顶堆化操作，同时，我们假设$i$的左子节点和右子节点已经完成了大顶堆化的操作，其左右子树为大顶堆。现在，我们以一个实例来看一看大顶堆化的具体过程。</p>
<p>下图展示了一个堆，注意到在值为4的节点处出现了冲突，所以这个堆不是一个大顶堆，我们要在值为4的节点处执行$\textrm{max_heapify}$操作，根据我们上面的约定，4的节点编号为2，故我们需要执行$\textrm{max_heapify}(A,2)$。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/902d959e22cf3f027c292cc00fba57ceefa41794/202010162232.svg" width = "570" alt="" align=center /></p>
<blockquote>
<p>$\textrm{MAX_HEAPIFY}(A,2)$</p>
<p>​    $\textrm{heap_size}(A)=10$</p>
<p>​    $\textrm{exchange with bigger child: swap(A[2], A[4])}$</p>
<p>​    $\textrm{call MAX_HEAPIFY}(A,4)$</p>
</blockquote>
<p>下面分析一下时间复杂度，首先树是一个几乎完全二叉树，以及根据限制，左子树和右子树已经是大顶堆，所以这个时间复杂度被限制在$\log(n)$。</p>
<h5 id="根据max-heapify创建堆"><a href="#根据max-heapify创建堆" class="headerlink" title="根据max_heapify创建堆"></a>根据max_heapify创建堆</h5><p>下面我们利用上面的算法，将$A[1…n]$转换为一个大顶堆，我们的算法名称为build_max_heap，其逻辑如下：</p>
<blockquote>
<p>$\textrm{build_max_heap}(A)$:</p>
<p>​    $\textrm{for  }\ i=n/2\ \ \textrm{ downto  }\ 1$</p>
<p>​        $\textrm{max_heapify}(A,i)$:</p>
</blockquote>
<p>为什么从$n/2$开始呢？因为$A[n/2+1,…,n]$全部都是叶子节点，而叶子节点已经是大顶堆了，所以自然满足假设，而从$n/2$到$1$，实际上是一个自底向上的过程。</p>
<p>从直观上来看，这个操作的时间复杂度为$O(n\log(n))$，但是实际上这个时间复杂度要更低一些。当节点$i$比叶子节点高一层时，max_heapify需要1次操作，时间复杂度为$\Theta(1)$；而当节点$i$比叶子节点高$l$层时，max_heapify需要$l$次操作，时间复杂度为$\Theta(l)$。我们令叶子层为第0层，那么第一层有$n/4$个节点，需要1次操作，第2层有$n/8$个节点，需要两次操作，第$\log(n)$层有1个节点，需要$\log(n)$次操作，所以时间复杂度为：</p>
<script type="math/tex; mode=display">
\Theta = \frac{n}{4}+\frac{n}{8}\times2+\frac{n}{16}\times3+...+\log(n)</script><p>令$n/4=2^k$，并提取公因式，那么上式可以写为</p>
<script type="math/tex; mode=display">
\Theta = 2^k(\frac{1}{2^0}+\frac{2}{2^1}+...+\frac{k+1}{2^k})=\sum_{i=0}^{k}\frac{i+1}{2^i}</script><p>后面的级数是一个收敛级数，所以实际上我们的时间复杂度为$\Theta(n)$</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>利用堆的特性，我们可以进行排序操作。</p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="数字电路仿真"><a href="#数字电路仿真" class="headerlink" title="数字电路仿真"></a>数字电路仿真</h3><h4 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h4><p>组合逻辑电路是由门构成的，门以逻辑电平（真/1，假/0）作为输入信号，输出信号是输入信号的函数，逻辑门的计算是需要时间的，假设延迟时间为$\delta$，那么在$\tau$时刻的输出信号对应$\tau-\delta$时刻的输入信号。门的输出信号也是逻辑电平，可以通过电路与其他门相连，将输出信号作为下一个门的输入信号，例如，一个两输入、延迟时间为2ns的异或门的真值表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Time(ns)</th>
<th style="text-align:center">Input A</th>
<th style="text-align:center">Input B</th>
<th style="text-align:center">Output O</th>
<th style="text-align:center">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center">Inputs at time -2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">Inputs at time -1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0 XOR 0，在第0时刻输出</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0 XOR 1，在第1时刻输出</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1 XOR 0，在第2时刻输出</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1 XOR 1，在第3时刻输出</td>
</tr>
</tbody>
</table>
</div>
<p>电路模拟器通过一个输入文件描述电路的布局，包括门延迟时间、待监测的门以及输入信号。随后以时间序列的方式对整个电路的信号变换过程进行仿真并输出结果，同时也会输出待监测的门的信号变换情况。现在，给定一个仿真代码，然后你需要对代码进行测试，找到性能瓶颈及产生原因，并对性能瓶颈进行优化，<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/ps2.zip">点击此处下载代码</a>。解压缩后进入<code>circuit/</code>文件夹，电路仿真文件为<code>circuit.py</code>，输入文件为<code>tests/5devadas13.in</code>，但是对这个文件的仿真时间过长。我们提供了测试文件，测试文件为<code>test-circuit.py</code>。</p>
<h4 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h4><p>在python的代码性能分析器下运行仿真程序，找到最耗时的函数，请在cmd命令行下运行下面这行代码，并根据结果分析哪个函数运行时间最长，如果有多个函数执行时间相同，忽略简单的那个。注意，请不要使用powershell运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m cProfile -s time circuit.py &lt; tests/5devadas13.in</span><br></pre></td></tr></table></figure>
<p>执行完上面这行命令大概需要一两分钟。运行完成后，我们得到的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Ordered by: internal time</span><br><span class="line"></span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">625762426  102.299    0.000  102.299    0.000 circuit.py:286(__lt__)</span><br><span class="line">   259964  102.299    0.000  204.606    0.001 circuit.py:381(_find_min)</span><br><span class="line">    32768    4.087    0.000    4.087    0.000 &#123;method &apos;write&apos; of &apos;_io.TextIOWrapper&apos; objects&#125;</span><br><span class="line">    64400    0.591    0.000  206.397    0.003 circuit.py:423(step)</span><br><span class="line">828801/634389    0.229    0.000    0.286    0.000 &#123;built-in method builtins.len&#125;</span><br><span class="line">   194381    0.177    0.000  204.791    0.001 circuit.py:361(min)</span><br><span class="line">    65554    0.144    0.000    0.309    0.000 circuit.py:163(transition_output)</span><br><span class="line">    65583    0.119    0.000    0.176    0.000 circuit.py:268(__init__)</span><br><span class="line">        1    0.112    0.112  206.614  206.614 circuit.py:456(run)</span><br><span class="line">    65583    0.089    0.000    0.163    0.000 circuit.py:368(pop)</span><br><span class="line">    65554    0.063    0.000    0.079    0.000 circuit.py:33(output)</span><br></pre></td></tr></table></figure>
<p>可以看出，忽略掉<code>__lt__</code>函数，那么性能的瓶颈为<code>_find_min</code>函数，一共被调用了255964次。</p>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><p>阅读<code>_find_min</code>的源代码，并指出<code>_find_min</code>实际是在执行哪种数据结构，假设一共有$n$个元素，时间复杂度是多少？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_min</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># Computes the index of the minimum element in the queue.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># This method may crash if called when the queue is empty.</span></span><br><span class="line">    <span class="keyword">if</span> self.min_index <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    min = self.queue[<span class="number">0</span>]</span><br><span class="line">    self.min_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(self.queue)):</span><br><span class="line">        key = self.queue[i]</span><br><span class="line">        <span class="keyword">if</span> key &lt; min:</span><br><span class="line">            min = key</span><br><span class="line">            self.min_index = i</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们可以看出，<code>_find_min</code>实际上是在一个数组中顺序查找最小的元素，即<strong>基于数组的优先队列</strong>。在最坏的情况下，需要遍历所有的$n$个元素，所以时间复杂度为$\Theta(n)$。</p>
<h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><p>如果使用最高效的数据结构，那么请问在$n$个元素的情况下其渐近紧范围（asymptotically tight bound）是多少？</p>
<h2 id="Heap-实现"><a href="#Heap-实现" class="headerlink" title="Heap 实现"></a>Heap 实现</h2><p>这里参考STL库实现一个heap操作，由于STL库模板有一些额外的函数支持，所以这里的容器简单地选为<code>vector&lt;int&gt;</code>，算法分别实现<code>push_heap</code>、<code>pop_heap</code>、<code>sort_heap</code>和<code>make_heap</code>四个操作。</p>
<h3 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h3><p>对于push_heap操作，我们先将元素插入底层的vector的end()位置，然后将该节点与父节点进行比较交换操作并重复这个上溯过程，最后将节点放置到正确的位置上。我们的函数接受两个迭代器，用来表示heap底部容器的头尾，需要注意的是头尾迭代器表示的范围是左闭右开的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator VectorIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __push_heap(VectorIterator first, <span class="keyword">int</span> holeIndex, <span class="keyword">int</span> topIndex, <span class="keyword">int</span> value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应当注意的是，当调用push_heap时，新元素应当已经位于底层容器的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(VectorIterator first, VectorIterator last)</span></span>&#123;</span><br><span class="line">    __push_heap(first, (last-first)<span class="number">-1</span>, <span class="number">0</span>, *(last<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __push_heap(VectorIterator first, <span class="keyword">int</span> holeIndex, <span class="keyword">int</span> topIndex, <span class="keyword">int</span> value)&#123;</span><br><span class="line">    <span class="comment">// first: 绝对坐标下容器的起始值</span></span><br><span class="line">    <span class="comment">// holeIndex: 相对坐标下容器的末位位置</span></span><br><span class="line">    <span class="comment">// topIndex: 相对坐标系下容器的起始位置</span></span><br><span class="line">    <span class="comment">// value: holeIndex的值</span></span><br><span class="line">    <span class="keyword">int</span> parent = (holeIndex - <span class="number">1</span>)/<span class="number">2</span>;   </span><br><span class="line">    <span class="keyword">while</span>(holeIndex &gt; topIndex &amp;&amp; *(first+parent) &lt; value)&#123;  <span class="comment">// 当尚未到堆顶且parent的值小于插入值</span></span><br><span class="line">        *(first + holeIndex) = *(first + parent);            <span class="comment">// 下放parent</span></span><br><span class="line">        holeIndex = parent;                                  <span class="comment">// 调整holeIndex和parent的index</span></span><br><span class="line">        parent = (holeIndex<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(first + holeIndex) = value;                            <span class="comment">// 最后在正确的位置插入值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><iframe src="https://www.youtube.com/v/Kg4bqzAqRBM" height=325 width=545 frameborder=0></iframe>

<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-4-heaps-and-heap-sort/">第四课视频</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/assignments/MIT6_006F11_ps2_sol.pdf">第三课作业</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT 6006 Lecture 5——二叉查找树（Binary search tree, BST）</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%AF%BE%E7%A8%8B/MIT6006-5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>二叉查找树：左子节点小于根节点，右子节点大于根节点</p>
</blockquote>
<a id="more"></a>
<h2 id="跑道预留系统（Runway-Reservation-System）"><a href="#跑道预留系统（Runway-Reservation-System）" class="headerlink" title="跑道预留系统（Runway Reservation System）"></a>跑道预留系统（Runway Reservation System）</h2><p>让我们先从机场跑道预留系统作为引子，引入二叉查找树的概念。</p>
<h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>假设有一个机场只有一条跑道预留给飞机降落，这个系统有以下约束：</p>
<ul>
<li><p>预留的需求决定了降落时间$t$，$t$必须是未来的时间</p>
</li>
<li><p>如果在$k$分钟内没有规划其他的降落请求，那么就将$t$加入集合$R$中。</p>
</li>
<li><p>飞机降落后，将$t$从$R$中移出</p>
</li>
<li><p>对于规模为$n$的$R$，我们希望上述操作时间复杂度为$O(\lg n)$</p>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/6aafc0cc5a4aa26c29a54dec2d37073509f12b89/20201121239.svg" width = "500" alt="" align=center /></p>
<p>假设降落规划的时间轴如上图，现在有三个规划请求，分别是在53、44和20秒降落，根据约束可知44和20是无效的请求。现在我们需要一个合适的数据结构描述规划。可选的数据结构包括：</p>
<ul>
<li>未排序的链表或数组：不符合时间复杂度，常规操作基本都是线性复杂度</li>
<li>排序的数组：查找符合$O(\lg n)$的复杂度，但是插入的操作需要线性复杂度，因为需要移动</li>
<li>排序的链表：链表做二分查找有难度</li>
<li>堆：查找需要线性的时间，因为堆只提供了最大（最小）元素的$O(1)$时间查找</li>
</ul>
<p>从上面的数据结构可以看出，它们或多或少都有一些问题，所以我们需要一个新的结构解决上述问题，即我们今天要介绍的BST。</p>
<h2 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h2><h3 id="树的组成"><a href="#树的组成" class="headerlink" title="树的组成"></a>树的组成</h3><p>一个简单的二叉查找树如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>树的组成为：</p>
<ul>
<li>节点$x$：key($x$)为该节点的值</li>
<li>指针：parent($x$)，left($x$)，right($x$)，parent指向节点$x$的父节点，left指向左子节点，right指向右子节点</li>
</ul>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>二叉查找树的最重要的性质为：对于所有节点$x$，$x$左子树的节点值小于等于$x$的值；$x$右子树的节点值大于等于$x$的值。根据这个特性，BST的中序遍历是一个有序数列</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h4><p>插入删除的时间复杂度取决于树的高度$h$，为$O(h)$。</p>
<h4 id="寻找最小值find-min"><a href="#寻找最小值find-min" class="headerlink" title="寻找最小值find_min()"></a>寻找最小值find_min()</h4><p>寻找最小值就是一路向左，寻找最大值就是一路向右，所以时间复杂度为$O(h)$。</p>
<h4 id="寻找下一个较大的值next-larger-x"><a href="#寻找下一个较大的值next-larger-x" class="headerlink" title="寻找下一个较大的值next_larger(x)"></a>寻找下一个较大的值next_larger(x)</h4><p>时间复杂度也是$O(h)$</p>
<h4 id="寻找比某个节点小的所有节点的个数rank-x-2"><a href="#寻找比某个节点小的所有节点的个数rank-x-2" class="headerlink" title="寻找比某个节点小的所有节点的个数rank(x)2"></a>寻找比某个节点小的所有节点的个数rank(x)<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h4><p>时间复杂度也是$O(h)$，这个过程分为三步：</p>
<ul>
<li>第一步寻找插入点</li>
<li>第二步寻找过程中加上比该节点小的节点的个数</li>
<li>第三步加入该节点的左子树的所有节点</li>
</ul>
<h3 id="树的增长与收缩"><a href="#树的增长与收缩" class="headerlink" title="树的增长与收缩"></a>树的增长与收缩</h3><p>当插入或删除节点时，树会动态地调整大小，而我们也需要对树进行调整，从而使得树始终满足二叉搜索树的性质。我们有一个简单的二叉树如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/a456fd60f6446899a0571cde6bb3a49a3e077557/20201121342.svg" width = "250" alt="" align=center /></p>
<p>其中节点右侧的数表示以该节点为根节点的树的规模。现在，我们要往树中插入新的节点43，我们需要从49开始，依次向下遍历，每经过一个节点，就将节点的规模+1，得到的新树如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/5fd196cb6e388e819aebe0aca32e142d21eec15d/20201121346.svg" width = "350" alt="" align=center /></p>
<h2 id="BST实现"><a href="#BST实现" class="headerlink" title="BST实现"></a>BST实现</h2><p>下面是一个使用java实现的BST：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> *  Compilation:  javac BST.java</span></span><br><span class="line"><span class="comment"> *  Execution:    java BST</span></span><br><span class="line"><span class="comment"> *  Dependencies: StdIn.java StdOut.java Queue.java</span></span><br><span class="line"><span class="comment"> *  Data files:   https://algs4.cs.princeton.edu/32bst/tinyST.txt  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  A symbol table implemented with a binary search tree.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  % more tinyST.txt</span></span><br><span class="line"><span class="comment"> *  S E A R C H E X A M P L E</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  % java BST &lt; tinyST.txt</span></span><br><span class="line"><span class="comment"> *  A 8</span></span><br><span class="line"><span class="comment"> *  C 4</span></span><br><span class="line"><span class="comment"> *  E 12</span></span><br><span class="line"><span class="comment"> *  H 5</span></span><br><span class="line"><span class="comment"> *  L 11</span></span><br><span class="line"><span class="comment"> *  M 9</span></span><br><span class="line"><span class="comment"> *  P 10</span></span><br><span class="line"><span class="comment"> *  R 3</span></span><br><span class="line"><span class="comment"> *  S 0</span></span><br><span class="line"><span class="comment"> *  X 7</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The &#123;<span class="doctag">@code</span> BST&#125; class represents an ordered symbol table of generic</span></span><br><span class="line"><span class="comment"> *  key-value pairs.</span></span><br><span class="line"><span class="comment"> *  It supports the usual &lt;em&gt;put&lt;/em&gt;, &lt;em&gt;get&lt;/em&gt;, &lt;em&gt;contains&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> *  &lt;em&gt;delete&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, and &lt;em&gt;is-empty&lt;/em&gt; methods.</span></span><br><span class="line"><span class="comment"> *  It also provides ordered methods for finding the &lt;em&gt;minimum&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> *  &lt;em&gt;maximum&lt;/em&gt;, &lt;em&gt;floor&lt;/em&gt;, &lt;em&gt;select&lt;/em&gt;, &lt;em&gt;ceiling&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> *  It also provides a &lt;em&gt;keys&lt;/em&gt; method for iterating over all of the keys.</span></span><br><span class="line"><span class="comment"> *  A symbol table implements the &lt;em&gt;associative array&lt;/em&gt; abstraction:</span></span><br><span class="line"><span class="comment"> *  when associating a value with a key that is already in the symbol table,</span></span><br><span class="line"><span class="comment"> *  the convention is to replace the old value with the new value.</span></span><br><span class="line"><span class="comment"> *  Unlike &#123;<span class="doctag">@link</span> java.util.Map&#125;, this class uses the convention that</span></span><br><span class="line"><span class="comment"> *  values cannot be &#123;<span class="doctag">@code</span> null&#125;—setting the</span></span><br><span class="line"><span class="comment"> *  value associated with a key to &#123;<span class="doctag">@code</span> null&#125; is equivalent to deleting the key</span></span><br><span class="line"><span class="comment"> *  from the symbol table.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  It requires that</span></span><br><span class="line"><span class="comment"> *  the key type implements the &#123;<span class="doctag">@code</span> Comparable&#125; interface and calls the</span></span><br><span class="line"><span class="comment"> *  &#123;<span class="doctag">@code</span> compareTo()&#125; and method to compare two keys. It does not call either</span></span><br><span class="line"><span class="comment"> *  &#123;<span class="doctag">@code</span> equals()&#125; or &#123;<span class="doctag">@code</span> hashCode()&#125;.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  This implementation uses an (unbalanced) &lt;em&gt;binary search tree&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> *  The &lt;em&gt;put&lt;/em&gt;, &lt;em&gt;contains&lt;/em&gt;, &lt;em&gt;remove&lt;/em&gt;, &lt;em&gt;minimum&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> *  &lt;em&gt;maximum&lt;/em&gt;, &lt;em&gt;ceiling&lt;/em&gt;, &lt;em&gt;floor&lt;/em&gt;, &lt;em&gt;select&lt;/em&gt;, and</span></span><br><span class="line"><span class="comment"> *  &lt;em&gt;rank&lt;/em&gt;  operations each take &amp;Theta;(&lt;em&gt;n&lt;/em&gt;) time in the worst</span></span><br><span class="line"><span class="comment"> *  case, where &lt;em&gt;n&lt;/em&gt; is the number of key-value pairs.</span></span><br><span class="line"><span class="comment"> *  The &lt;em&gt;size&lt;/em&gt; and &lt;em&gt;is-empty&lt;/em&gt; operations take &amp;Theta;(1) time.</span></span><br><span class="line"><span class="comment"> *  The keys method takes &amp;Theta;(&lt;em&gt;n&lt;/em&gt;) time in the worst case.</span></span><br><span class="line"><span class="comment"> *  Construction takes &amp;Theta;(1) time.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  For alternative implementations of the symbol table API, see &#123;<span class="doctag">@link</span> ST&#125;,</span></span><br><span class="line"><span class="comment"> *  &#123;<span class="doctag">@link</span> BinarySearchST&#125;, &#123;<span class="doctag">@link</span> SequentialSearchST&#125;, &#123;<span class="doctag">@link</span> RedBlackBST&#125;,</span></span><br><span class="line"><span class="comment"> *  &#123;<span class="doctag">@link</span> SeparateChainingHashST&#125;, and &#123;<span class="doctag">@link</span> LinearProbingHashST&#125;,</span></span><br><span class="line"><span class="comment"> *  For additional documentation, see</span></span><br><span class="line"><span class="comment"> *  &lt;a href="https://algs4.cs.princeton.edu/32bst"&gt;Section 3.2&lt;/a&gt; of</span></span><br><span class="line"><span class="comment"> *  &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Robert Sedgewick</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Kevin Wayne</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;             <span class="comment">// root of BST</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;           <span class="comment">// sorted by key</span></span><br><span class="line">        <span class="keyword">private</span> Value val;         <span class="comment">// associated data</span></span><br><span class="line">        <span class="keyword">private</span> Node left, right;  <span class="comment">// left and right subtrees</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;          <span class="comment">// number of nodes in subtree</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes an empty symbol table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this symbol table is empty.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this symbol table is empty; &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value pairs in this symbol table.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value pairs in this symbol table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return number of key-value pairs in BST rooted at x</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Does this symbol table contain the given key?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this symbol table contains &#123;<span class="doctag">@code</span> key&#125; and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to contains() is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value associated with the given key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value associated with the given key if the key is in the symbol table</span></span><br><span class="line"><span class="comment">     *         and &#123;<span class="doctag">@code</span> null&#125; if the key is not in the symbol table</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"calls get() with a null key"</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">        <span class="keyword">else</span>              <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified key-value pair into the symbol table, overwriting the old </span></span><br><span class="line"><span class="comment">     * value with the new value if the symbol table already contains the specified key.</span></span><br><span class="line"><span class="comment">     * Deletes the specified key (and its associated value) from this symbol table</span></span><br><span class="line"><span class="comment">     * if the specified value is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  val the value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"calls put() with a null key"</span>);</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">            delete(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = put(root, key, val);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) x.left  = put(x.left,  key, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = put(x.right, key, val);</span><br><span class="line">        <span class="keyword">else</span>              x.val   = val;</span><br><span class="line">        x.size = <span class="number">1</span> + size(x.left) + size(x.right);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the smallest key and associated value from the symbol table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Symbol table underflow"</span>);</span><br><span class="line">        root = deleteMin(root);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x.right;</span><br><span class="line">        x.left = deleteMin(x.left);</span><br><span class="line">        x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the largest key and associated value from the symbol table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Symbol table underflow"</span>);</span><br><span class="line">        root = deleteMax(root);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x.left;</span><br><span class="line">        x.right = deleteMax(x.right);</span><br><span class="line">        x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the specified key and its associated value from this symbol table     </span></span><br><span class="line"><span class="comment">     * (if the key is in this symbol table).    </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"calls delete() with a null key"</span>);</span><br><span class="line">        root = delete(root, key);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) x.left  = delete(x.left,  key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = delete(x.right, key);</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x.left;</span><br><span class="line">            <span class="keyword">if</span> (x.left  == <span class="keyword">null</span>) <span class="keyword">return</span> x.right;</span><br><span class="line">            Node t = x;</span><br><span class="line">            x = min(t.right);</span><br><span class="line">            x.right = deleteMin(t.right);</span><br><span class="line">            x.left = t.left;</span><br><span class="line">        &#125; </span><br><span class="line">        x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the smallest key in the symbol table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the smallest key in the symbol table</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"calls min() with empty symbol table"</span>);</span><br><span class="line">        <span class="keyword">return</span> min(root).key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x; </span><br><span class="line">        <span class="keyword">else</span>                <span class="keyword">return</span> min(x.left); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the largest key in the symbol table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the largest key in the symbol table</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the symbol table is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"calls max() with empty symbol table"</span>);</span><br><span class="line">        <span class="keyword">return</span> max(root).key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x; </span><br><span class="line">        <span class="keyword">else</span>                 <span class="keyword">return</span> max(x.right); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the largest key in the symbol table less than or equal to &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the largest key in the symbol table less than or equal to &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if there is no such key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to floor() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"calls floor() with empty symbol table"</span>);</span><br><span class="line">        Node x = floor(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"argument to floor() is too small"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt;  <span class="number">0</span>) <span class="keyword">return</span> floor(x.left, key);</span><br><span class="line">        Node t = floor(x.right, key); </span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor2</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        Key x = floor2(root, key, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"argument to floor() is too small"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">floor2</span><span class="params">(Node x, Key key, Key best)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> best;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>      (cmp  &lt; <span class="number">0</span>) <span class="keyword">return</span> floor2(x.left, key, best);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp  &gt; <span class="number">0</span>) <span class="keyword">return</span> floor2(x.right, key, x.key);</span><br><span class="line">        <span class="keyword">else</span>               <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the smallest key in the symbol table greater than or equal to &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the smallest key in the symbol table greater than or equal to &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if there is no such key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to ceiling() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"calls ceiling() with empty symbol table"</span>);</span><br><span class="line">        Node x = ceiling(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"argument to floor() is too large"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">ceiling</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            Node t = ceiling(x.left, key); </span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> x; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ceiling(x.right, key); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the key in the symbol table of a given &#123;<span class="doctag">@code</span> rank&#125;.</span></span><br><span class="line"><span class="comment">     * This key has the property that there are &#123;<span class="doctag">@code</span> rank&#125; keys in</span></span><br><span class="line"><span class="comment">     * the symbol table that are smaller. In other words, this key is the</span></span><br><span class="line"><span class="comment">     * (&#123;<span class="doctag">@code</span> rank&#125;+1)st smallest key in the symbol table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  rank the order statistic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the key in the symbol table of given &#123;<span class="doctag">@code</span> rank&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> rank&#125; is between 0 and</span></span><br><span class="line"><span class="comment">     *        &lt;em&gt;n&lt;/em&gt;–1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rank &lt; <span class="number">0</span> || rank &gt;= size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to select() is invalid: "</span> + rank);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select(root, rank);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return key in BST rooted at x of given rank.</span></span><br><span class="line">    <span class="comment">// Precondition: rank is in legal range.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">select</span><span class="params">(Node x, <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSize = size(x.left);</span><br><span class="line">        <span class="keyword">if</span>      (leftSize &gt; rank) <span class="keyword">return</span> select(x.left,  rank);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (leftSize &lt; rank) <span class="keyword">return</span> select(x.right, rank - leftSize - <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">else</span>                      <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the number of keys in the symbol table strictly less than &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of keys in the symbol table strictly less than &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> key&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument to rank() is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> rank(key, root);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of keys in the subtree less than key.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key); </span><br><span class="line">        <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, x.left); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + size(x.left) + rank(key, x.right); </span><br><span class="line">        <span class="keyword">else</span>              <span class="keyword">return</span> size(x.left); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns all keys in the symbol table as an &#123;<span class="doctag">@code</span> Iterable&#125;.</span></span><br><span class="line"><span class="comment">     * To iterate over all of the keys in the symbol table named &#123;<span class="doctag">@code</span> st&#125;,</span></span><br><span class="line"><span class="comment">     * use the foreach notation: &#123;<span class="doctag">@code</span> for (Key key : st.keys())&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> all keys in the symbol table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">        <span class="keyword">return</span> keys(min(), max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns all keys in the symbol table in the given range,</span></span><br><span class="line"><span class="comment">     * as an &#123;<span class="doctag">@code</span> Iterable&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  lo minimum endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  hi maximum endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> all keys in the symbol table between &#123;<span class="doctag">@code</span> lo&#125; </span></span><br><span class="line"><span class="comment">     *         (inclusive) and &#123;<span class="doctag">@code</span> hi&#125; (inclusive)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if either &#123;<span class="doctag">@code</span> lo&#125; or &#123;<span class="doctag">@code</span> hi&#125;</span></span><br><span class="line"><span class="comment">     *         is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"first argument to keys() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (hi == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"second argument to keys() is null"</span>);</span><br><span class="line"></span><br><span class="line">        Queue&lt;Key&gt; queue = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">        keys(root, queue, lo, hi);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">        <span class="keyword">int</span> cmplo = lo.compareTo(x.key); </span><br><span class="line">        <span class="keyword">int</span> cmphi = hi.compareTo(x.key); </span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt; <span class="number">0</span>) keys(x.left, queue, lo, hi); </span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt;= <span class="number">0</span> &amp;&amp; cmphi &gt;= <span class="number">0</span>) queue.enqueue(x.key); </span><br><span class="line">        <span class="keyword">if</span> (cmphi &gt; <span class="number">0</span>) keys(x.right, queue, lo, hi); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of keys in the symbol table in the given range.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  lo minimum endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  hi maximum endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of keys in the symbol table between &#123;<span class="doctag">@code</span> lo&#125; </span></span><br><span class="line"><span class="comment">     *         (inclusive) and &#123;<span class="doctag">@code</span> hi&#125; (inclusive)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if either &#123;<span class="doctag">@code</span> lo&#125; or &#123;<span class="doctag">@code</span> hi&#125;</span></span><br><span class="line"><span class="comment">     *         is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"first argument to size() is null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (hi == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"second argument to size() is null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lo.compareTo(hi) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (contains(hi)) <span class="keyword">return</span> rank(hi) - rank(lo) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>              <span class="keyword">return</span> rank(hi) - rank(lo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the height of the BST (for debugging).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the height of the BST (a 1-node tree has height 0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(x.left), height(x.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the keys in the BST in level order (for debugging).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the keys in the BST in level order traversal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; keys = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> Queue&lt;Node&gt;();</span><br><span class="line">        queue.enqueue(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node x = queue.dequeue();</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            keys.enqueue(x.key);</span><br><span class="line">            queue.enqueue(x.left);</span><br><span class="line">            queue.enqueue(x.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    *  Check integrity of BST data structure.</span></span><br><span class="line"><span class="comment">    ***************************************************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isBST())            StdOut.println(<span class="string">"Not in symmetric order"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isSizeConsistent()) StdOut.println(<span class="string">"Subtree counts not consistent"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isRankConsistent()) StdOut.println(<span class="string">"Ranks not consistent"</span>);</span><br><span class="line">        <span class="keyword">return</span> isBST() &amp;&amp; isSizeConsistent() &amp;&amp; isRankConsistent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// does this binary tree satisfy symmetric order?</span></span><br><span class="line">    <span class="comment">// Note: this test also ensures that data structure is a binary tree since order is strict</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the tree rooted at x a BST with all keys strictly between min and max</span></span><br><span class="line">    <span class="comment">// (if min or max is null, treat as empty constraint)</span></span><br><span class="line">    <span class="comment">// Credit: Bob Dondero's elegant solution</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node x, Key min, Key max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; x.key.compareTo(min) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; x.key.compareTo(max) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBST(x.left, min, x.key) &amp;&amp; isBST(x.right, x.key, max);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// are the size fields correct?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSizeConsistent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isSizeConsistent(root); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSizeConsistent</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (x.size != size(x.left) + size(x.right) + <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSizeConsistent(x.left) &amp;&amp; isSizeConsistent(x.right);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that ranks are consistent</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRankConsistent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (i != rank(select(i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Key key : keys())</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(select(rank(key))) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unit tests the &#123;<span class="doctag">@code</span> BST&#125; data type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        BST&lt;String, Integer&gt; st = <span class="keyword">new</span> BST&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; !StdIn.isEmpty(); i++) &#123;</span><br><span class="line">            String key = StdIn.readString();</span><br><span class="line">            st.put(key, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : st.levelOrder())</span><br><span class="line">            StdOut.println(s + <span class="string">" "</span> + st.get(s));</span><br><span class="line"></span><br><span class="line">        StdOut.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : st.keys())</span><br><span class="line">            StdOut.println(s + <span class="string">" "</span> + st.get(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><iframe src="https://www.youtube.com/v/9Jry5-82I68" height=325 width=545 frameborder=0></iframe>



<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-5-binary-search-trees-bst-sort/">第五课视频</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://algs4.cs.princeton.edu/32bst/">Binary Search Trees</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://algs4.cs.princeton.edu/32bst/BST.java.html">java实现的BST</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT 6006 Lecture 6——AVL树，AVL排序</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%AF%BE%E7%A8%8B/MIT6006-6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>AVL树——一种平衡的BST</p>
</blockquote>
<a id="more"></a>
<h2 id="普通BST的问题：不平衡"><a href="#普通BST的问题：不平衡" class="headerlink" title="普通BST的问题：不平衡"></a>普通BST的问题：不平衡</h2><p>树的平衡性是很重要的，在BST中，查找的时间复杂度为$O(h)$，其中$h$为树高，如果树不平衡，树可能会退化为一个链表，此时时间复杂度会变为$O(n)$。普通的BST不具有平衡的特性，所以我们需要对其进行改进。平衡的二叉树高度为$\lg (n)$，而不平衡的二叉树，高度最坏情况下为$O(n)$。其中，树的高度的定义为：从根节点到叶子节点的最长路径的长度。</p>
<ul>
<li>平衡：$h=\lg n$</li>
<li>不平衡：$h=n$</li>
</ul>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>我们先定义节点的高度，一个节点的高度为从该节点到一个叶子节点的最长路径，即：</p>
<script type="math/tex; mode=display">
h_n=\max(path)=\max\{height(left), height(right)\}+1</script><p>我们规定叶子节点的高度为0，空节点的高度为-1。而AVL树的目标就是使节点高度尽可能小。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>AVL树的性质：每一个节点的左右子节点的高度差最大为1，即：</p>
<script type="math/tex; mode=display">
|h_r-h_l|\leq1</script><p>根据这个性质，AVL树是一种平衡树，最坏情况下，每一个右子树都比左子树高1。</p>
<p>令$N<em>h$为一棵高度为$h$的AVL树的最小节点数，现在我们来证明最坏情况下$N_h$和$h$之间的关系。根据AVL树高的定义，我们规定$N</em>{O(1)}=O(1)$，而$N_h$为：</p>
<script type="math/tex; mode=display">
N_h=1+N_{h-1}+N_{h-2}</script><p>其中1为根节点，$N<em>{h-1}$为右子树节点，$N</em>{h-2}$为左子树节点。由这个公式可以推导出，$h&lt;1.44\lg n$。所以高度被限制在了$O(\lg n)$。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ol>
<li>做一个基本的BST操作</li>
<li>调整树，使得其符合AVL的性质</li>
</ol>
<p>现在我们以一个简单的插入操作为例，看一下AVL树的插入过程：</p>
<h5 id="情况1：右子树中插入右节点（或左子树中插入左节点）"><a href="#情况1：右子树中插入右节点（或左子树中插入左节点）" class="headerlink" title="情况1：右子树中插入右节点（或左子树中插入左节点）"></a>情况1：右子树中插入右节点（或左子树中插入左节点）</h5><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/8a088247ac46c977629b04777659bf35b4a01769/20201141405.svg" width = "250" alt="" align = center /></p>
<p>假设我们有一棵AVL树，现在要插入一个新节点23，根据插入操作的顺序，我们先将节点23按照BST的定义插入，然后再对树进行调整。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/8fadc239c31b4e99e023c90b054ee111b327b728/20201141409.svg" width = "250" alt="" align = center /></p>
<p>插入节点后，树不平衡了，我们需要平衡化，就是绕着某个节点进行旋转，其过程示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/f919d793ef66610c862d9682432e298df156cc17/20201141422.svg" width = "1000" alt="" align = center /></p>
<p>这个操作叫做绕着$x$的左旋转（如果固定$x$，$y$是逆时针在转动），<code>left_rotate(x)</code>，这个操作的时间复杂度为$O(1)$，同时，这个操作也保持了树的BST特性。根据对称性，如果在左子树插入左节点，那么是做一个右旋转。</p>
<h5 id="情况2：左子树中插入右节点（或右子树中插入左节点）"><a href="#情况2：左子树中插入右节点（或右子树中插入左节点）" class="headerlink" title="情况2：左子树中插入右节点（或右子树中插入左节点）"></a>情况2：左子树中插入右节点（或右子树中插入左节点）</h5><p>而另一种情况更加复杂，如果在左子节点插入右子树，或者在右子节点插入左子树，我们就不能通过一次旋转解决，而是需要两次。此时旋转过程如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/1fa088e9e4c41e31f477bed63a28f08174c56560/20201141514.svg" width = "1000" alt="" align = center /></p>
<p>现在我们来总结一下插入的过程：</p>
<ul>
<li><p>假设$x$是最低的违背AVL性质的节点</p>
</li>
<li><p>假设right$(x)$是更高的子树</p>
<ul>
<li>如果$x$的右子节点的右子树是平衡的或者right-heavy的，那么就右旋转$x$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/f919d793ef66610c862d9682432e298df156cc17/20201141422.svg" width = "1000" alt="" align = center /></p>
<ul>
<li>如果$x$的右子节点的左子树是left-heavy的，那么先RR(z)，在LR(x)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/1fa088e9e4c41e31f477bed63a28f08174c56560/20201141514.svg" width = "1000" alt="" align = center /></p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="AVL排序"><a href="#AVL排序" class="headerlink" title="AVL排序"></a>AVL排序</h4><p>只需要进行中序遍历即可，时间复杂度为$\Theta(n)$，而插入$n$个元素所需的时间复杂度为$\Theta(n\lg n)$</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><iframe src="https://www.youtube.com/v/FNeL18KsWPc" height=325 width=545 frameborder=0></iframe>



<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-6-avl-trees-avl-sort/">第六课视频</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://algs4.cs.princeton.edu/32bst/">Binary Search Trees</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://algs4.cs.princeton.edu/32bst/BST.java.html">java实现的BST</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT 6006 Lecture 7——计数排序，基数排序，排序的时间复杂度下界</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%AF%BE%E7%A8%8B/MIT6006-7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>AVL树——一种平衡的BST</p>
</blockquote>
<a id="more"></a>
<h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul>
<li>比较模型</li>
<li>时间复杂度下界<ul>
<li>搜索：$\Omega(\lg n)$</li>
<li>排序：$\Omega(n\lg n)$</li>
</ul>
</li>
<li>$O(n)$时间复杂度的排序<ul>
<li>计数排序</li>
<li>基数排序</li>
</ul>
</li>
</ul>
<h2 id="比较模型"><a href="#比较模型" class="headerlink" title="比较模型"></a>比较模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>所有输入对象均为黑盒（抽象数据结构）</li>
<li>唯一允许的操作是比较操作（$&lt;,\le,&gt;,\ge,=$）</li>
<li>时间损耗只和比较操作的次数有关</li>
</ul>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>任何的比较操作，实际上都可以视为一棵树，这棵树由可能的路径和结果构成。例如，二分查找可以被视为一颗二分查找树。下面给出了一个二分查找的过程，在长度$n=3$的数组里进行二分查找：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/5a0630f895a79490c92f7e194be22e42f03977c3/202011101603.svg" width = "550" alt="" align = center /></p>
<p>算法和树的对应关系如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">决策树</th>
<th style="text-align:center">算法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内部节点</td>
<td style="text-align:center">二分决策（比较）</td>
</tr>
<tr>
<td style="text-align:center">叶节点</td>
<td style="text-align:center">结果</td>
</tr>
<tr>
<td style="text-align:center">根到叶的路径</td>
<td style="text-align:center">一次算法的执行</td>
</tr>
<tr>
<td style="text-align:center">路径长度</td>
<td style="text-align:center">算法的执行时间</td>
</tr>
<tr>
<td style="text-align:center">树高</td>
<td style="text-align:center">最坏执行时间</td>
</tr>
</tbody>
</table>
</div>
<h2 id="时间复杂度下界"><a href="#时间复杂度下界" class="headerlink" title="时间复杂度下界"></a>时间复杂度下界</h2><h3 id="搜索的时间复杂度下界"><a href="#搜索的时间复杂度下界" class="headerlink" title="搜索的时间复杂度下界"></a>搜索的时间复杂度下界</h3><p>在$n$个<strong>经过处理</strong>（排序或其他操作）的对象中，根据比较模型找到一个指定的目标，最坏情况下时间复杂度下界为$\Omega(\lg n)$。</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ul>
<li>首先，我们的决策树是一个二叉树，同时，这棵树至少有$n$个节点，每个节点对应一个解</li>
<li>所以树的高度$h\ge \lg n$，证明完毕</li>
</ul>
<h3 id="排序的时间复杂度下界"><a href="#排序的时间复杂度下界" class="headerlink" title="排序的时间复杂度下界"></a>排序的时间复杂度下界</h3><p>在搜索算法中，我们证明了$\Omega = \lg n$，即从$n$个对象中找到一个解的时间复杂度下界为$\lg n$，那么直观来看，如果我们要排序，就是从$n$个元素中找到$n$个解，这$n$个解分别为第一大元素、第二大元素、…、第$n$大元素，所以时间复杂度应为$n\lg n$。</p>
<h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>首先，对于这个排序问题，我们的决策树依旧是一个二叉树，所以我们要看一下这个树有多少个节点。对于排序问题，我们的一个节点也是一个解，这个解是一个排序序列，例如：</p>
<script type="math/tex; mode=display">
A[5]\le A[7]\le A[10]\le A[2]\le...\le A[3]</script><p>那么有多少个节点呢，根据排列组合，所有可能的情况为$A_n^n=n!$（$n$ factorial），则树高$h$满足</p>
<script type="math/tex; mode=display">
h\ge \lg (n!)</script><p>我们现在要证明$\lg(n!)\ge n\lg n$，证明过程如下：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
\lg(n!)&=\lg(n(n-1)(n-2)...(2)(1)) \\
&=\lg(n)+\lg(n-1)+...+\lg(2)+\lg(1) \\
&\ge \sum_{i=n/2}^{n}\lg(i) \\
&\ge \sum_{i=n/2}^{n}\lg \frac{n}{2} \\
&=\sum_{i=n/2}^{n}(\lg n-1) \\
&=\frac{n}{2}(\lg n-1) \\ 
&=\Omega(n\lg n)
\end{aligned}
\end{equation}</script><h2 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h2><p>假设我们的待排序的对象是整数，那么我们可以制造出一些整数排序的结果，我们先进行一些假设：</p>
<ul>
<li>假设key是整数，且$key\in{0,1,2,…,k-1}$，同时一个key的长度小于计算机的一个字</li>
<li>不止可以进行比较操作，还可以进行别的操作</li>
<li>对于$k$，可以在$O(n)$时间复杂度下进行排序</li>
</ul>
<p>目前来说，最好的排序算法能够达到的时间复杂度为$O(n\sqrt{(\lg n\lg n)})$</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>配置一个计数器，然后遍历数组，每遇到一个元素，就将对应的$key$所在的位置+1，然后遍历计数器，进行排序。计数排序中一个比较重要的问题是考虑排序的稳定性，如果我们要保证相同元素排序后位次不变，那么可以使用如下算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L = array of k empty lists      O(k)</span><br><span class="line">for i in range(n):              O(n)</span><br><span class="line">    L[key(A[j])].append(A[j])   O(1)</span><br><span class="line">output = []</span><br><span class="line">for i in range(k)               O(n+k)</span><br><span class="line">    output.extend(L[i])         O(|li|)</span><br></pre></td></tr></table></figure>
<p>所以计数排序的时间复杂度为$O(n+k)$，如果$k$很大，那么性能很差。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序基于计数排序，其基本原理是使用对数缩小数的范围，然后再利用计数排序进行排序</p>
<ul>
<li>同样假设key为整数，令其表示为以$b$为底的对数，即$d=\log_bk$</li>
<li>然后我们的key的范围变成了$0-d$</li>
</ul>
<p>实际上是进行了一次分组操作，对于一组进行计数排序，需要$O(n+b)$次操作；而对于全部，则需要$O((n+b)d)=O((n+b)\log_bk)$</p>
<p>可以证明，当$b=n$时，时间复杂度最小，为$O(n\log_nk)=O(nc)$</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><iframe src="https://www.youtube.com/v/Nz1KZXbghj8" height=325 width=545 frameborder=0></iframe>

<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-7-counting-sort-radix-sort-lower-bounds-for-sorting/">第七课视频</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT 6006 课程大纲</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E8%AF%BE%E7%A8%8B/MIT6006-%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>人的新鲜感总是难以为继，我们总是会不经意间开始厌倦已经熟悉的人和事</p>
</blockquote>
<a id="more"></a>
<p>&lt;iframe src=”<a href="https://www.youtube.com/v/Nz1KZXbg">https://www.youtube.com/v/Nz1KZXbg</a></p>
<h2 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">LEC #</th>
<th style="text-align:left">TOPICS</th>
<th style="text-align:left">KEY DATES</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Unit 1: Introduction</strong></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Algorithmic thinking, peak finding</td>
<td style="text-align:left">Problem set 1 out</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Models of computation, Python cost model, document distance</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>Unit 2: Sorting and Trees</strong></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">Insertion sort, merge sort</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">Heaps and heap sort</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">Binary search trees, BST sort</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">AVL trees, AVL sort</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">Counting sort, radix sort, lower bounds for sorting and searching</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>Unit 3: Hashing</strong></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">Hashing with chaining</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">Table doubling, Karp-Rabin</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">Open addressing, cryptographic hashing</td>
</tr>
</tbody>
</table>
</div>
<h2 id="课程阅读"><a href="#课程阅读" class="headerlink" title="课程阅读"></a>课程阅读</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">课程</th>
<th style="text-align:left">内容</th>
<th style="text-align:center">完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LEC1</td>
<td style="text-align:left">阅读：课程大纲</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">观看：Unix系统介绍</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">LEC2</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-x86.pdf">PC hardware and x86 programming slides</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-x86.html">notes</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Bootstrap/PC hardware appendices and the related xv6 source files</a></td>
<td style="text-align:center">完成，但是剩下三个题目不会</td>
</tr>
<tr>
<td style="text-align:left">LEC3</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/gdb_slides.pdf">gdb (mit.edu)</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：K&amp;R2.9、5.1-5.5、6.4章节</td>
<td style="text-align:center">完成，2.9节三个练习没做</td>
</tr>
<tr>
<td style="text-align:left">LEC4</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-shell.txt">Shell &amp; OS organization</a></td>
<td style="text-align:center">剩下三个挑战问题和两个问答题没做</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">chapter 0 of the xv6 book</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">LEC5</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-internal.txt">Isolation mechanisms</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Chapter 1: Operating system organization” and the related xv6 source files</a></td>
<td style="text-align:center">读到了22页</td>
</tr>
<tr>
<td style="text-align:left">LEC6</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm.md">Virtual memory (1)</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/x86_translation_and_registers.pdf">page table translation and registers</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm.pdf">slides</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Chapter 2: Page Tables</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">LEC7</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-usevm.md">Virtual memory (2)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-josmem.html">JOS virtual memory layout</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-usingvm.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC8</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-interrupt.txt">System calls, interrupts, exceptions</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/x86_idt.pdf">IDT</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Traps, interrupts, and drivers” and the related xv6 source files</a></td>
<td style="text-align:center">大致浏览了一遍，代码还没看</td>
</tr>
<tr>
<td style="text-align:left">LEC9</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-lockv2.txt">Multiprocessors and locking (mit.edu)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-locks.pdf">slides (mit.edu)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读： <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Locking”</a> with spinlock.c and skim mp.c</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC10</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-threads.txt">Processes and switching</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Scheduling”</a> up to “Sleep and wakeup” and proc.c, swtch.S</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC11</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-coordination.txt">sleep&amp;wakeup</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：remainder of <a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">“Scheduling”</a>, and corresponding parts of proc.c</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC12</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-fs.txt">File systems</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：bio.c, fs.c, sysfile.c, file.c and “File system” except for the logging sections</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC13</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-crash.txt">Crash recovery</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：log.c and the logging sections of “File system”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC14</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-journal.txt">File system performance and fast crash recovery</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/journal-ext2fs.html">Journaling the Linux ext2fs Filesystem (1998)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC15</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm-again.txt">Virtual Memory (3)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vm-again.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/appel-li.pdf">Virtual Memory Primitives for User Programs (1991)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC16</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-organization.txt">OS Organization</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/engler95exokernel.pdf">Exokernel (1995)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC17</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-biscuit.txt">Kernels and HLL</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/biscuit.pdf">Biscuit paper (2018)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC18</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-scalable-lock.md">Scalable locks</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-mcs.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/scalable-lock-code.c">code</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/linux-lock.pdf">Non-scalable locks paper (2012)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC19</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-rcu.pdf">Scaling OSes slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/rcu-decade-later.pdf">RCU (2013)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC20</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vmware.txt">Virtual Machines (1)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vmware.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC21</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/adams06vmware.pdf"><a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-vmm.md">Virtual Machines (2)</a></a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-virt2.pdf">slides</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/belay-dune.pdf">Dune: Safe User-level Access to Privileged CPU Features (2012)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">LEC22</td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-net.txt">High-performance networking</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/osdi14-paper-belay.pdf">IX: A Protected Dataplane Operating System for High Throughput and Low Latency (2014)</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="课程视频"><a href="#课程视频" class="headerlink" title="课程视频"></a>课程视频</h2><p>由于本课程视频较为模糊，因此我们以其他的视频进行替代</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">课程</th>
<th style="text-align:left">内容</th>
<th style="text-align:center">完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">第一讲</td>
<td style="text-align:left"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-1-algorithmic-thinking-peak-finding">lecture-1-algorithmic-thinking-peak-finding</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">第二讲</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">第三讲</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">第四讲</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">第五讲</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">第六讲</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">第七讲</td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">第八讲</td>
<td style="text-align:left"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-8-hashing-with-chaining/">Hashing with Chaining</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><div class="table-container">
<table>
<thead>
<tr>
<th>作业</th>
<th>内容</th>
<th style="text-align:center">完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-boot.html">boot xv6 (mit.edu)</a></td>
<td>Boot xv6</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>Finding and breaking at an address</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>Exercise: What is on the stack?</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-shell.html">shell (mit.edu)</a></td>
<td>完成：<a href="http://web.mit.edu/6.033/2004/wwwdocs/handouts/handson/unix.html">6.033: Hands-on Assignment (UNIX) (mit.edu)</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td></td>
<td>阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">chapter 0 of the xv6 book</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/sh.c">6.828 shell</a></td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：实验环境搭建</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：执行简单命令</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：IO重定向</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：实施管道</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：挑战练习</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">xv6 system calls (mit.edu)</a></td>
<td>完成：syscall函数</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：date函数</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">lazy page allocation</a></td>
<td>完成：修改sbrk函数</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td></td>
<td>完成：lazy allocation</td>
<td style="text-align:center">框架搭好了，但尚未实现</td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/homework/lock.html">Threads and Locking</a></td>
<td>完成：对put进行加锁保护</td>
<td style="text-align:center">完成，但是Hash表原理不太懂</td>
</tr>
</tbody>
</table>
</div>
<h2 id="实-验"><a href="#实-验" class="headerlink" title="实     验"></a>实     验</h2><div class="table-container">
<table>
<thead>
<tr>
<th>实验</th>
<th>内容</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">Lab1</a></td>
<td></td>
<td>完成</td>
</tr>
<tr>
<td><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab2/">Lab2</a></td>
<td>阅读：Introduction</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>完成：实验环境搭建</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>阅读：第一部分，物理页管理</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>阅读：第二部分，虚拟内存</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>阅读：第三部分，内核地址空间</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>编程：编写一个物理内存分配 boot_alloc</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第一部分：编写mem_init()</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第一部分：编写page_init</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第一部分：编写page_alloc和page_free</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第二部分：编写pgdir_walk</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td>第二部分：</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>测试一：<a href="https://pdos.csail.mit.edu/6.828/2018/quiz.html">previous years’ quizzes</a>.</li>
<li>测试二：<a href="https://pdos.csail.mit.edu/6.828/2018/quiz.html">previous years’ quizzes</a>.</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.bilibili.com/video/av15896196/">MIT6828课程视频链接</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">6.828 / Fall 2018 (mit.edu)</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>算法和数据结构</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>AXI procol</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Bus%20Protocol/AXI%20protocol/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>In this article, we will introduce the AXI protocol which is a high performance, high bandwidth, low latency interconnect for high speed communication between components on the same chip. The AXI protocol is based on a point-to-point interconnect to provide high-speed data transfer between the master and slave components. The AXI protocol is designed to support multiple masters and multiple slaves, and it is widely used in many modern SoC designs.</p>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In AXI protocol, we have 5 groups of signals:</p>
<ul>
<li>AR: Read request</li>
<li>R: Read response</li>
<li>AW: Write request</li>
<li>W: Write data</li>
<li>B: Write response</li>
</ul>
<p>With these signals, we are able to build a flexible connection between master and slave components.</p>
<h2 id="AXI-wave-analysis"><a href="#AXI-wave-analysis" class="headerlink" title="AXI wave analysis"></a>AXI wave analysis</h2><p>This section let’s take a look at a specific AXI bus protocol wave form, let’s first analyze the read burst operation<br><img src="https://github.com/sqduan/blog/assets/51660739/b47c71bb-d9fb-4fdc-8c19-d89ddd2fbe01" alt="image"><br>Here we have 4 burst request, the address are incremental, <code>arlen = 0xF</code> which means that we have 16 burst for each of the transaction, <code>arsize = 0x2</code>means that for each burst, the size is 4bytes, and <code>arburst = 0x1</code> means that the address is incremental when burst. We can observe that the start addr is not aligned, according to AXI protocol, the first transfer would be 3 bytes.<br>After several delay, the slave gave out response and read data:<br><img src="https://github.com/sqduan/blog/assets/51660739/4c261474-603d-4f95-948f-b7eef54e4d5e" alt="image"></p>
<p>Let’s expand the read data, we can observe that when master &amp; slave have a handshake (valid &amp; ready signal to high), the data is transferred successfully, and when it reaches 16 burst, rlast will be pull up to indicate the last transaction.<br><img src="https://github.com/sqduan/blog/assets/51660739/fd8e9ab6-8265-4d43-9de2-ee43a02302fb" alt="image"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>Bus Protocol</category>
      </categories>
  </entry>
  <entry>
    <title>DMA Introduction</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/DMA/DMA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>You cannot create experience. You must undergo it.</p>
</blockquote>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Flow-of"><a href="#Flow-of" class="headerlink" title="Flow of"></a>Flow of</h2><h2 id="DMA-Performance-Analysis"><a href="#DMA-Performance-Analysis" class="headerlink" title="DMA Performance Analysis"></a>DMA Performance Analysis</h2><p><strong>Throughput with different blockts</strong><br>One thing which strongly affect DMA throughput is the blockts, that is, the size of each transferred block, we measured the throughput with different blockts, the result are shown below:<br><img src="https://github.com/sqduan/blog/assets/51660739/453082db-ee19-4e44-8b61-bae0a52ee49f" alt="image"><br>We can see that with blockts increases, the through put also increases, but when it reaches a threshold, the increase is limited, as an experience, when blockts = 64 (256 bytes one block), it reaches the best efficiency and power consumption.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>DMA</category>
      </categories>
  </entry>
  <entry>
    <title>Branch Prediction Unit(BPU)</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/FrontEnd/BPU/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>“I don’t make mistakes. I make prophecies which immediately turn out to be wrong.”</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文将对香山的分支预测顶层模块BPU进行介绍，BPU为取值目标队列（FTQ）提供预测的取址目标，BPU主要包含如下逻辑：</p>
<ul>
<li>覆盖预测逻辑（后级预测对前级进行覆盖）</li>
<li>流水线握手（各级之间以及BPU和FTQ之间）</li>
<li>全局分支历史管理</li>
</ul>
<h2 id="基本结构及参数"><a href="#基本结构及参数" class="headerlink" title="基本结构及参数"></a>基本结构及参数</h2><p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20221010103033.png" width = "550" alt="BPU" align=center /></p>
<p>分支预测单元采用多级混合预测架构，主要包含两个部分</p>
<ul>
<li><p>Next Line Predictor (NLP)：$\mu $BTB</p>
</li>
<li><p>Accurate Predictor (APD): FTB/TAGE-SC/ITTAGE/RAS</p>
</li>
</ul>
<h2 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input/Output"></a>Input/Output</h2><h3 id="BasePredictor"><a href="#BasePredictor" class="headerlink" title="BasePredictor"></a>BasePredictor</h3><h4 id="IO-in"><a href="#IO-in" class="headerlink" title="IO.in"></a>IO.in</h4><p>预测器的基本输入如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePredictorInput</span> (<span class="params">implicit p: <span class="type">Parameters</span></span>) <span class="keyword">extends</span> <span class="title">XSBundle</span> <span class="keyword">with</span> <span class="title">HasBPUConst</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nInputs</span> </span>= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> s0_pc = <span class="type">UInt</span>(<span class="type">VAddrBits</span>.<span class="type">W</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> folded_hist = <span class="keyword">new</span> <span class="type">AllFoldedHistories</span>(foldedGHistInfos)    <span class="comment">// 经过折叠的历史</span></span><br><span class="line">    <span class="keyword">val</span> ghist = <span class="type">UInt</span>(<span class="type">HistoryLength</span>.<span class="type">W</span>)                             <span class="comment">// 全局历史</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resp_in = <span class="type">Vec</span>(nInputs, <span class="keyword">new</span> <span class="type">BranchPredictionResp</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IO-out"><a href="#IO-out" class="headerlink" title="IO.out"></a>IO.out</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePredictorOutput</span> (<span class="params">implicit p: <span class="type">Parameters</span></span>) <span class="keyword">extends</span> <span class="title">XSBundle</span> <span class="keyword">with</span> <span class="title">HasBPUConst</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> last_stage_meta = <span class="type">UInt</span>(<span class="type">MaxMetaLength</span>.<span class="type">W</span>) <span class="comment">// This is use by composer</span></span><br><span class="line">    <span class="keyword">val</span> resp = <span class="keyword">new</span> <span class="type">BranchPredictionResp</span>         <span class="comment">// 预测器的结果，包含了各个stage的预测结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePredictorIO</span> (<span class="params">implicit p: <span class="type">Parameters</span></span>) <span class="keyword">extends</span> <span class="title">XSBundle</span> <span class="keyword">with</span> <span class="title">HasBPUConst</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> reset_vector = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="type">PAddrBits</span>.<span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> in  = <span class="type">Flipped</span>(<span class="type">DecoupledIO</span>(<span class="keyword">new</span> <span class="type">BasePredictorInput</span>)) <span class="comment">// BasePredictorInput</span></span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="keyword">new</span> <span class="type">BasePredictorOutput</span>)              <span class="comment">// BasePredictorOutput</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ctrl = <span class="type">Input</span>(<span class="keyword">new</span> <span class="type">BPUCtrl</span>)                          <span class="comment">// Control signal</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> s0_fire = <span class="type">Input</span>(<span class="type">Bool</span>())                            <span class="comment">// 驱动下一级stage</span></span><br><span class="line">    <span class="keyword">val</span> s1_fire = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">    <span class="keyword">val</span> s2_fire = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">    <span class="keyword">val</span> s3_fire = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> s2_redirect = <span class="type">Input</span>(<span class="type">Bool</span>())                        <span class="comment">// 重定向，后级预测错误，需要冲刷前一级</span></span><br><span class="line">    <span class="keyword">val</span> s3_redirect = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> s1_ready = <span class="type">Output</span>(<span class="type">Bool</span>())</span><br><span class="line">    <span class="keyword">val</span> s2_ready = <span class="type">Output</span>(<span class="type">Bool</span>())</span><br><span class="line">    <span class="keyword">val</span> s3_ready = <span class="type">Output</span>(<span class="type">Bool</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> update = <span class="type">Flipped</span>(<span class="type">Valid</span>(<span class="keyword">new</span> <span class="type">BranchPredictionUpdate</span>))    </span><br><span class="line">    <span class="keyword">val</span> redirect = <span class="type">Flipped</span>(<span class="type">Valid</span>(<span class="keyword">new</span> <span class="type">BranchPredictionRedirect</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PredictorIO"><a href="#PredictorIO" class="headerlink" title="PredictorIO"></a>PredictorIO</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PredictorIO</span>(<span class="params">implicit p: <span class="type">Parameters</span></span>) <span class="keyword">extends</span> <span class="title">XSBundle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> bpu_to_ftq = <span class="keyword">new</span> <span class="type">BpuToFtqIO</span>()             <span class="comment">// 预测结果</span></span><br><span class="line">    <span class="keyword">val</span> ftq_to_bpu = <span class="type">Flipped</span>(<span class="keyword">new</span> <span class="type">FtqToBpuIO</span>())    <span class="comment">// reverse input and output, update及redirect信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ctrl = <span class="type">Input</span>(<span class="keyword">new</span> <span class="type">BPUCtrl</span>)</span><br><span class="line">    <span class="keyword">val</span> reset_vector = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="type">PAddrBits</span>.<span class="type">W</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="预测器逻辑"><a href="#预测器逻辑" class="headerlink" title="预测器逻辑"></a>预测器逻辑</h2><h3 id="握手逻辑"><a href="#握手逻辑" class="headerlink" title="握手逻辑"></a>握手逻辑</h3><p>BPU 的各个流水级都会连接 <a href="https://xiangshan-doc.readthedocs.io/zh_CN/latest/frontend/ftq/">FTQ</a>，一旦第一个预测流水级存在有效预测结果，或者后续预测流水级产生不同的预测结果，和 <a href="https://xiangshan-doc.readthedocs.io/zh_CN/latest/frontend/ftq/">FTQ</a> 的握手信号有效位都会置高。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 握手逻辑</span></span><br><span class="line">io.bpu_to_ftq.resp.valid :=</span><br><span class="line">    s1_valid &amp;&amp; s2_components_ready &amp;&amp; s2_ready ||</span><br><span class="line">    s2_fire &amp;&amp; s2_redirect ||                          <span class="comment">// different predict result</span></span><br><span class="line">    s3_fire &amp;&amp; s3_redirect</span><br><span class="line">io.bpu_to_ftq.resp.bits  := <span class="type">BpuToFtqBundle</span>(predictors.io.out.resp)</span><br><span class="line">io.bpu_to_ftq.resp.bits.meta  := predictors.io.out.last_stage_meta <span class="comment">// <span class="doctag">TODO:</span> change to lastStageMeta</span></span><br><span class="line">io.bpu_to_ftq.resp.bits.s3.folded_hist := s3_folded_gh</span><br><span class="line">io.bpu_to_ftq.resp.bits.s3.histPtr := s3_ghist_ptr</span><br><span class="line">io.bpu_to_ftq.resp.bits.s3.lastBrNumOH := s3_last_br_num_oh</span><br><span class="line">io.bpu_to_ftq.resp.bits.s3.afhob := s3_ahead_fh_oldest_bits</span><br></pre></td></tr></table></figure>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>当不同预测阶段的预测结果不一致时，需要进行重定向：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s3_redirect_on_br_taken = resp.s3.full_pred.real_br_taken_mask().asUInt =/= previous_s2_pred.full_pred.real_br_taken_mask().asUInt</span><br><span class="line"><span class="keyword">val</span> s3_redirect_on_target = resp.s3.getTarget =/= previous_s2_pred.getTarget</span><br><span class="line"><span class="keyword">val</span> s3_redirect_on_jalr_target = resp.s3.full_pred.hit_taken_on_jalr &amp;&amp; resp.s3.full_pred.jalr_target =/= previous_s2_pred.full_pred.jalr_target</span><br><span class="line"><span class="keyword">val</span> s3_redirect_on_fall_thru_error = resp.s3.fallThruError</span><br><span class="line"></span><br><span class="line">s3_redirect := s3_fire &amp;&amp; (</span><br><span class="line">    s3_redirect_on_br_taken || s3_redirect_on_target || s3_redirect_on_fall_thru_error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preds_needs_redirect_vec</span></span>(x: <span class="type">BranchPredictionBundle</span>, y: <span class="type">BranchPredictionBundle</span>) = &#123;</span><br><span class="line">    <span class="type">VecInit</span>(</span><br><span class="line">        x.getTarget =/= y.getTarget,</span><br><span class="line">        x.lastBrPosOH.asUInt =/= y.lastBrPosOH.asUInt,</span><br><span class="line">        x.taken =/= y.taken,</span><br><span class="line">        (x.taken &amp;&amp; y.taken) &amp;&amp; x.cfiIndex.bits =/= y.cfiIndex.bits,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流水线逻辑"><a href="#流水线逻辑" class="headerlink" title="流水线逻辑"></a>流水线逻辑</h3><p>不同的预测stage之间依靠寄存器保存中间结果，当某一级发射后，相应的PC值以及分支历史等信息进入下一级：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> reset_vector = <span class="type">DelayN</span>(io.reset_vector, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> s0_pc = <span class="type">Wire</span>(<span class="type">UInt</span>(<span class="type">VAddrBits</span>.<span class="type">W</span>))</span><br><span class="line"><span class="keyword">val</span> s0_pc_reg = <span class="type">RegNext</span>(s0_pc)</span><br><span class="line">when (<span class="type">RegNext</span>(<span class="type">RegNext</span>(reset.asBool) &amp;&amp; !reset.asBool)) &#123;</span><br><span class="line">s0_pc_reg := reset_vector</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> s1_pc = <span class="type">RegEnable</span>(s0_pc, s0_fire)</span><br><span class="line"><span class="keyword">val</span> s2_pc = <span class="type">RegEnable</span>(s1_pc, s1_fire)</span><br><span class="line"><span class="keyword">val</span> s3_pc = <span class="type">RegEnable</span>(s2_pc, s2_fire)</span><br><span class="line"></span><br><span class="line"><span class="comment">// folded history</span></span><br><span class="line"><span class="keyword">val</span> s0_folded_gh = <span class="type">Wire</span>(<span class="keyword">new</span> <span class="type">AllFoldedHistories</span>(foldedGHistInfos))</span><br><span class="line"><span class="keyword">val</span> s0_folded_gh_reg = <span class="type">RegNext</span>(s0_folded_gh, <span class="number">0.</span><span class="type">U</span>.asTypeOf(s0_folded_gh))</span><br><span class="line"><span class="keyword">val</span> s1_folded_gh = <span class="type">RegEnable</span>(s0_folded_gh, <span class="number">0.</span><span class="type">U</span>.asTypeOf(s0_folded_gh), s0_fire)</span><br><span class="line"><span class="keyword">val</span> s2_folded_gh = <span class="type">RegEnable</span>(s1_folded_gh, <span class="number">0.</span><span class="type">U</span>.asTypeOf(s0_folded_gh), s1_fire)</span><br><span class="line"><span class="keyword">val</span> s3_folded_gh = <span class="type">RegEnable</span>(s2_folded_gh, <span class="number">0.</span><span class="type">U</span>.asTypeOf(s0_folded_gh), s2_fire)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ???????</span></span><br><span class="line"><span class="keyword">val</span> s0_last_br_num_oh = <span class="type">Wire</span>(<span class="type">UInt</span>((numBr+<span class="number">1</span>).<span class="type">W</span>))</span><br><span class="line"><span class="keyword">val</span> s0_last_br_num_oh_reg = <span class="type">RegNext</span>(s0_last_br_num_oh, <span class="number">0.</span><span class="type">U</span>)</span><br><span class="line"><span class="keyword">val</span> s1_last_br_num_oh = <span class="type">RegEnable</span>(s0_last_br_num_oh, <span class="number">0.</span><span class="type">U</span>, s0_fire)</span><br><span class="line"><span class="keyword">val</span> s2_last_br_num_oh = <span class="type">RegEnable</span>(s1_last_br_num_oh, <span class="number">0.</span><span class="type">U</span>, s1_fire)</span><br><span class="line"><span class="keyword">val</span> s3_last_br_num_oh = <span class="type">RegEnable</span>(s2_last_br_num_oh, <span class="number">0.</span><span class="type">U</span>, s2_fire)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ???????</span></span><br><span class="line"><span class="keyword">val</span> s0_ahead_fh_oldest_bits = <span class="type">Wire</span>(<span class="keyword">new</span> <span class="type">AllAheadFoldedHistoryOldestBits</span>(foldedGHistInfos))</span><br><span class="line"><span class="keyword">val</span> s0_ahead_fh_oldest_bits_reg = <span class="type">RegNext</span>(s0_ahead_fh_oldest_bits, <span class="number">0.</span><span class="type">U</span>.asTypeOf(s0_ahead_fh_oldest_bits))</span><br><span class="line"><span class="keyword">val</span> s1_ahead_fh_oldest_bits = <span class="type">RegEnable</span>(s0_ahead_fh_oldest_bits, <span class="number">0.</span><span class="type">U</span>.asTypeOf(s0_ahead_fh_oldest_bits), s0_fire)</span><br><span class="line"><span class="keyword">val</span> s2_ahead_fh_oldest_bits = <span class="type">RegEnable</span>(s1_ahead_fh_oldest_bits, <span class="number">0.</span><span class="type">U</span>.asTypeOf(s0_ahead_fh_oldest_bits), s1_fire)</span><br><span class="line"><span class="keyword">val</span> s3_ahead_fh_oldest_bits = <span class="type">RegEnable</span>(s2_ahead_fh_oldest_bits, <span class="number">0.</span><span class="type">U</span>.asTypeOf(s0_ahead_fh_oldest_bits), s2_fire)</span><br></pre></td></tr></table></figure>
<p>当发生重定向时，需要进行流水线冲刷</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 流水线冲刷</span></span><br><span class="line">s3_flush := redirect_req.valid <span class="comment">// flush when redirect comes</span></span><br><span class="line">s2_flush := s3_flush || s3_redirect</span><br><span class="line">s1_flush := s2_flush || s2_redirect</span><br><span class="line"></span><br><span class="line">s1_components_ready := predictors.io.s1_ready</span><br><span class="line">s1_ready := s1_fire || !s1_valid</span><br><span class="line">s0_fire := !reset.asBool &amp;&amp; s1_components_ready &amp;&amp; s1_ready    <span class="comment">// s0 chould fire when s1 ready</span></span><br><span class="line">predictors.io.s0_fire := s0_fire</span><br><span class="line"></span><br><span class="line">s2_components_ready := predictors.io.s2_ready</span><br><span class="line">s2_ready := s2_fire || !s2_valid</span><br><span class="line">s1_fire := s1_valid &amp;&amp; s2_components_ready &amp;&amp; s2_ready &amp;&amp; io.bpu_to_ftq.resp.ready</span><br><span class="line"></span><br><span class="line">s3_components_ready := predictors.io.s3_ready</span><br><span class="line">s3_ready := s3_fire || !s3_valid</span><br><span class="line">s2_fire := s2_valid &amp;&amp; s3_components_ready &amp;&amp; s3_ready</span><br><span class="line"></span><br><span class="line">when (redirect_req.valid) &#123; s1_valid := <span class="literal">false</span>.<span class="type">B</span> &#125;</span><br><span class="line">.elsewhen(s0_fire)        &#123; s1_valid := <span class="literal">true</span>.<span class="type">B</span>  &#125;</span><br><span class="line">.elsewhen(s1_flush)       &#123; s1_valid := <span class="literal">false</span>.<span class="type">B</span> &#125;</span><br><span class="line">.elsewhen(s1_fire)        &#123; s1_valid := <span class="literal">false</span>.<span class="type">B</span> &#125;</span><br><span class="line"></span><br><span class="line">predictors.io.s1_fire := s1_fire</span><br><span class="line"></span><br><span class="line">s2_fire := s2_valid        <span class="comment">// ?????????????</span></span><br><span class="line"></span><br><span class="line">when(s2_flush)       &#123; s2_valid := <span class="literal">false</span>.<span class="type">B</span> &#125;</span><br><span class="line">.elsewhen(s1_fire) &#123; s2_valid := !s1_flush &#125;</span><br><span class="line">.elsewhen(s2_fire) &#123; s2_valid := <span class="literal">false</span>.<span class="type">B</span> &#125;</span><br><span class="line"></span><br><span class="line">predictors.io.s2_fire := s2_fire</span><br><span class="line">predictors.io.s2_redirect := s2_redirect</span><br><span class="line"></span><br><span class="line">s3_fire := s3_valid</span><br><span class="line"></span><br><span class="line">when(s3_flush)       &#123; s3_valid := <span class="literal">false</span>.<span class="type">B</span> &#125;</span><br><span class="line">.elsewhen(s2_fire)   &#123; s3_valid := !s2_flush &#125;</span><br><span class="line">.elsewhen(s3_fire)   &#123; s3_valid := <span class="literal">false</span>.<span class="type">B</span> &#125;</span><br><span class="line"></span><br><span class="line">predictors.io.s3_fire := s3_fire</span><br><span class="line">predictors.io.s3_redirect := s3_redirect</span><br></pre></td></tr></table></figure>
<h3 id="分支历史管理"><a href="#分支历史管理" class="headerlink" title="分支历史管理"></a>分支历史管理</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// History manage</span></span><br><span class="line"><span class="comment">// s1</span></span><br><span class="line"><span class="keyword">val</span> s1_possible_predicted_ghist_ptrs = (<span class="number">0</span> to numBr).map(s1_ghist_ptr - _.<span class="type">U</span>)</span><br><span class="line"><span class="keyword">val</span> s1_predicted_ghist_ptr = <span class="type">Mux1H</span>(resp.s1.lastBrPosOH, s1_possible_predicted_ghist_ptrs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s1_possible_predicted_fhs = (<span class="number">0</span> to numBr).map(i =&gt;</span><br><span class="line">    s1_folded_gh.update(s1_ahead_fh_oldest_bits, s1_last_br_num_oh, i, resp.s1.brTaken &amp;&amp; resp.s1.lastBrPosOH(i)))</span><br><span class="line"><span class="keyword">val</span> s1_predicted_fh = <span class="type">Mux1H</span>(resp.s1.lastBrPosOH, s1_possible_predicted_fhs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s1_ahead_fh_ob_src = <span class="type">Wire</span>(<span class="keyword">new</span> <span class="type">AllAheadFoldedHistoryOldestBits</span>(foldedGHistInfos))</span><br><span class="line">s1_ahead_fh_ob_src.read(ghv, s1_ghist_ptr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="type">EnableGHistDiff</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> s1_predicted_ghist = <span class="type">WireInit</span>(getHist(s1_predicted_ghist_ptr).asTypeOf(<span class="type">Vec</span>(<span class="type">HistoryLength</span>, <span class="type">Bool</span>())))</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numBr) &#123;</span><br><span class="line">        when (resp.s1.shouldShiftVec(i)) &#123;</span><br><span class="line">            s1_predicted_ghist(i) := resp.s1.brTaken &amp;&amp; (i==<span class="number">0</span>).<span class="type">B</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    when (s1_valid) &#123;</span><br><span class="line">        s0_ghist := s1_predicted_ghist.asUInt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s1_ghv_wens = (<span class="number">0</span> until <span class="type">HistoryLength</span>).map(n =&gt;</span><br><span class="line">                                              (<span class="number">0</span> until numBr).map(b =&gt; (s1_ghist_ptr).value === (<span class="type">CGHPtr</span>(<span class="literal">false</span>.<span class="type">B</span>, n.<span class="type">U</span>) + b.<span class="type">U</span>).value &amp;&amp; resp.s1.shouldShiftVec(b) &amp;&amp; s1_valid))</span><br><span class="line"><span class="keyword">val</span> s1_ghv_wdatas = (<span class="number">0</span> until <span class="type">HistoryLength</span>).map(n =&gt;</span><br><span class="line">                                                <span class="type">Mux1H</span>(</span><br><span class="line">                                                    (<span class="number">0</span> until numBr).map(b =&gt; (</span><br><span class="line">                                                        (s1_ghist_ptr).value === (<span class="type">CGHPtr</span>(<span class="literal">false</span>.<span class="type">B</span>, n.<span class="type">U</span>) + b.<span class="type">U</span>).value &amp;&amp; resp.s1.shouldShiftVec(b),</span><br><span class="line">                                                        resp.s1.brTaken &amp;&amp; resp.s1.lastBrPosOH(b+<span class="number">1</span>)</span><br><span class="line">                                                    ))</span><br><span class="line">                                                )</span><br><span class="line">                                               )</span><br></pre></td></tr></table></figure>
<h3 id="结果保存"><a href="#结果保存" class="headerlink" title="结果保存"></a>结果保存</h3><p>每个stage产生的结果保存在对应的Priority Mux中</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> npcGen   = <span class="keyword">new</span> <span class="type">PhyPriorityMuxGenerator</span>[<span class="type">UInt</span>]</span><br><span class="line"><span class="keyword">val</span> foldedGhGen = <span class="keyword">new</span> <span class="type">PhyPriorityMuxGenerator</span>[<span class="type">AllFoldedHistories</span>]</span><br><span class="line"><span class="keyword">val</span> ghistPtrGen = <span class="keyword">new</span> <span class="type">PhyPriorityMuxGenerator</span>[<span class="type">CGHPtr</span>]</span><br><span class="line"><span class="keyword">val</span> lastBrNumOHGen = <span class="keyword">new</span> <span class="type">PhyPriorityMuxGenerator</span>[<span class="type">UInt</span>]</span><br><span class="line"><span class="keyword">val</span> aheadFhObGen = <span class="keyword">new</span> <span class="type">PhyPriorityMuxGenerator</span>[<span class="type">AllAheadFoldedHistoryOldestBits</span>]</span><br><span class="line"></span><br><span class="line">npcGen.register(s1_valid, resp.s1.getTarget, <span class="type">Some</span>(<span class="string">"s1_target"</span>), <span class="number">4</span>)</span><br><span class="line">foldedGhGen.register(s1_valid, s1_predicted_fh, <span class="type">Some</span>(<span class="string">"s1_FGH"</span>), <span class="number">4</span>)</span><br><span class="line">ghistPtrGen.register(s1_valid, s1_predicted_ghist_ptr, <span class="type">Some</span>(<span class="string">"s1_GHPtr"</span>), <span class="number">4</span>)</span><br><span class="line">lastBrNumOHGen.register(s1_valid, resp.s1.lastBrPosOH.asUInt, <span class="type">Some</span>(<span class="string">"s1_BrNumOH"</span>), <span class="number">4</span>)</span><br><span class="line">aheadFhObGen.register(s1_valid, s1_ahead_fh_ob_src, <span class="type">Some</span>(<span class="string">"s1_AFHOB"</span>), <span class="number">4</span>)</span><br><span class="line">ghvBitWriteGens.zip(s1_ghv_wens).zipWithIndex.map&#123;<span class="keyword">case</span> ((b, w), i) =&gt;</span><br><span class="line">    b.register(w.reduce(_||_), s1_ghv_wdatas(i), <span class="type">Some</span>(<span class="string">s"s1_new_bit_<span class="subst">$i</span>"</span>), <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">npcGen.register(s2_redirect, resp.s2.getTarget, <span class="type">Some</span>(<span class="string">"s2_target"</span>), <span class="number">5</span>)</span><br><span class="line">foldedGhGen.register(s2_redirect, s2_predicted_fh, <span class="type">Some</span>(<span class="string">"s2_FGH"</span>), <span class="number">5</span>)</span><br><span class="line">ghistPtrGen.register(s2_redirect, s2_predicted_ghist_ptr, <span class="type">Some</span>(<span class="string">"s2_GHPtr"</span>), <span class="number">5</span>)</span><br><span class="line">lastBrNumOHGen.register(s2_redirect, resp.s2.lastBrPosOH.asUInt, <span class="type">Some</span>(<span class="string">"s2_BrNumOH"</span>), <span class="number">5</span>)</span><br><span class="line">aheadFhObGen.register(s2_redirect, s2_ahead_fh_ob_src, <span class="type">Some</span>(<span class="string">"s2_AFHOB"</span>), <span class="number">5</span>)</span><br><span class="line">ghvBitWriteGens.zip(s2_ghv_wens).zipWithIndex.map&#123;<span class="keyword">case</span> ((b, w), i) =&gt;</span><br><span class="line">    b.register(w.reduce(_||_), s2_ghv_wdatas(i), <span class="type">Some</span>(<span class="string">s"s2_new_bit_<span class="subst">$i</span>"</span>), <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?????? why stage 3's prio is less than s2</span></span><br><span class="line">npcGen.register(s3_redirect, resp.s3.getTarget, <span class="type">Some</span>(<span class="string">"s3_target"</span>), <span class="number">3</span>)</span><br><span class="line">foldedGhGen.register(s3_redirect, s3_predicted_fh, <span class="type">Some</span>(<span class="string">"s3_FGH"</span>), <span class="number">3</span>)</span><br><span class="line">ghistPtrGen.register(s3_redirect, s3_predicted_ghist_ptr, <span class="type">Some</span>(<span class="string">"s3_GHPtr"</span>), <span class="number">3</span>)</span><br><span class="line">lastBrNumOHGen.register(s3_redirect, resp.s3.lastBrPosOH.asUInt, <span class="type">Some</span>(<span class="string">"s3_BrNumOH"</span>), <span class="number">3</span>)</span><br><span class="line">aheadFhObGen.register(s3_redirect, s3_ahead_fh_ob_src, <span class="type">Some</span>(<span class="string">"s3_AFHOB"</span>), <span class="number">3</span>)</span><br><span class="line">ghvBitWriteGens.zip(s3_ghv_wens).zipWithIndex.map&#123;<span class="keyword">case</span> ((b, w), i) =&gt;</span><br><span class="line">    b.register(w.reduce(_||_), s3_ghv_wdatas(i), <span class="type">Some</span>(<span class="string">s"s3_new_bit_<span class="subst">$i</span>"</span>), <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">when (<span class="type">RegNext</span>(<span class="type">RegNext</span>(reset.asBool) &amp;&amp; !reset.asBool)) &#123;    <span class="comment">// reset release</span></span><br><span class="line">    s1_pc := reset_vector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="">Proteus软件</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>FrontEnd</category>
      </categories>
  </entry>
  <entry>
    <title>Branch History Table</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/FrontEnd/BHT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>“I don’t make mistakes. I make prophecies which immediately turn out to be wrong.”</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Branch history table(BHT)是前端预测器的一种，可以根据当前跳转指令和全局或局部分支历史，预测出跳转指令的结果（跳转或不跳转），再配合branch target buffer中保存的跳转目标地址，实现无空泡的执行流。本文将针对XuanTie C910的BHT进行总结。</p>
<h2 id="玄铁BHT结构及关键模块"><a href="#玄铁BHT结构及关键模块" class="headerlink" title="玄铁BHT结构及关键模块"></a>玄铁BHT结构及关键模块</h2><p>BHT中关键的模块、功能及具体结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模块名</th>
<th>功能</th>
<th>structure</th>
</tr>
</thead>
<tbody>
<tr>
<td>x_ct_ifu_bht_pre_array</td>
<td>BHT predict array SRAM</td>
<td>可以划分为两个entry为32bits的表，分别记录大概率跳转与不跳转的分支预测信息</td>
</tr>
<tr>
<td>x_ct_ifu_bht_sel_array</td>
<td>BHT select array SRAM</td>
<td>一个entry为16bits的表，根据PC高位记录分支可能的跳转方向，做一个一级预测</td>
</tr>
</tbody>
</table>
</div>
<h2 id="关键IO及Signal-Bundle"><a href="#关键IO及Signal-Bundle" class="headerlink" title="关键IO及Signal Bundle"></a>关键IO及Signal Bundle</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><div class="table-container">
<table>
<thead>
<tr>
<th>信号名</th>
<th>功能</th>
<th>来源模块或信号</th>
</tr>
</thead>
<tbody>
<tr>
<td>bht_pred_array_index</td>
<td>predict array 更新index</td>
<td>bht_pred_array_rd_index    rd index<br />bht_wr_buf_pred_updt_index wr index, cur_ghr拼接成</td>
</tr>
<tr>
<td>bht_pred_array_din</td>
<td>predict array 更新data</td>
<td>bht_wr_buf_pred_updt_val</td>
</tr>
<tr>
<td>bht_sel_array_index</td>
<td>select array rd index</td>
<td>pcgen_bht_pcindex    rd index，读来自pcgen<br />bht_wr_buf_sel_updt_index    wr index</td>
</tr>
<tr>
<td>bht_sel_array_din</td>
<td>select array 输入</td>
<td>bht_wr_buf_sel_updt_val</td>
</tr>
<tr>
<td>bht_sel_data</td>
<td>select array data</td>
<td>bht_sel_data_out    // 直接从内存中输出<br />bht_sel_data_reg    // 从寄存器中输出(防止写内存改变输出值)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Input-from-BJU"><a href="#Input-from-BJU" class="headerlink" title="Input from BJU"></a>Input from BJU</h4><p>BJU从PCFIFO中获得预测信息后，会在EX2阶段将实际的分支信息反馈给FrontEnd，作为BHT更新时的依据</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号名</th>
<th>功能</th>
<th>来源模块或信号</th>
</tr>
</thead>
<tbody>
<tr>
<td>bju_mispred</td>
<td>是否发生误预测</td>
<td>iu_ifu_chgflw_vld</td>
</tr>
<tr>
<td>bju_pred_rst</td>
<td>BHT进行分支预测时提供的pred result</td>
<td>{iu_ifu_bht_pred, iu_ifu_chk_idx[24]}</td>
</tr>
<tr>
<td>bju_sel_rst</td>
<td>BHT进行分支预测时提供的sel result</td>
<td>iu_ifu_chk_idx[23:22]</td>
</tr>
<tr>
<td>bju_ghr</td>
<td>来自BJU的GHR</td>
<td>iu_ifu_chk_idx</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>玄铁BHT中重要的Output信号包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模块</th>
<th>信号名</th>
<th>功能</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>IPDP</td>
<td>bht_ipdp_pre_array_data_ntake;</td>
<td>pred 预测结果</td>
<td></td>
</tr>
<tr>
<td></td>
<td>bht_ipdp_pre_array_data_taken;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>bht_ipdp_pre_offset_onehot;</td>
<td>pred 位选</td>
<td></td>
</tr>
<tr>
<td></td>
<td>bht_ipdp_sel_array_result;</td>
<td>sel 预测结果</td>
<td></td>
</tr>
<tr>
<td></td>
<td>bht_ipdp_vghr</td>
<td>vghr</td>
</tr>
</tbody>
</table>
</div>
<h2 id="外部模块关系"><a href="#外部模块关系" class="headerlink" title="外部模块关系"></a>外部模块关系</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方向</th>
<th>模块名</th>
<th>信号</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Output</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Indirect BTB</td>
<td>bht_ind_btb_rtu_ghr<br />bht_ind_btb_vghr</td>
<td>为Ind BTB提供rtu ghr和ghr</td>
</tr>
<tr>
<td></td>
<td>Loop Buff</td>
<td>bht_lbuf_pre_taken\<ntaken\>_result<br />bht_lbuf_vghr</td>
<td>为loop buff提供predict 预测结果和ghr</td>
</tr>
<tr>
<td>Input</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>pcgen</td>
<td>pcgen_bht_ifpc</td>
<td>待预测pc</td>
</tr>
<tr>
<td></td>
<td></td>
<td>pcgen_bht_pcindex</td>
<td>[9:3]作为SA读时的index</td>
</tr>
<tr>
<td></td>
<td>BJU</td>
<td>bju_mispred(iu_ifu_chgflw_vld)</td>
<td>是否误预测</td>
</tr>
<tr>
<td></td>
<td></td>
<td>bju_pred_rst</td>
<td>predict result</td>
</tr>
<tr>
<td></td>
<td></td>
<td>bju_sel_rst</td>
<td>select result</td>
</tr>
<tr>
<td></td>
<td></td>
<td>bju_ghr(iu_ifu_chk_idx[21:0])</td>
<td>来自BJU的ghr</td>
</tr>
<tr>
<td></td>
<td>RTU</td>
<td>rtu_ifu_flush</td>
<td>来自RTU的前端冲刷信号(RTU状态机)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>rtu_ifu_retire0\<1/2\>_condbr_taken</td>
<td>来自RTU单元的br实际执行情况，用于更新rtughr</td>
</tr>
<tr>
<td></td>
<td>ipctrl</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="关键逻辑"><a href="#关键逻辑" class="headerlink" title="关键逻辑"></a>关键逻辑</h2><p>BHT中的一些关键逻辑包括：</p>
<ul>
<li>Bypass 逻辑</li>
<li>前端流水线逻辑<ul>
<li>IP级逻辑</li>
</ul>
</li>
<li>Select/Predict array index 计算逻辑</li>
<li>多分支处理</li>
<li>Select/Predict array </li>
<li>输出逻辑</li>
<li>BHT更新逻辑<ul>
<li>Predict array 更新逻辑</li>
<li>Select array更新逻辑</li>
</ul>
</li>
<li>GHR 更新逻辑<ul>
<li>VGHR(全局历史寄存器)</li>
<li>RTU GHR</li>
</ul>
</li>
<li>BHT write buffer逻辑</li>
<li>失效逻辑</li>
</ul>
<p>此外，在BHT部分逻辑还位于ipdp中(根据select array的结果选择predict array的结果)，实际上BHT中完成了对SA和PA的读取，进一步的筛选在ipdp中完成</p>
<h3 id="前端流水线逻辑"><a href="#前端流水线逻辑" class="headerlink" title="前端流水线逻辑"></a>前端流水线逻辑</h3><p>前端流水线由<code>bht_pipe_clk</code>进行驱动</p>
<h4 id="IP级逻辑"><a href="#IP级逻辑" class="headerlink" title="IP级逻辑"></a>IP级逻辑</h4><p>在IF到IP的逻辑中，需要将BHT的data发射到IP级，具体包括</p>
<ul>
<li>PA result: bht_ipdp_pre_array_data_taken\<ntaken\></li>
<li>SA result: bht_ipdp_sel_array_result</li>
<li>predict array offset</li>
<li>vghr</li>
<li>pre array offset</li>
</ul>
<h3 id="Select-amp-Predict-array-index-计算逻辑"><a href="#Select-amp-Predict-array-index-计算逻辑" class="headerlink" title="Select &amp; Predict array index 计算逻辑"></a>Select &amp; Predict array index 计算逻辑</h3><p>根据不同操作，predict array的index有不同来源（w/r），而对于rd_index，又可以根据分支执行状态从不同来源中得到</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @( ... )</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(rtu_ifu_flush)    <span class="comment">// RTU冲刷IFU</span></span><br><span class="line">        bht_pred_array_rd_index[<span class="number">9</span>:<span class="number">0</span>] = &#123;rtughr_reg[<span class="number">13</span>:<span class="number">10</span>],&#123;rtughr_reg[<span class="number">9</span>:<span class="number">4</span>]^rtughr_reg[<span class="number">21</span>:<span class="number">16</span>]&#125;&#125;;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bju_mispred &amp;&amp; !iu_ifu_bht_check_vld)   <span class="comment">// 误预测，不检查bht是否vld</span></span><br><span class="line">        bht_pred_array_rd_index[<span class="number">9</span>:<span class="number">0</span>] = &#123;bju_ghr[<span class="number">13</span>:<span class="number">10</span>],&#123;bju_ghr[<span class="number">9</span>:<span class="number">4</span>]^bju_ghr[<span class="number">21</span>:<span class="number">16</span>]&#125;&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bju_mispred &amp;&amp; iu_ifu_bht_check_vld)    <span class="comment">// 误预测，检查bht是否vld</span></span><br><span class="line">        bht_pred_array_rd_index[<span class="number">9</span>:<span class="number">0</span>] = &#123;bju_ghr[<span class="number">12</span>:<span class="number">9</span>],&#123;bju_ghr[<span class="number">8</span>:<span class="number">3</span>]^bju_ghr[<span class="number">20</span>:<span class="number">15</span>]&#125;&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(after_bju_mispred || after_rtu_ifu_flush)    <span class="comment">// ????</span></span><br><span class="line">        bht_pred_array_rd_index[<span class="number">9</span>:<span class="number">0</span>] = &#123;vghr_reg[<span class="number">12</span>:<span class="number">9</span>],&#123;vghr_reg[<span class="number">8</span>:<span class="number">3</span>]^vghr_reg[<span class="number">20</span>:<span class="number">15</span>]&#125;&#125;;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//ipctrl_bht_con_br_vld</span></span><br><span class="line">        bht_pred_array_rd_index[<span class="number">9</span>:<span class="number">0</span>] = &#123;vghr_reg[<span class="number">11</span>:<span class="number">8</span>],&#123;vghr_reg[<span class="number">7</span>:<span class="number">2</span>]^vghr_reg[<span class="number">19</span>:<span class="number">14</span>]&#125;&#125;;</span><br><span class="line"><span class="comment">// &amp;CombEnd; @162</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// write buff index 更新</span></span><br><span class="line"><span class="keyword">assign</span> bht_wr_buf_pred_updt_index[<span class="number">9</span>:<span class="number">0</span>] = &#123;cur_ghr[<span class="number">13</span>:<span class="number">10</span>],&#123;cur_ghr[<span class="number">9</span>:<span class="number">4</span>]^cur_ghr[<span class="number">21</span>:<span class="number">16</span>]&#125;&#125;;</span><br></pre></td></tr></table></figure>

</div></div>
<p>位选逻辑：在IF和IP阶段会分别给出pred array offset值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assign pre_offset_onehot[15:0]    = (ipctrl_bht_more_br || ipdp_bht_h0_con_br)</span><br><span class="line">                                    ? pre_offset_onehot_ip[15:0]</span><br><span class="line">                                    : pre_offset_onehot_if[15:0];</span><br><span class="line"></span><br><span class="line">assign pre_offset_onehot_ip[15:0] = (ipctrl_bht_con_br_vld)</span><br><span class="line">                                    ? pre_offset_onehot_ip_1[15:0]</span><br><span class="line">                                    : pre_offset_onehot_ip_0[15:0];</span><br><span class="line">assign pre_offset_onehot_if[15:0] = (ipctrl_bht_con_br_vld)</span><br><span class="line">                                    ? pre_offset_onehot_if_1[15:0]</span><br><span class="line">                                    : pre_offset_onehot_if_0[15:0];</span><br></pre></td></tr></table></figure>
<h3 id="多分支处理"><a href="#多分支处理" class="headerlink" title="多分支处理"></a>多分支处理</h3><p>前端在进行指令fetch时一次会取出128bits的指令block，（RISCV支持32位的标准指令与16位压缩指令，因此128位的block块可能包含4到8条指令），pcgen模块提供给BHT的用于索引的PC实际是block PC，由于一个块中可能包含多条分支指令，因此在设计过程中需要对多条分支的情况进行处理。</p>
<h4 id="如何判断是否存在多条分支"><a href="#如何判断是否存在多条分支" class="headerlink" title="如何判断是否存在多条分支"></a>如何判断是否存在多条分支</h4><p>在IF到IP的阶段，我们会进行pre-decode（该部分逻辑位于）</p>
<h3 id="BHT-更新逻辑（重要）"><a href="#BHT-更新逻辑（重要）" class="headerlink" title="BHT 更新逻辑（重要）"></a>BHT 更新逻辑（重要）</h3><h4 id="Write-Buffer结构"><a href="#Write-Buffer结构" class="headerlink" title="Write Buffer结构"></a>Write Buffer结构</h4><p>在介绍BHT更新逻辑之前，我们先介绍一下BHT的write buffer，玄铁BHT的预测表使用的是single port的SRAM，这意味着会发生RW的conflict，读的优先级要高于写，因此需要设置一个write buffer，对写进行缓冲。从结构上讲，write buffer就是一个FIFO队列，通过指针进行实现。关于FIFO的维护不做过多介绍，这里直接给出代码：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Entry 1</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> wr_buf_clk <span class="keyword">or</span> <span class="keyword">negedge</span> cpurst_b)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(!cpurst_b)</span><br><span class="line">    entry1_vld &lt;= <span class="number">1'b0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(bht_inv_on_reg)</span><br><span class="line">    entry1_vld &lt;= <span class="number">1'b0</span>;</span><br><span class="line">  <span class="comment">// 创建与销毁</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(entry_create[<span class="number">1</span>])</span><br><span class="line">    entry1_vld &lt;= <span class="number">1'b1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(entry_retire[<span class="number">1</span>])</span><br><span class="line">    entry1_vld &lt;= <span class="number">1'b0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    entry1_vld &lt;= entry1_vld;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="从哪里获取更新"><a href="#从哪里获取更新" class="headerlink" title="从哪里获取更新"></a>从哪里获取更新</h4><p>BHT的更新信息来源为<strong>Write Buffer</strong>或者<strong>BJU data</strong>，对于write buffer的entry data，会根据<code>retire_ptr[3:0]</code>进行选择。BHT会利用这些信息，对pred/sel的index以及content进行update。（Overflow 如何处理）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从iu_ifu_chk_idx中解析</span></span><br><span class="line"><span class="comment">// pcfifo_bju_chk_idx -&gt; iu_ifu_bht_pred</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If buffer entry valid</span></span><br><span class="line">cur_condbr_taken  = buf_condbr_taken;    <span class="comment">// 分支实际执行情况</span></span><br><span class="line"></span><br><span class="line">cur_sel_rst[<span class="number">1</span>:<span class="number">0</span>]  = buf_sel_rst[<span class="number">1</span>:<span class="number">0</span>];    <span class="comment">// 进行预测时sel的result</span></span><br><span class="line">cur_pred_rst[<span class="number">1</span>:<span class="number">0</span>] = buf_pred_rst[<span class="number">1</span>:<span class="number">0</span>];   <span class="comment">// 进行预测时pred的result</span></span><br><span class="line"></span><br><span class="line">cur_ghr[<span class="number">21</span>:<span class="number">0</span>]     = buf_ghr[<span class="number">21</span>:<span class="number">0</span>];       <span class="comment">// 进行预测时的分支历史</span></span><br><span class="line">cur_cur_pc[<span class="number">9</span>:<span class="number">0</span>]   = buf_cur_pc[<span class="number">9</span>:<span class="number">0</span>];     <span class="comment">// 进行预测时的PC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// else，直接利用BJU的info，不做入队处理</span></span><br><span class="line">cur_condbr_taken  = iu_ifu_bht_condbr_taken;</span><br><span class="line">cur_sel_rst[<span class="number">1</span>:<span class="number">0</span>]  = bju_sel_rst[<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">cur_pred_rst[<span class="number">1</span>:<span class="number">0</span>] = bju_pred_rst[<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">cur_ghr[<span class="number">21</span>:<span class="number">0</span>]     = bju_ghr[<span class="number">21</span>:<span class="number">0</span>];</span><br><span class="line">cur_cur_pc[<span class="number">9</span>:<span class="number">0</span>]   = iu_ifu_cur_pc[<span class="number">12</span>:<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h4 id="何时可以更新（wr）"><a href="#何时可以更新（wr）" class="headerlink" title="何时可以更新（wr）"></a>何时可以更新（wr）</h4><p>在发生BHT无效化或允许update的时候，可以进行更新：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wr enable</span></span><br><span class="line"><span class="keyword">assign</span> bht_pred_array_wr     = bht_inv_on_reg ||    </span><br><span class="line">                               bht_wr_buf_updt_vld;    <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>而update vld更新逻辑为，或者BJU检查发现可以更新，或者在wr_buf不为空且满足一系列条件时，可以更新</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> bht_wr_buf_updt_vld       = (bju_check_updt_vld ||         <span class="comment">// BJU允许更新</span></span><br><span class="line">                           bht_wr_buf_not_empty) &amp;&amp; </span><br><span class="line">                           !(</span><br><span class="line">                           after_inv_reg || </span><br><span class="line">                           ipctrl_bht_con_br_vld ||   <span class="comment">// 为何没有bju_mispred</span></span><br><span class="line">                           after_bju_mispred || </span><br><span class="line">                           rtu_ifu_flush || </span><br><span class="line">                           after_rtu_ifu_flush || </span><br><span class="line">                           pcgen_bht_chgflw &amp;&amp; !lbuf_bht_active_state ||</span><br><span class="line">                           pcgen_bht_seq_read  <span class="comment">// When read, do not write</span></span><br><span class="line">                           );</span><br><span class="line"></span><br><span class="line"><span class="comment">// BJU 检查，pred和sel vld,且分支vld</span></span><br><span class="line"><span class="keyword">assign</span> bju_check_updt_vld        = (pred_array_check_updt_vld || </span><br><span class="line">                                   sel_array_check_updt_vld) &amp;&amp; </span><br><span class="line">                                   iu_ifu_bht_check_vld;</span><br></pre></td></tr></table></figure>
<h4 id="往哪里更新"><a href="#往哪里更新" class="headerlink" title="往哪里更新"></a>往哪里更新</h4><p>(更新表选择)</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> bht_wr_buf_pred_updt_index[<span class="number">9</span>:<span class="number">0</span>] = &#123;cur_ghr[<span class="number">13</span>:<span class="number">10</span>],&#123;cur_ghr[<span class="number">9</span>:<span class="number">4</span>]^cur_ghr[<span class="number">21</span>:<span class="number">16</span>]&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> bht_wr_buf_sel_updt_index[<span class="number">6</span>:<span class="number">0</span>] = cur_cur_pc[<span class="number">9</span>:<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h4 id="如何更新（两位饱和计数器）"><a href="#如何更新（两位饱和计数器）" class="headerlink" title="如何更新（两位饱和计数器）"></a>如何更新（两位饱和计数器）</h4><p>Predict与select array更新时，需要根据现有的info，对表中的两位饱和计数器进行update，比较简单。而index和位选信号则是根据进行预测时的分支历史及PC进行计算。</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新时表索引的计算</span></span><br><span class="line"><span class="keyword">assign</span> bht_wr_buf_sel_updt_index[<span class="number">6</span>:<span class="number">0</span>] = cur_cur_pc[<span class="number">9</span>:<span class="number">3</span>];</span><br><span class="line"><span class="keyword">assign</span> bht_wr_buf_pred_updt_index[<span class="number">9</span>:<span class="number">0</span>] = &#123;cur_ghr[<span class="number">13</span>:<span class="number">10</span>],&#123;cur_ghr[<span class="number">9</span>:<span class="number">4</span>]^cur_ghr[<span class="number">21</span>:<span class="number">16</span>]&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表内容update</span></span><br><span class="line"><span class="keyword">always</span> @( cur_pred_rst[<span class="number">1</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> cur_condbr_taken)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(&#123;cur_pred_rst[<span class="number">1</span>:<span class="number">0</span>],cur_condbr_taken&#125;)</span><br><span class="line">  <span class="number">3'b001</span>  : pred_array_updt_data[<span class="number">1</span>:<span class="number">0</span>] = <span class="number">2'b01</span>;</span><br><span class="line">  <span class="number">3'b011</span>  : pred_array_updt_data[<span class="number">1</span>:<span class="number">0</span>] = <span class="number">2'b10</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span> : pred_array_updt_data[<span class="number">1</span>:<span class="number">0</span>] = <span class="number">2'b00</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>在更新数据<code>pred_array_updt_data</code>准备好后，扩展为<code>bht_wr_buf_pred_updt_val</code>，作为SRAM的输入</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> bht_pred_array_din[<span class="number">63</span>:<span class="number">0</span>] = bht_inv_on_reg </span><br><span class="line">                                ? <span class="number">64'h3333_3333_3333_3333</span> </span><br><span class="line">                                : bht_wr_buf_pred_updt_val[<span class="number">63</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h3 id="Select-array-amp-predict-array输出逻辑"><a href="#Select-array-amp-predict-array输出逻辑" class="headerlink" title="Select array &amp; predict array输出逻辑"></a>Select array &amp; predict array输出逻辑</h3><h4 id="rd-enable"><a href="#rd-enable" class="headerlink" title="rd enable"></a>rd enable</h4><p>读使能信号是sel/pred中的一个关键信号，控制BHT在正确的时机输出预测结果。pred和sel的读使能信号分别如下：</p>
<p>pred array读使能信号</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> bht_pred_array_rd     = after_inv_reg ||</span><br><span class="line">                               ipctrl_bht_con_br_vld &amp;&amp; !lbuf_bht_active_state ||   <span class="comment">// condition branch happen in IP stage</span></span><br><span class="line">                               lbuf_bht_con_br_vld &amp;&amp; lbuf_bht_active_state || </span><br><span class="line">                               bju_mispred || </span><br><span class="line">                               after_bju_mispred || </span><br><span class="line">                               rtu_ifu_flush || </span><br><span class="line">                               after_rtu_ifu_flush;</span><br></pre></td></tr></table></figure>
<p>IP阶段会进行predecode，判断一条指令是否为一个分支指令，因此pred需要在IP阶段输出一个预测结果，同时在该阶段根据sel的结果，对taken/ntaken两张表中的内容进行选择。但是这里有一个不太明白的点，为何在mispred和flush的时候也要对pred array进行读操作，从原理上来讲，当发生mispred和flush时，需要更新pred array，更新操作需要进行read。但是由于在更新时我们并不依赖预测表中的内容，而是直接根据BJU反馈的发生错误的预测结果对表进行更新，因此从实际来讲，不需要对pred array进行读。</p>
<p>sel array读使能信号如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> bht_sel_array_rd    = after_inv_reg || </span><br><span class="line">                             pcgen_bht_chgflw ||</span><br><span class="line">                             pcgen_bht_seq_read;</span><br></pre></td></tr></table></figure>
<p>从sel array的读使能信号我们可以看到，在发生chgflw以及顺序执行的情况下，我们都要对sel array进行读操作，这个也合理，因为读sel时在IF阶段，此时尚无法知道指令是否为分支指令，所以我们必须每条指令都读sel array，并在IP阶段根据是否为分支指令，对pred array进行处理。</p>
<h4 id="位选"><a href="#位选" class="headerlink" title="位选"></a>位选</h4><p>Select array 一个entry包含了8个分支预测器，由<code>pc[5:3]</code>生成一个独热码<code>if_pc_onehot</code>进行选择</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @( pcgen_bht_ifpc[<span class="number">5</span>:<span class="number">3</span>])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(pcgen_bht_ifpc[<span class="number">5</span>:<span class="number">3</span>])</span><br><span class="line">  <span class="number">3'b000</span>  : if_pc_onehot[<span class="number">7</span>:<span class="number">0</span>] = <span class="number">8'b0000_0001</span>; </span><br><span class="line">  <span class="number">3'b001</span>  : if_pc_onehot[<span class="number">7</span>:<span class="number">0</span>] = <span class="number">8'b0000_0010</span>; </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span> : if_pc_onehot[<span class="number">7</span>:<span class="number">0</span>] = <span class="number">8'b0000_0001</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">assign</span> sel_array_val_cur[<span class="number">1</span>:<span class="number">0</span>] = (&#123;<span class="number">2</span>&#123;if_pc_onehot[ <span class="number">0</span>]&#125;&#125; &amp; bht_sel_data[ <span class="number">1</span>: <span class="number">0</span>]) | </span><br><span class="line">                                (&#123;<span class="number">2</span>&#123;if_pc_onehot[ <span class="number">1</span>]&#125;&#125; &amp; bht_sel_data[ <span class="number">3</span>: <span class="number">2</span>]) |</span><br></pre></td></tr></table></figure>
<p>Predict array 类似，一个entry包含16个分支预测器，同样使用独热码进行选择</p>
<h3 id="GHR更新逻辑"><a href="#GHR更新逻辑" class="headerlink" title="GHR更新逻辑"></a>GHR更新逻辑</h3><h4 id="VGHR（Foldered-History）"><a href="#VGHR（Foldered-History）" class="headerlink" title="VGHR（Foldered History）"></a>VGHR（Foldered History）</h4><p>VGHR是BHT中的全局历史寄存器，用于记录ifu中条件分支执行情况，根据分支执行状态，VGHR有不同的更新来源：</p>
<ul>
<li>RTU冲刷时，VGHR来自RTU</li>
<li>分支跳转单元(BJU)检测到条件分支预测错误时，VGHR来自BJU</li>
<li>短循环被加载到loop buffer中时，来自短循环加速器</li>
<li>以上情况均未发生，VGHR从BHT中获取更新信息</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> bht_ghr_updt_clk <span class="keyword">or</span> <span class="keyword">negedge</span> cpurst_b)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(!cpurst_b)</span><br><span class="line">    vghr_reg[<span class="number">21</span>:<span class="number">0</span>] &lt;= <span class="number">22'b0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(bht_inv_on_reg)</span><br><span class="line">    vghr_reg[<span class="number">21</span>:<span class="number">0</span>] &lt;= <span class="number">22'b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rtu_ifu_flush &amp;&amp; cp0_ifu_bht_en)         <span class="comment">// RTU冲刷，说明在RTU阶段发现预测错误</span></span><br><span class="line">    vghr_reg[<span class="number">21</span>:<span class="number">0</span>] &lt;= rtughr_reg[<span class="number">21</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ghr_updt_vld &amp;&amp; iu_ifu_bht_check_vld)</span><br><span class="line">    vghr_reg[<span class="number">21</span>:<span class="number">0</span>] &lt;= &#123;bju_ghr[<span class="number">20</span>:<span class="number">0</span>], iu_ifu_bht_condbr_taken&#125;;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ghr_updt_vld &amp;&amp; !iu_ifu_bht_check_vld)</span><br><span class="line">    vghr_reg[<span class="number">21</span>:<span class="number">0</span>] &lt;= bju_ghr[<span class="number">21</span>:<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ???</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(vghr_lbuf_updt_vld)</span><br><span class="line">    vghr_reg[<span class="number">21</span>:<span class="number">0</span>] &lt;= &#123;vghr_reg[<span class="number">20</span>:<span class="number">0</span>], lbuf_bht_con_br_taken&#125;; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(vghr_ip_updt_vld  &amp;&amp; !lbuf_bht_active_state)</span><br><span class="line">    vghr_reg[<span class="number">21</span>:<span class="number">0</span>] &lt;= &#123;vghr_reg[<span class="number">20</span>:<span class="number">0</span>], ipctrl_bht_con_br_taken&#125;;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    vghr_reg[<span class="number">21</span>:<span class="number">0</span>] &lt;= vghr_reg[<span class="number">21</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="RTU-GHR"><a href="#RTU-GHR" class="headerlink" title="RTU GHR"></a>RTU GHR</h4><p>在乱序执行处理器中，需要一个指令退休单元，当指令离开退休单元时，意味着该指令最终成功执行，并且其结果在架构状态中是正确且可见的。但是如果在RTU阶段发现一条跳转指令方向错误了，那么需要由RTU更新一下GHR（否则如果一条分支指令从RTU正常退休，说明跳转方向正确，即BHT和RTU的结果是一致的，直接使用BHT即可）。玄铁中包含三个RTU：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @( rtu_ifu_retire2_condbr_taken</span><br><span class="line">       <span class="keyword">or</span> rtu_ifu_retire1_condbr</span><br><span class="line">       <span class="keyword">or</span> rtu_ifu_retire0_condbr_taken</span><br><span class="line">       <span class="keyword">or</span> rtughr_reg[<span class="number">21</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> rtu_ifu_retire1_condbr_taken</span><br><span class="line">       <span class="keyword">or</span> rtu_ifu_retire2_condbr</span><br><span class="line">       <span class="keyword">or</span> rtu_ifu_retire0_condbr)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(&#123;rtu_ifu_retire0_condbr, rtu_ifu_retire1_condbr, rtu_ifu_retire2_condbr&#125;)</span><br><span class="line">  <span class="number">3'b000</span>  : rtughr_pre[<span class="number">21</span>:<span class="number">0</span>] =  rtughr_reg[<span class="number">21</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="number">3'b001</span>  : rtughr_pre[<span class="number">21</span>:<span class="number">0</span>] = &#123;rtughr_reg[<span class="number">20</span>:<span class="number">0</span>], rtu_ifu_retire2_condbr_taken&#125;;</span><br><span class="line">  ... <span class="comment">// rtu状态机</span></span><br><span class="line">  <span class="keyword">default</span> : rtughr_pre[<span class="number">21</span>:<span class="number">0</span>] =  rtughr_reg[<span class="number">21</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// &amp;CombEnd; @295</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="write-buffer"><a href="#write-buffer" class="headerlink" title="write buffer"></a>write buffer</h3><p>BHT使用了一套write buffer的机制，对来自BJU的更新信息进行缓存。write buffer包含两个移位寄存器：<code>create_ptr</code>和<code>retire_ptr</code>，每次更新实际是从valid的buffer中选择一个，此处的逻辑涉及entry的create和retire</p>
<h4 id="饱和更新"><a href="#饱和更新" class="headerlink" title="饱和更新"></a>饱和更新</h4><p>pre/sel array在饱和的情况下不再更新，其中sel array更复杂一些</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assign sel_array_check_updt_vld  = !( ( 饱和不更新</span><br><span class="line">                                      // sel 表示不更新，但是实际结果是更新，且ifu chgflw not valid???</span><br><span class="line">                                      ( (bju_sel_rst[1] == 1&apos;b0) &amp;&amp; //bi-mode logic  </span><br><span class="line">                                        iu_ifu_bht_condbr_taken &amp;&amp; </span><br><span class="line">                                        !iu_ifu_chgflw_vld</span><br><span class="line">                                      ) || </span><br><span class="line">                                      ( (bju_sel_rst[1] == 1&apos;b1) &amp;&amp; //bi-mode logic</span><br><span class="line">                                        !iu_ifu_bht_condbr_taken &amp;&amp; </span><br><span class="line">                                        !iu_ifu_chgflw_vld</span><br><span class="line">                                      )</span><br><span class="line">                                    );</span><br></pre></td></tr></table></figure>
<h3 id="失效逻辑"><a href="#失效逻辑" class="headerlink" title="失效逻辑"></a>失效逻辑</h3><p>BHT中使用一个counter，定期对BHT进行失效</p>
<h2 id="逻辑筛选"><a href="#逻辑筛选" class="headerlink" title="逻辑筛选"></a>逻辑筛选</h2><ul>
<li>predict/select array w/r及模块enable，时钟enable，write bit enable，两者基本上是对称的</li>
<li>predict/select array index</li>
<li>GHR更新（GHR时钟及其使能）</li>
<li>select array最终输出逻辑</li>
<li>根据RTU的信号知道怎么了解是哪条指令mispred</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>BHT在IF阶段就开始进行预测，但是在IP阶段才能知道指令是否为分支指令</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> bht_pred_array_rd     = after_inv_reg ||</span><br><span class="line">                               ipctrl_bht_con_br_vld &amp;&amp; !lbuf_bht_active_state ||  <span class="comment">// ip阶段 decode后发现是分支指令，需要更新BHT，所以需要读pred array</span></span><br></pre></td></tr></table></figure>
<p>BHT使用了Single Port SRAM，如何解决RW conflict</p>
<p><strong>Most Important: RW confilct</strong></p>
<p>SRAM Single port：每个cycle 固定做RW，内部有仲裁，怎么做这个仲裁（worst case怎么搞，一定是考虑Worst case，RW请求连续到达该如何仲裁，Write buffer能进行写缓存，缓存该有多大，满了之后该怎么处理，停止后端？）。Multi bank，</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://zhuanlan.zhihu.com/p/460942331">玄铁C910微架构学习（3）——分支预测（一） - 知乎 (zhihu.com)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>FrontEnd</category>
      </categories>
  </entry>
  <entry>
    <title>Instruction Buffer</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/FrontEnd/IBUF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Life is all like this, meaningless, hopeless and </p>
</blockquote>
<a id="more"></a>
<h2 id="Inst-Buffer-Structure"><a href="#Inst-Buffer-Structure" class="headerlink" title="Inst Buffer Structure"></a>Inst Buffer Structure</h2><p>Inst buffer包含32个entries，每个entry的structure如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//==========================================================</span><br><span class="line">//Inst Buffer Entry Fields Description:</span><br><span class="line">//+-----+------+----------+---------+-------+-----------+--------+--------+-------+</span><br><span class="line">//| vld | inst | 32_start | acc_err | pgflt | high_expt | split1 | split0 | fence |  </span><br><span class="line">//+-----+------+----------+---------+-------+-----------+--------+--------+-------+</span><br><span class="line">//==========================================================</span><br><span class="line">//vld           means entry valid </span><br><span class="line">//inst[15:0]    means the half word inst data</span><br><span class="line">//32_start      means this half is the start of 32 inst</span><br><span class="line">//acc_err       means this half have acc_err expt</span><br><span class="line">//pgflt         means this half have pgflt expt</span><br><span class="line">//tinv          means this half have tinv expt</span><br><span class="line">//tfatal        means this half have tfatal expt</span><br><span class="line">//high_expt      means 32 bit inst &amp; expt happen at low half</span><br><span class="line">//split1        means predecode info</span><br><span class="line">//split0        means predecode info</span><br><span class="line">//fence         means predecode info</span><br></pre></td></tr></table></figure>
<h2 id="Inst-Buffer-关键逻辑"><a href="#Inst-Buffer-关键逻辑" class="headerlink" title="Inst Buffer 关键逻辑"></a>Inst Buffer 关键逻辑</h2><h3 id="空满逻辑"><a href="#空满逻辑" class="headerlink" title="空满逻辑"></a>空满逻辑</h3><p>ibuf的空满逻辑如下，当ibuf满时，需要将ibctrl进行stall</p>
<ul>
<li>Full：当ibuf中不能再保存9条指令时，为满（指针左移8位，并与vld信号比较，如果发现移动后的指针所在位置已经vld，说明ibuf full）</li>
<li>Empty：当创建的指令数和退休的指令数相同，且entry invalid，则为空</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> ibuf_full  = |(&#123;ibuf_create_pointer[ENTRY_NUM-<span class="number">9</span>:<span class="number">0</span>],</span><br><span class="line">                       ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>:ENTRY_NUM-<span class="number">8</span>]&#125; &amp; </span><br><span class="line">                       entry_vld[<span class="number">31</span>:<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">assign</span> ibuf_empty = (ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>] == </span><br><span class="line">                     ibuf_retire_num[<span class="number">4</span>:<span class="number">0</span>]) &amp;&amp; </span><br><span class="line">                    !entry_vld[<span class="number">0</span>]; <span class="comment">//in case of 32 entry all valid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> ibuf_lbuf_empty   = ibuf_empty;        </span><br><span class="line"><span class="keyword">assign</span> ibuf_ibctrl_stall = ibuf_full;</span><br><span class="line"><span class="keyword">assign</span> ibuf_ibctrl_empty = ibuf_empty;</span><br></pre></td></tr></table></figure>
<p>Empty的判断条件相对比较绕</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Time</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$T$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$2T$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$3T$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$4T$</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Create-Logic"><a href="#Create-Logic" class="headerlink" title="Create Logic"></a>Create Logic</h3><p>在<code>ibuf</code>的create逻辑中，我们重点需要解决两个问题：</p>
<ul>
<li>在<code>ibuf</code>什么位置保存指令（pointer logic）</li>
<li>指令是否需要保存在<code>ibuf</code>中（vld logic）</li>
</ul>
<h4 id="Create-pointer-logic"><a href="#Create-pointer-logic" class="headerlink" title="Create pointer logic"></a>Create pointer logic</h4><p>对于一个FIFO，我们会有入队列和出队列两种逻辑，而在ibuf中，入队列的逻辑是由create pointer logic进行控制的，使用了一个变量<code>ibuf_create_pointer</code>作为FIFO的指针。当CPU进行rst之后，<code>ibuf_create_pointer</code>的值为0x00000001。更新create pointer时，会根据半字的数量，预先生成create pointer</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @( ibuf_create_pointer[<span class="number">31</span>:<span class="number">0</span>]</span><br><span class="line">         <span class="keyword">or</span> ibdp_ibuf_half_vld_num[<span class="number">3</span>:<span class="number">0</span>])    <span class="comment">// 根据半字的数量，决定create_pointer</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(ibdp_ibuf_half_vld_num[<span class="number">3</span>:<span class="number">0</span>])</span><br><span class="line">  <span class="number">4'b0001</span> : create_pointer_pre[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = &#123;ibuf_create_pointer[ENTRY_NUM-<span class="number">2</span>:<span class="number">0</span>],  <span class="comment">// 坐移一位</span></span><br><span class="line">                                                 ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>]&#125;;</span><br><span class="line">  <span class="number">4'b0010</span> : create_pointer_pre[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = &#123;ibuf_create_pointer[ENTRY_NUM-<span class="number">3</span>:<span class="number">0</span>],  <span class="comment">// 左移两位</span></span><br><span class="line">                                                 ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>:ENTRY_NUM-<span class="number">2</span>]&#125;;</span><br><span class="line">  <span class="number">4'b1001</span>:</span><br><span class="line"> <span class="comment">// 左移九位</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// &amp;CombEnd; @187</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将准备好的pointer赋给实际的ibuf create pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> ibuf_create_pointer_update_clk <span class="keyword">or</span> <span class="keyword">negedge</span> cpurst_b)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(!cpurst_b || ibuf_flush)</span><br><span class="line">    ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] &lt;= &#123;&#123;(ENTRY_NUM-<span class="number">1</span>)&#123;<span class="number">1'b0</span>&#125;&#125;, <span class="number">1'b1</span>&#125;;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ibuf_create_vld)</span><br><span class="line">    ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] &lt;= create_pointer_pre[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] &lt;= ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于最多有9条指令需要被保存在ibuf中，因此我们会创建9个pointer（通过左移指向待保存的位置）。这个半字的数量是由<code>ibdp_ibuf_half_vld_num</code>决定的，根据block中是否存在条件分支或转移语句，决定提供给<code>ib</code>阶段的半字有多少个：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> ibdp_half_vld_num[<span class="number">3</span>:<span class="number">0</span>]    = (ipdp_ibdp_con_br_num_vld)</span><br><span class="line">                                 ? ipdp_ibdp_con_br_num[<span class="number">3</span>:<span class="number">0</span>]</span><br><span class="line">                                 : (ipdp_ibdp_chgflw_num_vld)</span><br><span class="line">                                   ? ipdp_ibdp_chgflw_num[<span class="number">3</span>:<span class="number">0</span>]</span><br><span class="line">                                   : ipdp_ibdp_no_chgflw_num[<span class="number">3</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>所以，此处create<em>pointer_pre表示ibuf需要预先创建多少个指针用来保存需要存在<code>ibuf</code>中的指令数目$N</em>{max}$，但是实际保存的指令数目$N&lt;N_{max}$。那么，实际需要保存至<code>ibuf</code>中的指令数目该如何计算呢，设<code>ibuf</code>中当前保存的指令数目为$N_0$，那么理论上需要保存的有效指令数最大为$n_v$，则<code>ibuf</code>中预计需要保存到指令数为：</p>
<script type="math/tex; mode=display">
N_{max}=N_0+n_v</script><p>$N_{max}$表示无bypass的情况。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @( ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> ibdp_ibuf_half_vld_num[<span class="number">3</span>:<span class="number">0</span>])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(ibdp_ibuf_half_vld_num[<span class="number">3</span>:<span class="number">0</span>])</span><br><span class="line">  <span class="number">4'b0001</span> : create_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>] + <span class="number">5'd1</span>;</span><br><span class="line">  <span class="number">4'b0010</span> : create_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>] + <span class="number">5'd2</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="number">4'b1001</span> : create_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>] + <span class="number">5'd9</span>;</span><br><span class="line">  <span class="keyword">default</span> : create_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// &amp;CombEnd; @282</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>而实际保存的指令需要减掉bypass的指令数$n_b$，故最终保存在ibuf中有效的指令数目为：</p>
<script type="math/tex; mode=display">
N=N_{max}-n_b\\
=N_0+n_v-n_b</script><p>而$n_b$在处理bypass的情况时进行计算</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @( ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> bypass_way_inst2_valid</span><br><span class="line">       <span class="keyword">or</span> bypass_way_half_num[<span class="number">2</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> create_num_pre[<span class="number">4</span>:<span class="number">0</span>])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">casez</span>(&#123;bypass_way_inst2_valid, bypass_way_half_num[<span class="number">2</span>:<span class="number">0</span>]&#125;)</span><br><span class="line">  <span class="number">4'b0</span>??? : create_num_pre_bypass[<span class="number">4</span>:<span class="number">0</span>] = ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="number">4'b1011</span> : create_num_pre_bypass[<span class="number">4</span>:<span class="number">0</span>] = create_num_pre[<span class="number">4</span>:<span class="number">0</span>] - <span class="number">5'd3</span>;</span><br><span class="line">  <span class="number">4'b1100</span> : create_num_pre_bypass[<span class="number">4</span>:<span class="number">0</span>] = create_num_pre[<span class="number">4</span>:<span class="number">0</span>] - <span class="number">5'd4</span>;</span><br><span class="line">  <span class="number">4'b1101</span> : create_num_pre_bypass[<span class="number">4</span>:<span class="number">0</span>] = create_num_pre[<span class="number">4</span>:<span class="number">0</span>] - <span class="number">5'd5</span>;</span><br><span class="line">  <span class="number">4'b1110</span> : create_num_pre_bypass[<span class="number">4</span>:<span class="number">0</span>] = create_num_pre[<span class="number">4</span>:<span class="number">0</span>] - <span class="number">5'd6</span>;</span><br><span class="line">  <span class="keyword">default</span> : create_num_pre_bypass[<span class="number">4</span>:<span class="number">0</span>] = create_num_pre[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>实际的指针如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> ibuf_create_pointer0[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] =  ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> ibuf_create_pointer1[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = &#123;ibuf_create_pointer[ENTRY_NUM-<span class="number">2</span>:<span class="number">0</span>],</span><br><span class="line">                                              ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>]&#125;;</span><br><span class="line"><span class="keyword">assign</span> ibuf_create_pointer2[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = &#123;ibuf_create_pointer[ENTRY_NUM-<span class="number">3</span>:<span class="number">0</span>],</span><br><span class="line">                                              ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>:ENTRY_NUM-<span class="number">2</span>]&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">assign</span> ibuf_create_pointer8[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = &#123;ibuf_create_pointer[ENTRY_NUM-<span class="number">9</span>:<span class="number">0</span>],</span><br><span class="line">                                              ibuf_create_pointer[ENTRY_NUM-<span class="number">1</span>:ENTRY_NUM-<span class="number">8</span>]&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Create-Num-Logic"><a href="#Create-Num-Logic" class="headerlink" title="Create Num Logic"></a>Create Num Logic</h4><p>在对FIFO进行入队列操作时，我们还需要对进入FIFO的指令数量进行统计，这个参数会被用于判断bypass是否有效，以及<code>ibuf</code>是否为空，计算方法如下：</p>
<script type="math/tex; mode=display">
N[n]=N[n-1]+V</script><p>其中，$V$是用于保存至ibuf中的有效半字个数</p>
<h5 id="Merge-情况处理"><a href="#Merge-情况处理" class="headerlink" title="Merge 情况处理"></a>Merge 情况处理</h5><p>当ibuf中存在指令，但是指令不足以凑成完整的三条送入idu时，需要和ip送来的指令进行Merge</p>
<p><strong>Merge 指令数量计算</strong></p>
<p>我们需要根据ibuf中能pop出的指令数目，来确认需要bypass提供的merge指令数目</p>
<script type="math/tex; mode=display">
N_m=3-N_{pop}</script><p>其中，$N_m$为bypass提供的与pop的指令进行merge的指令（32位）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casez</span>(&#123;ibuf_pop_inst1_valid,bypass_way_inst0_32_start,bypass_way_inst1_valid,bypass_way_inst1_32_start&#125;)</span><br><span class="line">   <span class="comment">// if inst1 is valid, bypass only needs merge 1</span></span><br><span class="line">   <span class="number">4'b10</span>?? : merge_way_inst1_num[<span class="number">4</span>:<span class="number">0</span>] = <span class="number">5'b00001</span>;</span><br><span class="line">   <span class="number">4'b11</span>?? : merge_way_inst1_num[<span class="number">4</span>:<span class="number">0</span>] = <span class="number">5'b00010</span>;</span><br><span class="line">   <span class="number">4'b000</span>? : merge_way_inst1_num[<span class="number">4</span>:<span class="number">0</span>] = <span class="number">5'b00001</span>;</span><br><span class="line">   <span class="number">4'b0010</span> : merge_way_inst1_num[<span class="number">4</span>:<span class="number">0</span>] = <span class="number">5'b00010</span>;</span><br><span class="line">   <span class="number">4'b0011</span> : merge_way_inst1_num[<span class="number">4</span>:<span class="number">0</span>] = <span class="number">5'b00011</span>;</span><br><span class="line">   <span class="number">4'b010</span>? : merge_way_inst1_num[<span class="number">4</span>:<span class="number">0</span>] = <span class="number">5'b00010</span>;</span><br><span class="line">   <span class="number">4'b0110</span> : merge_way_inst1_num[<span class="number">4</span>:<span class="number">0</span>] = <span class="number">5'b00011</span>;</span><br><span class="line">   <span class="number">4'b0111</span> : merge_way_inst1_num[<span class="number">4</span>:<span class="number">0</span>] = <span class="number">5'b00100</span>;</span><br><span class="line">   <span class="keyword">default</span> : merge_way_inst1_num[<span class="number">4</span>:<span class="number">0</span>] = <span class="number">5'b00000</span>;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// &amp;CombEnd; @5278</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当发生merge时</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &amp;CombBeg; @315</span></span><br><span class="line"><span class="keyword">always</span> @( merge_half_num[<span class="number">4</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> ibuf_retire_num[<span class="number">4</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> ibuf_pop_inst2_valid</span><br><span class="line">       <span class="keyword">or</span> ibuf_pop3_half_num[<span class="number">2</span>:<span class="number">0</span>])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">casez</span>(&#123;ibuf_pop_inst2_valid, ibuf_pop3_half_num[<span class="number">2</span>:<span class="number">0</span>]&#125;)</span><br><span class="line">  <span class="comment">// This is the merge number when merge happened, but don't know why add merge_half_num</span></span><br><span class="line">  <span class="comment">// 这个是什么原理，为啥是创建的数目+merge的bypass数目</span></span><br><span class="line">  <span class="number">4'b0</span>??? : retire_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>] + merge_half_num[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="number">4'b1011</span> : retire_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_retire_num[<span class="number">4</span>:<span class="number">0</span>] + <span class="number">5'd3</span>;</span><br><span class="line">  <span class="number">4'b1100</span> : retire_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_retire_num[<span class="number">4</span>:<span class="number">0</span>] + <span class="number">5'd4</span>;</span><br><span class="line">  <span class="number">4'b1101</span> : retire_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_retire_num[<span class="number">4</span>:<span class="number">0</span>] + <span class="number">5'd5</span>;</span><br><span class="line">  <span class="number">4'b1110</span> : retire_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_retire_num[<span class="number">4</span>:<span class="number">0</span>] + <span class="number">5'd6</span>;</span><br><span class="line">  <span class="keyword">default</span> : retire_num_pre[<span class="number">4</span>:<span class="number">0</span>] = ibuf_retire_num[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// &amp;CombEnd; @324</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>Merge retire指针计算</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casez</span>(&#123;ibuf_pop_inst1_valid,bypass_way_inst0_32_start,bypass_way_inst1_valid,bypass_way_inst1_32_start&#125;)</span><br><span class="line">   <span class="number">4'b10</span>?? : merge_way_retire_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = ibuf_create_pointer1[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">   <span class="number">4'b11</span>?? : merge_way_retire_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = ibuf_create_pointer2[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>]; </span><br><span class="line">   ...</span><br><span class="line">   <span class="number">4'b0111</span> : merge_way_retire_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = ibuf_create_pointer4[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">default</span> : merge_way_retire_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = ibuf_create_pointer0[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// &amp;CombEnd; @5292</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="Create-Valid-Logic"><a href="#Create-Valid-Logic" class="headerlink" title="Create Valid Logic"></a>Create Valid Logic</h4><p>在前面的小节中我们讨论了当向<code>ibuf</code>中保存指令时Create指针移动的逻辑，本节讨论哪些指令需要保存在<code>ibuf</code>中或从<code>ibuf</code>中退休，即entry create &amp; retire vld的逻辑。在Xuantie的代码中，使用了<code>entry_create_*</code>和<code>entry_retire_*</code>两个32位的变量，与<code>ibuf</code>的32个entry一一对应，用于表示哪一个entry需要创建或退休。本文首先讨论entry create的逻辑。</p>
<p>在entry create的逻辑中，Xuantie的代码分为了nopass和bypass两种类型进行讨论，实际nopass还可以分为merge和pop两种情况。对于nopass的情况，我们依据三个条件确定需要create的entry：</p>
<ul>
<li><code>ibuf</code>create指针所在位置，即create_pointer0-9</li>
<li>传递给<code>ibuf</code>的指令的有效性，即ib_hn_create_vld[8:0]</li>
<li>merge指令的掩码（当merge无效时为全1，此时无merge指令，否则根据merge指令数量及指令是否为32bit，确定掩码）</li>
</ul>
<p>对于bypass的情况，则根据<code>ibuf</code>create指针所在位置以及bypass的指令数量及类型，确定create的entry。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span>  : <span class="keyword">begin</span> <span class="comment">//1?1?1</span></span><br><span class="line">           bypass_way_inst0_valid       = bypass_way_h0_vld;</span><br><span class="line">           ...</span><br><span class="line">           bypass_way_half_num[<span class="number">2</span>:<span class="number">0</span>]     = <span class="number">3'b110</span>;</span><br><span class="line">           ib_hn_create_vld_bypass[<span class="number">8</span>:<span class="number">0</span>] = &#123;<span class="number">6'b0</span>,ib_hn_create_vld[<span class="number">2</span>:<span class="number">0</span>]&#125;;</span><br></pre></td></tr></table></figure>
<p>得到32位create vld bits后，会将每一位赋给entry，作为vld信号。注意，<strong>vld信号仅控制control signal的更新，保存在entry中的数据不受vld信号控制</strong>。control signal包括：</p>
<ol>
<li>entry是否vld</li>
<li>entry中的指令是否为32位指令前半部分</li>
</ol>
<h4 id="Create-Input-Data-Generate"><a href="#Create-Input-Data-Generate" class="headerlink" title="Create Input Data Generate"></a>Create Input Data Generate</h4><p>在得到<code>ibuf</code>的entry create vld信号后，还需要组织向<code>ibuf</code>中保存的指令的信息，这一部分逻辑较为简单，从3667行到5520行为该段逻辑。</p>
<h3 id="retire-logic"><a href="#retire-logic" class="headerlink" title="retire logic"></a>retire logic</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @( ibuf_merge_retire_pointer[<span class="number">31</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> ibuf_retire_pointer[<span class="number">31</span>:<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">or</span> ibuf_pop_inst2_valid</span><br><span class="line">       <span class="keyword">or</span> ibuf_pop3_half_num[<span class="number">2</span>:<span class="number">0</span>])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">casez</span>(&#123;ibuf_pop_inst2_valid, ibuf_pop3_half_num[<span class="number">2</span>:<span class="number">0</span>]&#125;)</span><br><span class="line">  <span class="number">4'b0</span>??? : retire_pointer_pre[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] =  ibuf_merge_retire_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="number">4'b1011</span> : retire_pointer_pre[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = &#123;ibuf_retire_pointer[ENTRY_NUM-<span class="number">4</span>:<span class="number">0</span>],</span><br><span class="line">                                                 ibuf_retire_pointer[ENTRY_NUM-<span class="number">1</span>:ENTRY_NUM-<span class="number">3</span>]&#125;;</span><br><span class="line">  <span class="number">4'b1100</span> : retire_pointer_pre[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = &#123;ibuf_retire_pointer[ENTRY_NUM-<span class="number">5</span>:<span class="number">0</span>],</span><br><span class="line">                                                 ibuf_retire_pointer[ENTRY_NUM-<span class="number">1</span>:ENTRY_NUM-<span class="number">4</span>]&#125;;</span><br><span class="line">  <span class="number">4'b1101</span> : retire_pointer_pre[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = &#123;ibuf_retire_pointer[ENTRY_NUM-<span class="number">6</span>:<span class="number">0</span>],</span><br><span class="line">                                                 ibuf_retire_pointer[ENTRY_NUM-<span class="number">1</span>:ENTRY_NUM-<span class="number">5</span>]&#125;;</span><br><span class="line">  <span class="number">4'b1110</span> : retire_pointer_pre[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] = &#123;ibuf_retire_pointer[ENTRY_NUM-<span class="number">7</span>:<span class="number">0</span>],</span><br><span class="line">                                                 ibuf_retire_pointer[ENTRY_NUM-<span class="number">1</span>:ENTRY_NUM-<span class="number">6</span>]&#125;;</span><br><span class="line">  <span class="keyword">default</span> : retire_pointer_pre[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>] =  ibuf_retire_pointer[ENTRY_NUM-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// &amp;CombEnd; @399</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="Retire-Valid-Logic"><a href="#Retire-Valid-Logic" class="headerlink" title="Retire Valid Logic"></a>Retire Valid Logic</h4><p>Retire Valid逻辑相比Create来说较为简单，首先由<code>retire_pointer*</code>确定可能retire的entry，然后和<code>retire_vld_*</code>进行mask，而<code>retire_vld_*</code>根据实际从<code>ibuf</code>中pop的指令数量确定</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casez</span>(&#123;pop_h0_32_start,pop_h1_32_start,pop_h2_32_start,</span><br><span class="line">       pop_h3_32_start,pop_h4_32_start&#125;)</span><br><span class="line">       <span class="number">5'b000</span>?? : <span class="keyword">begin</span></span><br><span class="line">                  ibuf_pop_inst0_valid      = pop_h0_vld;</span><br><span class="line">                  ibuf_pop_inst0_data[<span class="number">31</span>:<span class="number">0</span>] = &#123;<span class="number">16'b0</span>,pop_h0_data[<span class="number">15</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                  ibuf_pop_inst0_pc[<span class="number">14</span>:<span class="number">0</span>]   = pop_h0_pc[<span class="number">14</span>:<span class="number">0</span>];                  </span><br><span class="line">                  <span class="comment">// inst0-2's data</span></span><br><span class="line">                  ibuf_pop3_half_num[<span class="number">2</span>:<span class="number">0</span>]   = <span class="number">3'b011</span>;    <span class="comment">// Get poped half number</span></span><br><span class="line">                  ibuf_pop3_retire_vld[<span class="number">5</span>:<span class="number">0</span>] = <span class="number">6'b111000</span>; <span class="comment">// Get the retire mask</span></span><br></pre></td></tr></table></figure>
<h2 id="Bypass-逻辑"><a href="#Bypass-逻辑" class="headerlink" title="Bypass 逻辑"></a>Bypass 逻辑</h2><h3 id="何时进行bypass"><a href="#何时进行bypass" class="headerlink" title="何时进行bypass"></a>何时进行bypass</h3><p>在ibuf为空时，将会对指令进行bypass，最多bypass3条指令，其余的将会被保存在ibuf中。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> bypass_vld = (ibuf_create_num[<span class="number">4</span>:<span class="number">0</span>] == </span><br><span class="line">                     ibuf_retire_num[<span class="number">4</span>:<span class="number">0</span>]) &amp;&amp; </span><br><span class="line">                     !ibctrl_ibuf_bypass_not_select;</span><br></pre></td></tr></table></figure>
<h3 id="Inst-attr"><a href="#Inst-attr" class="headerlink" title="Inst attr"></a>Inst attr</h3><p>在IBUF的bypass逻辑中，最多可以输出三条指令（16bits或32bits）。首先，ibuf以16bits为单位，对h0到h5的属性进行了判断</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> bypass_way_h0_vld = (ibdp_ibuf_h0_vld)</span><br><span class="line">                         ? ibdp_ibuf_h0_vld</span><br><span class="line">                         : ibdp_ibuf_hn_vld[<span class="number">7</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">assign</span> bypass_way_h4_vld = (ibdp_ibuf_h0_vld)</span><br><span class="line">                         ? ibdp_ibuf_hn_vld[<span class="number">4</span>]</span><br><span class="line">                         : ibdp_ibuf_hn_vld[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h3 id="Inst-Gen"><a href="#Inst-Gen" class="headerlink" title="Inst Gen"></a>Inst Gen</h3><p>指令生成逻辑。在bypass valid的情况下，ibuf最多会提供三条指令（16或32位），此时的逻辑如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/bypass_logic1.svg" width = "580" alt="图片名称" align=center /></p>
<p>ibuf中会根据<code>bypass_way_hn_32_start</code>的标志位来进行指令的生成（8570-9383行），同时记录bypass了几条half的指令</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casez</span>(&#123;bypass_way_h0_32_start,bypass_way_h1_32_start,bypass_way_h2_32_start,</span><br><span class="line">       bypass_way_h3_32_start,bypass_way_h4_32_start&#125;)</span><br><span class="line">        <span class="number">5'b1</span>?<span class="number">1</span>?<span class="number">0</span> : <span class="keyword">begin</span></span><br><span class="line">                  bypass_way_inst0_valid       = bypass_way_h0_vld;</span><br><span class="line">                  bypass_way_inst0_data[<span class="number">31</span>:<span class="number">0</span>]  = &#123;bypass_way_h1_data[<span class="number">15</span>:<span class="number">0</span>],bypass_way_h0_data[<span class="number">15</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                  ... <span class="comment">// inst 0 attrs</span></span><br><span class="line">                  bypass_way_inst1_valid       = bypass_way_h2_vld;</span><br><span class="line">                  bypass_way_inst1_data[<span class="number">31</span>:<span class="number">0</span>]  = &#123;bypass_way_h3_data[<span class="number">15</span>:<span class="number">0</span>],bypass_way_h2_data[<span class="number">15</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                  bypass_way_inst1_pc[<span class="number">14</span>:<span class="number">0</span>]    = bypass_way_h2_pc[<span class="number">14</span>:<span class="number">0</span>];                  </span><br><span class="line">                  ...</span><br><span class="line">                  bypass_way_inst2_data[<span class="number">31</span>:<span class="number">0</span>]  = &#123;<span class="number">16'b0</span>,bypass_way_h4_data[<span class="number">15</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">                  bypass_way_inst2_pc[<span class="number">14</span>:<span class="number">0</span>]    = bypass_way_h4_pc[<span class="number">14</span>:<span class="number">0</span>];                  </span><br><span class="line">                  ...</span><br><span class="line">                  bypass_way_half_num[<span class="number">2</span>:<span class="number">0</span>]     = <span class="number">3'b101</span>;    <span class="comment">//一共bypass了5条half指令</span></span><br><span class="line">                  ib_hn_create_vld_bypass[<span class="number">8</span>:<span class="number">0</span>] = &#123;<span class="number">5'b0</span>,ib_hn_create_vld[<span class="number">3</span>:<span class="number">0</span>]&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="指令Merge逻辑"><a href="#指令Merge逻辑" class="headerlink" title="指令Merge逻辑"></a>指令Merge逻辑</h2><p>在<code>ibuf</code>中，需要根据ibuf中所保存的指令，将Bypass和ibuf中获得的指令进行Merge，并得到最终送给decoder的指令。其代码片段如下，此处容易迷惑的点是这里虽然叫<code>merge_way_inst0</code>，<strong>但是实际上指的是用于指令merge的bypass的指令</strong>。当需要从ibuf中取出指令时，bypass最多提供两条指令进行merge，所以此处我们只需要考虑<code>inst0</code>和<code>inst1</code>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> merge_way_inst0_sel        = !ibuf_pop_inst1_valid;</span><br><span class="line"><span class="keyword">assign</span> merge_way_inst0_valid      = bypass_way_inst0_valid &amp;&amp; ibctrl_ibuf_merge_vld;</span><br><span class="line"><span class="keyword">assign</span> merge_way_inst0[<span class="number">31</span>:<span class="number">0</span>]      = bypass_way_inst0_data[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> merge_way_inst1_sel        = !ibuf_pop_inst1_valid || !ibuf_pop_inst2_valid;</span><br><span class="line"><span class="keyword">assign</span> merge_way_inst1_valid      = (ibuf_pop_inst1_valid) ? bypass_way_inst0_valid &amp;&amp; ibctrl_ibuf_merge_vld</span><br><span class="line">                                                           : bypass_way_inst1_valid &amp;&amp; ibctrl_ibuf_merge_vld;</span><br><span class="line"><span class="keyword">assign</span> merge_way_inst1[<span class="number">31</span>:<span class="number">0</span>]      = (ibuf_pop_inst1_valid) ? bypass_way_inst0_data[<span class="number">31</span>:<span class="number">0</span>]: bypass_way_inst1_data[<span class="number">31</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>我们考虑如下几种情况：</p>
<ul>
<li>情况一：ibuf中的3条指令都有效</li>
</ul>
<p>此时直接使用ibuf中pop出来的指令，无需进行merge</p>
<ul>
<li>情况二：ibuf中<code>inst1</code>或<code>inst2</code>无效，此时分为如下几种情况讨论：<ul>
<li><code>inst1</code>无效</li>
<li><code>inst2</code>无效</li>
<li><code>inst1</code>和<code>inst2</code>均无效</li>
</ul>
</li>
</ul>
<p>对于第一种子情况，得到的结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">merge_way_inst0 = bypass_way_inst0_data;</span><br><span class="line">merge_way_inst1 = bypass_way_inst1_data;</span><br></pre></td></tr></table></figure>
<p>对于第二种子情况，得到的结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">merge_way_inst0 <span class="comment">// 不会被选择</span></span><br><span class="line">merge_way_inst1 = bypass_way_inst1_data;</span><br></pre></td></tr></table></figure>
<p>对于第三种子情况，得到的结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">merge_way_inst0 = bypass_way_inst0_data;</span><br><span class="line">merge_way_inst1 = bypass_way_inst1_data;</span><br></pre></td></tr></table></figure>
<p>最终，从<code>ibuf</code>提供给<code>ibdp</code>的三条指令如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> ibuf_ibdp_inst0[<span class="number">31</span>:<span class="number">0</span>]      = ibuf_pop_inst0_data[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> ibuf_ibdp_inst1[<span class="number">31</span>:<span class="number">0</span>]      = (merge_way_inst0_sel) ? merge_way_inst0[<span class="number">31</span>:<span class="number">0</span>]     :  ibuf_pop_inst1_data[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> ibuf_ibdp_inst2[<span class="number">31</span>:<span class="number">0</span>]      = (merge_way_inst1_sel) ? merge_way_inst1[<span class="number">31</span>:<span class="number">0</span>]     :  ibuf_pop_inst2_data[<span class="number">31</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>这三条指令已经包含了merge bypass的过程，因此可以在ib阶段直接进行mux，选择需要送给decoder的三条指令即可：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span>(&#123;bypass_inst_vld,ibuf_inst_vld,lbuf_inst_vld&#125;)</span><br><span class="line"> <span class="comment">// Pure bypass</span></span><br><span class="line"> <span class="number">3'b100</span>: <span class="keyword">begin</span></span><br><span class="line">         inst0[<span class="number">31</span>:<span class="number">0</span>]      = ibuf_ibdp_bypass_inst0[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">         inst1[<span class="number">31</span>:<span class="number">0</span>]      = ibuf_ibdp_bypass_inst1[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">         inst2[<span class="number">31</span>:<span class="number">0</span>]      = ibuf_ibdp_bypass_inst2[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line"> <span class="comment">// ibuf merged with bypass    </span></span><br><span class="line"> <span class="number">3'b010</span>:  <span class="keyword">begin</span></span><br><span class="line">         inst0[<span class="number">31</span>:<span class="number">0</span>]      = ibuf_ibdp_inst0[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">         inst1[<span class="number">31</span>:<span class="number">0</span>]      = ibuf_ibdp_inst1[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">         inst2[<span class="number">31</span>:<span class="number">0</span>]      = ibuf_ibdp_inst2[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line"> <span class="comment">// lbuf</span></span><br><span class="line"> <span class="number">3'b001</span>:  <span class="keyword">begin</span></span><br><span class="line">         inst0[<span class="number">31</span>:<span class="number">0</span>]      = lbuf_ibdp_inst0[<span class="number">31</span>:<span class="number">0</span>]; </span><br><span class="line">         inst1[<span class="number">31</span>:<span class="number">0</span>]      = lbuf_ibdp_inst1[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">         inst2[<span class="number">31</span>:<span class="number">0</span>]      = lbuf_ibdp_inst2[<span class="number">31</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h2 id="Design-4-normal-inst-bypass"><a href="#Design-4-normal-inst-bypass" class="headerlink" title="Design: 4 normal inst bypass"></a>Design: 4 normal inst bypass</h2><p>为了增加ibuf的吞吐量，我们为<code>ibuf</code>设计了一个新的bypass路径，当fetch的指令为4条normal类型的指令，且<code>ibuf</code>为空的情况下，我们会将这四条normal指令直接送至IDU进行decoder处理，此时control signal新增一条</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assign bypass_all_inst_vld  = ibctrl_ibdp_bypass_all_inst_vld;</span><br><span class="line"></span><br><span class="line">assign bypass_inst_vld = ibctrl_ibdp_bypass_inst_vld &amp; !bypass_all_inst_vld;</span><br><span class="line">assign ibuf_inst_vld   = ibctrl_ibdp_ibuf_inst_vld &amp; !bypass_all_inst_vld;</span><br><span class="line">assign lbuf_inst_vld   = ibctrl_ibdp_lbuf_inst_vld &amp; !bypass_all_inst_vld;</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>在Bypass逻辑的判断过程中，为何是h0-h4而不是h0-h5？</li>
</ol>
<p>因为根据h0-h4即可知道全部bypass inst的信息，首先如果h4是一条16bits的语句，那么bypass的指令必然没有h5；如果h4是32位指令，那么{h4, h5}可以拼成一条32位指令，根据h4即可获得h5的信息</p>
<ol>
<li>在Merge的逻辑判断过程中，为何没有考虑ibuf的inst0无效的逻辑？</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> ibuf_ibdp_inst0[<span class="number">31</span>:<span class="number">0</span>]      = ibuf_pop_inst0_data[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> ibuf_ibdp_inst1[<span class="number">31</span>:<span class="number">0</span>]      = (merge_way_inst0_sel) ? merge_way_inst0[<span class="number">31</span>:<span class="number">0</span>]     :  ibuf_pop_inst1_data[<span class="number">31</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="">Proteus软件</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>FrontEnd</category>
      </categories>
  </entry>
  <entry>
    <title>Branch Target Buffer</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/FrontEnd/BTB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>“I don’t make mistakes. I make prophecies which immediately turn out to be wrong.”</p>
<a id="more"></a>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="">Proteus软件</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>FrontEnd</category>
      </categories>
  </entry>
  <entry>
    <title>Front End Compare</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/FrontEnd/Front%20End%20Compare/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>人类从历史中学到的唯一的教训，就是没有从历史中吸取到任何教训。</p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文将对香山/BOOM/玄铁几款CPU的前端组成及结构进行比较整理，包括FrontEnd结构及流水级</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>香山</th>
<th>玄铁</th>
<th>BOOM</th>
</tr>
</thead>
<tbody>
<tr>
<td>branch target</td>
<td>l0 BTB</td>
<td>uBTB ()</td>
<td>l0 BTB</td>
<td>uBTB(很小的全相联buffer)</td>
</tr>
<tr>
<td></td>
<td>L1 BTB</td>
<td></td>
<td>L1 BTB</td>
<td></td>
</tr>
<tr>
<td></td>
<td>RAS</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>branch predictor</td>
<td>TAGE</td>
<td>Y</td>
<td>-</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td>SC</td>
<td>Y</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td>BIM</td>
<td>Y</td>
<td>-</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td>BHT</td>
<td>-</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td>GShare</td>
<td>-</td>
<td>-</td>
<td>Y</td>
</tr>
<tr>
<td>indirect branch</td>
<td>ITTAGE</td>
<td>Y</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>loop</td>
<td></td>
<td>Y</td>
<td>-</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td>FTQ</td>
<td>Y</td>
<td>-</td>
<td>Y</td>
</tr>
<tr>
<td>unknown</td>
<td>SFP</td>
<td>-</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td>vector</td>
<td>-</td>
<td>Y</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href=""></a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>FrontEnd</category>
      </categories>
  </entry>
  <entry>
    <title>TAGE predictor</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/FrontEnd/TAGE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“时间久了，日子似乎变成了一种很单调的东西，就在这每天的日出与日落里，我可以清楚地听到我的生命在渐渐枯萎”</p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TAGE 是连续几届分支预测器比赛的冠军，本文将针对TAGE预测器进行介绍，重点涉及TAGE的原理，TAGE的结构以及TAGE中重要的行为模型。</p>
<h2 id="分支历史"><a href="#分支历史" class="headerlink" title="分支历史"></a>分支历史</h2><h3 id="History-length计算"><a href="#History-length计算" class="headerlink" title="History length计算"></a>History length计算</h3><p>Tage的分支历史可以使用如下公式进行计算</p>
<script type="math/tex; mode=display">
L(i)=(\textrm{int})(\alpha^{i-1}\times L(1)+0.5)\\
1\le i < M</script><p>选$\alpha = 2$，$L(1)=2$，$M=7$，可以得到分支历史的几何级数为${2,4,8,16,32,64,128}$</p>
<h3 id="Folded-history计算"><a href="#Folded-history计算" class="headerlink" title="Folded history计算"></a>Folded history计算</h3><h2 id="TAGE结构"><a href="#TAGE结构" class="headerlink" title="TAGE结构"></a>TAGE结构</h2><h3 id="Storage-components"><a href="#Storage-components" class="headerlink" title="Storage components"></a>Storage components</h3><p>本文设计的Tage预测器storage components如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>base predictor</th>
<th>T1</th>
<th>T2</th>
<th>T3</th>
<th>T4</th>
<th>T5</th>
<th>T6</th>
<th>T7</th>
</tr>
</thead>
<tbody>
<tr>
<td>History Length</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>128</td>
</tr>
<tr>
<td>Entry number</td>
<td>1K</td>
<td>1K</td>
<td>1K</td>
<td>2K</td>
<td>2K</td>
<td>1K</td>
<td>1K</td>
<td>0.5K</td>
</tr>
<tr>
<td>index length</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>11</td>
<td>11</td>
<td>10</td>
<td>10</td>
<td>9</td>
</tr>
<tr>
<td>Width</td>
<td>3bits</td>
<td>12</td>
<td>12</td>
<td>13</td>
<td>13</td>
<td>14</td>
<td>14</td>
<td>15</td>
</tr>
<tr>
<td>Tag width</td>
<td></td>
<td>7</td>
<td>7</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>useful count</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>predict count</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>Total bits</td>
<td>1K*3 bits</td>
<td>1K*12 bits</td>
<td>1K*12 bits</td>
<td>2K*13 bits</td>
<td>2K * 13 bits</td>
<td>1K * 14 bits</td>
<td>1K * 14 bits</td>
<td>0.5K * 15 bits</td>
</tr>
</tbody>
</table>
</div>
<h2 id="TAGE更新策略"><a href="#TAGE更新策略" class="headerlink" title="TAGE更新策略"></a>TAGE更新策略</h2><h3 id="TAGE表项更新策略"><a href="#TAGE表项更新策略" class="headerlink" title="TAGE表项更新策略"></a>TAGE表项更新策略</h3><p>TAGE在retire阶段进行更新，以避免错误路径造成的污染（由于乱序执行，因此不能认为从BJU中执行的分支一定是正确的path，有可能会存在分支抢跑的情况，即错误地执行了可能完全不会走到的分支），关于路径污染，可以参考下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (cond1)</span><br><span class="line">    if (cond2)</span><br><span class="line">else</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>有两条分支语句cond1和cond2，由于乱序执行机制，完全可能存在先执行cond2再执行cond1的情况，如果cond2在执行后对表进行更新，而后续执行时发现cond1根本执行不到，那么对于cond2则进行了一个虚假的更新，产生了污染。</p>
<p>但是从retire阶段进行更新就引入了另外一个问题，更新延迟，一条指令虽然已经执行，但是直到retire才会被更新，TAGE中使用了IUM（Immediate update mimicker），来解决这个问题，后面会重点讲到。</p>
<h4 id="Useful-bit更新"><a href="#Useful-bit更新" class="headerlink" title="Useful bit更新"></a>Useful bit更新</h4><h2 id="Boom-TAGE与BHT信号映射"><a href="#Boom-TAGE与BHT信号映射" class="headerlink" title="Boom TAGE与BHT信号映射"></a>Boom TAGE与BHT信号映射</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Xuantie Signal</th>
<th>Boom signal</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>pcgen_bht_ifpc</td>
<td>io_f0_pc</td>
<td>目前BHT只用到了PC一部分</td>
</tr>
<tr>
<td>pcgen_bht_pcindex</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vghr</td>
<td>io_f1_ghist</td>
<td>关于history，xuantie在BHT中自己维护，可能需要将History这一段逻辑拆分出来</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>iu_ifu_chk_idx</td>
<td>update_bits_meta</td>
<td>关于meta信号的具体内容再看下</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>iu_ifu_bht_condbr_taken</td>
<td>cfi_taken</td>
<td></td>
</tr>
<tr>
<td>iu_ifu_chgflw_vld</td>
<td>cfi_mispredicted</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="TAGE设计"><a href="#TAGE设计" class="headerlink" title="TAGE设计"></a>TAGE设计</h2><p>本节将给出一个完整的TAGE设计，用于替换玄铁中的BHT。</p>
<h3 id="Signal-List"><a href="#Signal-List" class="headerlink" title="Signal List"></a>Signal List</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Direction</th>
<th>Width</th>
<th>Name</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>1</td>
<td>cp0_ifu_tage_en</td>
<td>tage enable</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>cp0_ifu_icg_en</td>
<td>inner clk gate?</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>cp0_yy_clk_en</td>
<td>clk enable</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>cpurst_b</td>
<td>cpu reset</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>forever_cpuclk</td>
<td>cpu clk</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ifctrl_tage_inv</td>
<td>invalidate singal</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ifctrl_tage_pipedown</td>
<td>流水线推进</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ifctrl_tage_stall</td>
<td>流水线stall</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ipctrl_tage_con_br_gateclk_en</td>
<td>gate clk enable</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ipctrl_tage_con_br_taken</td>
<td>bht预测的结果，用作history 更新</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ipctrl_tage_con_br_vld</td>
<td>分支有效</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ipctrl_tage_more_br</td>
<td>分支中存在多条语句（在第一条不跳转的情况下处理）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>ipctrl_tage_vld</td>
<td>tage是否有效</td>
</tr>
<tr>
<td></td>
<td></td>
<td>ipdp_bht_h0_con_br</td>
<td>上一条block中是否存在分支</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://zhuanlan.zhihu.com/p/460942331">玄铁C910微架构学习（3）——分支预测（一） - 知乎 (zhihu.com)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>FrontEnd</category>
      </categories>
  </entry>
  <entry>
    <title>TAGE predictor</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/FrontEnd/iddp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“时间久了，日子似乎变成了一种很单调的东西，就在这每天的日出与日落里，我可以清楚地听到我的生命在渐渐枯萎”</p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TAGE 是连续几届分支预测器比赛的冠军，本文将针对TAGE预测器进行介绍，重点涉及TAGE的原理，TAGE的结构以及TAGE中重要的行为模型。</p>
<h2 id="分支历史"><a href="#分支历史" class="headerlink" title="分支历史"></a>分支历史</h2><h3 id="History-length计算"><a href="#History-length计算" class="headerlink" title="History length计算"></a>History length计算</h3><p>Tage的分支历史可以使用如下公式进行计算</p>
<script type="math/tex; mode=display">
L(i)=(\textrm{int})(\alpha^{i-1}\times L(1)+0.5)\\
1\le i < M</script><p>选$\alpha = 2$，$L(1)=2$，$M=7$，可以得到分支历史的几何级数为${2,4,8,16,32,64,128}$</p>
<h3 id="Folded-history计算"><a href="#Folded-history计算" class="headerlink" title="Folded history计算"></a>Folded history计算</h3><h2 id="TAGE结构"><a href="#TAGE结构" class="headerlink" title="TAGE结构"></a>TAGE结构</h2><h3 id="Storage-components"><a href="#Storage-components" class="headerlink" title="Storage components"></a>Storage components</h3><p>本文设计的Tage预测器storage components如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>base predictor</th>
<th>T1</th>
<th>T2</th>
<th>T3</th>
<th>T4</th>
<th>T5</th>
<th>T6</th>
<th>T7</th>
</tr>
</thead>
<tbody>
<tr>
<td>History Length</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>128</td>
</tr>
<tr>
<td>Entry number</td>
<td>1K</td>
<td>1K</td>
<td>1K</td>
<td>2K</td>
<td>2K</td>
<td>1K</td>
<td>1K</td>
<td>0.5K</td>
</tr>
<tr>
<td>index length</td>
<td>10</td>
<td>10</td>
<td>10</td>
<td>11</td>
<td>11</td>
<td>10</td>
<td>10</td>
<td>9</td>
</tr>
<tr>
<td>Width</td>
<td>3bits</td>
<td>12</td>
<td>12</td>
<td>13</td>
<td>13</td>
<td>14</td>
<td>14</td>
<td>15</td>
</tr>
<tr>
<td>Tag width</td>
<td></td>
<td>7</td>
<td>7</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>useful count</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>predict count</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>Total bits</td>
<td>1K*3 bits</td>
<td>1K*12 bits</td>
<td>1K*12 bits</td>
<td>2K*13 bits</td>
<td>2K * 13 bits</td>
<td>1K * 14 bits</td>
<td>1K * 14 bits</td>
<td>0.5K * 15 bits</td>
</tr>
</tbody>
</table>
</div>
<h2 id="TAGE更新策略"><a href="#TAGE更新策略" class="headerlink" title="TAGE更新策略"></a>TAGE更新策略</h2><h3 id="TAGE表项更新策略"><a href="#TAGE表项更新策略" class="headerlink" title="TAGE表项更新策略"></a>TAGE表项更新策略</h3><p>TAGE在retire阶段进行更新，以避免错误路径造成的污染（由于乱序执行，因此不能认为从BJU中执行的分支一定是正确的path，有可能会存在分支抢跑的情况，即错误地执行了可能完全不会走到的分支），关于路径污染，可以参考下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (cond1)</span><br><span class="line">    if (cond2)</span><br><span class="line">else</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>有两条分支语句cond1和cond2，由于乱序执行机制，完全可能存在先执行cond2再执行cond1的情况，如果cond2在执行后对表进行更新，而后续执行时发现cond1根本执行不到，那么对于cond2则进行了一个虚假的更新，产生了污染。</p>
<p>但是从retire阶段进行更新就引入了另外一个问题，更新延迟，一条指令虽然已经执行，但是直到retire才会被更新，TAGE中使用了IUM（Immediate update mimicker），来解决这个问题，后面会重点讲到。</p>
<h4 id="Useful-bit更新"><a href="#Useful-bit更新" class="headerlink" title="Useful bit更新"></a>Useful bit更新</h4><h2 id="Boom-TAGE与BHT信号映射"><a href="#Boom-TAGE与BHT信号映射" class="headerlink" title="Boom TAGE与BHT信号映射"></a>Boom TAGE与BHT信号映射</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Xuantie Signal</th>
<th>Boom signal</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>pcgen_bht_ifpc</td>
<td>io_f0_pc</td>
<td>目前BHT只用到了PC一部分</td>
</tr>
<tr>
<td>pcgen_bht_pcindex</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vghr</td>
<td>io_f1_ghist</td>
<td>关于history，xuantie在BHT中自己维护，可能需要将History这一段逻辑拆分出来</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>iu_ifu_chk_idx</td>
<td>update_bits_meta</td>
<td>关于meta信号的具体内容再看下</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>iu_ifu_bht_condbr_taken</td>
<td>cfi_taken</td>
<td></td>
</tr>
<tr>
<td>iu_ifu_chgflw_vld</td>
<td>cfi_mispredicted</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="TAGE设计"><a href="#TAGE设计" class="headerlink" title="TAGE设计"></a>TAGE设计</h2><p>本节将给出一个完整的TAGE设计，用于替换玄铁中的BHT。</p>
<h3 id="Signal-List"><a href="#Signal-List" class="headerlink" title="Signal List"></a>Signal List</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Direction</th>
<th>Width</th>
<th>Name</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>1</td>
<td>cp0_ifu_tage_en</td>
<td>tage enable</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>cp0_ifu_icg_en</td>
<td>inner clk gate?</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>cp0_yy_clk_en</td>
<td>clk enable</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>cpurst_b</td>
<td>cpu reset</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>forever_cpuclk</td>
<td>cpu clk</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ifctrl_tage_inv</td>
<td>invalidate singal</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ifctrl_tage_pipedown</td>
<td>流水线推进</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ifctrl_tage_stall</td>
<td>流水线stall</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ipctrl_tage_con_br_gateclk_en</td>
<td>gate clk enable</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ipctrl_tage_con_br_taken</td>
<td>bht预测的结果，用作history 更新</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ipctrl_tage_con_br_vld</td>
<td>分支有效</td>
</tr>
<tr>
<td>input</td>
<td>1</td>
<td>ipctrl_tage_more_br</td>
<td>分支中存在多条语句（在第一条不跳转的情况下处理）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>ipctrl_tage_vld</td>
<td>tage是否有效</td>
</tr>
<tr>
<td></td>
<td></td>
<td>ipdp_bht_h0_con_br</td>
<td>上一条block中是否存在分支</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://zhuanlan.zhihu.com/p/460942331">玄铁C910微架构学习（3）——分支预测（一） - 知乎 (zhihu.com)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>FrontEnd</category>
      </categories>
  </entry>
  <entry>
    <title>Access Protection</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/RISC-V/AccessControl/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Be a security in 20, avoid 30 years of detours</p>
</blockquote>
<a id="more"></a>
<h2 id="RISC-V-Access-Protection-Introduction"><a href="#RISC-V-Access-Protection-Introduction" class="headerlink" title="RISC-V Access Protection Introduction"></a>RISC-V Access Protection Introduction</h2><p>In a RISC-V core, we have three types of access control unit, the PMP (Physical Memory Protection) and MPU (Memory Protection Unit) and APU (Access Protection Unit) to distinguish &amp; protect regions between User/Machine mode and Privilege/Unprivilege mode. In a general use case, the roles of PMP/MPU/APU are as follows:</p>
<ul>
<li>PMP: Protect machine mode region in user mode</li>
<li>MPU: Separate privilege and unprivilege in user mode</li>
<li>APU: Access control for RISC-V handling outside master access</li>
</ul>
<h2 id="PMP"><a href="#PMP" class="headerlink" title="PMP"></a>PMP</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>PMPs control the access privileges of physical memory including R/W and execute, normally it is used to regulate supervisor or user mode.</p>
<p>In a general RISC-V core, there are normally 16 PMP entries, which means we can divide 16 resource groups.</p>
<h3 id="PMP-configure"><a href="#PMP-configure" class="headerlink" title="PMP configure"></a>PMP configure</h3><h4 id="Address-amp-range-calculation"><a href="#Address-amp-range-calculation" class="headerlink" title="Address &amp; range calculation"></a>Address &amp; range calculation</h4><p>When we talk about memory protection, the first thing we consider is the protection range, the setting for PMP range is quite not initiative, here we basically introduce the range setting called <strong>NAPOT</strong>, it setting the range to an amount of Power of Two, it will first calculate a pmpaddr using some bit operations, then check the lower 1 number <code>n</code> in this addr, and it will protect the region starting from <code>pmpaddr &amp; LOWER_MASK</code> with a range of $2^{n+3}$ bytes. The calculation rules are:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>pmpaddr</th>
<th>pmpcfg.A</th>
<th>Match type and size</th>
</tr>
</thead>
<tbody>
<tr>
<td>aaaaa…aaaa</td>
<td>NA4</td>
<td>4-byte NAPOT range</td>
</tr>
<tr>
<td>aaaaa…aaa0</td>
<td>NAPOT</td>
<td>8-byte NAPOT range</td>
</tr>
<tr>
<td>aaaaa…aa01</td>
<td>NAPOT</td>
<td>16-byte NAPOT range</td>
</tr>
<tr>
<td>aaaaa…a011</td>
<td>NAPOT</td>
<td>32-byte NAPOT range</td>
</tr>
<tr>
<td>aaa01…1111</td>
<td>NAPOT</td>
<td>$2^{XLEN}$  byte NAPOT range</td>
</tr>
</tbody>
</table>
</div>
<p>Here we have a range of global uninit data which resides in <code>.bss</code> section that we want to protect<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECTED_ATTAY_LENGTH 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAPOT_SIZE             128</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint32_t</span> protected_global[PROTECTED_ARRAY_LENGTH] __attribute__(aligned(NAPOT_SIZE));</span><br></pre></td></tr></table></figure></p>
<p>Now we start to calculate the <code>pmpaddr</code> and range, assume that the <code>protected_global</code> is at <code>0x30415880</code>, so we are going to protect the range <code>0x30415880 -- 0x304158FF</code></p>
<p>For the PMP addr reg, since it is 4bytes aligned, so first we omit the least two bits in the addr, and since the range is $2^{n+3}$, so we clear the bits corresponding with alignment.<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* PMP address are 4-bytes aligned, drop the bottom 2 bits */</span></span><br><span class="line"><span class="keyword">size_t</span> pmpaddr = ((<span class="keyword">size_t</span>)&amp;protected_global) &gt;&gt; <span class="number">2</span>;    <span class="comment">// 0x30415880 &gt;&gt; 2 = 0xC105620</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clear the bit corresponding with alignment */</span></span><br><span class="line">protected_addr &amp;= ~(NAPOT_SIZE &gt;&gt; <span class="number">3</span>);                 <span class="comment">// 0x30415880 &amp; 0xFFFFFFEF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the bits up to the alignment bit, this address will be set in pmpaddr */</span></span><br><span class="line">protected_addr |= ((NAPOT_SIZE &gt;&gt; <span class="number">3</span>) - <span class="number">1</span>);    <span class="comment">// 0x3041588F</span></span><br></pre></td></tr></table></figure></p>
<p>Finally we get an address of 0x3041588F, according to the <strong>NAPOT</strong> rule, we will protect $2^{4+3}$ bytes.</p>
<h4 id="Exception-handler-register"><a href="#Exception-handler-register" class="headerlink" title="Exception handler register"></a>Exception handler register</h4><p>The next step is to handle an exception handler so that we could go and handle the exception after exception happened, here please refer to spec 3.1.20 for the exception code.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Register a handler for the store access fault exception */</span></span><br><span class="line">rc = metal_cpu_exception_register(cpu, ECODE_STORE_FAULT, store_access_fault_handler);</span><br><span class="line"><span class="keyword">if</span>(rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    vv_msg(SEV_INFO,ST_FUNCTION,<span class="string">"Failed to register exception handler\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Initialization-and-region-config"><a href="#Initialization-and-region-config" class="headerlink" title="Initialization and region config"></a>Initialization and region config</h4><p>Finally we do initialization and region config to finally open up the PMP module. The pmp will be sequentially used for protecting the physical region.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize PMPs */</span></span><br><span class="line">pmp = metal_pmp_get_device();</span><br><span class="line"><span class="keyword">if</span>(!pmp) &#123;</span><br><span class="line">    vv_msg(SEV_INFO,ST_FUNCTION,<span class="string">"Unable to get PMP Device\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">metal_pmp_init(pmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure PMP 0 to only allow reads to protected_global. The</span></span><br><span class="line"><span class="comment"> * PMP region is locked so that the configuration applies to M-mode</span></span><br><span class="line"><span class="comment"> * accesses. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">metal_pmp_config</span> <span class="title">config</span> = &#123;</span></span><br><span class="line">    .L = METAL_PMP_LOCKED, <span class="comment">/*the orginal is UNLOCKED*/</span></span><br><span class="line">    .A = METAL_PMP_NAPOT, <span class="comment">/* Naturally-aligned power of two */</span></span><br><span class="line">    .X = <span class="number">0</span>,</span><br><span class="line">    .W = <span class="number">0</span>,</span><br><span class="line">    .R = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rc = metal_pmp_set_region(pmp, <span class="number">0</span>, config, protected_addr);</span><br><span class="line"><span class="keyword">if</span>(rc != <span class="number">0</span>) &#123;</span><br><span class="line">    vv_msg(SEV_INFO,ST_FUNCTION,<span class="string">"Failed to configure PMP 0\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Attempting to write the protected region will cause an exception:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">protected_global[<span class="number">0</span>] = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<h3 id="An-actual-case-of-PMP-to-protect-the-whole-DDR-region"><a href="#An-actual-case-of-PMP-to-protect-the-whole-DDR-region" class="headerlink" title="An actual case of PMP to protect the whole DDR region"></a>An actual case of PMP to protect the whole DDR region</h3><p>In our chip, DDR lower 2GB region is <code>0x80000000 - 0xFFFFFFFF</code>, first we use TOR range config, it will use two PMP entries to determine the protected retion, it’s</p>
<script type="math/tex; mode=display">
pmp_{i-1}\leq addr < pmp_{i}</script><p>(If we use pmp entry0 as TOR mode, then $0\leq addr &lt; pmp_{0}$). The configuration code is<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Configure PMP 0 to allow access to all memory */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">metal_pmp_config</span> <span class="title">config</span> = &#123;</span></span><br><span class="line">    .L = METAL_PMP_UNLOCKED,    <span class="comment">// Unlocked, all machine access will success</span></span><br><span class="line">                                <span class="comment">// user access will be restricted.</span></span><br><span class="line">    .A = METAL_PMP_TOR,</span><br><span class="line">    .X = <span class="number">1</span>,</span><br><span class="line">    .W = <span class="number">1</span>,</span><br><span class="line">    .R = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the whole region for PMP</span></span><br><span class="line">rc = metal_pmp_set_region(pmp, <span class="number">0</span>, config, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(rc != <span class="number">0</span>) &#123;</span><br><span class="line">    vv_msg(SEV_INFO,ST_FUNCTION,<span class="string">"\nUnable to set PMP Region\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> VV_FAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Since our PMP addr is 4bytes granularity, it means that we are not able to access to last 4 bytes if we set it as TOR mode. For example, if we set pmp0 addr as <code>0xFFFFFFFF</code>, according to RISCV privileged doc, we will record address bit from 2 to 33, so our pmp addr is <code>0xFFFFFFFF &gt;&gt; 2 = 0x3FFFFFFF</code>, and when 0x3FFFFFFF lsh 2, we get 0xFFFFFFFC, so our right boundary is 0xFFFFFFFC, we will encounter a load access fault if access <code>0xFC - 0xFF</code>.</p>
<p><img src="https://github.com/sqduan/blog/assets/51660739/1f503b1a-5e57-4187-801d-037049ed976f" alt="image"></p>
<p>When we switch to user mode and access DDR region, if we visit last four bytes, we will get the following MCAUSE:</p>
<p><img src="https://github.com/sqduan/blog/assets/51660739/b9635fe5-216e-4ee8-a825-25e00e718fe6" alt="image"></p>
<p>From the spec, we know that we have a load access fault when access the last 4 bytes of DDR region.</p>
<h2 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>MPU is used to separate the privilege and unprivilege in user mode, it is used to protect the region between user and supervisor mode. Though MPU can be used to protect memory region under machine mode.</p>
<h3 id="Execution-Fault"><a href="#Execution-Fault" class="headerlink" title="Execution Fault"></a>Execution Fault</h3><h2 id="APU"><a href="#APU" class="headerlink" title="APU"></a>APU</h2><h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><p>In our trust engine, there’s an APU which protectes the access from masters to RISC-V, we can setting the start/end address and RD/WR enable bit to control the access behavior.</p>
<h3 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h3><p>To configure the APU, we need to assign the left and right boundary ($a_l$ and $a_r$) to define the region, given an access region <code>a</code>, it should satisfy that $a_l \le a \le a_r$.</p>
<p>If at least one APU is configured, then the space will become a white list mechanism, when master try to access the unprotected region, it will face an error.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Configuration for Front Port APU</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">apu_glb_cfg global_cfg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">apu_config  apu_cfg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">global_cfg.enable = <span class="number">1</span>;</span><br><span class="line">global_cfg.lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restrict the region</span></span><br><span class="line">apu_cfg.start_address = &amp;dplain;</span><br><span class="line">apu_cfg.end_address   = apu_cfg.start_address + <span class="keyword">sizeof</span>(dplain);</span><br><span class="line">apu_cfg.rg_no = <span class="number">0</span>;</span><br><span class="line">apu_cfg.rg_en = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">apu_cfg.rg_rd_en = <span class="number">1</span>;</span><br><span class="line">apu_cfg.rg_wr_en = <span class="number">0</span>;</span><br><span class="line">apu_cfg.rg_lock = <span class="number">0</span>;</span><br><span class="line">TE_apu_global_enable(global_cfg);</span><br><span class="line">TE_riscv_configure_apu(apu_cfg);</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf">RISCV Privilege Spec</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>RISC-V</category>
      </categories>
  </entry>
  <entry>
    <title>Performance</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/RISC-V/Performance/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将介绍RISV-V性能测试过程中常用的一些方式</p>
<a id="more"></a>
<h2 id="RTC-Timer"><a href="#RTC-Timer" class="headerlink" title="RTC Timer"></a>RTC Timer</h2><p>RISC-V Core中有一个Real time clock timer (mcycle)，使用方式如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Defines to access CSR registers within C code */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_csr(reg) (&#123; unsigned long __tmp; \</span></span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"csrr %0, "</span> #reg : <span class="string">"=r"</span>(__tmp))</span></span>; \</span><br><span class="line">        __tmp; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_csr(reg, val) (&#123; \</span></span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"csrw "</span> #reg <span class="string">", %0"</span> :: <span class="string">"rK"</span>(val))</span></span>; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear timer</span></span><br><span class="line">write_csr(mcycle, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">VVDRV_qtm_setTestResult(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get MCYCLE</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>RISC-V</category>
      </categories>
  </entry>
  <entry>
    <title>Papers about Front-End Architecture</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Papers%20about%20Front-End%20Architecture/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>“I don’t make mistakes. I make prophecies which immediately turn out to be wrong.”</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文主要针对前端架构相关的文章进行总结</p>
<h2 id="Papers"><a href="#Papers" class="headerlink" title="Papers"></a>Papers</h2><h3 id="Paper1-A-Scalable-Front-End-Architecture-for-Fast-Instruction-Delivery"><a href="#Paper1-A-Scalable-Front-End-Architecture-for-Fast-Instruction-Delivery" class="headerlink" title="Paper1 : A Scalable Front-End Architecture for Fast Instruction Delivery"></a>Paper1 : A Scalable Front-End Architecture for Fast Instruction Delivery</h3><p>ILP很重要的点是取指/指令分发/指令执行的速率相匹配，而在实际中执行速度受限于取指效率：</p>
<ul>
<li>I$ miss，直到指令从下一级缓存返回</li>
<li>分支误预测（地址或方向错误）</li>
<li>分支目标获取（读取BTB的时间）</li>
</ul>
<p>本文提出了一种结构叫做取指目标队列（FTQ），用于将取指令和译码流水线解耦，提高前端指令分发效率</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://dl.acm.org/doi/pdf/10.1145/307338.300999">A scalable front-end architecture for fast instruction delivery</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>CS152 - LAB1</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AF%BE%E7%A8%8B/CS152%20-%20LAB1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“I feel within me a peace above all earthly dignities, a still and quiet conscience.”</p>
</blockquote>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="RISC-V-指令集架构"><a href="#RISC-V-指令集架构" class="headerlink" title="RISC-V 指令集架构"></a>RISC-V 指令集架构</h3><p>RISC-V的官方网站参考文献1<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，对于LAB1，所有的处理器都基于32位的ISA (RV32I)。LAB1需要安装如下工具链：</p>
<ul>
<li><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://riscv.org/technical/specifications/">Specifications - RISC-V International (riscv.org)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>CS152</category>
      </categories>
  </entry>
  <entry>
    <title>程序加载及执行</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/RISC-V/RISCV%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文将针对RISC-V的加载和执行流程进行介绍。<br><a id="more"></a></p>
<h2 id="elf分段"><a href="#elf分段" class="headerlink" title="elf分段"></a>elf分段</h2><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h2 id="RISCV程序执行流程"><a href="#RISCV程序执行流程" class="headerlink" title="RISCV程序执行流程"></a>RISCV程序执行流程</h2><h3 id="初始化代码"><a href="#初始化代码" class="headerlink" title="初始化代码"></a>初始化代码</h3><p>RISCV程序执行前需要一段初始化代码，执行硬件、内存初始化、设置堆栈指针等操作，初始化代码为start.S：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.section .init</span><br><span class="line">.globl _start</span><br><span class="line">.globl _end</span><br><span class="line">.type _start, @function</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    /* Clear general purpose registers */</span><br><span class="line">    mv x1, x0</span><br><span class="line">    mv x2, x0</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">.option push</span><br><span class="line">.option norelax</span><br><span class="line">    la gp, __global_pointer$    // 设置全局指针寄存器，指向global data (x3)</span><br><span class="line">.option pop</span><br><span class="line">    la sp, __sp_start           // 设置堆栈起始地址(x2)</span><br><span class="line"></span><br><span class="line">    la a0, _default_handler     // 设置default exception handler, 如果未指定异常处理流程，就会</span><br><span class="line">    csrw mtvec, a0              // 跳转至此处</span><br><span class="line"></span><br><span class="line">    /* Load text section */</span><br><span class="line">    la a0, __text_lma_start     // load memory addr (物理地址)</span><br><span class="line">    la a1, __text_vma_start     // virtual memory addr</span><br><span class="line">    la a2, __text_vma_end       // virtual memory end</span><br><span class="line">    bgeu a1, a2, 2f             // start &gt;= end? maybe start from ROM</span><br><span class="line"></span><br><span class="line">/* 下面这段代码进行了一个简单的内存搬运，</span><br><span class="line">   将从lma开始的text完全搬运至vma开始的地址。</span><br><span class="line">   不过此处lma和vma地址相同 */</span><br><span class="line">1:</span><br><span class="line">    lw t0, (a0)</span><br><span class="line">    sw t0, (a1)</span><br><span class="line">    addi a0, a0, 4</span><br><span class="line">    addi a1, a1, 4</span><br><span class="line">    bltu a1, a2, 1b</span><br><span class="line">2:</span><br><span class="line">    call _startFromROM</span><br></pre></td></tr></table></figure></p>
<p>程序接下来会跳转至<code>startROM.S</code>中的<code>_startFromROM</code>继续执行，并逐步跳转至main函数，<code>_startFromROM</code>位于text段内，主要会做一下段拷贝工作，然后跳转至<code>vv_main</code>中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    .section .text</span><br><span class="line">    .globl _startFromROM</span><br><span class="line">    .type _startFromROM,@function</span><br><span class="line"></span><br><span class="line">_startFromROM:</span><br><span class="line"></span><br><span class="line">    /* Load rodata section */</span><br><span class="line">    la a0, __rodata_lma_start</span><br><span class="line">    la a1, __rodata_vma_start</span><br><span class="line">    la a2, __rodata_vma_end</span><br><span class="line">    bgeu a1, a2, skip_rodata</span><br><span class="line">loop_rodata:</span><br><span class="line">    lw t0, (a0)</span><br><span class="line">    sw t0, (a1)</span><br><span class="line">    addi a0, a0, 4</span><br><span class="line">    addi a1, a1, 4</span><br><span class="line">    bltu a1, a2, loop_rodata</span><br><span class="line">skip_rodata:</span><br><span class="line"></span><br><span class="line">    /* Load &quot;init_n_xtors&quot; section */</span><br><span class="line">    /* Load data section */</span><br><span class="line">    /* Clear bss section */</span><br><span class="line"></span><br><span class="line">    /* argc = argv = 0 */</span><br><span class="line">    li a0, 0</span><br><span class="line">    li a1, 0</span><br><span class="line">    call vv_main</span><br></pre></td></tr></table></figure></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>RISC-V</category>
      </categories>
  </entry>
  <entry>
    <title>The Road Ahead week1</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AF%BE%E7%A8%8B/The%20Road%20Ahead%20week1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“The great wall is made by blocks”</p>
</blockquote>
<a id="more"></a>
<h1 id="布尔函数基础"><a href="#布尔函数基础" class="headerlink" title="布尔函数基础"></a>布尔函数基础</h1><p>计算机组成原理课程的第一周<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，本周我们将使用HDL搭建基本门电路，构建起组成CPU的基本单元。首先记住德摩根定律</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
\neg(x\and y)&=\neg x\or \neg y \\
\neg(x\or y)&=\neg x \and \neg y
\end{aligned}
\end{equation}</script><p>根据真值表就能得到上面的规律，下面我们讨论布尔函数与真值表之间的转换。根据布尔函数能够很容易推出真值表，那么如何根据真值表反推布尔函数呢？例如给定如下真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>z</th>
<th>f</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>如何根据上述真值表推出如下函数：</p>
<script type="math/tex; mode=display">
f(x,y,z)=(x\and y)\or (\neg(x)\and z)</script><p>方法如下：</p>
<ul>
<li>遍历真值表中$f(x,y,z)=1$的行</li>
<li>用与逻辑表示等式，例如$f(0,0,1)=1$可以表示为：$\neg (x)\and \neg(y) \and z = 1$，可以证明该等式仅在当前行生效，将所有为1的行相加，我们得到真值表对应等式为：</li>
</ul>
<script type="math/tex; mode=display">
f(x,y,z)=(\neg x\and \neg y \and z)\or (\neg x \and y \and z)\or (x\and y \and \neg z)\or (x\and y\and z)</script><ul>
<li>将上面的公式进行化简，得到$f(x,y,z)=(x\and y)\or(\neg x\and z)$，化简过程实际上是一个很难的问题，但是这里我们得到了第一个结论</li>
</ul>
<blockquote>
<p>$\textrm{Theory}\ 1$: 所有的布尔函数都可以用简单的与、或、非来表示，进一步地，根据德摩根定律，$(x\or y)=\neg (\neg x\and \neg y)$，所以所有的布尔函数都可以用简单的与、非来表示</p>
</blockquote>
<p>为了进一步化简，我们引入NAND($\neg (x\and y)$)，真值表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>NAND</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>实际上，NAND(x,x)即为$\neg x$，我们可以将Theory 1进一步化简，所有布尔函数都可以用NAND简单表示，证明如下：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
\neg x&=(x\ \textrm{NAND}\ x)\\
x\and y&=\neg (x\ \textrm{NAND}\ y)
\end{aligned}
\end{equation}</script><p>所以这个世界实际上是NAND（与非门）组成的。</p>
<h1 id="逻辑门与HDL"><a href="#逻辑门与HDL" class="headerlink" title="逻辑门与HDL"></a>逻辑门与HDL</h1><h2 id="基本逻辑门"><a href="#基本逻辑门" class="headerlink" title="基本逻辑门"></a>基本逻辑门</h2><p>我们现在来讨论如何用硬件实现布尔逻辑，由于我们知道这个世界是由NAND组成的，我们来讨论如何构造一个NAND门</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220519234759.png" width = "240" alt="图片名称" align=center /></p>
<p>用代码描述得到与非门如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NAND</span><span class="params">(<span class="keyword">bool</span> x, <span class="keyword">bool</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下常见的门和对应的真值表：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220520201507.png" width = "640" alt="图片名称" align=center /></p>
<h2 id="Hardware-Description-Language-HDL"><a href="#Hardware-Description-Language-HDL" class="headerlink" title="Hardware Description Language(HDL)"></a>Hardware Description Language(HDL)</h2><p>我们使用HDL语言描述相关门电路，以异或门为例，根据其真值表，我们可以得到异或门的布尔函数如下：</p>
<script type="math/tex; mode=display">
\textrm{Xor}=(a\and \neg b) \or (\neg a \and b)</script><p>根据布尔函数，我们可以搭建对应的电路（假设我们已经根据与非门建立了与、非以及或电路）：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/xor.svg" width = "480" alt="图片名称" align=center /></p>
<p>下面我们来写一下异或门的HDL描述，分为如下几步：</p>
<ul>
<li>搭建好门的框架，包括输入输出和门组成部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Xor gate: out = (a And Not(b)) Or (Not(a) And b)*/</span></span><br><span class="line"></span><br><span class="line">CHIP Xor &#123;</span><br><span class="line">    IN  a, b;</span><br><span class="line">    OUT out;</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用已经构建好的其他门，描述门的组成部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Xor gate: out = (a == b) ? 0 : 1</span></span><br><span class="line"><span class="comment"> * Xor can be written as (a And Not(b)) Or (Not(a) And b) */</span></span><br><span class="line"></span><br><span class="line">CHIP Xor &#123;</span><br><span class="line">    IN  a, b;</span><br><span class="line">    OUT out;</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Use not gate to create nota and notb</span></span><br><span class="line">    Not (in = a, out = nota);</span><br><span class="line">    Not (in = b, out = notb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use and gate to create the next part of the gate</span></span><br><span class="line">    And (a = a, b = notb, out = aAndNotb);</span><br><span class="line">    And (a = nota, b = b, out = notaAndb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, use or gate to create Xor output</span></span><br><span class="line">    Or (a = aAndNotb, b = notaAndb, out = out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>描述一般是从左到右的顺序。</p>
<h1 id="多位逻辑总线"><a href="#多位逻辑总线" class="headerlink" title="多位逻辑总线"></a>多位逻辑总线</h1><p>有些时候我们需要处理多位输入，此时需要将一组信号集成，构成总线，例如我们考虑一个16位的加法器</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/16bit.svg" width = "480" alt="图片名称" align=center /></p>
<p>这里有两个16位输入，一个16位输出，该模块的HDL框架如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add16: add two 16-bit numbers */</span></span><br><span class="line">CHIP Add16 &#123;</span><br><span class="line">    IN   a[<span class="number">16</span>], b[<span class="number">16</span>];</span><br><span class="line">    OUT  out[<span class="number">16</span>];</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再例如，我们可以设计一个Add4模块，将两个输入的4bit数进行And操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* And4: Computes a bit-wise and of its two 4-bit input buses */</span></span><br><span class="line">CHIP And4 &#123;</span><br><span class="line">    IN   a[<span class="number">4</span>], b[<span class="number">4</span>];</span><br><span class="line">    OUT  out[<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    PARTS:</span><br><span class="line">    And(a = a[<span class="number">0</span>], b = b[<span class="number">0</span>], out = out[<span class="number">0</span>]);</span><br><span class="line">    And(a = a[<span class="number">1</span>], b = b[<span class="number">1</span>], out = out[<span class="number">1</span>]);</span><br><span class="line">    And(a = a[<span class="number">2</span>], b = b[<span class="number">2</span>], out = out[<span class="number">2</span>]);</span><br><span class="line">    And(a = a[<span class="number">3</span>], b = b[<span class="number">3</span>], out = out[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编写多位逻辑电路时，我们需要注意位数匹配，例如Add16，输出是16位，我们不能只输出15个</p>
<h1 id="项目1：根据NAND搭建基本逻辑电路"><a href="#项目1：根据NAND搭建基本逻辑电路" class="headerlink" title="项目1：根据NAND搭建基本逻辑电路"></a>项目1：根据NAND搭建基本逻辑电路</h1><h2 id="项目简述"><a href="#项目简述" class="headerlink" title="项目简述"></a>项目简述</h2><p>现在请根据NAND搭建如下电路：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Not</th>
<th>And</th>
<th>Or</th>
<th>Xor</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mux</td>
<td>Dmux</td>
<td>Not16</td>
<td>And16</td>
</tr>
<tr>
<td>Or16</td>
<td>Mux16</td>
<td>Or8Way</td>
<td>Mux4Way16</td>
</tr>
<tr>
<td>Mux8Way16</td>
<td>DMux4Way</td>
<td>DMux8Way</td>
<td>Nand(基本)</td>
</tr>
</tbody>
</table>
</div>
<p>根据功能，我们可以将上面的chip分为如下几类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>基本逻辑门</th>
<th>16-bit 门变种</th>
<th>多路变种</th>
</tr>
</thead>
<tbody>
<tr>
<td>Not(已完成)</td>
<td>Not16(已完成)</td>
<td>Or8Way(已完成，将输入的8bit进行或操作)</td>
</tr>
<tr>
<td>And(已完成)</td>
<td>And16(已完成)</td>
<td>Mux4Way16(已完成，4选1)</td>
</tr>
<tr>
<td>Or(已完成)</td>
<td>Or16(已完成)</td>
<td>Mux8Way16(已完成，8选1)</td>
</tr>
<tr>
<td>Xor(已完成)</td>
<td>Mux16(已完成)</td>
<td>DMux4Way(已完成，1分4)</td>
</tr>
<tr>
<td>Mux(已完成)</td>
<td></td>
<td>DMux8Way(已完成，1分8)</td>
</tr>
<tr>
<td>DMux(已完成)</td>
<td></td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Mux和DMux"><a href="#Mux和DMux" class="headerlink" title="Mux和DMux"></a>Mux和DMux</h2><p>此处我们特别讲解一下Mux和DMux门</p>
<ul>
<li>数据选择器（Multiplexer, Mux）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220521142235.png" width = "480" alt="数据选择器" align=center /></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以看出，mux电路主要用于实现if逻辑</span><br><span class="line">if (sel == 0)</span><br><span class="line">    out = a</span><br><span class="line">else</span><br><span class="line">    out = b</span><br></pre></td></tr></table></figure>
<p>真值表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>sel</th>
<th>out</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>有了数据选择器之后，我们可以创建一些可编程门，例如<code>AndMuxOr</code>门</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/andmuxor.svg" width = "480" alt="数据选择器" align=center /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sel == <span class="number">0</span>)</span><br><span class="line">    out = (a And b)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    out = (a Or b)</span><br></pre></td></tr></table></figure>
<ul>
<li>数据分解器</li>
</ul>
<p>和数据选择器正相反，数据分解器将一个数据进行拆分：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220521154722.png" width = "560" alt="数据选择器" align=center /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sel == <span class="number">0</span>)</span><br><span class="line">    &#123;a, b&#125; = &#123;in, <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;a, b&#125; = &#123;<span class="number">0</span>, in&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多路数据选择器（Mux4Way16）</li>
</ul>
<p>一个四路的16位数据选择器如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4-way 16-bit multiplexor:</span></span><br><span class="line"><span class="comment"> * out = a if sel == 00</span></span><br><span class="line"><span class="comment"> *       b if sel == 01</span></span><br><span class="line"><span class="comment"> *       c if sel == 10</span></span><br><span class="line"><span class="comment"> *       d if sel == 11</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>实际上我们只需要按照层层筛选的过程，先根据一位在ab和cd中各选出一个，再根据sel另一位做剩下的选择：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/mux4way16.svg" width = "480" alt="数据选择器" align=center /></p>
<blockquote>
<p>Example：实际上Mux和Dmux是构成网络交换机的重要组成部分，通过一根总线，即可传输多组数据，再根据不同的sel进行筛选分发</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220521155557.png" width = "720" alt="数据选择器" align=center /></p>
<p>一个多路的Mux和DMux代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************** Mux8Way16 (8 in 1 out) ****************/</span></span><br><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/01/Mux8Way16.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8-way 16-bit multiplexor:</span></span><br><span class="line"><span class="comment"> * out = a if sel == 000</span></span><br><span class="line"><span class="comment"> *       b if sel == 001</span></span><br><span class="line"><span class="comment"> *       etc.</span></span><br><span class="line"><span class="comment"> *       h if sel == 111</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CHIP Mux8Way16 &#123;</span><br><span class="line">    IN a[<span class="number">16</span>], b[<span class="number">16</span>], c[<span class="number">16</span>], d[<span class="number">16</span>],</span><br><span class="line">       e[<span class="number">16</span>], f[<span class="number">16</span>], g[<span class="number">16</span>], h[<span class="number">16</span>],</span><br><span class="line">       sel[<span class="number">3</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    <span class="comment">// 实际上多选一的原理类似于比赛赛程，先小组赛，再半决赛</span></span><br><span class="line">    Mux4Way16(a = a, b = b, c = c, d = d, sel = sel[<span class="number">0.</span><span class="number">.1</span>], out = p1);</span><br><span class="line">    Mux4Way16(a = e, b = f, c = g, d = h, sel = sel[<span class="number">0.</span><span class="number">.1</span>], out = p2);</span><br><span class="line">    Mux16(a = p1, b = p2, sel = sel[<span class="number">2</span>], out = out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** DMux8Way (1 in 8 out) ****************/</span></span><br><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/01/DMux8Way.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8-way demultiplexor:</span></span><br><span class="line"><span class="comment"> * &#123;a, b, c, d, e, f, g, h&#125; = &#123;in, 0, 0, 0, 0, 0, 0, 0&#125; if sel == 000</span></span><br><span class="line"><span class="comment"> *                            &#123;0, in, 0, 0, 0, 0, 0, 0&#125; if sel == 001</span></span><br><span class="line"><span class="comment"> *                            etc.</span></span><br><span class="line"><span class="comment"> *                            &#123;0, 0, 0, 0, 0, 0, 0, in&#125; if sel == 111</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CHIP DMux8Way &#123;</span><br><span class="line">    IN in, sel[<span class="number">3</span>];</span><br><span class="line">    OUT a, b, c, d, e, f, g, h;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    <span class="comment">// First we DMux the in to 4 group &#123;a, e&#125;/&#123;b, f&#125;/&#123;c, g&#125;/&#123;d, h&#125;</span></span><br><span class="line">    <span class="comment">// a and e are in the same group because the sel[0..1] of a and e are same</span></span><br><span class="line">    DMux4Way(in = in, sel = sel[<span class="number">0.</span><span class="number">.1</span>], a = p1, b = p2, c = p3, d = p4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Then we Dmux each of them by sel[2]</span></span><br><span class="line">    DMux(in = p1, sel = sel[<span class="number">2</span>], a = a, b = e);</span><br><span class="line">    DMux(in = p2, sel = sel[<span class="number">2</span>], a = b, b = f);</span><br><span class="line">    DMux(in = p3, sel = sel[<span class="number">2</span>], a = c, b = g);</span><br><span class="line">    DMux(in = p4, sel = sel[<span class="number">2</span>], a = d, b = h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一章的实验并不难，下一节中，我们会用上面搭建好的逻辑门，构造一个基本加法器。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.coursera.org/learn/build-a-computer/supplement/gaUOI/module-1-boolean-functions-and-gate-logic-roadmap">Module 1: Boolean Functions and Gate Logic Roadmap | Coursera</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://b1391bd6-da3d-477d-8c01-38cdf774495a.filesusr.com/ugd/44046b_f2c9e41f0b204a34ab78be0ae4953128.pdf">Chapter 1 of <em>The Elements of Computing Systems</em>.</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://drive.google.com/file/d/1dPj4XNby9iuAs-47U9k3xtYy9hJ-ET0T/view">HDL Guide (except for A.2.4)</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://drive.google.com/file/d/1IsDnH0t7q_Im491LQ7_5_ajV0CokRbwR/view">Hack Chip Set (when writing your HDL programs, you can copy-paste chip-part signatures from here)</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>CS152 - Overview</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AF%BE%E7%A8%8B/CS152%20-%20Overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“This thing we call “failure” is not the falling down, but the staying down.”</p>
</blockquote>
<a id="more"></a>
<h2 id="课程日历"><a href="#课程日历" class="headerlink" title="课程日历"></a>课程日历</h2><p>CS 152的课程日历如下：<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/">Home Page for UCB CS152/CS252A, Spring 2022 (berkeley.edu)</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Week</strong></th>
<th><strong>Date</strong></th>
<th><strong>Lecture</strong></th>
<th><strong>Readings 5th Edition</strong></th>
<th><strong>Readings 6th Edition</strong></th>
<th><strong>Assignments / Handouts</strong></th>
<th>Finish?</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Tue Jan 18</td>
<td>L1: Introduction, Early Machines <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L01-Intro.pdf">PDF</a></td>
<td>Ch. 1, App. A</td>
<td>Ch. 1, App. A</td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td>Thu Jan 20</td>
<td>L2: Simple Machine Implementations, Microcoding <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L02-SimpleImps.pdf">PDF</a></td>
<td></td>
<td></td>
<td>Lab 1 <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/lab1.pdf">PDF</a> <br /><a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/microcode.pdf">Handout 1</a> <br /><a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/microcode-table.docx">Blank microcode table</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Thu Jan 20</td>
<td>CS252A No Readings Discussion</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Fri Jan 21</td>
<td>CS152 Section 1: Microcode, Lab 1 Overview <a href="https://docs.google.com/presentation/d/1sHDrnV7o6uXe63DzKnrVG8vBCcJb3U0MNWpKsXsF9AM/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/1blGy5BrQVDUpMqHs-T7XLg1PDc4-oFNyQs4IJ8caAD4/edit?usp=sharing">Worksheet 1 </a><a href="https://inst.eecs.berkeley.edu/~cs152/sp21/sections/sp21/sec01-worksheet.pdf">PDF</a></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>Tue Jan 25</td>
<td>L3: Pipelining <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L03-Pipelining.pdf">PDF</a></td>
<td>App. C.1-C.3</td>
<td>App. C.1-C.3</td>
<td>PS 1 (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps1.pdf">PDF</a>, <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps1.doc">DOC</a>)</td>
<td></td>
</tr>
<tr>
<td>Thu Jan 27</td>
<td>L4: Pipelining II <a href="https://inst.eecs.berkeley.edu/~cs152/sp21/lectures/L04-PipeliningII.pdf">PDF</a></td>
<td>App. C.4-C.6</td>
<td>App. C.4-C.6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Jan 27</td>
<td>CS252A Readings Discussion</td>
<td><a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4463978">“Design of the B5000 System”</a>, Lonergan, King, 1961 <a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5389178">“Architecture of the IBM System/360”</a>, Amdahl, Blaauw, Brooks, 1964</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Jan 28</td>
<td>CS152 Section 2: Pipelining review <a href="https://docs.google.com/presentation/d/1CdsS2tlLlZctx21mkzzy9pwE-jVyjDf5qh_GrCt2mEs/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/1-JyMeYbrjaEc66XnYRwGVBRFlKgqqfLjPFQVhmuXW7Q/edit?usp=sharing">Worksheet 2</a> (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/sections/sp22/sec02-worksheet.pdf">PDF</a>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Tue Feb 1</td>
<td>L5: Memory Hierarchy <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L05-Memory.pdf">PDF</a></td>
<td>App. B.1-B.2, Ch. 2.1-2.3</td>
<td>App. B.1-B.2, Ch. 2.1-2.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Feb 3</td>
<td>L6: Memory Hierarchy II <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L06-MemoryII.pdf">PDF</a></td>
<td>App. B.3</td>
<td>App. B.3</td>
<td>PS 1 due <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps1-sol.pdf">PS 1 solutions</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Feb 3</td>
<td>CS252A Readings Discussion</td>
<td><a href="http://dl.acm.org/ft_gateway.cfm?id=641917">“The Case for the Reduced Instruction Set Computer”</a>, Patterson, Ditzel, 1980 <a href="http://dl.acm.org/citation.cfm?id=641918">Comments on the “The Case for the RISC”</a>, Clark, Strecker, 1980 <a href="http://dl.acm.org/ft_gateway.cfm?id=107003">“Performance from architecture: comparing a RISC and CISC with similar hardware organization”</a>, Bhandarkar, Clark, 1991</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Feb 4</td>
<td>CS152 Section 3: Memory Hierarchy <a href="https://docs.google.com/presentation/d/1KKM1Z_ebCIpKTgFyJKRsejTDQATHjemPAKOMwXegATo/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/1Xzy0bis9MeA5_88Q9XoTqyffM2-TkI_K_IoiqZvPYI0/edit?usp=sharing">Worksheet 3</a> (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/sections/sp22/sec03-worksheet.pdf">PDF</a>) <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/handout2.pdf">Handout 2</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>Tue Feb 8</td>
<td>L7: Address Translation <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L07-AddressTranslation.pdf">PDF</a></td>
<td>App. B. 4-7</td>
<td>App. B. 4-7</td>
<td>PS 2 (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps2.pdf">PDF</a>, <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps2.doc">DOC</a>)</td>
<td></td>
</tr>
<tr>
<td>Thu Feb 10</td>
<td>L8: Apple Guest Lecture: Prefetching</td>
<td></td>
<td></td>
<td>Lab 1 due</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lab 2 <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/lab2.pdf">PDF</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Feb 10</td>
<td>CS252A Projects Office Hours</td>
<td>(Email JohnW for Zoom link)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Feb 11</td>
<td>CS152 Section 4: Address Translation and Lab 2 Overview/PS 1 Review <a href="https://docs.google.com/presentation/d/1cCkNVQ0PkzYAb6mSE9P3B1USX9p_GDYAoX8LeJD7pRs/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/1rDB8jFaCoD6Gi3nJSNaOJf6HfHnha0CJ3_9Icusmxuc/edit?usp=sharing">Worksheet 4</a> (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/sections/sp22/sec04-worksheet.pdf">PDF</a>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Tue Feb 15</td>
<td>L9: Virtual Memory <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L09-VirtualMemory.pdf">PDF</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Feb 17</td>
<td>L10: Complex pipelines, out-of-order issue, register renaming <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L10-ComplexPipes.pdf">PDF</a></td>
<td>Ch. 3.1,3.4-3.5</td>
<td>Ch. 3.1,3.4-3.6</td>
<td>PS 2 due CS252A project proposals due</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Feb 17</td>
<td>CS252A Readings Discussion</td>
<td><a href="http://cacm.acm.org/magazines/2010/12/102128-ibms-single-processor-supercomputer-efforts/pdf">“IBM’s Single-Processor Supercomputer Efforts”</a>, Smotherman, Spicer, CACM, 53(1), 2010 <a href="https://ieeexplore.ieee.org/document/4607">“Implementation of Precise Interrupts in Pipelined Processors”</a> , Smith, Pleszkun, ISCA, 1985 (IEEE Trans. Computer Journal version) <a href="http://dl.acm.org/ft_gateway.cfm?id=1464045">“Parallel Operation in the Control Data 6600”</a>, Thornton, Proceedings of the Fall Joint Computers Conference, vol 26, pp. 33-40, 1964</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Feb 18</td>
<td>CS152 Section 5: Midterm 1 Review <a href="https://docs.google.com/presentation/d/10AAtgLk_4xLrmtI8ZZLlMqKOrIEV1CgQy4HXf3drNa8/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps2-sol.pdf">PS 2 solutions</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>Tue Feb 22</td>
<td>Midterm 1: (L1-L9) <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/mt1-sol.pdf">Solutions</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Feb 24</td>
<td>L11: Out-of-order execution <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L11-OutOfOrder.pdf">PDF</a></td>
<td>Ch. 3.6, 3.8</td>
<td>Ch. 3.6, 3.8</td>
<td>PS 3 (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps3.pdf">PDF</a>, <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps3.doc">DOC</a>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Feb 24</td>
<td>CS252A Project Proposal Discussion, Session I</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Feb 25</td>
<td>CS152 Section 6: Out-of-order Execution <a href="https://docs.google.com/presentation/d/1KafyYMCbLvN7C6rUiZIPh_OKJcsFqenl1J2xUvADZeg/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/1E0k_Ms-F9RHKHqvFDW9sRDS61cafD9TRrulZJJxdA-k/edit?usp=sharing">Worksheet 6</a> (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/sections/sp22/sec06-worksheet.pdf">PDF</a>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>Tue Mar 1</td>
<td>Finish L11: Out-of-order execution <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L11-OutOfOrder.pdf">PDF</a></td>
<td>Ch. 3.6, 3.8</td>
<td>Ch. 3.6, 3.8</td>
<td>Lab 2 due</td>
<td></td>
</tr>
<tr>
<td>Thu Mar 3</td>
<td>L12: Branch Prediction <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L12-Superscalars.pdf">PDF</a></td>
<td></td>
<td>Ch. 3.3,3.9-3.10</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Mar 4</td>
<td>CS252A Project Checkpoint</td>
<td>Revised Proposal Due</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Mar 4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>Tue Mar 8</td>
<td>Apple Guest Lecture</td>
<td></td>
<td></td>
<td>PS 3 due (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps3-sol.pdf">Solutions</a>) Lab 3 <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/lab3.pdf">PDF</a></td>
<td></td>
</tr>
<tr>
<td>Thu Mar 10</td>
<td>L13: VLIW <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L13-VLIW.pdf">PDF</a></td>
<td>Ch. 3.2,3.7</td>
<td>Ch. 3.2,3.7</td>
<td>PS 4 (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps4.pdf">PDF</a>, <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps4.docx">DOC</a>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Mar 10</td>
<td>CS252A Readings Discussion</td>
<td><a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5392028">“An Efficient Algorithm for Exploiting Multiple Arithmetic units”</a>, Tomasulo, IBM Journal, January 1967 <a href="http://dl.acm.org/ft_gateway.cfm?id=357403">“Decoupled Access/Execute Computer Architectures”</a>, Smith, ISCA 1982 (ACM TOCS version) <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=491460">“The MIPS R10000 Superscalar microprocessor”</a>, Yeager, IEEE Micro 16(2), 1996</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Mar 11</td>
<td>CS152 Section 7: Branch Predictions and VLIW <a href="https://docs.google.com/presentation/d/1yOuSm4FrbWVI5FbB1jjCGDLyXPJ2OdM5dNEsqCq6Zrs/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/1ByZXsRouYhSeVaPpk2iqznj2fRVGGEkL_eAnE3I4M78/edit?usp=sharing">Worksheet 7</a> (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/sections/sp22/sec07-worksheet.pdf">PDF</a>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>Tue Mar 15</td>
<td>L14: Multithreading <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L14-Multithread.pdf">PDF</a></td>
<td>Ch. 3.12</td>
<td>Ch. 3.11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Mar 17</td>
<td>L15: Vectors <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L15-Vectors.pdf">PDF</a></td>
<td>Ch. 4.1-4.3 (App. G)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Mar 17</td>
<td>CS252A Readings Discussion</td>
<td><a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-TN-36.pdf">“Combining Branch Predictors”</a>, McFarling, DEC WRL Technical Note TN-36, 1993 <a href="http://ieeexplore.ieee.org/document/903263/">“Dynamic Branch Prediction with Perceptrons”</a>, Jimenez, Lin, HPCA 2001 <a href="http://www.irisa.fr/caps/people/seznec/JILP-COTTAGE.pdf">“A case for (partially) TAgged GEometric history length branch prediction </a>, Seznec, Michaud, Journal of Instruction Level Parallelism (JILP), 2006”</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Mar 19</td>
<td>CS152 Section 8: Multithreading and Vectors <a href="https://docs.google.com/presentation/d/1-y2WsY7HC1WOwu0Ymj1iYA4R34bDdLZdWEg5aAdnIBI/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/1gzGBmyk8Vd9XSFK5txMe2Xg8dMmBlqf6prS7yyDTfyU/edit?usp=sharing">Worksheet 8</a> (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/sections/sp22/sec08-worksheet.pdf">PDF</a>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>Mar 21-25</td>
<td>Spring Break</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>Tue Mar 29</td>
<td>L16: GPUs <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L16-GPU.pdf">PDF</a></td>
<td>Ch. 4.4-4.9</td>
<td>Ch. 4.4-4.9</td>
<td>PS 4 due <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps4-sol.pdf">PS 4 Solutions</a> Lab 3 due</td>
<td></td>
</tr>
<tr>
<td>Thu Mar 31</td>
<td>L17: Cache Coherence <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L17-Coherence.pdf">PDF</a></td>
<td>Ch. 4.1-4.3 (App. G)</td>
<td>Ch. 4.1-4.3 (App. G)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Mar 31</td>
<td>CS252A Readings Discussion</td>
<td><a href="http://dl.acm.org/citation.cfm?id=359336">“The CRAY-1 Computer System”</a>, Russel, CACM 1978 <a href="http://dl.acm.org/ft_gateway.cfm?id=801649">“Very Long Instruction Word Architectures and the ELI-512”</a>, Fisher, ISCA 1983 <a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=2247">“A VLIW Architecture for a Trace Scheduling Compiler”</a>, Colwell et al., IEEE Trans. Computers, 1988</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Apr 1</td>
<td>CS152 Section 9: Midterm 2 Review <a href="https://docs.google.com/presentation/d/1Hr5yp3Ir5tvgSQItyldyTxAB4W77LzuW6FMgcxJKuIQ/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/1Xatwgb6w1-ak7YWkPGzkAoeMdC6TsvRjgMa2eF4dLhs/edit?usp=sharing">Worksheet 10</a> (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/sections/sp22/sec10-worksheet.pdf">PDF</a>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>Tue Apr 5</td>
<td>L18: Cache Coherence II, Directories <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L18-Directory.pdf">PDF</a></td>
<td>Ch. 5.1-5.4</td>
<td>Ch. 5.1-5.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Apr 7</td>
<td>Midterm 2: L10-16 <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/mt2-sol.pdf">Solutions</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Apr 8</td>
<td>CS152 Section 10: Cache Coherence <a href="https://docs.google.com/presentation/d/1C4XvPVaE3iBSQo04GfwKEdWvck_sLf7v4IZriJ6XooY/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/1dSmS0TGCRsh-aWP0pxm-tN-nJxn2rja-VtHIdrNBaGY/edit?usp=sharing">Worksheet 11</a> (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/sections/sp22/sec11-worksheet.pdf">PDF</a>) PS 5 (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps5.pdf">PDF</a>, <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps5.doc">DOC</a>) <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/handout6.pdf">Handout 6</a> <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/handout7.pdf">Handout 7</a>  <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/lab4.pdf">Lab 4</a> <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/riscv-v-spec-0.10.html">RVV 0.10</a> <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/riscv-v-spec-0.10.pdf">[PDF]</a>  <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/lab5.pdf">Lab 5</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mon Apr 11</td>
<td>CS252A Project Checkpoint</td>
<td>Project update</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tue Apr 12</td>
<td>L19: Memory Consistency Models, Synchronization <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L19-MCM-Synch.pdf">PDF</a></td>
<td>Ch. 5.1, 5.5-5.6</td>
<td>Ch. 5.1, 5.5-5.6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Apr 14</td>
<td>L20: Power and Energy <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L20-Energy.pdf">PDF</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Apr 14</td>
<td>CS252A Readings Discussion</td>
<td><a href="http://dl.acm.org/ft_gateway.cfm?id=255132">“The Tera Computer System”</a>, Alverson et al, ICS 1990 <a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf">“Shared Memory Consistency Models: A Tutorial”</a>, Adve, Gharachorloo, DEC WRL TR, 1995 <a href="http://www.sgidepot.co.uk/origin/isca.pdf">“The SGI Origin: a ccNUMA highly scalable server”</a>, Laudon, Lenoski, ISCA 1997</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Fri Apr 15</td>
<td>CS152 Section 11: Memory Consistency and Synchronization <a href="https://docs.google.com/presentation/d/19e5jzldusf3We8EwoYxiPP6rPaEFTcwbWiBD4AACL6U/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td><a href="https://docs.google.com/document/d/10fBwgZagsr_68D-XRxxC5P5tml4OH-ejjz1C1jZuXbo/edit?usp=sharing">Worksheet 12</a> (<a href="https://inst.eecs.berkeley.edu/~cs152/sp22/sections/sp22/sec12-worksheet.pdf">PDF</a>)</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>Tue Apr 19</td>
<td>L21: Warehouse-Scale Computing <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L21-IO-WSC.pdf">PDF</a></td>
<td>Ch. 5.2-5.3</td>
<td>Ch. 5.2-5.3</td>
<td>Lab 4 due</td>
<td></td>
</tr>
<tr>
<td>Thu Apr 21</td>
<td>L22: <strong>2017 Turing Award Lecture</strong> <a href="https://www.acm.org/hennessy-patterson-turing-lecture">New Golden Age for Computer Architecture: Domain-Specific Hardware/Software Co-Design, Enhanced Security, Open Instruction Sets, and Agile Chip Development</a>, David Patterson and John Hennessy</td>
<td></td>
<td>Ch. 7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Apr 22</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>Tue Apr 26</td>
<td>L23: Reconfigurable Computing <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L23-RC.pdf">PDF</a></td>
<td>Ch. 6</td>
<td>Ch. 6</td>
<td>PS 5 due <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/assignments/sp22/sp22-ps5-sol.pdf">PS 5 Solutions</a></td>
<td></td>
</tr>
<tr>
<td>Thu Apr 28</td>
<td>L24: Last lecture: Wrap-up <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/lectures/L24-WrapUp.pdf">PDF</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu Apr 28</td>
<td>CS252A Project Checkpoint</td>
<td>Project update</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri Apr 29</td>
<td>CS152 Section 13: Final Review (Part 1) <a href="https://docs.google.com/presentation/d/1tbdv4n3ttcIDVPu0xbssjeWYYxPhUWwA-WFVmQFKjm8/edit?usp=sharing">Slides</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>Tue May 3</td>
<td>No lecture - RRR Week</td>
<td></td>
<td></td>
<td>Lab 5 due</td>
<td></td>
</tr>
<tr>
<td>Thu May 5</td>
<td>No CS152 lecture - RRR Week</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thu May 6</td>
<td>CS 252A Final Project Presentations</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri May 7</td>
<td>CS152 Section 14: Final Review</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>Wed May 11</td>
<td>CS 152 Final Exam: 11:30-2:30PM PDT (Exam Group 10) <a href="https://inst.eecs.berkeley.edu/~cs152/sp22/handouts/sp22/final-sol.pdf">Solutions</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fri May 14</td>
<td>CS 252A Final Project Papers due, 11:59PM PDT</td>
<td></td>
<td></td>
<td>Email pdf to all instructors.</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://inst.eecs.berkeley.edu/~cs152/sp22/">Home Page for UCB CS152/CS252A, Spring 2022 (berkeley.edu)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
        <category>CS152</category>
      </categories>
  </entry>
  <entry>
    <title>The Road Ahead week3 Sequential Logic</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AF%BE%E7%A8%8B/The%20Road%20Ahead%20week3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“The great wall is made by blocks”</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="为何要引入时间概念"><a href="#为何要引入时间概念" class="headerlink" title="为何要引入时间概念"></a>为何要引入时间概念</h2><p>目前为止，我们所讨论的电路都是直接输入输出，没有考虑时间因素，这种电路又叫做组合电路，从现在开始，我们要考虑引入时间影响。例如有如下场景：</p>
<ul>
<li>在不同时间下使用相同的硬件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入改变，输出也应当随之变化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> .. <span class="number">100</span>:</span><br><span class="line">    a[i] = b[i] + c[i]</span><br></pre></td></tr></table></figure>
<ul>
<li>记录状态，例如内存/计数器等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in 1 .. 100:</span><br><span class="line">    sum = sum + i</span><br></pre></td></tr></table></figure>
<ul>
<li>处理速度时，尽管我们希望我们的电路无延迟，但是实际过程肯定是有的，所以我们需要考虑计算机中器件的延迟</li>
</ul>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>离散的时钟信号如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220529120126.png" width = "580" alt="图片名称" align=center /></p>
<p>在一个时钟周期中，输入与输出是固定的，在不同时钟周期可能会有变化，且由于器件延迟，变化并不是实时的，会有一个变化时间。选择时钟信号的频率时，我们需要确保能够满足器件的响应时间</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/notsignal.svg" width = "580" alt="图片名称" align=center /></p>
<h2 id="组合逻辑和时序逻辑的区别"><a href="#组合逻辑和时序逻辑的区别" class="headerlink" title="组合逻辑和时序逻辑的区别"></a>组合逻辑和时序逻辑的区别</h2><ul>
<li>组合逻辑：<code>out[t] = func(in[t])</code></li>
<li>时序逻辑：<code>out[t] = func(in[t-1])</code>，或者<code>state[t] = func[state[t-1]]</code></li>
</ul>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="触发器介绍"><a href="#触发器介绍" class="headerlink" title="触发器介绍"></a>触发器介绍</h2><p>现在，让我们实现一个触发器功能，即在两种状态间进行翻转的电路，并最终实现以下逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">state[t] = func[state[t-1]]</span><br><span class="line"></span><br><span class="line">t0: a</span><br><span class="line">t1: b = func(a)</span><br><span class="line">t2: c = func(b)</span><br><span class="line">t3: d = func(c)</span><br></pre></td></tr></table></figure>
<p>为了实现上述功能，我们需要考虑下面这样一个部件：</p>
<ul>
<li>缺失的部件：<code>t-1</code>时刻的信息可以在<code>t</code>时刻使用</li>
<li>在<code>t-1</code>时刻的末尾，该部件可以有两种状态，记忆0或者记忆1</li>
<li>这个部件在可能的状态间进行切换，这种器件叫做触发器</li>
</ul>
<p>该器件的示意图和信号如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220529142301.png" width = "720" alt="图片名称" align=center /></p>
<p>其中尖角代表时钟信号，根据状态转移函数，可知out为前一时刻的in，实际就是将输入信号滞后一个时钟周期输出</p>
<h2 id="触发器实现"><a href="#触发器实现" class="headerlink" title="触发器实现"></a>触发器实现</h2><p>使用与非门实现触发器一般需要如下两个步骤：</p>
<ul>
<li>通过闭环实现一个时间无关的触发器</li>
<li>通过一个”主从”结构实现时间的隔离</li>
</ul>
<p>通过组合多个触发器，我们能够实现比较复杂的时序逻辑</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/secquencecircuit.svg" width = "640" alt="图片名称" align=center /></p>
<p>在本课程中，触发器是作为基本元件提供的</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器的目标是永久性存储一个值，直到载入一个新值为止</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220529142057.png" width = "320" alt="图片名称" align=center /></p>
<p>逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (load[t-1])</span><br><span class="line">    out[t] = in[t-1]</span><br><span class="line">else</span><br><span class="line">    out[t] = out[t-1]</span><br></pre></td></tr></table></figure>
<p>我们可以利用一个Mux和一个D触发器实现上面的电路：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220529142842.png" width = "320" alt="图片名称" align=center /></p>
<p>从电路图中我们能够看出，DFF总是保存输入的bit，但是寄存器仅在<code>load = true</code>时保存<code>in</code>，DFF仅能在一个时间单位保存信息，但是寄存器能够在多个时间单位中保存。</p>
<p>寄存器有两个重要属性：</p>
<ul>
<li>寄存器位宽</li>
<li>寄存器状态：保存在寄存器中的值</li>
</ul>
<p>需要注意的是，寄存器的状态和寄存器的输出值是有差异的，一个CPU时钟周期内，如果设置load为1，那么寄存器状态会在前半个周期就改变，而寄存器输出的值直到完整的一个周期才会发生变化。</p>
<h1 id="内存单元"><a href="#内存单元" class="headerlink" title="内存单元"></a>内存单元</h1><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>内存单元实际上就是寄存器组，假设一个内存块包含$n$个寄存器，那么内存的地址就是从0到$n-1$，对于任意时刻，内存中只会有一个寄存器被选中</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/memregister.svg" width = "480" alt="mem unit" align=center /></p>
<p>RAM是一个时序芯片，包含了时间行为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Let M stands for the state of the selected register</span></span><br><span class="line"><span class="keyword">if</span> load then &#123;</span><br><span class="line">    M = in</span><br><span class="line">    <span class="comment">// from the next cycle onward:</span></span><br><span class="line">    out = M        <span class="comment">// The output of RAM is slower than input</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    out = M</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存读写"><a href="#内存读写" class="headerlink" title="内存读写"></a>内存读写</h3><p><strong>读操作：</strong></p>
<ul>
<li><code>set address = i</code></li>
</ul>
<p>输出的结果即为寄存器$i$的值</p>
<p><strong>写操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set address = i</span><br><span class="line">set in = v</span><br><span class="line">set load = 1</span><br></pre></td></tr></table></figure>
<h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 16-bit counter with load and reset control bits.</span></span><br><span class="line"><span class="comment"> * if      (reset[t] == 1) out[t+1] = 0</span></span><br><span class="line"><span class="comment"> * else if (load[t] == 1)  out[t+1] = in[t]</span></span><br><span class="line"><span class="comment"> * else if (inc[t] == 1)   out[t+1] = out[t] + 1  (integer addition)</span></span><br><span class="line"><span class="comment"> * else                    out[t+1] = out[t]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CHIP PC &#123;</span><br><span class="line">    IN in[<span class="number">16</span>],load,inc,reset;</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    Inc16(in = dout, out = pcInc);</span><br><span class="line">    Mux16(a = dout, b = pcInc, sel = inc, out = out1);</span><br><span class="line">    Mux16(a = out1, b = in, sel = load, out = out2);</span><br><span class="line">    Mux16(a = out2, b = <span class="literal">false</span>, sel = reset, out = out3);</span><br><span class="line"></span><br><span class="line">    Register(in = out3, load = <span class="literal">true</span>, out = out, out = dout);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.coursera.org/learn/build-a-computer/lecture/ssuag/unit-3-1-sequential-logic">Unit 3.1: Sequential Logic | Coursera</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://zhangruochi.com/Sequential-Logic/2019/05/27/">Sequential Logic | RUOCHI.AI (zhangruochi.com)</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>The Road Ahead week2 Boolean Arithmetic and the ALU</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AF%BE%E7%A8%8B/The%20Road%20Ahead%20week2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“The great wall is made by blocks”</p>
</blockquote>
<a id="more"></a>
<h1 id="二进制加法"><a href="#二进制加法" class="headerlink" title="二进制加法"></a>二进制加法</h1><h2 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h2><p>我们考虑最基本的二进制加法，两位相加，然后再扩展到高位上。对于一个对<code>a, b</code>两位相加的加法器，我们称其为半加器，输入是<code>a, b</code>两位，输出为和<code>sum</code>以及进位<code>carry</code></p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220522103649.png" width = "480" alt="图片名称" align=center /></p>
<p>半加器实际上就是不考虑输入进位的加法器</p>
<h2 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h2><p>现在我们考虑进位，引入全加器，即在输入端考虑有进位的情况，全加器的真值表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>c</th>
<th>b</th>
<th>a</th>
<th>sum(out)</th>
<th>carry(out)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>实际上全加器就是计算( a + b + carry)，可以用两个半加器实现，实现方式如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220522113305.png" width = "480" alt="图片名称" align=center /></p>
<h2 id="多位加法器"><a href="#多位加法器" class="headerlink" title="多位加法器"></a>多位加法器</h2><p>现在我们来考虑如何实现多位加法，一样的道理，对于每一位运算，我们可以使用一个全加器，对于第一位，输入的carry设置为0即可，也不难，这里来直接给出HDL实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/02/Adder16.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds two 16-bit values.</span></span><br><span class="line"><span class="comment"> * The most significant carry bit is ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CHIP Add16 &#123;</span><br><span class="line">    IN a[<span class="number">16</span>], b[<span class="number">16</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put you code here:</span></span><br><span class="line">    HalfAdder(a = a[<span class="number">0</span>], b = b[<span class="number">0</span>],            sum = out[<span class="number">0</span>],  carry = c0);    <span class="comment">// The first bit not have a carry, use a half adder</span></span><br><span class="line">    FullAdder(a = a[<span class="number">1</span>], b = b[<span class="number">1</span>],   c = c0,  sum = out[<span class="number">1</span>],  carry = c1);</span><br><span class="line">    FullAdder(a = a[<span class="number">2</span>], b = b[<span class="number">2</span>],   c = c1,  sum = out[<span class="number">2</span>],  carry = c2);</span><br><span class="line">    FullAdder(a = a[<span class="number">3</span>], b = b[<span class="number">3</span>],   c = c2,  sum = out[<span class="number">3</span>],  carry = c3);</span><br><span class="line"></span><br><span class="line">    FullAdder(a = a[<span class="number">4</span>], b = b[<span class="number">4</span>],   c = c3,  sum = out[<span class="number">4</span>],  carry = c4);</span><br><span class="line">    FullAdder(a = a[<span class="number">5</span>], b = b[<span class="number">5</span>],   c = c4,  sum = out[<span class="number">5</span>],  carry = c5);</span><br><span class="line">    FullAdder(a = a[<span class="number">6</span>], b = b[<span class="number">6</span>],   c = c5,  sum = out[<span class="number">6</span>],  carry = c6);</span><br><span class="line">    FullAdder(a = a[<span class="number">7</span>], b = b[<span class="number">7</span>],   c = c6,  sum = out[<span class="number">7</span>],  carry = c7);</span><br><span class="line"></span><br><span class="line">    FullAdder(a = a[<span class="number">8</span>], b = b[<span class="number">8</span>],   c = c7,  sum = out[<span class="number">8</span>],  carry = c8);</span><br><span class="line">    FullAdder(a = a[<span class="number">9</span>], b = b[<span class="number">9</span>],   c = c8,  sum = out[<span class="number">9</span>],  carry = c9);</span><br><span class="line">    FullAdder(a = a[<span class="number">10</span>], b = b[<span class="number">10</span>], c = c9,  sum = out[<span class="number">10</span>], carry = c10);</span><br><span class="line">    FullAdder(a = a[<span class="number">11</span>], b = b[<span class="number">11</span>], c = c10, sum = out[<span class="number">11</span>], carry = c11);</span><br><span class="line"></span><br><span class="line">    FullAdder(a = a[<span class="number">12</span>], b = b[<span class="number">12</span>], c = c11, sum = out[<span class="number">12</span>], carry = c12);</span><br><span class="line">    FullAdder(a = a[<span class="number">13</span>], b = b[<span class="number">13</span>], c = c12, sum = out[<span class="number">13</span>], carry = c13);</span><br><span class="line">    FullAdder(a = a[<span class="number">14</span>], b = b[<span class="number">14</span>], c = c13, sum = out[<span class="number">14</span>], carry = c14);</span><br><span class="line">    FullAdder(a = a[<span class="number">15</span>], b = b[<span class="number">15</span>], c = c14, sum = out[<span class="number">15</span>], carry = c15);    <span class="comment">// Omit the carry when do last bit add</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个加法器的一个问题是进位信号在16个门之间传递，效率比较低，有一种方法叫做<code>carry look ahead</code>，即超前进位加法器，优点是速度快，缺点是器件会增加很多：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220528092929.png" width = "640" alt="图片名称" align=center /></p>
<h1 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h1><p>如果我们用最高位表示符号，即可得到负数，$-x$可以使用如下公式进行计算：</p>
<script type="math/tex; mode=display">
-(2^{n}-x)</script><p>例如对于二进制1001 (9)，对应的负数为$-(2^{4}-9) = (-7)$，我们称$9$为$-7$的补数，此处我们给出一个重要结论，两个负数相加可以表示为它们的补数相加：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{aligned}
-7+(-6)&=-(2^{4}-9) + (-(2^{4}-10))\\
       &=9+10
\end{aligned}
\end{equation}</script><p>由于我们抛弃了最高位，因此得到的补数和所需的负数结果相同。现在我们需要考虑给定一个数$x$，如何获取他的负数$-x$？这样我们就可以将减法转化为加法：$y-x=y+(-x)$。即我们需要如下芯片：</p>
<blockquote>
<p>$\textrm{Input}: x$</p>
<p>$\textrm{Output}: -x$</p>
</blockquote>
<p>这里我们运用一个小技巧：为了计算$(2^{n}-x)$，我们可以计算$2^n-x=1+(2^{n}-1)-x$，这样做的好处是$2^{n}-1$全部为1，做减法不需要借位，只需要将被减数按位翻转即可，所以这里我们得到了最终的结论，很重要，记住：<strong>一个负数等于其正数按位翻转后+1</strong></p>
<h1 id="算数逻辑单元（ALU）"><a href="#算数逻辑单元（ALU）" class="headerlink" title="算数逻辑单元（ALU）"></a>算数逻辑单元（ALU）</h1><p>现在我们来构造CPU中最重要的模块：ALU，其模块图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220522153801.png" width = "560" alt="图片名称" align=center /></p>
<p>ALU：输入两个操作数和待执行的函数（算数或逻辑运算），给出指定结果，对于本课程的Hack ALU，其结构如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220522154129.png" width = "480" alt="图片名称" align=center /></p>
<p>根据六个输入控制位<code>zx, nx, zy, ny, f, no</code>，可以选择不同的操作，Hack ALU支持的操作如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出立即数</th>
<th>一元逻辑运算</th>
<th>二元逻辑运算</th>
<th>数学运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>x</td>
<td>x &amp; y</td>
<td>-x</td>
</tr>
<tr>
<td>1</td>
<td>y</td>
<td>x \</td>
<td>y</td>
<td>-y</td>
</tr>
<tr>
<td>-1</td>
<td>!x</td>
<td></td>
<td>x+1</td>
</tr>
<tr>
<td></td>
<td>!y</td>
<td></td>
<td>y+1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>x-1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>y-1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>x+y</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>x-y</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>y-x</td>
</tr>
</tbody>
</table>
</div>
<p>同时，该ALU还有两个输出控制位<code>zr, ng</code>，表示输出是否为0或者为负数，ALU的HDL代码框架如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Chip name: ALU</span><br><span class="line">Inputs: x[<span class="number">16</span>], y[<span class="number">16</span>], <span class="comment">// Two 16-bit data inputs</span></span><br><span class="line">    <span class="comment">// Your ALU should first deal with zx, then nx</span></span><br><span class="line">    zx, <span class="comment">// Zero the x input</span></span><br><span class="line">    nx, <span class="comment">// Negate the x input</span></span><br><span class="line">    zy, <span class="comment">// Zero the y input</span></span><br><span class="line">    ny, <span class="comment">// Negate the y input</span></span><br><span class="line">    f, <span class="comment">// Function code: 1 for Add, 0 for And</span></span><br><span class="line">    no <span class="comment">// Negate the out output</span></span><br><span class="line">Outputs: out[<span class="number">16</span>], <span class="comment">// 16-bit output</span></span><br><span class="line">    zr, <span class="comment">// True iff out=0</span></span><br><span class="line">    ng <span class="comment">// True iff out&lt;0</span></span><br><span class="line">Function: <span class="keyword">if</span> zx then x = <span class="number">0</span> <span class="comment">// 16-bit zero constant</span></span><br><span class="line">          <span class="keyword">if</span> nx then x = !x <span class="comment">// Bit-wise negation</span></span><br><span class="line">          <span class="keyword">if</span> zy then y = <span class="number">0</span> <span class="comment">// 16-bit zero constant</span></span><br><span class="line">          <span class="keyword">if</span> ny then y = !y <span class="comment">// Bit-wise negation</span></span><br><span class="line">          <span class="keyword">if</span> f then out = x + y <span class="comment">// Integer 2's complement addition</span></span><br><span class="line">               <span class="keyword">else</span> out = x &amp; y <span class="comment">// Bit-wise And</span></span><br><span class="line">          <span class="keyword">if</span> no then out = !out <span class="comment">// Bit-wise negation</span></span><br><span class="line">          <span class="keyword">if</span> out=<span class="number">0</span> then zr = <span class="number">1</span> <span class="keyword">else</span> zr = <span class="number">0</span> <span class="comment">// 16-bit eq. comparison</span></span><br><span class="line">          <span class="keyword">if</span> out&lt;<span class="number">0</span> then ng = <span class="number">1</span> <span class="keyword">else</span> ng = <span class="number">0</span> <span class="comment">// 16-bit neg. comparison</span></span><br><span class="line">Comment: Overflow is neither detected nor handled</span><br></pre></td></tr></table></figure>
<p>控制位的真值表如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20220525123131.png" width = "720" alt="图片名称" align=center /></p>
<p>我们解释一下其中几行比较迷惑的</p>
<ul>
<li>计算1：为了计算1，我们可以对齐按位取反，得到b’1110，而b’1110为$-2$，即$-1+(-1)$，故只需要将$x$与$y$归零并按位取反即可</li>
<li>计算$-x$：$-x=\overline x+1$，故$-x-1=\overline x$，两边同时取反，可得$\overline{-x-1}=x$，令$x=-x$，即可得到$\overline{x-1}=-x$。</li>
<li>计算$x-y$：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
x-y&=-(\overline x+1)-y \\
&=-(\overline x+y)-1\\
-(\overline x+y) &=\overline{(\overline x+y)}+1\\
x-y&=\overline{\overline x+y}
\end{aligned}</script><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.nand2tetris.org/_files/ugd/44046b_89c60703ebfc4bf39acef13bdc050f5d.pdf">The Elements of Computing Systems (nand2tetris.org)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>The Road Ahead week5 CPU</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AF%BE%E7%A8%8B/The%20Road%20Ahead%20week5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>从本章开始，我们已经具备了搭建一个CPU的所有部件，现在需要将这些部件进行组装，形成一个真正的CPU。</p>
<a id="more"></a>
<h2 id="CPU接口"><a href="#CPU接口" class="headerlink" title="CPU接口"></a>CPU接口</h2><p>CPU的接口如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/cpudiagram.svg" width = "480" alt="Hack computer Arch" align=center /></p>
<p>输入：</p>
<ul>
<li>inM：来自Data Memory</li>
<li>instruction: 来自Instruction Memory</li>
</ul>
<p>输出：</p>
<ul>
<li>outM/writeM/addressM：输出至Data Memory</li>
<li>pc：输出至Instruction Memory</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.nand2tetris.org/_files/ugd/44046b_89c60703ebfc4bf39acef13bdc050f5d.pdf">The Elements of Computing Systems (nand2tetris.org)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>增删查改排序</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>增删查改排序是处理多对象的几种常规操作，本文将针对面向对象过程中的增删查改排序操作进行总结。</p>
<a id="more"></a>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="http://asi.insa-rouen.fr/enseignement/siteUV/genie_logiciel/supports/ressources/exemples_de_la_vie_reelle_pour_illustrer_pattern.pdf">Gamma E. Design patterns: elements of reusable object-oriented software[M]. Pearson Education India, 1995.</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">设计模式简介</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>设计模式</category>
        <category>面向对象</category>
      </categories>
  </entry>
  <entry>
    <title>The Road Ahead week4 Machine language</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AF%BE%E7%A8%8B/The%20Road%20Ahead%20week4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>“The great wall is made by blocks”</p>
</blockquote>
<a id="more"></a>
<h2 id="Hack-computer-and-machine-language"><a href="#Hack-computer-and-machine-language" class="headerlink" title="Hack computer and machine language"></a>Hack computer and machine language</h2><p>在前几章中，我们已经定义了内存以及加法器，从本章开始我们将介绍Hack computer的基本结构，并最终搭建起一个简单的CPU。我们的机器是一个16位机器，由以下几个部分组成：</p>
<ul>
<li>Data memory (RAM)：A sequence of 16 bit registers</li>
<li>Instruction memory (ROM)：A sequence of 16 bit registers</li>
<li>Central processing unit (CPU)：perform 16 bit instructions</li>
<li>Instruction bus/data bus/address bus</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/Hackcomarch.svg" width = "480" alt="Hack computer Arch" align=center /></p>
<p>而Hack的机器语言包括16位的A指令和C指令，操作3个寄存器：</p>
<ul>
<li>D寄存器保存一个16位的数据</li>
<li>A寄存器保存16位地址</li>
<li>M寄存器保存A寄存器地址对应的内存寄存器</li>
</ul>
<h2 id="Hack计算机的汇编代码"><a href="#Hack计算机的汇编代码" class="headerlink" title="Hack计算机的汇编代码"></a>Hack计算机的汇编代码</h2><h3 id="A-指令"><a href="#A-指令" class="headerlink" title="A 指令"></a>A 指令</h3><p>A指令的语法为：<code>@value</code>，其中，value是一个非负整数；其作用是将A寄存器设置为<code>value</code>，并将<code>RAM[A]</code>置为所选择的寄存器，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set A = 21 and select RAM[21]</span><br><span class="line">@21  # A = 21, M = RAM[21]</span><br><span class="line"></span><br><span class="line">; to set RAM[100] to -1</span><br><span class="line">@100     # A = 100</span><br><span class="line">M = -1   # RAM[100] = -1</span><br></pre></td></tr></table></figure>
<p>当我们需要操作内存时，总是需要A指令。</p>
<h3 id="C指令"><a href="#C指令" class="headerlink" title="C指令"></a>C指令</h3><p>C指令的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dest = comp ; jump    # 其中dest和jump都是可选的，comp指计算的操作，可选的computation如下：</span><br><span class="line"></span><br><span class="line">comp = 0, 1, -1, D, A, !D, !A, -D, -A, D + 1, A + 1, D - 1, A - 1, D + A, D - A, A - D, D &amp; A, D | A</span><br><span class="line">                    M,     !M,     -M,        M + 1,        M - 1, D + M, D - M, M - D, D &amp; M, D | M</span><br><span class="line"></span><br><span class="line">dest = NULL, M, D, MD, A, AM, AD, AMD     # M refers to RAM[A]</span><br><span class="line"></span><br><span class="line">jump = NULL, JGT, JEQ, JGE, JLT, JNE, JLE, JMP  # 如果计算结果 (&gt;, &gt;=, ==, &lt;=, &lt;, !=) 0, 则跳转至ROM[A]</span><br></pre></td></tr></table></figure>
<p>C指令的功能包括：</p>
<ul>
<li>执行comp</li>
<li>将结果保存在dest中</li>
<li>如果计算结果与0比较成立，那么跳转</li>
</ul>
<p>一个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># if (D - 1 == 0), jump to execute instruction in ROM[56]</span><br><span class="line">@56          # A = 56</span><br><span class="line">D - 1; JEQ   # if (D - 1 == 0) goto 56</span><br><span class="line"></span><br><span class="line"># unconditional jump</span><br><span class="line">@END</span><br><span class="line">D ; JGE      # jump to END</span><br></pre></td></tr></table></figure>
<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>Hack computer实现了一种非常简单的指令集，支持上述的A指令和C指令，指令集的格式分别如下：</p>
<h3 id="A指令"><a href="#A指令" class="headerlink" title="A指令"></a>A指令</h3><p>A指令的二进制机器码格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 + value   # value是一个15位的二进制数</span><br></pre></td></tr></table></figure>
<p>例如，代码<code>0000000000010101</code>表示为将A寄存器置为21。</p>
<h3 id="C指令-1"><a href="#C指令-1" class="headerlink" title="C指令"></a>C指令</h3><p>C指令的格式相对较为复杂    ，其二进制语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   15    14 13  12 11 10  9  8  7  6    5  4  3    2  1  0</span><br><span class="line">   1   |  1 1  | a c1 c2 c3 c4 c5 c6 | d1 d2 d3 | j1 j2 j3 |</span><br><span class="line">opcode | unuse |      comp bits      |   dest   | jump bit |</span><br></pre></td></tr></table></figure>
<p>我们先来看下comp字段，对于comp字段，对应的含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Comp</th>
<th></th>
<th>c1(instruction[11])</th>
<th>c2(10)</th>
<th>c3(9)</th>
<th>c4(8)</th>
<th>c5(7)</th>
<th>c6(6)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>-1</td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>D</td>
<td></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>A</td>
<td>M</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>!D</td>
<td></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>!A</td>
<td>!M</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>-D</td>
<td></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>-A</td>
<td>-M</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>D+1</td>
<td></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>A+1</td>
<td>M+1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>D-1</td>
<td></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>A-1</td>
<td>M-1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>D+A</td>
<td>D+M</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>D-A</td>
<td>D-M</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>A-D</td>
<td>M-D</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>D&amp;A</td>
<td>D&amp;M</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>D\</td>
<td>A</td>
<td>D\</td>
<td>M</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>a(12) = 0</strong></td>
<td><strong>a = 1</strong></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>dest字段为寄存器写入字段，指示待写入寄存器</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>dest</th>
<th>d1(instruction[5])</th>
<th>d2(4)</th>
<th>d3(3)</th>
<th>effect: the value is stored in</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>The value is not stored</td>
</tr>
<tr>
<td>M</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>RAM[A]</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>D register</td>
</tr>
<tr>
<td>MD</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>RAM[A] and D register</td>
</tr>
<tr>
<td>A</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>A register</td>
</tr>
<tr>
<td>AM</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>A register and RAM[A]</td>
</tr>
<tr>
<td>AD</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>A register and D register</td>
</tr>
<tr>
<td>AMD</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>A/RAM[A]/D</td>
</tr>
</tbody>
</table>
</div>
<p>jump字段如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>jump</th>
<th>j1(2)</th>
<th>j2(1)</th>
<th>j3(0)</th>
<th>effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>no jump</td>
</tr>
<tr>
<td>JGT</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>if out &gt; 0 jump<br />j3 == 1 &amp;&amp; ALUOut &gt; 0</td>
</tr>
<tr>
<td>JEQ</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>out == 0</td>
</tr>
<tr>
<td>JGE</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>out &gt;= 0</td>
</tr>
<tr>
<td>JLT</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>out &lt; 0</td>
</tr>
<tr>
<td>JNE</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>out != 0</td>
</tr>
<tr>
<td>JLE</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>out &lt;= 0</td>
</tr>
<tr>
<td>JMP</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>unconditional jump</td>
</tr>
</tbody>
</table>
</div>
<h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h2><h3 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h3><p>我们需要接收用户的输入，并从屏幕上进行显示，对于屏幕显示的部分，我们可以将屏幕视为一个矩阵，对其进行操作，通过定期刷新映射到屏幕的内存，实现屏幕更新。我们的计算机是双字节计算机，对于一个$512\times256$大小的屏幕，所需要的内存单元数量为8192（512*256/16）个。32个内存单元能够表示一行，例如我要设置第$(row,col)$个像素，那么我要修改的内存单元为：</p>
<script type="math/tex; mode=display">
i = 32\times row+col/16</script><p>写为代码即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">word = Screen[<span class="number">32</span> * row + col / <span class="number">16</span>]</span><br></pre></td></tr></table></figure>
<p>需要注意的是，屏幕映射的内存是我们整个内存的一部分，因此我们还需要知道屏幕内存的基地址，假设我们的屏幕内存位于16384，则</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">word = RAM[<span class="number">16384</span> + <span class="number">32</span> * row + col / <span class="number">16</span>]</span><br></pre></td></tr></table></figure>
<p>找到了这个双字后，我们需要将第<code>col % 16</code>个bit设置，然后将其写回到内存中。</p>
<h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>我们同样对于键盘进行了映射，不过相比屏幕，键盘所需的内存很小，我们只映射16位的内存给键盘，当我们按下一个按键后，键盘中的内容会记录在这个内存中，对于Hack计算机，能够识别的字符集为ASCII的子集。在Hack中，我们将键盘映射至24567这个地址中。经过映射之后，Hack的内存布局如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/hackmemoryio.svg" width = "320" alt="Hack computer Arch" align=center /></p>
<h2 id="Hack程序"><a href="#Hack程序" class="headerlink" title="Hack程序"></a>Hack程序</h2><h3 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h3><p>这里我们列举了Hack中一些基本的寄存器和内存的操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// D = 10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D = A</span><br><span class="line"></span><br><span class="line"><span class="comment">// D++</span></span><br><span class="line">D = D + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[17] = 0</span></span><br><span class="line">@<span class="number">17</span></span><br><span class="line">M = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[17] = 10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D = A</span><br><span class="line">@<span class="number">17</span></span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line"><span class="comment">// RAM[5] = RAM[3]</span></span><br><span class="line">@<span class="number">3</span></span><br><span class="line">D = M</span><br><span class="line">@<span class="number">5</span></span><br><span class="line">M = D</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的计算两数相加的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// RAM[2] = RAM[0] + RAM[1]</span><br><span class="line">@0</span><br><span class="line">D = M        // D = RAM[0]</span><br><span class="line"></span><br><span class="line">@1</span><br><span class="line">D = D + M    // D = D + RAM[1]</span><br><span class="line"></span><br><span class="line">@2</span><br><span class="line">M = D        // RAM[2] = D</span><br></pre></td></tr></table></figure>
<h3 id="内嵌符号"><a href="#内嵌符号" class="headerlink" title="内嵌符号"></a>内嵌符号</h3><p>Hack汇编包含了一些内嵌的符号，对一些值进行了常数替换，前16个RAM的字用作虚拟寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbol   value</span><br><span class="line">    R0       0</span><br><span class="line">    R1       1</span><br><span class="line">   ...     ...</span><br><span class="line">   R15      15</span><br><span class="line"></span><br><span class="line">SCREEN   16384</span><br><span class="line">   KBD   24576</span><br></pre></td></tr></table></figure>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Program: Signum.asm</span><br><span class="line">// Compute if R0 &gt; 0 then R1 = 1; else R1 = 0</span><br><span class="line"></span><br><span class="line">@R0</span><br><span class="line">D = M</span><br><span class="line"></span><br><span class="line">@8</span><br><span class="line">D; JGT    // if R0 &gt; 0</span><br><span class="line"></span><br><span class="line">@R1</span><br><span class="line">M = 0</span><br><span class="line">@10</span><br><span class="line">0; JMP</span><br><span class="line"></span><br><span class="line">@R1</span><br><span class="line">M = 1</span><br><span class="line"></span><br><span class="line">@10</span><br><span class="line">0; JMP</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>我们能够指定内存中某个寄存器，保存对应的变量，变量由变量名、地址以及值组成，下面是一个变量使用的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Program: Flip.asm</span><br><span class="line">// flips the values of</span><br><span class="line">// RAM[0] and RAM[1]</span><br><span class="line"></span><br><span class="line">// temp = R1</span><br><span class="line">// R1 = R0</span><br><span class="line">// R0 = temp</span><br><span class="line"></span><br><span class="line">@R1</span><br><span class="line">D = M</span><br><span class="line">@temp        // @16</span><br><span class="line">M = D</span><br><span class="line">// @temp : find some available memory register, say the n&apos;th register, use it to represent the variable temp, the @temp in program will be translated into @n</span><br><span class="line"></span><br><span class="line">@R0</span><br><span class="line">D = M</span><br><span class="line">@R1</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">@temp        // @16</span><br><span class="line">D = M</span><br><span class="line">@R0</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">@END</span><br><span class="line">0; JMP</span><br></pre></td></tr></table></figure>
<p>变量的使用语境如下：</p>
<ul>
<li>加入一个符号没有与之对应的标签，那么将其视为一个变量</li>
<li>变量从内存中某个位置开始，逐渐向上递增</li>
</ul>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>这里给出一个迭代的实现，计算$1+2+…+n$的值，假设$n$保存在<code>RAM[0]</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Computes RAM[1] = 1 + 2 + 3 + ... + n</span><br><span class="line">// Put a number n in RAM[0]</span><br><span class="line">// Program: Sum1toN.asm</span><br><span class="line"></span><br><span class="line">    n = R0</span><br><span class="line">    i = 1</span><br><span class="line">    sum = 0</span><br><span class="line">LOOP:</span><br><span class="line">    if i &gt; n goto STOP</span><br><span class="line">    sum = sum + i</span><br><span class="line">    i = i + 1</span><br><span class="line">    goto LOOP</span><br><span class="line"></span><br><span class="line">STOP:</span><br><span class="line">    R1 = sum</span><br></pre></td></tr></table></figure>
<p>此处关键的实现是迭代的逻辑，这里给出迭代的逻辑实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(LOOP)</span><br><span class="line">    @i</span><br><span class="line">    D = M</span><br><span class="line">    @n</span><br><span class="line">    D = D - M</span><br><span class="line">    @STOP</span><br><span class="line">    D; JGT</span><br></pre></td></tr></table></figure>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">//     arr[i] = -1;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// suppose that arr = 100, n = 10</span><br><span class="line">    @100</span><br><span class="line">    D = A    // D = 100</span><br><span class="line">    @arr</span><br><span class="line">    M = D    // arr = 100</span><br><span class="line"></span><br><span class="line">    @10</span><br><span class="line">    D = A</span><br><span class="line">    @n</span><br><span class="line">    M = D</span><br><span class="line">    </span><br><span class="line">    @i</span><br><span class="line">    M = 0</span><br></pre></td></tr></table></figure>
<p>在对变量进行初始化之后，内存布局如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0x0 </span><br><span class="line">|                  |</span><br><span class="line">+------------------+  </span><br><span class="line">|        ...       |</span><br><span class="line">+------------------+  &lt;- 0x10 (arr)</span><br><span class="line">|        100       |</span><br><span class="line">+------------------+  &lt;- 0x11 (n)</span><br><span class="line">|        10        |</span><br><span class="line">+------------------+  &lt;- 0x12 (i)</span><br><span class="line">|        0         |</span><br><span class="line">+------------------+</span><br><span class="line">|        ...       |</span><br><span class="line">+------------------+  &lt;- 0x64 </span><br><span class="line">|        ...       |</span><br><span class="line">+------------------+</span><br><span class="line">|        ...       |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>
<p>循环部分如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(LOOP)</span><br><span class="line">    // if (i - n &gt;= 0) &#123;Jump to END&#125;</span><br><span class="line">    @i</span><br><span class="line">    D = M</span><br><span class="line">    @n</span><br><span class="line">    D = D - M</span><br><span class="line">    @END</span><br><span class="line">    D; JGE</span><br><span class="line"></span><br><span class="line">    // arr[i] = -1</span><br><span class="line">    @arr</span><br><span class="line">    D = M        // arr stores the base address</span><br><span class="line">    @i</span><br><span class="line">    A = D + M    // Pointer</span><br><span class="line">    M = -1</span><br><span class="line"></span><br><span class="line">    // i++</span><br><span class="line">    @i</span><br><span class="line">    M = M + 1</span><br><span class="line"></span><br><span class="line">    @LOOP</span><br><span class="line">    0; JMP</span><br></pre></td></tr></table></figure>
<p>当我们需要使用指针对内存进行访问时，我们需要如下指令：A = M</p>
<h3 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h3><p>最后，我们给出一些简单的IO操作，让我们能够在屏幕上绘制一些基本的图形，例如从屏幕的左上角开始，绘制多行黑色的像素，对应的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">//      draw 16 hack pixels at the</span><br><span class="line">//      beginning of row i</span><br><span class="line">//  &#125;</span><br><span class="line"></span><br><span class="line">addr = SCREEN</span><br><span class="line">n    = RAM[0]</span><br><span class="line">i    = 0</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    if i &gt; n goto END</span><br><span class="line">    RAM[addr] = -1     // 1111,1111,1111,1111</span><br><span class="line">    // advances to the next row</span><br><span class="line">    addr = addr + 32   // To next line</span><br><span class="line">    i = i + 1</span><br><span class="line">    goto LOOP</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">    goto END</span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.nand2tetris.org/_files/ugd/44046b_89c60703ebfc4bf39acef13bdc050f5d.pdf">The Elements of Computing Systems (nand2tetris.org)</a><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>素描基础</title>
    <url>/2024/10/13/%E7%94%9F%E6%B4%BB/%E7%BE%8E%E6%9C%AF/%E7%B4%A0%E6%8F%8F/%E7%B4%A0%E6%8F%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://images.uffizi.it/production/attachments/1537269300157660-tre-alberi.jpg?ixlib=rails-2.1.3&w=2500&h=2500&fit=unset&crop=center&fm=pjpg&auto=compress&mark=https%3A%2F%2Fimages.uffizi.it%2Fproduction%2Fattachments%2Flogo-watermark.png" width = 1000 alt="" align=center /></p>
<p>本文将针对素描中的一些基础概念进行总结</p>
<a id="more"></a>
<h2 id="明暗关系"><a href="#明暗关系" class="headerlink" title="明暗关系"></a>明暗关系</h2><p>物体受光照射后，会呈现出不同的明暗关系，这里我们针对描述明暗关系的三大面和五大调进行总结</p>
<h3 id="三大面"><a href="#三大面" class="headerlink" title="三大面"></a>三大面</h3><p>三大面即黑白灰三个面</p>
<ul>
<li>受光面：亮面</li>
<li>测光面：灰面</li>
<li>被光面：暗面</li>
</ul>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/8df7b4fa7398f69272a85b3b93cd0201.jpg?raw=true" width = 500 alt="" align=center /></p>
<h3 id="五大调"><a href="#五大调" class="headerlink" title="五大调"></a>五大调</h3><p>而五大调是在三大面基础上分出的画面中的五种元素，分别为：</p>
<ul>
<li>受光面<ul>
<li>亮面</li>
<li>灰面</li>
</ul>
</li>
<li>被光面<ul>
<li>明暗交界线</li>
<li>反光</li>
<li>阴影</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/news_1587878159958.jpeg?raw=true" width = 600 alt="" align=center /></p>
<p>在亮面中，还有高光的概念，就是光源最直接照射的关系，即垂直照射。下面是一个立方体的素描。比球体的亮暗关系更加锐利，它也有反光部分，一般来说暗面底部会比上部亮一些</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/20209261709.JPG?raw=true" width = 200 alt="" align=center /></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.youtube.com/watch?v=N4Z4MdZ1KWY&amp;list=PLR3Ra9cf8aV2Zl8LIqT93rsgnpkSvmevk&amp;index=2&amp;ab_channel=MortMort">Youtube 上关于Aseprite的教程</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://www.mortmort.net/">mortmort官网</a><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>生活</category>
        <category>美术</category>
        <category>素描</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-Lab3-用户环境</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-Lab3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>且将杯酒对星河</p>
</blockquote>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文将实现使用户环境（即进程）运行的内核功能。在本实验中，你需要：</p>
<ul>
<li>建立起跟踪进程的数据结构</li>
<li>创建一个进程</li>
<li>载入程序镜像</li>
<li>让程序运行</li>
<li>处理进程的系统调用</li>
</ul>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">athena% cd ~/<span class="number">6.828</span>/lab</span><br><span class="line">athena% add git</span><br><span class="line">athena% git commit -am 'changes to lab2 after handin'</span><br><span class="line">Created commit <span class="number">734f</span>ab7: changes to lab2 after handin</span><br><span class="line"> <span class="number">4</span> files changed, <span class="number">42</span> insertions(+), <span class="number">9</span> deletions(-)</span><br><span class="line">athena% git pull</span><br><span class="line">Already up-to-date.</span><br><span class="line">athena% git checkout -b lab3 origin/lab3</span><br><span class="line">Branch lab3 <span class="built_in">set</span> up to track remote branch refs/remotes/origin/lab3.</span><br><span class="line">Switched to a <span class="keyword">new</span> branch <span class="string">"lab3"</span></span><br><span class="line">athena% git merge lab2</span><br><span class="line">Merge made by recursive.</span><br><span class="line"> kern/pmap.c |   <span class="number">42</span> +++++++++++++++++++</span><br><span class="line"> <span class="number">1</span> files changed, <span class="number">42</span> insertions(+), <span class="number">0</span> deletions(-)</span><br><span class="line">athena%</span><br></pre></td></tr></table></figure>
<p>首先，合并lab2，然后切换至lab3，在lab3中，你需要参考及阅读的源码如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>文件</th>
<th>功能</th>
<th>进度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inc/</code></td>
<td><code>env.h</code></td>
<td>Public definitions for user-mode environments</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code></td>
<td>Public definitions for trap handling</td>
<td>完成</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>Public definitions for system calls from user environments to the kernel</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>lib.h</code></td>
<td>Public definitions for the user-mode support library</td>
<td></td>
</tr>
<tr>
<td><code>kern/</code></td>
<td><code>env.h</code></td>
<td>Kernel-private definitions for user-mode environments</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>env.c</code></td>
<td>Kernel code implementing user-mode environments</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code></td>
<td>Kernel-private trap handling definitions</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>trap.c</code></td>
<td>Trap handling code</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>trapentry.S</code></td>
<td>Assembly-language trap handler entry-points</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>Kernel-private definitions for system call handling</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>System call implementation code</td>
<td></td>
</tr>
<tr>
<td><code>lib/</code></td>
<td><code>Makefrag</code></td>
<td>Makefile fragment to build user-mode library, <code>obj/lib/libjos.a</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>entry.S</code></td>
<td>Assembly-language entry-point for user environments</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>libmain.c</code></td>
<td>User-mode library setup code called from <code>entry.S</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>User-mode system call stub functions</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>console.c</code></td>
<td>User-mode implementations of <code>putchar</code> and <code>getchar</code>, providing console I/O</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>exit.c</code></td>
<td>User-mode implementation of <code>exit</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>panic.c</code></td>
<td>User-mode implementation of <code>panic</code></td>
<td></td>
</tr>
<tr>
<td><code>user/</code></td>
<td><code>*</code></td>
<td>Various test programs to check kernel lab 3 code</td>
</tr>
</tbody>
</table>
</div>

</div></div>
<h3 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h3><p>本次实验有AB两个部分，你需要分别完成，并至少完成一个挑战实验。</p>
<h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><p>GCC提供了内联汇编功能，参考<a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">该网站获得内联汇编讲解</a></p>
<h2 id="第一部分：进程和异常处理"><a href="#第一部分：进程和异常处理" class="headerlink" title="第一部分：进程和异常处理"></a>第一部分：进程和异常处理</h2><p><code>inc/env.h</code>包含了进程的一些定义，内核使用<code>Env</code>追踪进程，在<code>kern/env.c</code>中，包含如下全局变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> = <span class="title">NULL</span>;</span>		    <span class="comment">// All environments，指向一个进程array</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> = <span class="title">NULL</span>;</span>		    <span class="comment">// The current env，正在运行的进程，在第一个进程执行前为NULL</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>	<span class="comment">// Free environment list</span></span><br></pre></td></tr></table></figure>
<p>JOS允许的最大活动线程数定义在<code>inc/env.h</code>中，为<code>1&lt;&lt;10</code>即1024个。<code>env_free_list</code>为不活跃的Env链表，在表中添加或删除Env，即可分配或释放进程。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>我们使用<code>Env</code>结构体对进程进行描述，<code>Env</code>结构体如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers 保存进程未执行时的寄存器，即内核或其他进程运行时，trapframe</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">    <span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">    <span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></span><br><span class="line">    <span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></span><br><span class="line">    <span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Address space</span></span><br><span class="line">    <span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div>
<p>结构体成员功能如下：</p>
<p><strong>env_tf</strong>：保存进程未执行时的寄存器，即内核或其他进程运行时的寄存器。发生进程切换时，内核将保存该寄存器。</p>
<p><strong>env_link</strong>：指向<code>env_free_list</code>中的下一个空闲进程</p>
<p><strong>env_id</strong>：使用当前<code>Env</code>的进程的id，当进程被回收后，内核可能会将同一个<code>Env</code>分配给其他进程，但是进程号会发生改变</p>
<p><strong>env_parent_id</strong>：父进程id</p>
<p><strong>env_type</strong>：进程类型，对于大多数进程，都是用户进程，即<code>ENV_TYPE_USER</code></p>
<p><strong>env_status</strong>：进程状态，有如下几种：</p>
<p>​    <code>ENV_FREE</code>：不活跃进程，位于<code>env_free_list</code>中</p>
<p>​    <code>ENV_RUNNABLE</code>：等待执行的进程</p>
<p>​    <code>ENV_RUNNING</code>：正在执行的进程</p>
<p>​    <code>ENV_NOT_RUNNABLE</code>：活跃的进程，但是尚未准备运行，例如等待另一个进程通信的进程</p>
<p>​    <code>ENV_DYING</code>：僵尸进程，将会在下一次陷入内核时被回收</p>
<p><strong>env_pgdir</strong>：保存着当前进程页目录的内核虚拟地址</p>
<h3 id="陷帧"><a href="#陷帧" class="headerlink" title="陷帧"></a>陷帧</h3><p>我一直没有对这个名词找到一个合适的翻译，姑且顾名思义，称其为“陷帧”，因为进程切换是需要陷入内核的。</p>
<p>陷帧的作用如下，如果把进程的执行比作动画，动画是一帧一帧播放的，相应地，我们的进程也是一帧一帧执行的，我们使用一个结构体对进程关键信息进行描述。这个结构体称为陷帧。在这个帧中，保存有进程执行时的关键寄存器。当我们进行进程或线程切换时，实际就是先将当前进程的陷帧进行保存，然后加载新进程的陷帧</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;             <span class="comment">// es段寄存器</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;             <span class="comment">// ds数据段寄存器 pushl </span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;            </span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;           <span class="comment">// eip指令指针寄存器</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;             <span class="comment">// cs代码段寄存器</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;         </span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;           <span class="comment">// 栈顶指针寄存器</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;             <span class="comment">// 堆栈段寄存器</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="分配进程array"><a href="#分配进程array" class="headerlink" title="分配进程array"></a>分配进程array</h3><p>在上一个lab中，我们在<code>mem_init</code>函数中为<code>pages[]</code>分配了空间，类似地，分配一个<code>env[]</code>，用于保存<code>Env</code>结构体，这个比较简单，参考<code>pages</code>分配过程即可，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span></span><br><span class="line">n = NENV * <span class="keyword">sizeof</span>(struct Env);</span><br><span class="line">envs = (struct Env*) boot_alloc(n);</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U | PTE_P);</span><br></pre></td></tr></table></figure>
<p>现在你的代码应该能够通过<code>check_kern_pgdir()</code></p>
<h3 id="进程创建及运行"><a href="#进程创建及运行" class="headerlink" title="进程创建及运行"></a>进程创建及运行</h3><p>现在编写<code>kern/env.c</code>中的代码，运行一个用户进程。目前我们尚未提供文件系统，因此我们需要进程加载一个写死在内核中的静态二进制镜像作为进程。Lab3中使用了一些手段，将用户程序与内核进行了强绑定，具体实现可以参考参考文献<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。现在，请完成如下函数</p>
<div class="note default">
            <p><strong>练习2</strong>：在文件<code>env.c</code>中，完成如下代码：</p><p><code>env_init()</code>：初始化所有<code>Env</code>结构体对象，然后添加至<code>env_free_list</code>中，调用<code>env_init_percpu</code>，配置分段硬件优先级（0为内核，3为用户）</p>
          </div>
<h4 id="env-init"><a href="#env-init" class="headerlink" title="env_init()"></a>env_init()</h4><h5 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h5><p>该函数实现了<code>envs</code>以及<code>env_free_list</code>的初始化，其原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></span><br><span class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></span><br><span class="line"><span class="comment">// env_alloc() returns envs[0]).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Set up envs array</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">    env_init_percpu();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释，我们可以总结该函数如下工作：</p>
<ul>
<li>将<code>env_id</code>设置为0</li>
<li>将<code>env</code>按与array一致的顺序插入<code>env_free_list</code>中</li>
</ul>
<h5 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h5><p>该工作比较简单，实际就是一个链表的插入问题，直接得到代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">env_free_list = envs;</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NENV<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">    envs[i].envid = <span class="number">0</span>;</span><br><span class="line">    envs[i].env_link = &amp;envs[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">envs[i].envid = <span class="number">0</span>;</span><br><span class="line">envs[i].env_link = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>上面的实现中，链表是正序插入的，代码比较繁琐，可以采用倒插法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Set up envs array</span></span><br><span class="line">    env_free_list = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = NENV<span class="number">-1</span>; i&gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></span><br><span class="line">        <span class="comment">// and insert them into the env_free_list.</span></span><br><span class="line">        envs[i].env_status = ENV_FREE;</span><br><span class="line">        envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">    	envs[i].env_link = env_free_list;</span><br><span class="line">    	env_free_list = &amp;envs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">    env_init_percpu();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="env-setup-vm"><a href="#env-setup-vm" class="headerlink" title="env_setup_vm()"></a>env_setup_vm()</h4><h5 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h5><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize the kernel virtual memory layout for environment e.</span></span><br><span class="line"><span class="comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span></span><br><span class="line"><span class="comment">// and initialize the kernel portion of the new environment's address space.</span></span><br><span class="line"><span class="comment">// Do NOT (yet) map anything into the user portion</span></span><br><span class="line"><span class="comment">// of the environment's virtual address space.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if page directory or table could not be allocated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))  <span class="comment">//分配一个物理页</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    </span><br><span class="line">    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h5><p>从上面的注释中，我们能抽象出该函数具体的工作，即给进程<code>e</code>分配内核虚拟地址空间。首先我们申请了一张页，该页要作为<code>e-&gt;env_pgdir</code>的页目录，我们要将这段空间的虚拟地址给了<code>env_pgdir</code>。此外，还需要手动将该页的引用递增一下。</p>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">    <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))  <span class="comment">//分配一个物理页</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// In general, pp_ref is not maintained for</span></span><br><span class="line">    <span class="comment">// physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">    <span class="comment">// is an exception -- you need to increment env_pgdir's</span></span><br><span class="line">    <span class="comment">// pp_ref for env_free to work correctly.</span></span><br><span class="line">    p-&gt;pp_ref++;</span><br><span class="line">    <span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">    e-&gt;env_pgdir = (<span class="keyword">pde_t</span> *) page2kva(p);         <span class="comment">// 将分配的页用作页目录</span></span><br><span class="line">    <span class="comment">// The VA space of all envs is identical above UTOP</span></span><br><span class="line">    <span class="comment">// (except at UVPT, which we've set below).</span></span><br><span class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);     <span class="comment">// * 重要，将内核页目录拷贝给每个进程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;   <span class="comment">// UVPT指向用户页目录地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h5><p>在上面的实现中，我们还需要对<code>env_pgdir</code>指向的页进行初始化，初始化内核部分，因此还需要下面一句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memcpy(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br></pre></td></tr></table></figure>
<p>这一句说明，每个进程都了解内核的页目录。</p>
<h4 id="region-alloc-struct-Env-e-void-va-size-t-len"><a href="#region-alloc-struct-Env-e-void-va-size-t-len" class="headerlink" title="region_alloc(struct Env e, void va, size_t len)"></a>region_alloc(struct Env <em>e, void </em>va, size_t len)</h4><p>为进程<code>e</code>分配长度为<code>len</code>的物理内存，然后映射至<code>va</code></p>
<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">    <span class="comment">// 'va' and 'len' values that are not page-aligned.</span></span><br><span class="line">    <span class="comment">// You should round va down, and round (va + len) up.</span></span><br><span class="line">    <span class="comment">// (Watch out for corner-cases!)</span></span><br><span class="line">    <span class="keyword">void</span>* start = (<span class="keyword">void</span> *)ROUNDDOWN((<span class="keyword">uint32_t</span>)va, PGSIZE); <span class="comment">//对齐操作</span></span><br><span class="line">    <span class="keyword">void</span>* end   = (<span class="keyword">void</span> *)ROUNDUP((<span class="keyword">uint32_t</span>)(va + len), PGSIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(; start &lt;= end; start += PGSIZE)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> = <span class="title">page_alloc</span>(0);</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            panic(<span class="string">"region_alloc: page_alloc failed\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(page_insert(e-&gt;env_pgdir, pp, start, PTE_W | PTE_U) == -E_NO_MEM)&#123;</span><br><span class="line">            panic(<span class="string">"region_alloc: page_insert failed, no enough room\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="load-icode"><a href="#load-icode" class="headerlink" title="load_icode()"></a>load_icode()</h4><h5 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set up the initial program binary, stack, and processor flags</span></span><br><span class="line"><span class="comment">// for a user process.    设置程序二进制文件</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function loads all loadable segments from the ELF binary image</span></span><br><span class="line"><span class="comment">// into the environment's user memory, starting at the appropriate</span></span><br><span class="line"><span class="comment">// virtual addresses indicated in the ELF program header.</span></span><br><span class="line"><span class="comment">// At the same time it clears to zero any portions of these segments</span></span><br><span class="line"><span class="comment">// that are marked in the program header as being mapped</span></span><br><span class="line"><span class="comment">// but not actually present in the ELF file - i.e., the program's bss section.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All this is very similar to what our boot loader does, except the boot</span></span><br><span class="line"><span class="comment">// loader also needs to read the code from disk.  Take a look at</span></span><br><span class="line"><span class="comment">// boot/main.c to get ideas.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// load_icode panics if it encounters problems.</span></span><br><span class="line"><span class="comment">//  - How might load_icode fail?  What might be wrong with the given input?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数功能-1"><a href="#函数功能-1" class="headerlink" title="函数功能"></a>函数功能</h5><p>这个函数将会为一个用户进程设置初始程序的二进制文件、栈以及处理器标志位，该函数只在内核初始化阶段执行。</p>
<h5 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h5><p>为了实现该函数，我们需要解决如下问题：</p>
<ul>
<li>将ELF格式的二进制文件载入用户进程内存空间</li>
<li>将程序的<code>.bss</code>段置零</li>
<li>映射一个内存页给用户的进程栈</li>
</ul>
<p>函数具体实现如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">NULL</span> || binary == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        panic(<span class="string">"load_icode: wrong pointer!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELF</span> *<span class="title">ELFHDR</span> = (<span class="title">struct</span> <span class="title">ELF</span> *)<span class="title">binary</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">        panic(<span class="string">"load_icode: wrong Elf format!\n"</span>);</span><br><span class="line">    ph = (struct Proghdr *)((<span class="keyword">uint8_t</span> *)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line">    <span class="comment">//  at the address specified in the ELF section header.</span></span><br><span class="line">    <span class="keyword">for</span>(; ph &lt; eph; ph++)&#123;</span><br><span class="line">        <span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line">        <span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;</span><br><span class="line">            <span class="comment">// 在ph-&gt;p_va分配能够容纳p_memsz的物理页</span></span><br><span class="line">            <span class="comment">//  Each segment's virtual address can be found in ph-&gt;p_va</span></span><br><span class="line">            <span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line">            <span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line">            <span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line">            <span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line">            <span class="comment">//  the same virtual page.</span></span><br><span class="line">            region_alloc(e, ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line">            <span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line">            <span class="comment">//  So which page directory should be in force during</span></span><br><span class="line">            <span class="comment">//  this function? </span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line">            <span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></span><br><span class="line">            <span class="comment">//  ph-&gt;p_va.  </span></span><br><span class="line">            <span class="built_in">memcpy</span>(ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line">            <span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line">            <span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line">            <span class="built_in">memset</span>(ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Now map one page for the program's initial stack </span></span><br><span class="line">    <span class="comment">// at virtual address USTACKTOP-PGSIZE</span></span><br><span class="line">    region_alloc(e, USTACKTOP-PGSIZE, PGSIZE);  <span class="comment">// 用户栈的虚拟地址都是一样的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  You must also do something with the program's entry point,</span></span><br><span class="line">    <span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line">    <span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>这个函数算是partA中最难的函数实现，里面有很多细节一开始没注意到，导致调试时卡在了这里，现在总结一下这个函数中遇到的问题。</p>
<p>首先是内存分配的问题，这里有一个小技巧，要先清空大块内存，再对其中的局部进行拷贝，所以需要将上面的两句内存拷贝和设置语句重新排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将下面这两句</span></span><br><span class="line"><span class="built_in">memcpy</span>(ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_memsz);</span><br><span class="line"><span class="built_in">memset</span>(ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为下面这两句</span></span><br><span class="line"><span class="built_in">memset</span>(ph-&gt;p_va, <span class="number">0</span>, ph-&gt;p_memsz);   <span class="comment">//先全部清空</span></span><br><span class="line"><span class="built_in">memcpy</span>(ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);  <span class="comment">//再进行局部拷贝</span></span><br></pre></td></tr></table></figure>
<p>然后是内存目录管理，上面的代码遗漏了一个非常重要的部分，即内存目录的切换，由于我们是对用户进程的内存空间进行拷贝，所以必须通知CPU，页目录在<code>e-&gt;env_pgdir</code>中，否则CPU还是会继续访问内核内存空间，当访问了不可写的内存区域，内核会发送一个信号停止操作，代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Change </span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));	  <span class="comment">// 切换至进程页目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ph_num; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ph[i].p_type == ELF_PROG_LOAD) &#123;		</span><br><span class="line">        region_alloc(e, (<span class="keyword">void</span> *)ph[i].p_va, ph[i].p_memsz);</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span> *)ph[i].p_va, <span class="number">0</span>, ph[i].p_memsz);		</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)ph[i].p_va, binary + ph[i].p_offset, ph[i].p_filesz); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lcr3(PADDR(kern_pgdir));     <span class="comment">// 切换至内核页目录</span></span><br></pre></td></tr></table></figure>
<p>现在再来理解一下注释中的这段话</p>
<blockquote>
<p>Loading the segments is much simpler if you can move data directly into the virtual addresses stored in the ELF binary. So which page directory should be in force during this function? </p>
</blockquote>
<p>这段话的意思就是让我们切换页目录。</p>
<p>最后，我们需要记录一下可执行文件的入口，即第一条语句所在的位置，第一条语句地址是<code>ELFHDR-&gt;e_entry</code>，进程<code>e</code>中应当有一个字段专门保存执行时的地址。我们知道CPU是根据<code>eip</code>寄存器找到下一条语句执行的位置的，所以我们要将<code>ELFHDR-&gt;e_entry</code>保存于新进程<code>e</code>的陷帧中，即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</span><br></pre></td></tr></table></figure>
<h4 id="env-create"><a href="#env-create" class="headerlink" title="env_create()"></a>env_create()</h4><h5 id="函数功能-2"><a href="#函数功能-2" class="headerlink" title="函数功能"></a>函数功能</h5><p>创建一个新的进程，然后载入进程的可执行文件</p>
<h5 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Allocates a new env with env_alloc, the new env's parent ID is set to 0.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loads the named elf binary into it with load_icode </span></span><br><span class="line">    load_icode(e, binary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the env type to type</span></span><br><span class="line">    e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="env-run"><a href="#env-run" class="headerlink" title="env_run()"></a>env_run()</h4><h5 id="函数功能-3"><a href="#函数功能-3" class="headerlink" title="函数功能"></a>函数功能</h5><p>运行进程，同时实现内核态到用户态的转换</p>
<h5 id="具体实现-4"><a href="#具体实现-4" class="headerlink" title="具体实现"></a>具体实现</h5><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context switch from curenv to env e.</span></span><br><span class="line"><span class="comment">// Note: if this is the first call to env_run, curenv is NULL.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function does not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Hint: This function loads the new environment's state from</span></span><br><span class="line">    <span class="comment">//	e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">    <span class="comment">//	and make sure you have set the relevant parts of</span></span><br><span class="line">    <span class="comment">//	e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: If this is a context switch (a new environment is running)</span></span><br><span class="line">    <span class="comment">// 1. Set the current environment (if any) back to</span></span><br><span class="line">    <span class="comment">//	  ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line">    <span class="comment">//	  what other states it can be in)</span></span><br><span class="line">    <span class="keyword">if</span>(curenv != <span class="literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. Set 'curenv' to the new environment</span></span><br><span class="line">    curenv = e;</span><br><span class="line">    <span class="comment">// 3. Set its status to ENV_RUNNING</span></span><br><span class="line">    curenv-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    <span class="comment">// 4. Update its 'env_runs' counter</span></span><br><span class="line">    ++curenv-&gt;env_runs;</span><br><span class="line">    <span class="comment">// 5. Use lcr3() to switch to its address space</span></span><br><span class="line">    lcr3(PADDR(curenv-&gt;env_pgdir));   <span class="comment">// 切换页目录至当前进程的页目录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Use env_pop_tf() to restore the environment's</span></span><br><span class="line">    <span class="comment">//	   registers and drop into user mode in the</span></span><br><span class="line">    <span class="comment">//	   environment.</span></span><br><span class="line">    env_pop_tf(&amp;curenv-&gt;env_tf);      <span class="comment">// 进入内核态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p>至此，我们完成了进程管理的几个关键函数，当执行一个进程时，内核会调用<code>load_icode</code>加载并执行<code>hello</code>程序，直到使用系统调用后，通过<code>int</code>在进入内核中。但是这里会出现问题，OS尚未配置硬件实现用户态到内核态的转换。因此会触发保护异常，但是依然无法处理异常，于是又会触发一个保护异常的保护异常（开始套娃）。最终放弃，并产生一个<code>triple fault</code>然后重启系统。</p>
<p>这里我们进行一些调试，以gdb模式启动内核，然后在<code>env_pop_tf</code>处设置断点。这个是进入用户态之前的最后一个函数，在对现场进行了一些保护后，进程跳转至了<code>0x800020</code>这个地址，然后开始执行用户进程。查看<code>obj/user/hello.asm</code>获得<code>hello</code>中调用的系统调用<code>sys_cputs()</code>中<code>int</code>的地址（说明系统调用是中断触发的）。找到<code>int $0x30</code>所在地址（0x800a9b），设置断点执行，到这一句前应该都没有问题。如果有问题，那一定是你的问题。</p>
<h3 id="中断和异常处理"><a href="#中断和异常处理" class="headerlink" title="中断和异常处理"></a>中断和异常处理</h3><p>现在操作系统已经能够实现内核态到用户态的切换，由于中断会进入内核态，所以我们还需要完成用户态到内核态的切换，实现中断和异常。首先先熟悉x86的中断和异常机制</p>
<div class="note default">
            <p><strong>练习3</strong>：阅读如下材料，学习中断和异常背后的硬件知识</p><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual 第五章</a></p>
          </div>
<h3 id="受保护的控制转移"><a href="#受保护的控制转移" class="headerlink" title="受保护的控制转移"></a>受保护的控制转移</h3><p>异常和中断实际上都是受保护的控制转移，即在内核和用户之间的切换。按照英特尔的术语，中断是一种异步控制转移，而异常是同步的。受保护是指：<strong>当中断或异常发生后，当前运行的代码只能以指定的方式进入内核</strong>。在x86中，保护是由两种机制提供的：</p>
<p>1 <strong>中断描述表（IDT）</strong>：处理器保证进程只能由内核提供的进入点进入内核。x86提供了256个进入点，即256个中断向量（0-255）。中断向量由中断来源决定。CPU根据中断向量，到中断描述表指定的位置寻找中断描述符，并加载如下内容：</p>
<ul>
<li>将中断服务函数入口载入EIP中</li>
<li>将服务函数所在的代码段保存在CS寄存器中</li>
</ul>
<p>2 <strong>任务状态段（TSS）</strong>：在处理中断和异常前，处理器需要一个空间保存旧的状态，例如CS和EIP寄存器中的值，以便后续恢复现场。保存这些状态的空间必须被严格保护，禁止低权限的用户进程访问。因此当发生用户态到内核态的切换时，OS会切换至一个位于内核内存空间的堆栈段，并对关键数据进行保存。TSS即设置了这个堆栈的段选择符和地址。处理器会将<code>SS</code>, <code>ESP</code>, <code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>和一些错误码保存在堆栈中，并从中断描述符中加载CS和EIP，并设置指向新堆栈的ESP和SS。</p>
<p>在JOS中，我们只利用TSS来保存内核堆栈的位置，实际的操作系统中TSS还有许多其他功能。</p>
<h3 id="异常和中断的种类"><a href="#异常和中断的种类" class="headerlink" title="异常和中断的种类"></a>异常和中断的种类</h3><p>这一节详见<a href="/2024/10/13/计算机/操作系统/中断、异常和系统调用/" title="关于中断和异常区别的讲解">关于中断和异常区别的讲解</a>。本节我们将会处理0-31号中断。下一节我们会处理48号软中断。在Lab4中，我们还会添加一些外部中断，例如定时器中断等。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>假设处理器正在执行一个用户进程，结果遇到了除零异常，处理器会这样处理：</p>
<p>1 根据TSS中的<code>SS0</code>和<code>ESP0</code>字段，跳转至内核栈字段，在JOS中，<code>SS0</code>和<code>ESP0</code>的值分别为<code>GD_KD</code>和<code>KSTACKTOP</code></p>
<p>2 将异常参数压入内核栈中，栈顶地址为<code>KSTACKTOP</code>，压完后内核栈如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/kernelstack.svg" width = "350" alt="图片名称" align=center /></p>
<p>3 由于我们在处理除零错误，其中断向量号为0，因此处理器读取IDT的入口0，并设置<code>CS:EIP</code>至中断服务函数的入口地址</p>
<p>4 处理函数将会接管并处理异常，例如退出用户程序等</p>
<p>对于特定型号的x86处理器，除了上面的五个标准字段，还会向栈中压入一个错误码（一般是32位），关于错误码详见<a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual 第五章第13节</a>。有了错误码后，在返回时必须弹出错误码，否则会返回错误的位置执行程序。</p>
<h3 id="中断-异常嵌套"><a href="#中断-异常嵌套" class="headerlink" title="中断/异常嵌套"></a>中断/异常嵌套</h3><p>中断可能是在内核或者用户态产生，只有从用户态进入内核态时，才需要进行堆栈的切换，即对用户态堆栈的地址进行保存。如果已经位于内核中，那么内核就不需要进行栈切换，直接保存旧的<code>CS</code>和<code>EIP</code>即可。此外，对于内核产生的中断，我们可以很轻易地进行嵌套处理。因为内核处理自己的中断，可以简单地理解为函数调用。</p>
<p>极端情况下，当中断嵌套过多后，内核栈会爆掉，这种情况下内核只能重启。一个设计良好的内核应该确保这种极端情况永远不发生。</p>
<h3 id="设置IDT"><a href="#设置IDT" class="headerlink" title="设置IDT"></a>设置IDT</h3><p>现在，我们开始设置IDT，处理中断向量号为0-31的中断，首先，阅读 <a href="/downloads/inc_trap.h"><code>inc/trap.h</code></a>and<a href="/downloads/kern_trap.h"><code>kern/trap.h</code></a>，这两个文件包含了一些和中断、异常相关的重要定义。其中，<code>kern/trap.h</code>包含着和内核严格私有的代码，而<code>inc/trap.h</code>包含着和内核和用户态相关的代码。</p>
<p>注意，0-31号向量中有一些是保留的，这些不需要处理。我们实现的中断控制流应当如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过IDT，在trapentry中找到中断服务函数入口，然后跳转至trap中</span><br><span class="line">       IDT                   trapentry.S         trap.c</span><br><span class="line">   </span><br><span class="line">+----------------+                        </span><br><span class="line">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</span><br><span class="line">|                |             // do stuff      &#123;</span><br><span class="line">|                |             call trap          // handle the exception/interrupt</span><br><span class="line">|                |             // ...           &#125;</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handler2    |--------&gt; handler2:</span><br><span class="line">|                |            // do stuff</span><br><span class="line">|                |            call trap</span><br><span class="line">|                |            // ...</span><br><span class="line">+----------------+</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handlerX    |--------&gt; handlerX:</span><br><span class="line">|                |             // do stuff</span><br><span class="line">|                |             call trap</span><br><span class="line">|                |             // ...</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure>
<p>每一个异常或中断都需要有自己的中断服务函数（在<code>trapentry.S</code>中），同时<code>trap_init()</code>将对IDT进行初始化，写入这些服务函数的地址。每个服务函数应当在栈上建立一个<code>struct TrapFrame</code>，然后调用<code>trap()</code>并传入建立的陷帧 (在 <code>trap.c</code>) 。<code>trap</code>将会使用特定的服务函数处理中断和异常。</p>
<div class="note default">
            <p><strong>练习4</strong>：编辑<code>trapentry.S</code>和<code>trap.c</code>，实现上述功能。<code>trapentry.S</code>中的 <code>TRAPHANDLER</code> 和<code>TRAPHANDLER_NOEC</code> 宏以及<code>inc/trap.c</code>中的<code>T_*</code>能够帮助你。你需要在<code>trapentry.S</code>中为<code>inc/trap.h</code>中的每一个trap添加一个入口，并提供<code>_alltraps</code>作为<code>TRAPHANDLER</code>的参考。同时，你需要修改<code>trap_init()</code>，初始化<code>idt</code>，令其指向<code>trapentry.S</code>中定义的每一个入口，此处请使用<code>SETGATE</code>宏。</p><p>你的<code>_alltraps</code>应当：</p><ol><li>将对应的值压入栈中，使栈看起来像一个陷帧</li><li>将<code>GD_KD</code>载入<code>%ds</code>和<code>%es</code></li><li><code>pushl %esp</code> ，向<code>trap()</code>传递一个指向陷帧的指针</li><li><code>call trap</code>（<code>trap</code>可以返回吗？）</li></ol><p>使用<code>pushal</code>，这个指令符合<code>struct Trapframe</code>的布局，在完成上述内容后，<code>make grade</code>应当能够通过Part A</p>
          </div>
<p>练习4的要求挺多的，我们将问题一个一个拆解，分而治之。经过拆分后，练习4一共需要完成如下功能：</p>
<ul>
<li>在<code>trapentry.S</code>中为<code>inc/trap.h</code>中的每一个trap添加一个入口</li>
<li>编写<code>_alltraps</code>函数</li>
<li>修改<code>trap_init()</code>，初始化<code>idt</code>，令其指向<code>trapentry.S</code>中定义的每一个入口</li>
</ul>
<h4 id="实现顺序"><a href="#实现顺序" class="headerlink" title="实现顺序"></a>实现顺序</h4><p>为了解决这个问题，我们考虑如下实现顺序：</p>
<ul>
<li>首先，在<code>trapentry.S</code>中添加入口，但是不实现</li>
<li>修改<code>trap_init()</code>，初始化<code>idt</code>，令其指向每一个入口</li>
</ul>
<h4 id="在trapentry-S中为inc-trap-h中的每一个trap添加一个入口"><a href="#在trapentry-S中为inc-trap-h中的每一个trap添加一个入口" class="headerlink" title="在trapentry.S中为inc/trap.h中的每一个trap添加一个入口"></a>在<code>trapentry.S</code>中为<code>inc/trap.h</code>中的每一个trap添加一个入口</h4><h5 id="TRAPHANDLER-和TRAPHANDLER-NOEC"><a href="#TRAPHANDLER-和TRAPHANDLER-NOEC" class="headerlink" title="TRAPHANDLER 和TRAPHANDLER_NOEC"></a><code>TRAPHANDLER</code> 和<code>TRAPHANDLER_NOEC</code></h5><p>我们首先来看一下这两个宏函数，其定义如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span></span><br><span class="line"><span class="comment"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span></span><br><span class="line"><span class="comment"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You shouldn't call a TRAPHANDLER function from C, but you may</span></span><br><span class="line"><span class="comment"> * need to _declare_ one in C (for instance, to get a function pointer</span></span><br><span class="line"><span class="comment"> * during IDT setup).  You can declare the function with</span></span><br><span class="line"><span class="comment"> *   void NAME();</span></span><br><span class="line"><span class="comment"> * where NAME is the argument passed to TRAPHANDLER.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPHANDLER(name, num)                      \</span></span><br><span class="line">    .globl name;        <span class="comment">/* define global symbol for 'name' */</span>   \</span><br><span class="line">    .type name, @function;  <span class="comment">/* symbol type is function */</span>       \</span><br><span class="line">    .align <span class="number">2</span>;       <span class="comment">/* align function definition 令函数对齐，即其起始地址为2的倍数*/</span>     \ </span><br><span class="line">    name:           <span class="comment">/* function starts here */</span>      \</span><br><span class="line">                    <span class="comment">// 在此处CPU会自动压入一个错误码</span></span><br><span class="line">    pushl $(num);   <span class="comment">/* 将num地址压栈 */</span>               \</span><br><span class="line">    jmp _alltraps</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.</span></span><br><span class="line"><span class="comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span></span><br><span class="line"><span class="comment"> * format in either case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPHANDLER_NOEC(name, num)                 \</span></span><br><span class="line">    .globl name;                            \</span><br><span class="line">    .type name, @function;                      \</span><br><span class="line">    .align <span class="number">2</span>;                           \</span><br><span class="line">    name:                               \</span><br><span class="line">    pushl $<span class="number">0</span>;         <span class="comment">/* 错误码占位 */</span>      \</span><br><span class="line">    pushl $(num);                         \</span><br><span class="line">    jmp _alltraps</span><br></pre></td></tr></table></figure>

</div></div>
<p>这两个宏函数能够帮助我们定义中断服务函数入口，例如我们想定义vector0作为中断0的入口，那么只需要写入下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(vector0, <span class="number">0</span>)    <span class="comment">// 中断0 入口为 vector0，向量号为0</span></span><br></pre></td></tr></table></figure>
<p>这个宏会被扩展为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.globl vector0;                            </span><br><span class="line">.type vector0, @function;                      </span><br><span class="line">.align <span class="number">2</span>;                           </span><br><span class="line">vector0:                               </span><br><span class="line">pushl $<span class="number">0</span>;         <span class="comment">/* 错误码占位 */</span>      </span><br><span class="line">pushl $<span class="number">0</span>;                         </span><br><span class="line">jmp _alltraps</span><br></pre></td></tr></table></figure>
<h5 id="具体实现-5"><a href="#具体实现-5" class="headerlink" title="具体实现"></a>具体实现</h5><p>根据上面的两个宏，我们能够写出入口函数的定义如下所示，需要注意的是我们要查询硬件手册，看哪些中断要记录Error Code，哪些不需要。同时，中断向量号已经给出了我们宏定义，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set up the entries for traps, care about whether</span></span><br><span class="line"><span class="comment"> * the interrupt has error code, if not, use TRAPHANDLER_NOEC</span></span><br><span class="line"><span class="comment"> * otherwise use the TRAPHANDLER</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TRAPHANDLER_NOEC(divide_entry, T_DIVIDE)          # vector0:  divide zero, NOEC</span><br><span class="line">TRAPHANDLER_NOEC(debug_entry, T_DEBUG)            # vector1:  debug exception, NOEC</span><br><span class="line">TRAPHANDLER_NOEC(nmi_entry, T_NMI)                # vector2:  non-maskable interrupt, NOEC</span><br><span class="line">TRAPHANDLER_NOEC(breakpoint_entry, T_BRKPT)       # vector3:  breakpoint, NOEC</span><br><span class="line">TRAPHANDLER_NOEC(overflow_entry, T_OFLOW)         # vector4:  overflow, NOEC</span><br><span class="line">TRAPHANDLER_NOEC(bound_entry, T_BOUND)            # vector5:  bounds check, NOEC</span><br><span class="line">TRAPHANDLER_NOEC(illop_entry, T_ILLOP)            # vector6:  illegal opcode</span><br><span class="line">TRAPHANDLER_NOEC(device_entry, T_DEVICE)          # vector7:  device <span class="keyword">not</span> available</span><br><span class="line">TRAPHANDLER(dblflt_entry, T_DBLFLT)               # vector8:  <span class="keyword">double</span> fault</span><br><span class="line"># TRAPHANDLER_NOEC(coproc_entry, T_COPROC)        # vector9:  reserved</span><br><span class="line">TRAPHANDLER(tss_entry, T_TSS)                     # vector10: invalid task <span class="keyword">switch</span> segment</span><br><span class="line">TRAPHANDLER(segnp_entry, T_SEGNP)                 # vector11: segment <span class="keyword">not</span> present</span><br><span class="line">TRAPHANDLER(stack_entry, T_STACK)                 # vector12: <span class="built_in">stack</span> exception</span><br><span class="line">TRAPHANDLER(gpflt_entry, T_GPFLT)                 # vector13: general protection fault</span><br><span class="line">TRAPHANDLER(pgflt_entry, T_PGFLT)                 # vector14: page fault</span><br><span class="line"># TRAPHANDLER_NOEC(res_entry, T_RES)             # vector15: reserved</span><br><span class="line">TRAPHANDLER_NOEC(fperr_entry, T_FPERR)            # vector16: floating point error</span><br><span class="line">TRAPHANDLER(align_entry, T_ALIGN)                 # vector17: aligment check</span><br><span class="line">TRAPHANDLER_NOEC(mchk_entry, T_MCHK)              # vector18: machine check</span><br><span class="line">TRAPHANDLER_NOEC(simderr_entry, T_SIMDERR)        # vector19: SIMD floating point error</span><br></pre></td></tr></table></figure>
<h4 id="编写-alltraps函数"><a href="#编写-alltraps函数" class="headerlink" title="编写_alltraps函数"></a>编写<code>_alltraps</code>函数</h4><h5 id="函数功能-4"><a href="#函数功能-4" class="headerlink" title="函数功能"></a>函数功能</h5><p>通过查看<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">xv6 手册中关于alltrap的讲解</a>，可知这个函数完成了如下几件事请：</p>
<ul>
<li>将<code>%ds</code>、<code>%es</code>、<code>%fs</code>、<code>%gs</code>进行保存</li>
<li>然后将<code>eax</code> 、<code>ecx</code>、 <code>edx</code>、 <code>ebx</code>、 <code>oesp</code>、 <code>ebp</code>、 <code>esi</code>、 <code>edi</code>这些寄存器进行保存，这些操作可以用<code>pushal</code>一次性实现</li>
<li>将<code>GD_KD</code>载入<code>%ds</code>和<code>%es</code></li>
<li><code>pushl %esp</code> ，向<code>trap()</code>传递一个指向陷帧的指针</li>
<li><code>call trap</code>（<code>trap</code>可以返回吗？）</li>
</ul>
<h5 id="具体实现-6"><a href="#具体实现-6" class="headerlink" title="具体实现"></a>具体实现</h5><p>根据上面总结的功能，我们能够得到<code>_alltraps</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl _alltraps</span><br><span class="line">_alltraps:</span><br><span class="line">    # Step1: push ds, es, fs and gs separately</span><br><span class="line">    pushl %ds      # check the trap frame and get the length of the registers</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line">        </span><br><span class="line">    # Step2: push general purpose registers using pushal</span><br><span class="line">    pushal</span><br><span class="line">    </span><br><span class="line">    # Step3: load GD_KD in %ds and %es using movw</span><br><span class="line">    movw $(GD_KD), %ax  </span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line">    </span><br><span class="line">    # Step4: call trap(tf), where tf=%esp</span><br><span class="line">    pushl %esp</span><br><span class="line">    call trap</span><br></pre></td></tr></table></figure>
<h4 id="修改trap-init-，初始化idt，令其指向trapentry-S中定义的每一个入口"><a href="#修改trap-init-，初始化idt，令其指向trapentry-S中定义的每一个入口" class="headerlink" title="修改trap_init()，初始化idt，令其指向trapentry.S中定义的每一个入口"></a>修改<code>trap_init()</code>，初始化<code>idt</code>，令其指向<code>trapentry.S</code>中定义的每一个入口</h4><h5 id="函数功能-5"><a href="#函数功能-5" class="headerlink" title="函数功能"></a>函数功能</h5><p><code>trap_init()</code>函数的功能就是初始化<code>idt</code>，将<code>idt</code>数组中第$i$个值<code>idt[i]</code>设置为<code>trapentry.S</code>定义的入口。这里需要我们了解<code>idt</code>的具体格式，参考<a href="https://pdos.csail.mit.edu/6.828/2018/lec/x86_idt.pdf">x86_idt.pdf (mit.edu)</a>。在<code>mmu.h</code>中定义了<code>struct Gatedesc</code>对中断描述符进行描述，具体即每一位的作用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gatedesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_off_15_0 : <span class="number">16</span>;   <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_sel : <span class="number">16</span>;        <span class="comment">// segment selector</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_args : <span class="number">5</span>;        <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_rsv1 : <span class="number">3</span>;        <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_type : <span class="number">4</span>;        <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_s : <span class="number">1</span>;           <span class="comment">// must be 0 (system)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_dpl : <span class="number">2</span>;         <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_p : <span class="number">1</span>;           <span class="comment">// Present</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_off_31_16 : <span class="number">16</span>;  <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们使用<code>SETGATE</code>宏函数实现<code>idt</code>到入口的绑定，该函数见本文附录，为了正确调用这个函数，需要依次考虑如下问题：</p>
<ul>
<li>中断服务函数入口的代码段在哪里？在内核的代码段，查看<code>memlayout.h</code>可知，为<code>GD_KT</code>(0x08)</li>
<li>是什么类型的，中断？异常？查看中断描述符手册</li>
<li>中断服务函数入口的偏移量又是多少 ？即<code>TRAPHANDLER</code>和<code>TRAPHANDLER_NOEC</code>定义的函数的偏移量</li>
</ul>
<h5 id="具体实现-7"><a href="#具体实现-7" class="headerlink" title="具体实现"></a>具体实现</h5><p>具体绑定过程代码如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">    </span><br><span class="line">    SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, divide_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_DEBUG], <span class="number">1</span>, GD_KT, debug_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_NMI], <span class="number">1</span>, GD_KT, nmi_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, breakpoint_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_OFLOW], <span class="number">0</span>, GD_KT, overflow_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, bound_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, illop_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, device_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, dblflt_entry, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//SETGATE(idt[T_COPROC], 0, GD_KT, coproc_entry, 0)</span></span><br><span class="line">    SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, tss_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, segnp_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, stack_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, gpflt_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, pgflt_entry, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//SETGATE(idt[T_RES], 0, GD_KT, res_entry, 0)</span></span><br><span class="line">    SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, fperr_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, align_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, mchk_entry, <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, simderr_entry, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p>结果写完之后一运行，提示这些函数入口都没定义，这个就很难受了，参考xv6的源码，我们还需要在<code>trapentry.S</code>中手动添加<code>*_entry</code>的入口地址，在<code>trapentry.S</code>中设置一个代码段，创建<code>vectors</code>数组，将每一个<code>*_entry</code>对应的地址进行保存：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">.globl vectors</span><br><span class="line">vectors:</span><br><span class="line">  .long divide_entry</span><br><span class="line">  .long debug_entry</span><br><span class="line">  .long nmi_entry</span><br><span class="line">  .long breakpoint_entry</span><br><span class="line">  .long overflow_entry</span><br><span class="line">  .long bound_entry</span><br><span class="line">  .long illop_entry</span><br><span class="line">  .long device_entry</span><br><span class="line">  .long dblflt_entry</span><br><span class="line">#  .long coproc_entry</span><br><span class="line">  .long tss_entry</span><br><span class="line">  .long segnp_entry</span><br><span class="line">  .long stack_entry</span><br><span class="line">  .long gpflt_entry</span><br><span class="line">  .long pgflt_entry</span><br><span class="line">#  .long res_entry</span><br><span class="line">  .long fperr_entry</span><br><span class="line">  .long align_entry</span><br><span class="line">  .long mchk_entry</span><br><span class="line">  .long simderr_entry</span><br></pre></td></tr></table></figure>

</div></div>
<p>在有了<code>vectors</code>数组后，我们还可以采用循环的方式对<code>idt</code>进行初始化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">uint16_t</span> i;</span><br><span class="line">    <span class="comment">// Initialize the first 19 idt by using a loop</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">19</span>; ++i)&#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KT, vectors[i], <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_DEBUG], <span class="number">1</span>, GD_KT, vectors[T_DEBUG], <span class="number">0</span>)</span><br><span class="line">    SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, vectors[T_BRKPT], <span class="number">3</span>)    <span class="comment">// Int 3's DPL is 3</span></span><br><span class="line">    SETGATE(idt[T_NMI], <span class="number">1</span>, GD_KT, vectors[T_NMI], <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// Per-CPU setup </span></span><br><span class="line">    trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们只针对前19个<code>idt</code>进行初始化，其他的先忽略。</p>
<h4 id="调试与总结"><a href="#调试与总结" class="headerlink" title="调试与总结"></a>调试与总结</h4><p>在完成上面的相关代码后，我们现在应该能够运行用户程序，然后对异常进行处理，运行<code>make grade</code>应该能够通过 <code>divzero</code>、<code>softint</code>、 <code>badsegment</code>三个测试，通过part A，然后获得三十分。然而我的代码有问题，需要进行调试。</p>
<p>我们先针对<code>divzero</code>进行调试，查看<code>divzero</code>的输出日志，截取其中的栈帧部分，可以看到如下内容：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAP frame at <span class="number">0xefffffb4</span></span><br><span class="line">  edi  <span class="number">0x00000000</span></span><br><span class="line">  esi  <span class="number">0x00000000</span></span><br><span class="line">  ebp  <span class="number">0xeebfdfd0</span></span><br><span class="line">  oesp <span class="number">0xefffffd4</span></span><br><span class="line">  ebx  <span class="number">0x00000000</span></span><br><span class="line">  edx  <span class="number">0x00000000</span></span><br><span class="line">  ecx  <span class="number">0x00000000</span></span><br><span class="line">  eax  <span class="number">0x00000001</span></span><br><span class="line">  es   <span class="number">0</span>x---<span class="number">-0023</span></span><br><span class="line">  ds   <span class="number">0</span>x---<span class="number">-0023</span></span><br><span class="line">  trap <span class="number">0x00000023</span> (unknown trap)</span><br><span class="line">  err  <span class="number">0x00000023</span></span><br><span class="line">  eip  <span class="number">0x00000000</span></span><br><span class="line">  cs   <span class="number">0</span>x---<span class="number">-0000</span></span><br><span class="line">  flag <span class="number">0x0080004e</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>可以看到trap一行显示的是 unknown trap。除零应当是除零中断，怎么能是unknown trap呢，说明我们在处理栈帧的时候出现了问题，最有可能的是_alltraps写错了，导致栈布局不对。经过对比，因为我直接参考了xv6的代码，所以多压入了两个寄存器，直接导致栈布局错误，将下面两行删除即可：</p>
<pre><code># pushl %fs
# pushl %gs  
</code></pre><p>现在运行可以通过<code>divzero</code>，然后此处我又犯了一个小bug，由于我使用循环的方式对前19个中断进行处理，然而上面的代码中我注释掉了两个保留的中断向量入口，这就导致<code>idt</code>和<code>vectors</code>的映射关系错误了，后面的中断都往前移动了一个，所以如果不是采用一一赋值的方式，上面的代码就不能注释掉，并检查对应关系。修改之后即可通过Part A。</p>
<div class="note default">
            <p><strong>问题</strong>：回答下面的问题</p><ol><li>为何每个中断/异常都要有自己独立的服务函数，如果所有的中断/异常都被送入同一个入口，那么上面的什么机制无法实现？</li><li>是否需要做一些修改，使得<code>user/softint</code>表现正常？打分脚本期望产生一个通用保护错误(trap 13)，但是<code>softint</code>的代码中写了<code>int $14</code>。为何触发了中断向量13？如果内核允许<code>softint</code>的<code>int $14</code>命令触发一个缺页异常，会发生什么？</li></ol><p>回答：</p><ol><li>错误码无法实现，因为有的中断保存错误码，有的不保存，所以必须要不同的入口</li><li>在这里我们首先要明白什么情况会触发trap 13，通过查阅80386手册9.8.13节可知，所有的不触发其他中断的错误，都被归类为GP，其中第14条说：如果在非内核态(privilege 0)中触发中断，那么就会产生这个异常。所以我们不需要修改，操作系统的处理是正确的。如果引发了一个缺页异常，就是用户态直接调用了中断指令，这样做有悖于其优先级。</li></ol>
          </div>
<h2 id="第二部分：页错误、断点异常、系统调用"><a href="#第二部分：页错误、断点异常、系统调用" class="headerlink" title="第二部分：页错误、断点异常、系统调用"></a>第二部分：页错误、断点异常、系统调用</h2><h3 id="处理页错误"><a href="#处理页错误" class="headerlink" title="处理页错误"></a>处理页错误</h3><p>页错误（中断号14：T_PGFLT）是一个非常重要的异常。当处理器触发页错误后，会在CR2中保存触发页错误的指令的地址。 在<code>trap.c</code> 我们提供了 <code>page_fault_handler()</code>处理页错误。</p>
<div class="note default">
            <p><strong>练习5</strong>：修改 <code>trap_dispatch()</code> ，向<code>page_fault_handler()</code>发送页错误。现在<code>make grade</code>应该能通过<code>faultread</code>、<code>faultreadkernel</code>、<code>faultwrite</code>以及<code>faultwritekernel</code>。你可以使用<code>make run-x</code>命令令JOS启动后执行对应的用户程序，例如<code>make run-divzero</code></p>
          </div>
<h4 id="trap-dispatch"><a href="#trap-dispatch" class="headerlink" title="trap_dispatch()"></a>trap_dispatch()</h4><p>这个函数的功能是根据不同的中断号，调用具体的服务函数，dispatch的意思是派遣。那么为了解决page fault，我们只需要写下下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">    <span class="comment">// Handle the trap according to the trap num</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Handle the page fault (vector 14)</span></span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)&#123;</span><br><span class="line">                panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                env_destroy(curenv);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在应该能够通过题目中说的几个函数，再拿到20分</p>
<h3 id="断点异常"><a href="#断点异常" class="headerlink" title="断点异常"></a>断点异常</h3><p>断点异常(T_BRKPT=3)允许调试器在代码中插入断点，这个异常一般用于调试器插入断点，通过替换相关语句为一个1 byte的<code>int3</code>软中断指令。在JOS中，我们将针对该指令做一些调整，令其变为一个伪系统调用供用户程序使用。实际上，<code>lib/panic.c</code>中的<code>panic()</code>函数就通过调用<code>int3</code>实现了中断过程。</p>
<div class="note default">
            <p><strong>练习6</strong>：修改 <code>trap_dispatch()</code> ，添加断点异常并激活kernel monitor</p>
          </div>
<p>这个任务比较简单，直接给出代码，先写一个breakpoint的handler函数，然后在trap_dispatch中添加对应的路径即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">breakpoint_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    monitor(tf);   <span class="comment">// invoke the kernel monitor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是<code>int3</code>的DPL为3，即SETGATE的最后一个参数是3，否则用户进程无法激活该中断。</p>
<div class="note danger">
            <p><strong>挑战任务！</strong>：修改 <code>trap_dispatch()</code> ，添加断点异常，使得程序能够从当前位置继续执行（即在由断点异常引发的<code>int3</code>语句执行后）。实现真正的单步调试功能。你需要掌握<code>EFLAGS</code>中每一位的作用。</p>
          </div>
<div class="note default">
            <p><strong>问题</strong>：</p><ol><li>根据<code>IDT</code>初始化的过程，breakpoint中断会产生通用保护错误或者断点异常。为什么？你需要如何设置<code>IDT</code>，使得breakpoint产生断点异常？</li><li>你认为这个机制的目的是什么？</li></ol><p>回答：</p><ol><li>我们需要设置breakpoint中断<code>idt</code>的DPL为3，这样就允许用户进程激活该中断。</li><li>这个机制一方面可以保护内核，让用户进程不能随意动用中断来进入内核态；另一方面也开放了一些中断，方便用户执行一些特定的功能，例如断点调试等。</li></ol>
          </div>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户进程通过系统调用向内核请求服务。当用户进程激活系统调用后，处理器会进入内核态，处理器和内核共同合作保存用户进程的状态，随后内核执行系统调用，然后返回用户进程。</p>
<p>在JOS中，我们使用<code>int</code>指令产生处理器中断。我们将<code>int $0x30</code>用作系统调用中断，中断号为<code>T_SYSCALL</code>。设置系统调用中断的<code>idt</code>，使得用户能够触发该中断。</p>
<p>应用会将系统调用号和系统调用参数放置在寄存器中。这样，内核不需要在用户进程的栈或者指令流中读取。系统调用号将被放入<code>%eax</code>中，参数（最多五个）将分别进入 <code>%edx</code>、<code>%ecx</code>、<code>%ebx</code>、<code>%edi</code>和<code>%esi</code>。内核将返回值放入<code>%eax</code>。在<code>lib/syscall.c</code>的<code>syscall()</code>函数中提供了激活系统调用的代码，阅读并理解其中的内容（<code>lib</code>中的<code>syscall</code>是给用户使用的，通过<code>int</code>指令激活系统调用）。</p>
<div class="note default">
            <p><strong>练习7</strong>：添加系统调用中断<code>T_SYSCALL</code>的服务函数，编辑<code>kern/trapentry.S</code>和<code>kern/trap.c</code>的<code>trap_init()</code>。修改<code>trap_dispatch()</code>，通过调用<code>kern/syscall.c</code>的<code>syscall()</code>，并根据适当的参数，处理系统调用。将返回值保存在<code>%eax</code>中。最后，修改<code>kern/syscall.c</code>的<code>syscall()</code>。请阅读<code>lib/syscall.c</code>，并弄明白里面的内联汇编语句。通过激活对应的内核函数，处理<code>inc/syscall.h</code>中的所有系统调用。</p><p>通过<code>make run-hello</code>运行<code>user/hello</code>，现在应当在控制台打印”hello world”，并触发页错误。同时，<code>make grade</code>应当能通过<code>testbss</code>。</p>
          </div>
<p>练习7可以分为如下几个部分分别完成：</p>
<h4 id="阅读lib-syscall-c"><a href="#阅读lib-syscall-c" class="headerlink" title="阅读lib/syscall.c"></a>阅读<code>lib/syscall.c</code></h4><p>这个文件中<code>syscall()</code>函数的关键代码是一句内联汇编，关于内联汇编可以参考<a href="/2024/10/13/工具/Assembly/内联汇编/" title="关于内联汇编的讲解">关于内联汇编的讲解</a>。这句内联汇编如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"int %1\n"</span>       <span class="comment">// volatile 禁止优化  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="comment">// %1 表示第二个参数，即下面的输出和输入顺序中第二个参数，此处为 T_SYSCALL</span></span></span></span><br><span class="line"><span class="function"><span class="params">	     : <span class="string">"=a"</span> (ret)         <span class="comment">// 输出，从ax寄存器输出至ret</span></span></span></span><br><span class="line"><span class="function"><span class="params">	     : <span class="string">"i"</span> (T_SYSCALL),   <span class="comment">// 输入，将T_SYSCALL输入至i寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params">	       <span class="string">"a"</span> (num),         <span class="comment">// 输入，将num输入至a寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params">	       <span class="string">"d"</span> (a1),          <span class="comment">// ...</span></span></span></span><br><span class="line"><span class="function"><span class="params">	       <span class="string">"c"</span> (a2),</span></span></span><br><span class="line"><span class="function"><span class="params">	       <span class="string">"b"</span> (a3),</span></span></span><br><span class="line"><span class="function"><span class="params">	       <span class="string">"D"</span> (a4),</span></span></span><br><span class="line"><span class="function"><span class="params">	       <span class="string">"S"</span> (a5)</span></span></span><br><span class="line"><span class="function"><span class="params">	     : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="添加系统调用中断的框架"><a href="#添加系统调用中断的框架" class="headerlink" title="添加系统调用中断的框架"></a>添加系统调用中断的框架</h4><p>和上面的几个中断类似，这里直接给出代码。首先，在<code>trap.h</code>和<code>trap.c</code>中分别加入下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在 trap.h 中添加服务函数声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">system_call_handler</span><span class="params">(struct Trapframe *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在 trap.c 中添加服务函数定义*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * system call (interrupt 48) handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">system_call_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>trapentry.S</code>中添加入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(syscall_entry, T_SYSCALL)        # vector48: system call</span><br><span class="line"></span><br><span class="line">.long syscall_entry</span><br></pre></td></tr></table></figure>
<p>在<code>trap_init()</code>中设置系统调用<code>idt</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, syscall_entry_, <span class="number">3</span>)  <span class="comment">// 这里因为系统调用号是48，和前面的不相连</span></span><br><span class="line">                                                      <span class="comment">// 能重新定义一个变量保存其服务函数入口</span></span><br></pre></td></tr></table></figure>
<p>最后在<code>trap_dispatch()</code>中添加系统调用处理分支</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">system_call_handler(tf);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h4 id="编写系统调用服务函数"><a href="#编写系统调用服务函数" class="headerlink" title="编写系统调用服务函数"></a>编写系统调用服务函数</h4><p>系统调用服务函数的主要职责就是获取系统调用参数，并调用<code>syscall</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">system_call_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> syscallno = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg1 = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg2 = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg3 = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg4 = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg5 = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">    syscall(syscallno, arg1, arg2, arg3, arg4, arg5);  <span class="comment">// Error! Without a return value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而上面这个函数有点问题，我们没有保存系统调用的返回值，根据<code>syscall.c</code>中的内联汇编代码，我们需要将返回值存储至<code>eax</code>寄存器中，所以上面的代码需要稍作修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tf-&gt;tf_regs.reg_eax = syscall(syscallno, arg1, arg2, arg3, arg4, arg5);</span><br></pre></td></tr></table></figure>
<h4 id="编写syscall"><a href="#编写syscall" class="headerlink" title="编写syscall()"></a>编写syscall()</h4><p>在<code>kern/syscall.c</code>中，根据系统调用编号，调用对应的系统调用服务函数。这里主要注意一下输入参数和返回值即可，实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="comment">// Returns &gt;= on success, &lt; 0 on error. Errors are:</span></span><br><span class="line"><span class="comment">// -E_INVAL if syscallno is invalid</span></span><br><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Call the function corresponding to the 'syscallno' parameter.</span></span><br><span class="line">    <span class="comment">// Return any appropriate return value.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">        <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">    <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">        sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span>*)a1, a2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">        <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">    <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">        <span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="改进：使用Python脚本自动生成trapentry-S"><a href="#改进：使用Python脚本自动生成trapentry-S" class="headerlink" title="改进：使用Python脚本自动生成trapentry.S"></a>改进：使用Python脚本自动生成<code>trapentry.S</code></h4><p>自己手写维护<code>trapentry.S</code>中的中断入口不仅耗时耗力，还很容易出错，因此这里用python写一个脚本，自动生成包含256个中断的中断服务函数入口，以及保存这些入口的<code>vectors</code>数组。基本思路是采用循环语句构造中断服务函数入口函数以及入口函数地址数组。然后再对Makefile进行修改。脚本就不在此处列出了。</p>
<div class="note danger">
            <p><strong>Challenge!</strong> Implement system calls using the <code>sysenter</code> and <code>sysexit</code> instructions instead of using <code>int 0x30</code> and <code>iret</code>.</p><p>The <code>sysenter/sysexit</code> instructions were designed by Intel to be faster than <code>int/iret</code>. They do this by using registers instead of the stack and by making assumptions about how the segmentation registers are used. The exact details of these instructions can be found in Volume 2B of the Intel reference manuals.</p><p>The easiest way to add support for these instructions in JOS is to add a <code>sysenter_handler</code> in <code>kern/trapentry.S</code> that saves enough information about the user environment to return to it, sets up the kernel environment, pushes the arguments to <code>syscall()</code> and calls <code>syscall()</code> directly. Once <code>syscall()</code> returns, set everything up for and execute the <code>sysexit</code> instruction. You will also need to add code to <code>kern/init.c</code> to set up the necessary model specific registers (MSRs). Section 6.1.2 in Volume 2 of the AMD Architecture Programmer’s Manual and the reference on SYSENTER in Volume 2B of the Intel reference manuals give good descriptions of the relevant MSRs. You can find an implementation of <code>wrmsr</code> to add to <code>inc/x86.h</code> for writing to these MSRs <a href="http://ftp.kh.edu.tw/Linux/SuSE/people/garloff/linux/k6mod.c">here</a>.</p><p>Finally, <code>lib/syscall.c</code> must be changed to support making a system call with <code>sysenter</code>. Here is a possible register layout for the <code>sysenter</code> instruction:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eax                - syscall number</span><br><span class="line">edx, ecx, ebx, edi - arg1, arg2, arg3, arg4</span><br><span class="line">esi                - return pc</span><br><span class="line">ebp                - return esp</span><br><span class="line">esp                - trashed by sysenter</span><br></pre></td></tr></table></figure><p>GCC’s inline assembler will automatically save registers that you tell it to load values directly into. Don’t forget to either save (push) and restore (pop) other registers that you clobber, or tell the inline assembler that you’re clobbering them. The inline assembler doesn’t support saving <code>%ebp</code>, so you will need to add code to save and restore it yourself. The return address can be put into <code>%esi</code> by using an instruction like <code>leal after_sysenter_label, %%esi</code>.</p><p>Note that this only supports 4 arguments, so you will need to leave the old method of doing system calls around to support 5 argument system calls. Furthermore, because this fast path doesn’t update the current environment’s trap frame, it won’t be suitable for some of the system calls we add in later labs.</p><p>You may have to revisit your code once we enable asynchronous interrupts in the next lab. Specifically, you’ll need to enable interrupts when returning to the user process, which <code>sysexit</code> doesn’t do for you.</p>
          </div>
<h5 id="Makefile的编写"><a href="#Makefile的编写" class="headerlink" title="Makefile的编写"></a>Makefile的编写</h5><p>在编写了对应的python脚本后，我们希望将其写入Makefile中，使其自动化运行，我们最终生成的目标为<code>kern/vectors.S</code>，依赖文件为<code>kern/vectors.py</code>，因此我们可以在<code>kern/Makefrag</code>下添加这样一段：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">kern/vectors.S: kern/vectors.py</span></span><br><span class="line">    python kern/vectors.py &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>当makefile需要依赖<code>kern/vectors.S</code>时，就会找到<code>kern/vector.S</code>，然后执行python命令行，生成<code>vectors.S</code>。查看makefile，我们发现依赖<code>kern/vectors.S</code>的文件为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(OBJDIR)</span>/kern/%.o: kern/%.S <span class="variable">$(OBJDIR)</span>/.vars.KERN_CFLAGS</span><br><span class="line">    @echo + as <span class="variable">$&lt;</span></span><br><span class="line">    @mkdir -p $(@D)</span><br><span class="line">    <span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(KERN_CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>我们需要将第一行修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(OBJDIR)/kern/%.o: kern/%.S kern/vectors.S $(OBJDIR)/.vars.KERN_CFLAGS</span><br></pre></td></tr></table></figure>
<p>声明对于<code>kern/vectors.S</code>的依赖关系。这里还有一个疑问，我本来想直接写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">kern/%.S: kern/vectors.py</span></span><br><span class="line">    python kern/vectors.py &gt; vectors.S</span><br></pre></td></tr></table></figure>
<p>即不显式声明对某个文件的依赖，而是用通配符进行处理，但是并不行。这个问题目前暂未解决，先这样吧。</p>
<h3 id="用户模式起步"><a href="#用户模式起步" class="headerlink" title="用户模式起步"></a>用户模式起步</h3><p>一个用户程序在<code>lib/entry.S</code>的顶部启动。经过一些配置，这个代码调用位于<code>lib/libmain.c</code>的<code>libmain()</code>。修改<code>libmain()</code>，初始化全局指针<code>thisenv</code>，指向<code>envs[]</code>中当前进程的<code>struct Env</code> 。提示：参考<code>inc/env.h</code>并使用<code>sys_getenvid</code>。</p>
<p><code>libmain()</code>随后调用<code>umain</code>，这个函数定义在具体的用户程序中。在hello程序中为<code>user/hello.c</code>。注意到打印了”<code>hello, world</code>“后，<code>umain()</code>试图访问<code>thisenv-&gt;env_id</code>。而该指针还未初始化好，所以出现了错误。现在我们初始化了<code>thisenv</code>，因此不会出错。如果依然有错误，那么<code>UENVS</code>这个空间可能被设置为了用户不可读。</p>
<div class="note default">
            <p><strong>练习8</strong>：在用户库中添加所需的代码，支持用户程序运行。你应当看到<code>user/hello</code>打印<code>hello, world</code>以及<code>i am environment 00001000</code>，然后尝试调用<code>sys_env_destroy()</code>退出（参考<code>lib/libmain.c</code>和<code>lib/exit.c</code>）。由于当前内核仅支持一个用户程序，因此内核会报告销毁了唯一的进程，并进入了内核监视器。现在，<code>make grade</code>应当能够通过<code>hello</code>测试。</p>
          </div>
<p>练习8要求我们初始化全局指针<code>thisenv</code>并指向<code>envs</code>中的当前进程，我们需要做两件事情：</p>
<ul>
<li>找到当前进程</li>
<li>将当前进程对应的地址赋值给<code>thisenv</code></li>
</ul>
<p>第一个任务是靠<code>sys_getenvid()</code>和<code>ENVX</code>实现的，查阅<code>inc/env.h</code>，我们可以知道如何找到进程id，并根据id找到进程在<code>envs</code>数组中的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The environment index ENVX(eid) equals the environment's index in the</span></span><br><span class="line"><span class="comment">// 'envs[]' array.  The uniqueifier distinguishes environments that were</span></span><br><span class="line"><span class="comment">// created at different times, but share the same environment index.</span></span><br></pre></td></tr></table></figure>
<p>解决了第一个问题，第二个就很简单了，我们只需要修改<code>libmain.c</code>，加一句话即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">libmain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="页错误与内存保护"><a href="#页错误与内存保护" class="headerlink" title="页错误与内存保护"></a>页错误与内存保护</h3><p>操作系统依赖于硬件实施内存保护。内核会通知硬件，哪些虚拟内存是有效的，哪些不是。当一个程序尝试访问无效内存或者无权限内存，处理器会在触发错误的指令处停止该语句，并带着相关信息进入内核。如果错误是可修复的，内核修复错误并继续执行程序；否则程序无法继续执行。</p>
<p>As an example of a fixable fault, consider an automatically extended stack. In many systems the kernel initially allocates a single stack page, and then if a program faults accessing pages further down the stack, the kernel will allocate those pages automatically and let the program continue. By doing this, the kernel only allocates as much stack memory as the program needs, but the program can work under the illusion that it has an arbitrarily large stack.</p>
<p>System calls present an interesting problem for memory protection. Most system call interfaces let user programs pass pointers to the kernel. These pointers point at user buffers to be read or written. The kernel then dereferences these pointers while carrying out the system call. There are two problems with this:</p>
<ol>
<li>内核页错误更严重. If the kernel page-faults while manipulating its own data structures, that’s a kernel bug, and the fault handler should panic the kernel (and hence the whole system). But when the kernel is dereferencing pointers given to it by the user program, it needs a way to remember that any page faults these dereferences cause are actually on behalf of the user program.</li>
<li>The kernel typically has more memory permissions than the user program. The user program might pass a pointer to a system call that points to memory that the kernel can read or write but that the program cannot. The kernel must be careful not to be tricked into dereferencing such a pointer, since that might reveal private information or destroy the integrity of the kernel.</li>
</ol>
<p>For both of these reasons the kernel must be extremely careful when handling pointers presented by user programs.</p>
<p>You will now solve these two problems with a single mechanism that scrutinizes all pointers passed from userspace into the kernel. When a program passes the kernel a pointer, the kernel will check that the address is in the user part of the address space, and that the page table would allow the memory operation.</p>
<p>Thus, the kernel will never suffer a page fault due to dereferencing a user-supplied pointer. If the kernel does page fault, it should panic and terminate.</p>
<div class="note default">
            <p><strong>Exercise 9.</strong> </p><ul><li><p>Change <code>kern/trap.c</code> to panic if a page fault happens in kernel mode. Hint: to determine whether a fault happened in user mode or in kernel mode, check the low bits of the <code>tf_cs</code>.</p></li><li><p>Read <code>user_mem_assert</code> in <code>kern/pmap.c</code> and implement <code>user_mem_check</code> in that same file.</p></li><li><p>Change <code>kern/syscall.c</code> to sanity (理智) check arguments to system calls.</p></li><li><p>Boot your kernel, running <code>user/buggyhello</code>. The environment should be destroyed, and the kernel should <em>not</em> panic. You should see:</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[00001000] user_mem_check assertion failure for va 00000001</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br></pre></td></tr></table></figure><ul><li>Finally, change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>. If you now run <code>user/breakpoint</code>, you should be able to run backtrace from the kernel monitor and see the backtrace traverse into <code>lib/libmain.c</code> before the kernel panics with a page fault. What causes this page fault? You don’t need to fix it, but you should understand why it happens.</li></ul>
          </div>
<p>练习9一共给了5个任务，我们依次完成：</p>
<h4 id="修改-kern-trap-c，当内核发生页错误时，panic"><a href="#修改-kern-trap-c，当内核发生页错误时，panic" class="headerlink" title="修改 kern/trap.c，当内核发生页错误时，panic"></a>修改 <code>kern/trap.c</code>，当内核发生页错误时，panic</h4><p>这里提示我们使用 <code>tf_cs</code>的低位对内核和用户模式进行判断，如果页错误在内核，就将内核中止。这段代码比较简单，在<code>page_fault_handler</code>中添加下面的代码即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(tf-&gt;tf_cs == GD_KT)&#123;</span><br><span class="line">        panic(<span class="string">"kernel mode page faults"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现user-mem-check"><a href="#实现user-mem-check" class="headerlink" title="实现user_mem_check"></a>实现<code>user_mem_check</code></h4><h5 id="函数功能-6"><a href="#函数功能-6" class="headerlink" title="函数功能"></a>函数功能</h5><p>Check that an environment is allowed to access the range of memory <code>[va, va+len)</code> with permissions <code>perm | PTE_P</code>. Normally <code>perm</code> will contain PTE_U at least, but this is not required. <code>va</code> and <code>len</code> need not be page-aligned; you must test every page that contains any of that range.  You will test either <code>len/PGSIZE</code>, <code>len/PGSIZE + 1</code>, or <code>len/PGSIZE + 2</code> pages.</p>
<h5 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">user_mem_check(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数实现-1"><a href="#函数实现-1" class="headerlink" title="函数实现"></a>函数实现</h5><p>为了对<code>[va, va+len)</code>进行检查，我们需要完成以下工作：</p>
<ul>
<li>进行内存对齐，找到包含<code>[va, va+len)</code>的最小对齐内存</li>
<li>依次遍历，判断内存是否合法，如果不合法，记录非法内存所在地址<ul>
<li>内存是否在用户区域内？(<code>start &lt; ULIM</code>)</li>
<li>pte是否非空？</li>
<li>pte是否符合perm的要求？(<code>pte &amp; perm == perm</code>)</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">user_mem_check(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 'va' and 'len' need not be page-aligned; </span></span><br><span class="line">    <span class="comment">// To make sure that all the memory can be covered, we need to align the </span></span><br><span class="line">    <span class="comment">// address. [start, [va, va + len], end];</span></span><br><span class="line">    <span class="keyword">void</span>* start = (<span class="keyword">void</span>*) ROUNDDOWN((<span class="keyword">uint32_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="keyword">void</span>* end = (<span class="keyword">void</span>*) ROUNDUP((<span class="keyword">uint32_t</span>)(va+len), PGSIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// You must test every page that contains any of that range.  </span></span><br><span class="line">    <span class="comment">// You will test either 'len/PGSIZE', 'len/PGSIZE + 1', or 'len/PGSIZE + 2' pages.</span></span><br><span class="line">    <span class="keyword">for</span>(; start &lt; end; start += PGSIZE)&#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *pte = pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">void</span> *)start, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// A user program can access a virtual address if (1) the address is below</span></span><br><span class="line">        <span class="comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span></span><br><span class="line">        <span class="comment">// the tests you should implement here.</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">uintptr_t</span>)start &gt;= ULIM || !pte || !(*pte &amp; PTE_P) || ((*pte &amp; perm) != perm))&#123;</span><br><span class="line">            <span class="comment">// If there is an error, set the 'user_mem_check_addr' variable to the first</span></span><br><span class="line">            <span class="comment">// erroneous virtual address.</span></span><br><span class="line">            user_mem_check_addr = (<span class="keyword">uintptr_t</span>)(start &lt; va ? va : start);</span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;  <span class="comment">// Returns -E_FAULT if memory is invalid</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Returns 0 if the user program can access this range of addresses.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改-kern-syscall-c，检查syscall的调用参数"><a href="#修改-kern-syscall-c，检查syscall的调用参数" class="headerlink" title="修改 kern/syscall.c，检查syscall的调用参数"></a>修改 <code>kern/syscall.c</code>，检查<code>syscall</code>的调用参数</h4><p>由于<code>sys_cputs</code>系统调用要对内存进行写操作，因此我们要检查内存是否有效，在<code>/kern/syscall.c</code>的<code>sys_cputs</code>函数中加入进行检查即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">user_mem_assert(curenv, (<span class="keyword">void</span>*)s, len, PTE_P|PTE_U);</span><br></pre></td></tr></table></figure>
<h4 id="运行并查看结果"><a href="#运行并查看结果" class="headerlink" title="运行并查看结果"></a>运行并查看结果</h4><p>现在你的程序应当能够通过所有的测试，并获得相应的分数。至此，Lab3已经全部完成。</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20210609221753.png" width = "550" alt="图片名称" align=center /></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="其他几个重要但是不需要我们完成的函数"><a href="#其他几个重要但是不需要我们完成的函数" class="headerlink" title="其他几个重要但是不需要我们完成的函数"></a>其他几个重要但是不需要我们完成的函数</h3><h4 id="env-pop-tf-struct-Trapframe-tf"><a href="#env-pop-tf-struct-Trapframe-tf" class="headerlink" title="env_pop_tf(struct Trapframe *tf)"></a>env_pop_tf(struct Trapframe *tf)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Restores the register values in the Trapframe with the 'iret' instruction.</span></span><br><span class="line"><span class="comment">// This exits the kernel and starts executing some environment's code.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function does not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_pop_tf(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tmovl %0,%%esp\n"</span>				<span class="comment">// 将%esp指向tf地址处</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopal\n"</span>						<span class="comment">// 弹出Trapframe结构中的tf_regs值到通用寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%es\n"</span>					<span class="comment">// 弹出Trapframe结构中的tf_es值到%es寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%ds\n"</span>					<span class="comment">// 弹出Trapframe结构中的tf_ds值到%ds寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\taddl $0x8,%%esp\n"</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tiret\n"</span>						<span class="comment">// 中断返回指令，具体动作如下：从Trapframe结构中依次弹出tf_eip,tf_cs,tf_eflags,tf_esp,tf_ss到相应寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params">		: </span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"g"</span> (tf)                      <span class="comment">// 输入操作数</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">    panic(<span class="string">"iret failed"</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数将一个陷帧弹出，将其中的值恢复给寄存器，即恢复到<code>tf</code>描述的状态。</p>
<h4 id="SETGATE"><a href="#SETGATE" class="headerlink" title="SETGATE"></a><code>SETGATE</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: "The difference between</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an</span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF."</span></span><br><span class="line">    <span class="comment">//   为了正确设置gate，我们需要知道哪些是trap，哪些是interrupt，参考</span></span><br><span class="line"><span class="comment">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//	  the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//	  this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)			\</span></span><br><span class="line">&#123;								\</span><br><span class="line">    (gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>) (off) &amp; <span class="number">0xffff</span>;		\</span><br><span class="line">    (gate).gd_sel = (sel);					\</span><br><span class="line">    (gate).gd_args = <span class="number">0</span>;					\</span><br><span class="line">    (gate).gd_rsv1 = <span class="number">0</span>;					\</span><br><span class="line">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;	\</span><br><span class="line">    (gate).gd_s = <span class="number">0</span>;					\</span><br><span class="line">    (gate).gd_dpl = (dpl);					\</span><br><span class="line">    (gate).gd_p = <span class="number">1</span>;					\</span><br><span class="line">    (gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>) (off) &gt;&gt; <span class="number">16</span>;		\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数需要注意的是其中的<code>sel</code>段，这个段设置了中断/陷入handler的代码段，同时，<code>off</code>设置了代码段偏移量</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 bookc</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab3/">Lab3</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://www.cnblogs.com/gatsby123/p/9838304.html">Lab3实验答案</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://yangminz.github.io/images/OperatingSys/Lab3Report.html">Yangminz Blog</a><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-Lab1-启动一个PC</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-Lab1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>HumanCore - CP/M-17 Version 1.0, Date: January 08, 1996</p>
</blockquote>
<a id="more"></a>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>首先，建议使用32位ubuntu虚拟机作为实验环境，不建议自己配置，因为会遇到各种坑。我们的主要目的是学习操作系统，不是安装各种环境及工具，下载一个32位的ubuntu桌面镜像，然后配置一个虚拟机即可。我这里使用的是16.04版本的32位ubuntu镜像，使用的虚拟机是vmware。需要的qemu等软件可以在<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">如下网站中进行下载</a>，此处wo’shi’yong</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h4 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h4><p>输入如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% objdump -i</span><br></pre></td></tr></table></figure>
<p>The second line should say <code>elf32-i386</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% gcc -m32 -print-libgcc-file-name</span><br></pre></td></tr></table></figure>
<p>The command should print something like <code>/usr/lib/gcc/i486-linux-gnu/*version*/libgcc.a</code> or <code>/usr/lib/gcc/x86_64-linux-gnu/*version*/32/libgcc.a</code></p>
<p>If both these commands succeed, you’re all set, and don’t need to compile your own toolchain.</p>
<p>If the gcc command fails, you may need to install a development environment. On Ubuntu Linux, try this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% sudo apt-get install -y build-essential gdb</span><br></pre></td></tr></table></figure>
<p>On 64-bit machines, you may need to install a 32-bit support library. The symptom is that linking fails with error messages like “<code>__udivdi3</code> not found” and “<code>__muldi3</code> not found”. On Ubuntu Linux, try this to fix the problem:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>
<h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><p>请使用git获取实验源文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">athena%</span><span class="bash"> mkdir ~/6.828</span></span><br><span class="line"><span class="meta">athena%</span><span class="bash"> <span class="built_in">cd</span> ~/6.828</span></span><br><span class="line"><span class="meta">athena%</span><span class="bash"> add git</span></span><br><span class="line"><span class="meta">athena%</span><span class="bash"> git <span class="built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span></span><br><span class="line">Cloning into lab...</span><br><span class="line"><span class="meta">athena%</span><span class="bash"> <span class="built_in">cd</span> lab</span></span><br></pre></td></tr></table></figure>
<p>使用<code>git diff origin/lab1</code>对于代码的改变进行跟踪</p>
<h4 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h4><p>本实验使用qemu作为虚拟机，因此需要安装qemu，archlinux下安装qemu的方法很简单，需要注意的是，安装完成后，需要编辑<code>lab/conf/env.mk</code>文件，将</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> QEMU</span></span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">QEMU=/usr/bin/qemu-system-i386</span><br></pre></td></tr></table></figure>
<p>这样就为QEMU设置了路径。如果没有qemu-system-i386，请到<a href="https://www.archlinux.org/packages/extra/x86_64/qemu-arch-extra/files/">这个网站下载</a>。这里必须使用i386，否则会出现gdb和qemu体系结构不匹配的问题。</p>
<h3 id="作业上传"><a href="#作业上传" class="headerlink" title="作业上传"></a>作业上传</h3><p>接下来去<a href="https://6828.scripts.mit.edu/2018/handin.py/">这个网页</a>，用自己的邮箱注册一个账号，这样就可以上传作业并进行批改。以后只需要在lab文件中执行make handin，即可提交作业，下面的XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX改为自己邮箱注册后的API</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">athena%</span><span class="bash"> make handin</span></span><br><span class="line">git archive --prefix=lab1/ --format=tar HEAD | gzip &gt; lab1-handin.tar.gz</span><br><span class="line">Get an API key for yourself by visiting https://6828.scripts.mit.edu/2018/handin.py/</span><br><span class="line">Please enter your API key: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 50199  100   241  100 49958    414  85824 --:--:-- --:--:-- --:--:-- 85986</span><br><span class="line"><span class="meta">athena%</span></span><br></pre></td></tr></table></figure>
<h3 id="作业批改"><a href="#作业批改" class="headerlink" title="作业批改"></a>作业批改</h3><p>运行下面的命令进行作业批改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make grade</span><br></pre></td></tr></table></figure>
<p>需要注意的是，要将<code>./grade-lab1</code>的权限修改为可运行，此外，如果是linux系统，可能会出现下面的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/env: "python\r": 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>这个是因为UNIX和Linux上的字符集的差异所造成的，解决方法是<code>vim grade-lab1</code>，然后输入<code>:set  ff=unix</code>，再保存即可。</p>
<h2 id="第一部分-PC-Bootstrap"><a href="#第一部分-PC-Bootstrap" class="headerlink" title="第一部分 PC Bootstrap"></a>第一部分 PC Bootstrap</h2><h3 id="x86汇编"><a href="#x86汇编" class="headerlink" title="x86汇编"></a>x86汇编</h3><p>这里请参考<a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">应用于NASM 编译器的汇编教程</a>和<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Intel/AT&amp;T汇编语法转换</a>。本实验所用的汇编语言是<em>AT&amp;T</em> 语法</p>
<h3 id="x86模拟"><a href="#x86模拟" class="headerlink" title="x86模拟"></a>x86模拟</h3><p>我们使用qemu虚拟器对我们所编写的操作系统进行模拟，进入lab后，运行<code>make</code>，对操作系统进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">+ as kern/entry.S</span><br><span class="line">+ cc kern/entrypgdir.c</span><br><span class="line">+ cc kern/init.c</span><br><span class="line">+ cc kern/console.c</span><br><span class="line">+ cc kern/monitor.c</span><br><span class="line">+ cc kern/printf.c</span><br><span class="line">+ cc kern/kdebug.c</span><br><span class="line">+ cc lib/printfmt.c</span><br><span class="line">+ cc lib/readline.c</span><br><span class="line">+ cc lib/string.c</span><br><span class="line">+ ld obj/kern/kernel</span><br><span class="line">ld: warning: section `.bss' type changed to PROGBITS</span><br><span class="line">+ as boot/boot.S</span><br><span class="line">+ cc -Os boot/main.c</span><br><span class="line">+ ld boot/boot</span><br><span class="line">boot block is 396 bytes (max 510)</span><br><span class="line">+ mk obj/kern/kernel.img</span><br></pre></td></tr></table></figure>
<p>然后我们就获得了一个镜像文件<code>kernel.img</code>，运行<code>make qemu</code>即可在qemu虚拟机下，运行我们的操作系统，运行成功的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Booting from Hard Disk...</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type 'help' for a list of commands.</span><br><span class="line"><span class="meta">K&gt;</span></span><br></pre></td></tr></table></figure>
<p>目前这个操作系统提供了两个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">K&gt;</span><span class="bash"> <span class="built_in">help</span></span></span><br><span class="line">help - display this list of commands</span><br><span class="line">kerninfo - display information about the kernel</span><br><span class="line"><span class="meta">K&gt;</span><span class="bash"> kerninfo</span></span><br><span class="line">Special kernel symbols:</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f0101a75 (virt)  00101a75 (phys)</span><br><span class="line">  edata  f0112300 (virt)  00112300 (phys)</span><br><span class="line">  end    f0112960 (virt)  00112960 (phys)</span><br><span class="line">Kernel executable memory footprint: 75KB</span><br><span class="line"><span class="meta">K&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="机器的物理地址空间"><a href="#机器的物理地址空间" class="headerlink" title="机器的物理地址空间"></a>机器的物理地址空间</h3><p>一个计算机（32位）的物理地址空间布局基本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<p>早期的计算机内存很小，可能只有64KB的RAM。从0x000A000到0x000FFFFF这一段被用于硬件用途，例如视频播放缓存等。最重要的是BIOS所在的内存，占据了0x000F0000到0x000FFFFF的64KB空间。早期的BIOS是写死的，现在的计算机BIOS都位于可刷新的闪存区域。关于BIOS的讲解详见。</p>
<h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><h4 id="启动过程调试"><a href="#启动过程调试" class="headerlink" title="启动过程调试"></a>启动过程调试</h4><p>至此，我们终于可以使用qemu启动我们的程序，并观察启动的过程。在lab文件夹下，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make qemu-gdb</span><br></pre></td></tr></table></figure>
<p>即可令qemu运行在调试模式下，此时qemu作为一个虚拟远程机进入调试模式，打开另一个终端，输入<code>make gdb</code>，即可看到下面的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Type "apropos word" to search for commands related to "word".</span><br><span class="line">+ target remote localhost:26000</span><br><span class="line">warning: No executable has been specified and target does not support</span><br><span class="line">determining executable automatically.  Try using the "file" command.</span><br><span class="line">The target architecture is set to "i8086".</span><br><span class="line">[f000:fff0]    0xffff0:	ljmp   $0x3630,$0xf000e05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration</span><br><span class="line">of GDB.  Attempting to continue with the default i8086 settings.</span><br></pre></td></tr></table></figure>
<p>这里又遇到了一个坑，gdb反汇编的结果是有问题的，按照16位汇编的结果，应当CS=0xf000，而IP=0xe05b，但是这里gdb是用32位的模式进行的反汇编，结果就是CS=0x3630，而IP=$0xf000e05b，这不是我们想要的，解决方法如下：</p>
<ul>
<li>在lab文件夹下执行如下命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE target SYSTEM "gdb-target.dtd"&gt;&lt;target&gt;&lt;architecture&gt;i8086&lt;/architecture&gt;&lt;xi:include href="i386-32bit.xml"/&gt;&lt;/target&gt;'</span> &gt; target.xml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget https://raw.githubusercontent.com/qemu/qemu/master/gdb-xml/i386-32bit.xml</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后修改<code>gdbinit.tmpl</code>文件，将</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">12     if $lastcs == -1 || $lastcs == 8 || $lastcs == 27                           </span><br><span class="line">13       set architecture i8086                                                                             </span><br><span class="line">14     end</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">12     if $lastcs == -1 || $lastcs == 8 || $lastcs == 27                           </span><br><span class="line">13       set architecture i8086                                                    </span><br><span class="line">14       set tdesc filename target.xml                                             </span><br><span class="line">15     end</span><br></pre></td></tr></table></figure>
<ul>
<li>重新make</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make clean</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure>
<p>将<code>add-auto-load-safe-path /home/duan/Code/linux/6.828/xv6-public/.gdbinit</code>添加至<code>/home/user/.gdbinit</code>文件夹下（如果没有就新建一个），再次执行<code>make gdb</code>，我们得到了下面的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br></pre></td></tr></table></figure>
<p>这次的结果就很完美，是我们想要的，解释一下几个参数</p>
<ul>
<li>系统开始执行的物理地址为[CS:IP]=[f000:fff0]，这个区域位于内存的BIOS区域上部，实际物理地址为16*CS+IP=0xffff0（实模式寻址）</li>
<li>第一条指令为一个ljmp指令，跳转至CS=0xf000, IP=0xe05b</li>
</ul>
<p>这样启动后系统进入了BIOS区，可以确保上电后由BIOS接管机器，此时CPU处在实模式（所谓实模式，就是其地址采用真实的物理地址）。0xffff0是BIOS末尾（0x100000）的前16位，所以机器一上电，位于0xffff0，然后赶紧往回跳转，跳到0xfe05b，毕竟16byte什么都做不了。这一段代码是qemu内置的BIOS启动代码，和课程的代码无关，只需要了解他执行了一些上电检查，然后就将控制权交给了Boot loader段。我们只需要知道我们写的boot loader段起始位置在0x7c00即可(关于0x7c00这个魔数请参考<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>)。</p>
<h4 id="练习：使用gdb-si多运行几行命令，猜测命令的作用"><a href="#练习：使用gdb-si多运行几行命令，猜测命令的作用" class="headerlink" title="练习：使用gdb si多运行几行命令，猜测命令的作用"></a>练习：使用gdb si多运行几行命令，猜测命令的作用</h4><p>在这里我一共运行了五次si，分别记录下了命令和相应的结果</p>
<h5 id="第一次si"><a href="#第一次si" class="headerlink" title="第一次si"></a>第一次si</h5><p>第一次si得到的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:xe05b]    0xfe05b: cmpl   $0x0, %cs:0x6308  # 此条命令占据7byte</span><br></pre></td></tr></table></figure>
<p>这是一个长比较命令，对立即数0x0和f000:6308这个地址上的数进行了比较，推测是0x6308上有一些设置需要进行判断。但是具体是什么并不清楚。</p>
<h5 id="第二次si"><a href="#第二次si" class="headerlink" title="第二次si"></a>第二次si</h5><p>第二次si得到的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:e062]    0xfe062: jne    0xfd0a2  # 此条命令占据4byte</span><br></pre></td></tr></table></figure>
<p>如果不相等，就跳转至0xfd0a2，结合第一次si的结果可知，如果cs:0x6308保存的值不为0，那么跳转至0xfd0a2。</p>
<h5 id="第三次si"><a href="#第三次si" class="headerlink" title="第三次si"></a>第三次si</h5><p>第三次si得到的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:e066]    0xfe066: xor    %dx, %dx  # 此条命令占据2byte</span><br></pre></td></tr></table></figure>
<p>根据命令的地址，我们知道cs:0x6308保存的值确实为1，命令顺序执行，这里进行一个异或操作，清空dx寄存器。</p>
<h5 id="第四次si"><a href="#第四次si" class="headerlink" title="第四次si"></a>第四次si</h5><p>第四次si得到的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:e068]    0xfe068: mov    %dx, %ss</span><br></pre></td></tr></table></figure>
<p>将dx寄存器中的值保存至ss寄存器。就是说堆栈段基地址为0x0000</p>
<h5 id="第五次si"><a href="#第五次si" class="headerlink" title="第五次si"></a>第五次si</h5><p>第五次si得到的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[f000:e06a]    0xfe06a: mov    0x7000, %esp</span><br></pre></td></tr></table></figure>
<p>将0x7000保存至esp寄存器，说明堆栈段的地址为0x07000。可以看到，操作系统一开始的工作是进行了一些对内存的分段的操作。</p>
<h3 id="Boot-Loader"><a href="#Boot-Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h3><p>BIOS完成后，我们要进行Boot Loader，Boot Loader代码位于硬盘上，而硬盘扇区大小为512字节（现在也有4K的，能够加载更大的boot loader），Boot Loader程序就位于硬盘最初的512B上，我们要将整个扇区加载到内存物理地址为0x7c00到0x7dff所在的位置，然后使用jmp命令跳转至CS:IP = [0000:7c00]，将控制权移交给Boot Loader。boot loader的程序为<code>boot/boot.S</code>和<code>boot/main.c</code>，本节的主要工作就是阅读并理解这两个程序。boot loader主要完成两个功能：</p>
<ul>
<li>一：从实模式切换至32位保护模式，这样软件才能访问处理器的全部物理地址空间，关于保护模式请参考<a href="http://www.drpaulcarter.com/pcasm/">1.2.7和1.2.8节</a></li>
<li>二：boot loader通过x86的特殊io机制，直接访问硬盘设备的寄存器，读取硬盘上的内核</li>
</ul>
<p>下面给出<code>boot/boot.S</code>和<code>boot/main.c</code>的算法，其中，关于A20的控制请参考<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>。</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐boot.S代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;inc/mmu.h&gt;</span><br><span class="line"></span><br><span class="line"># Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line"># with %cs=0 %ip=7c00.</span><br><span class="line"># 这段代码将被加载至0x7c00处，然后以实模式运行</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                     # Assemble for 16-bit mode</span><br><span class="line">  cli                         # Disable interrupts BIOS作为一个微型操作系统，也是会开启中断的，但是BIOS结束后</span><br><span class="line">                              # 再触发硬件中断就不安全了，所以要先关闭中断</span><br><span class="line">  cld                         # String operations increment</span><br><span class="line"></span><br><span class="line">  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">  # BIOS并不保证这些寄存器中的值，所以要先清空</span><br><span class="line">  xorw    %ax,%ax             # Segment number zero</span><br><span class="line">  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">  # Enable A20:</span><br><span class="line">  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">  #   address line 20 is tied low, so that addresses higher than</span><br><span class="line">  #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">  #   关于这一部分的解释详见附录6，看不懂可以先略过，总之就是为了前向兼容</span><br><span class="line">  #   实际运行中，这两段也就是跳过了</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy                  |al|&lt;--------|0x64|</span><br><span class="line">  testb   $0x2,%al                # 0x00000010和al寄存器按位与，如果结果为0，将ZF置1</span><br><span class="line">  jnz     seta20.1                # 如果ZF为1，跳转</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br><span class="line">  # 从实模式向保护模式切换</span><br><span class="line">  # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">  # and segment translation that makes virtual addresses </span><br><span class="line">  # identical to their physical addresses, so that the </span><br><span class="line">  # effective memory map does not change during the switch.</span><br><span class="line">  # Global Descriptor Table (GDT) is a table in memory that defines the processor&apos;s memory segments.</span><br><span class="line">  lgdt    gdtdesc                 #将gdtdesc标识符送入全局描述符表GDTR寄存器中，这个标识符在文件末尾，给GDTR新值</span><br><span class="line">  movl    %cr0, %eax              #</span><br><span class="line">  orl     $CR0_PE_ON, %eax        #将cr0寄存器第0位置1，进入保护模式</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line">  </span><br><span class="line">  # 此时已经进入保护模式，但是CS还未更新，所以需要用ljmp进行更新，更新后CS为0x8</span><br><span class="line">  # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">  # Switches processor into 32-bit mode.</span><br><span class="line">  # ljmp完成了从16到32位的切换，由于不能直接设置CS，所以我们使用ljmp更改</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg  # 0000 0000 0000 1 000 selector为0000 0000 0000 1，使用GDT，优先级为00</span><br><span class="line"></span><br><span class="line">  .code32                     # Assemble for 32-bit mode </span><br><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class="line">  </span><br><span class="line">  # Set up the stack pointer and call into C.</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain                   # 0x7d19</span><br><span class="line"></span><br><span class="line">  # If bootmain returns (it shouldn&apos;t), loop.</span><br><span class="line">spin:</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL				                # null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	    # code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)	        # data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure>

</div></div>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐boot/main.c代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据 boot/Makefrag, main.o被加载到</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * This a dirt simple boot loader, whose sole job is to boot</span></span><br><span class="line"><span class="comment"> * an ELF kernel image from the first IDE hard disk. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DISK LAYOUT</span></span><br><span class="line"><span class="comment"> *  * This program(boot.S and main.c) is the bootloader.  It should</span></span><br><span class="line"><span class="comment"> *    be stored in the first sector of the disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The 2nd sector onward holds the kernel image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The kernel image must be in ELF format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BOOT UP STEPS  BIOS加载BOOTLOADER</span></span><br><span class="line"><span class="comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span></span><br><span class="line"><span class="comment"> *    reads the first sector of the boot device(e.g., hard-drive) </span></span><br><span class="line"><span class="comment"> *    into memory and jumps to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * Assuming this boot loader is stored in the first sector of the</span></span><br><span class="line"><span class="comment"> *    hard-drive, this code takes over...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * control starts in boot.S -- which sets up protected mode,</span></span><br><span class="line"><span class="comment"> *    and a stack so C code then run, then calls bootmain()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE	512                      <span class="comment">// 扇区大小为512</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR		((struct Elf *) 0x10000) <span class="comment">// scratch space </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">uint32_t</span>)</span></span>;              <span class="comment">// 读取一个Sector</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>)</span></span>;  <span class="comment">// 读取一个程序段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read 1st page off disk</span></span><br><span class="line">    readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);   <span class="comment">//将主引导扇区加载至0x10000内存处，这个扇区是ELF格式，能够对后续的内核进行加载</span></span><br><span class="line">    <span class="comment">//这个函数调用过程如下：</span></span><br><span class="line">    <span class="comment">// push $0x0</span></span><br><span class="line">    <span class="comment">// push $0x1000</span></span><br><span class="line">    <span class="comment">// push $0x10000 分别压入三个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a valid ELF?</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">    <span class="comment">// 找到第一个程序头表项的起始地址和结束地址</span></span><br><span class="line">    ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum; </span><br><span class="line">    <span class="comment">// 读取内核，内核的大小就是从ph到eph</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">        <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">        <span class="comment">// as the physical address)</span></span><br><span class="line">        readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the entry point from the ELF header 执行内核</span></span><br><span class="line">    <span class="comment">// note: does not return!</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();  <span class="comment">//call   *0x10018  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 故障！</span></span><br><span class="line">bad:   <span class="comment">//7d77 &lt;bootmain+0x5e&gt;</span></span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span></span><br><span class="line"><span class="comment">// Might copy more than asked</span></span><br><span class="line"><span class="comment">// 从offset 读取count字节到pa</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> end_pa;</span><br><span class="line"></span><br><span class="line">    end_pa = pa + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></span><br><span class="line">    offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line">        <span class="comment">// Since we haven't enabled paging yet and we're using</span></span><br><span class="line">        <span class="comment">// an identity segment mapping (see boot.S), we can</span></span><br><span class="line">        <span class="comment">// use physical addresses directly.  This won't be the</span></span><br><span class="line">        <span class="comment">// case once JOS enables the MMU.</span></span><br><span class="line">        readsect((<span class="keyword">uint8_t</span>*) pa, offset);</span><br><span class="line">        pa += SECTSIZE;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是readsect 的具体实现，可以先不看</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">waitdisk(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// wait for disk reaady</span></span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);		<span class="comment">// count = 1</span></span><br><span class="line">    </span><br><span class="line">    outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    </span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);	<span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="练习：使用gdb从boot-loader开始调试"><a href="#练习：使用gdb从boot-loader开始调试" class="headerlink" title="练习：使用gdb从boot loader开始调试"></a>练习：使用gdb从boot loader开始调试</h4><h5 id="跳转至boot-loader开始位置"><a href="#跳转至boot-loader开始位置" class="headerlink" title="跳转至boot loader开始位置"></a>跳转至boot loader开始位置</h5><p>在0x7c00处设置断点，然后执行，停止在0x7c00处</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) br *0x7c00</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[   0:7c00] =&gt; 0x7c00:	cli    </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br></pre></td></tr></table></figure>
<p>停留的位置即为<code>boot.S</code>开始处，使用x/N addr进行反汇编，查看此处的代码，反汇编结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/10 0x7c00</span><br><span class="line">=&gt; 0x7c00:	cli    </span><br><span class="line">   0x7c01:	cld    </span><br><span class="line">   0x7c02:	xor    %ax,%ax</span><br><span class="line">   0x7c04:	mov    %ax,%ds</span><br><span class="line">   0x7c06:	mov    %ax,%es</span><br><span class="line">   0x7c08:	mov    %ax,%ss</span><br><span class="line">   0x7c0a:	in     $0x64,%al</span><br><span class="line">   0x7c0c:	test   $0x2,%al</span><br><span class="line">   0x7c0e:	jne    0x7c0a</span><br><span class="line">   0x7c10:	mov    $0xd1,%al</span><br></pre></td></tr></table></figure>
<p>可以看到确实是在boot.S开始位置。</p>
<h5 id="研究readsect，弄清楚每一句语句的作用"><a href="#研究readsect，弄清楚每一句语句的作用" class="headerlink" title="研究readsect，弄清楚每一句语句的作用"></a>研究readsect，弄清楚每一句语句的作用</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是readsect 的具体实现，可以先不看</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">waitdisk(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// wait for disk reaady 11000000 01000000</span></span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)  <span class="comment">//读0x1F7，这个端口可以表示硬盘状态，判断最高位是否为1，是1硬盘未就绪</span></span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> offset) <span class="comment">//从第offset个扇区开始读取</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x1F2-0x1F7 The primary ATA harddisk controller.</span></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);		<span class="comment">// count = 1  设置读取扇区的数目为1</span></span><br><span class="line">    </span><br><span class="line">    outb(<span class="number">0x1F3</span>, offset);                 </span><br><span class="line">    outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);            </span><br><span class="line">    outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);           </span><br><span class="line">    outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);  <span class="comment">// 1110 0000</span></span><br><span class="line">    <span class="comment">// 上面四条指令联合制定了扇区号</span></span><br><span class="line">    <span class="comment">// 在这4个字节线联合构成的32位参数中</span></span><br><span class="line">    <span class="comment">// 29-31位强制设为1</span></span><br><span class="line">    <span class="comment">// 28位(=0)表示访问"Disk 0"</span></span><br><span class="line">    <span class="comment">// 0-27位是28位的偏移量</span></span><br><span class="line">    <span class="comment">// 所以上面的语句是找到Disk 0，偏移量位28位的</span></span><br><span class="line">    </span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);	<span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>); <span class="comment">// 从0x1F0读取SECTSIZE字节数到dst的位置,每次读四个Byte，读取 SECTSIZE/ 4次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用断点调试进入bootmain"><a href="#使用断点调试进入bootmain" class="headerlink" title="使用断点调试进入bootmain"></a>使用断点调试进入bootmain</h5><p>单步调试执行到<code>call bootmain</code>后，gdb显示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7c45:  call 0x7d19</span><br></pre></td></tr></table></figure>
<p>说明bootmain的起始地址是0x7d19，继续执行，后续的几行代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=&gt; 0x7d19:	push   %ebp          # 保存堆栈基址，ESP自动减小，栈向下生长</span><br><span class="line">   0x7d1a:	mov    %esp,%ebp     # 生成栈，此时栈顶栈底相同，栈为空</span><br><span class="line">   0x7d1c:	push   %esi</span><br><span class="line">   0x7d1d:	push   %ebx</span><br><span class="line">   0x7d1e:	push   %edx</span><br><span class="line">   0x7d1f:	push   $0x0</span><br><span class="line">   0x7d21:	push   $0x1000       # 临时变量</span><br><span class="line">   0x7d26:	push   $0x10000</span><br><span class="line">   0x7d2b:	call   0x7cda        # 执行readsect</span><br><span class="line">   0x7d30:	add    $0x10,%esp</span><br><span class="line">   0x7d33:	cmpl   $0x464c457f,0x10000</span><br></pre></td></tr></table></figure>
<h5 id="在boot-main中，会循环读取内核，当内核读完后，程序会去哪里？"><a href="#在boot-main中，会循环读取内核，当内核读完后，程序会去哪里？" class="headerlink" title="在boot main中，会循环读取内核，当内核读完后，程序会去哪里？"></a>在boot main中，会循环读取内核，当内核读完后，程序会去哪里？</h5><p>对boot main进行反编译，得到如下结果：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐boot/boot</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00007d19 &lt;bootmain&gt;:</span><br><span class="line">    7d19:	55                   	push   %ebp</span><br><span class="line">    7d1a:	89 e5                	mov    %esp,%ebp</span><br><span class="line">    7d1c:	56                   	push   %esi</span><br><span class="line">    7d1d:	53                   	push   %ebx</span><br><span class="line">    7d1e:	52                   	push   %edx</span><br><span class="line">    7d1f:	6a 00                	push   $0x0</span><br><span class="line">    7d21:	68 00 10 00 00       	push   $0x1000</span><br><span class="line">    7d26:	68 00 00 01 00       	push   $0x10000</span><br><span class="line">    7d2b:	e8 aa ff ff ff       	call   7cda &lt;readseg&gt;</span><br><span class="line">    7d30:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">    7d33:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000</span><br><span class="line">    7d3a:	45 4c 46 </span><br><span class="line">    7d3d:	75 38                	jne    7d77 &lt;bootmain+0x5e&gt;</span><br><span class="line">    7d3f:	a1 1c 00 01 00       	mov    0x1001c,%eax</span><br><span class="line">    7d44:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi</span><br><span class="line">    7d4b:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx</span><br><span class="line">    7d51:	c1 e6 05             	shl    $0x5,%esi</span><br><span class="line">    7d54:	01 de                	add    %ebx,%esi</span><br><span class="line">    7d56:	39 f3                	cmp    %esi,%ebx</span><br><span class="line">    7d58:	73 17                	jae    7d71 &lt;bootmain+0x58&gt;</span><br><span class="line">    7d5a:	50                   	push   %eax</span><br><span class="line">    7d5b:	83 c3 20             	add    $0x20,%ebx</span><br><span class="line">    7d5e:	ff 73 e4             	pushl  -0x1c(%ebx)</span><br><span class="line">    7d61:	ff 73 f4             	pushl  -0xc(%ebx)</span><br><span class="line">    7d64:	ff 73 ec             	pushl  -0x14(%ebx)</span><br><span class="line">    7d67:	e8 6e ff ff ff       	call   7cda &lt;readseg&gt;</span><br><span class="line">    7d6c:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">    7d6f:	eb e5                	jmp    7d56 &lt;bootmain+0x3d&gt;</span><br><span class="line">    </span><br><span class="line">    ### 下面这句就是循环执行完后的跳转</span><br><span class="line">    7d71:	ff 15 18 00 01 00    	call   *0x10018  # *0x10018 = 0x10000c</span><br><span class="line">    </span><br><span class="line">    7d77:	ba 00 8a 00 00       	mov    $0x8a00,%edx</span><br><span class="line">    7d7c:	b8 00 8a ff ff       	mov    $0xffff8a00,%eax</span><br><span class="line">    7d81:	66 ef                	out    %ax,(%dx)</span><br><span class="line">    7d83:	b8 00 8e ff ff       	mov    $0xffff8e00,%eax</span><br><span class="line">    7d88:	66 ef                	out    %ax,(%dx)</span><br><span class="line">    7d8a:	eb fe                	jmp    7d8a &lt;bootmain+0x71&gt;</span><br></pre></td></tr></table></figure>

</div></div>
<p>从上面的代码中我们能看出，当读取完成后，bootmain会执行<code>(ELFHDR-&gt;e_entry))();</code>在汇编中这句话是调用0x10018这个内存位置上保存的函数，最后执行后代码会转到10000c上。</p>
<blockquote>
<p>问题：这里我在调试过程中遇到一个问题，就是没有调试信息，使用GDB打印10000处内存提示没有”Elf”符号，说明符号表没有加载。</p>
</blockquote>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><blockquote>
<p>处理器是何时开始执行32位代码的，是什么使得处理器完成了从16位到32位代码的切换？</p>
</blockquote>
<p>从下面这句代码开始执行32位代码，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<p>下面这段代码完成了从16位到32位的切换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<blockquote>
<p>boot loader 最后一句执行的语句是什么？</p>
</blockquote>
<p>是<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code>，对应的汇编代码为：<code>7d63: ff 15 18 00 01 00     call   *0x10018</code></p>
<blockquote>
<p>加载内核后的第一句命令是什么？</p>
</blockquote>
<p>是<code>f010000c: 66 c7 05 72 04 00 00  movw   $0x1234,0x472</code>，对应的代码在<code>entry.S</code>中</p>
<blockquote>
<p>内核的第一句指令在内存什么位置？</p>
</blockquote>
<p>在<code>0x0010000c</code></p>
<blockquote>
<p>boot loader如何决定从硬盘中读取多少个sector来获得整个内核？他是从哪里得到这个信息的？</p>
</blockquote>
<p>boot loader通过ELF头读取相关信息并加载所有的程序头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>
<h3 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h3><h4 id="ELF-format"><a href="#ELF-format" class="headerlink" title="ELF format"></a>ELF format</h4><p>在了解内核工作原理前，我们先要明白ELF格式，ELF全称为”Executable and Linkable Format”即可执行与可链接文件格式，关于这个格式的详细描述请参考<a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf">ELF定义</a>或下面的阅读材料，其中很大一部分工作是支持动态链接库。一个ELF文件的结构如下所示：</p>
<p><img src="https://github.com/sqduan/hexoimg/blob/master/390px-Elf-layout--en.png?raw=true" width = "280" alt="图片名称" align=center /></p>
<p>对于本课程，我们可以简单地将ELF理解为一个包含了一些载入信息的数据头和一些程序片段所组成的文件，每一个程序片段包含将要被载入到指定内存的数据和代码，Boot loader只是载入这些片段，并不对其进行任何修改。现在我们对产生的ELF格式的kernel进行分析，执行下列语句<code>objdump -h obj/kern/kernel</code>，得到结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -h kernel </span></span><br><span class="line"></span><br><span class="line">kernel：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001a1d  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000006bc  f0101a20  00101a20  00002a20  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         0000375d  f01020dc  001020dc  000030dc  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00001529  f0105839  00105839  00006839  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         00009300  f0107000  00107000  00008000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          00000008  f0110300  00110300  00011300  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f0110308  00110308  00011308  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 00001000  f0111000  00111000  00012000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 00000044  f0112000  00112000  00013000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000661  f0112060  00112060  00013060  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      00000012  00000000  00000000  000136c1  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<p>可以看到不止6个段，有一些是和debug相关的，不必理会。我们这里重点关注一下.text段的VMA(link address)和LMA(load address)。load address就是某个片段实际被加载到内存当中的地址。而link address是指某个片段将要被执行时所在内存中的位置，可以简单地理解为：</p>
<ul>
<li>LMA：程序加载位置</li>
<li>VMA：程序执行位置</li>
</ul>
<p>一般来说，程序在哪里加载，就在哪里执行，所以一般情况下VMA=LMA，例如，对于我们的boot loader</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -h boot.out </span><br><span class="line"></span><br><span class="line">boot.out：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0000018c  00007c00  00007c00  00000074  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, CODE</span><br></pre></td></tr></table></figure>
<p>可以看到VMA = LMA。使用objdump显示kernel文件的程序头，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -x kernel</span></span><br><span class="line">kernel：     文件格式 elf32-i386</span><br><span class="line">kernel</span><br><span class="line">体系结构：i386，标志 0x00000112：</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">起始地址 0x0010000c</span><br><span class="line"></span><br><span class="line">程序头：</span><br><span class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</span><br><span class="line">         filesz 0x00006d62 memsz 0x00006d62 flags r-x</span><br><span class="line">    LOAD off    0x00008000 vaddr 0xf0107000 paddr 0x00107000 align 2**12</span><br><span class="line">         filesz 0x0000b6c1 memsz 0x0000b6c1 flags rw-</span><br><span class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</span><br><span class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</span><br></pre></td></tr></table></figure>
<p>LOAD就是要被加载到内存中的信息，其他信息还包括虚拟地址(“vaddr”)，物理地址(“paddr”)，加载空间的大小(“filesz”和”memsz”)。回到我们上面的<code>boot/main.c</code>，<code>ph-&gt;p_pa</code>域包含了每个段的目标物理地址。BIOS将boot的片段加载到0x7c00所在的内存位置，并从这个位置开始执行。我们可以在<code>boot/Makefrag</code>文件下修改链接的地址，打开Makefrag文件，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">$(OBJDIR)/boot/boot: $(BOOT_OBJS)                                               </span><br><span class="line">@echo + ld boot/boot                                                        </span><br><span class="line">$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o $@.out $^                 </span><br><span class="line">$(V)$(OBJDUMP) -S $@.out &gt;$@.asm                                            </span><br><span class="line">$(V)$(OBJCOPY) -S -O binary -j .text $@.out $@                              </span><br><span class="line">$(V)perl boot/sign.pl $(OBJDIR)/boot/boot   </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们可以看到，链接地址为-Ttext 0x7c00，这个地址是BIOS指定的，我们可以修改这个地址，从而跳过一些特定的指令，来观察boot loader 的表现。</p>
<h4 id="练习：调整boot-loader-link-address的位置，观察现象"><a href="#练习：调整boot-loader-link-address的位置，观察现象" class="headerlink" title="练习：调整boot loader link address的位置，观察现象"></a>练习：调整boot loader link address的位置，观察现象</h4><p>通过修改<code>boot/Makefrag</code>下链接地址，我们可以修改boot loader加载与运行地址，我们将地址前移，观察跳过一些语句后boot loader 会发生什么。将<code>-Ttext 0x7C00</code>改为<code>-Ttext 0x7BFC</code>，重新make，没有问题，<code>objdump -h boot.out</code>，发现该程序的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0000018c  00007bfc  00007bfc  00000074  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, CODE</span><br></pre></td></tr></table></figure>
<p>可以看到VMA和LMA此时都变成了00007bfc。</p>
<h5 id="直观表现"><a href="#直观表现" class="headerlink" title="直观表现"></a>直观表现</h5><p>我总结了一下修改link address后boot loader的直观表现，其中有一些比较奇怪，这里总结一下：</p>
<ul>
<li>对于反汇编后得到的文件<code>/obj/boot/boot.asm</code>，起始地址确实是变了，变为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00007bfc &lt;start&gt;:                                                               </span><br><span class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag                   </span><br><span class="line">                                                                                 </span><br><span class="line">.globl start                                                                    </span><br><span class="line">start:                                                                          </span><br><span class="line">.code16                          # Assemble for 16-bit mode                        </span><br><span class="line">cli                              # Disable interrupts                              </span><br><span class="line">7bfc:   fa                      cli     </span><br><span class="line">7bfd:   fc                      cld</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">7c00:   8e d8                   mov    %eax,%ds</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这一点是符合预期的。</p>
<ul>
<li>进行gdb调试，设置断点位置为0x7c00，原本以为0x7c00所在位置的语句会从原先的<code>cli</code>变为<code>mov</code>，但是奇怪的是并没有，<code>x/10</code>得到的结果如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) x/10 0x7c00</span><br><span class="line">=&gt; 0x7c00:	cli    </span><br><span class="line">   0x7c01:	cld    </span><br><span class="line">   0x7c02:	xor    %ax,%ax</span><br><span class="line">   0x7c04:	mov    %ax,%ds</span><br><span class="line">   0x7c06:	mov    %ax,%es</span><br><span class="line">   0x7c08:	mov    %ax,%ss</span><br><span class="line">   0x7c0a:	in     $0x64,%al</span><br><span class="line">   0x7c0c:	test   $0x2,%al</span><br><span class="line">   0x7c0e:	jne    0x7c0a</span><br><span class="line">   0x7c10:	mov    $0xd1,%al</span><br></pre></td></tr></table></figure>
<p>可以看到，0x7c00依然是cli，这一点令我非常疑惑。目前还没有比较好的答案（先跳过不管了），经过我实验，将地址前移或者后移后，均无法正确加载bootloader程序。每次都会在<code>ljmp   $0x8,$0x7c32</code>这条语句处发生跳转，重新回到BIOS第一条语句。</p>
<p>在ELF头中，除了section的信息，还有一个比较重要的是e_entry信息，表示程序的入口地址，我们可以使用<code>objdump -f</code>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -f obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel：     文件格式 elf32-i386</span><br><span class="line">体系结构：i386，标志 0x00000112：</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">起始地址 0x0010000c</span><br></pre></td></tr></table></figure>
<p>所以我们现在基本摸清了ELF loader的套路，将kernel中的每个section导入内存中，然后跳转至程序入口。</p>
<h4 id="练习6：观察0x00100000内存"><a href="#练习6：观察0x00100000内存" class="headerlink" title="练习6：观察0x00100000内存"></a>练习6：观察0x00100000内存</h4><blockquote>
<p>分别在BIOS进入boot loader和boot loader进入kernel的位置设置断点，然后运行至断点处，此时使用x/8x打印0x00100000开始的8个word的内存并观察，说明两者有何不同</p>
</blockquote>
<p>在BIOS进入boot loader处，0x00100000内存中内容为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[   0:7c01] =&gt; 0x7c01:	cld    </span><br><span class="line">0x00007c01 in ?? ()</span><br><span class="line"></span><br><span class="line">(gdb) x/8 0x00100000</span><br><span class="line">0x100000:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x100010:	0x00000000	0x00000000	0x00000000	0x00000000</span><br></pre></td></tr></table></figure>
<p>空的，然后在boot loader进入kernel的位置（0x0010000c）设置断点，再次访问0x00100000，其中的内容变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766</span><br><span class="line">0x100010:	0x34000004	0x1000b812	0x220f0011	0xc0200fd8</span><br></pre></td></tr></table></figure>
<p>说明内核被加载到了0x00100000这个位置，或者说有一部分在这个位置。实际上这里存储了内核的代码。</p>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><h4 id="虚拟内存初步建立"><a href="#虚拟内存初步建立" class="headerlink" title="虚拟内存初步建立"></a>虚拟内存初步建立</h4><p>了解了内核引导程序的原理，现在我们正式开始接触内核。在boot loader中，link address和load address是一致的，但是在内核程序中则不是这样，关于内核的链接地址详见/kern/kernel.ld</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SECTIONS                                                                        </span><br><span class="line">&#123;                                                                               </span><br><span class="line">    /* Link the kernel at this address: "." means the current address */        </span><br><span class="line">    . = 0xF0100000;                                                             </span><br><span class="line">                                                                                </span><br><span class="line">    /* AT(...) gives the load address of this section, which tells              </span><br><span class="line">       the boot loader where to load the kernel in physical memory */           </span><br><span class="line">    .text : AT(0x100000) &#123;                                                      </span><br><span class="line">        *(.text .stub .text.* .gnu.linkonce.t.*)                                </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在这个链接文件中，一开头就明确指出，LMA为0x100000，而VMA即链接地址为0xF0100000。说明内核在0x100000处加载，在0xF0100000处执行。但一些计算机可能根本没有0xF0100000这么大位置的内存，所以这里引入了虚拟内存的概念。将虚拟内存0xf0100000映射至0x00100000，所以内核存储在0x00100000的物理地址，然后在0xf0100000的虚拟地址处执行。低位的虚拟内存就留给用户使用。内存映射表详见<code>kern/entrypgdir.c</code>，这里只映射了4MB的地址。注意，这里实际就是将内核的一部分进行了虚拟化，建立了虚拟地址到物理地址的映射。当完成实验2和实验3后，再回顾这里会有更深的体会。</p>
<p>我们现在看一下<code>entrypgdir.c</code>中的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pte_t</span> entry_pgtable[NPTENTRIES];</span><br><span class="line"></span><br><span class="line"><span class="comment">// The entry.S page directory maps the first 4MB of physical memory</span></span><br><span class="line"><span class="comment">// starting at virtual address KERNBASE (that is, it maps virtual</span></span><br><span class="line"><span class="comment">// addresses [KERNBASE, KERNBASE+4MB) to physical addresses [0, 4MB)).</span></span><br><span class="line"><span class="comment">// We choose 4MB because that's how much we can map with one page</span></span><br><span class="line"><span class="comment">// table and it's enough to get us through early boot.  We also map</span></span><br><span class="line"><span class="comment">// virtual addresses [0, 4MB) to physical addresses [0, 4MB); this</span></span><br><span class="line"><span class="comment">// region is critical for a few instructions in entry.S and then we</span></span><br><span class="line"><span class="comment">// never use it again.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Page directories (and page tables), must start on a page boundary,</span></span><br><span class="line"><span class="comment">// hence the "__aligned__" attribute.  Also, because of restrictions</span></span><br><span class="line"><span class="comment">// related to linking and static initializers, we use "x + PTE_P"</span></span><br><span class="line"><span class="comment">// here, rather than the more standard "x | PTE_P".  Everywhere else</span></span><br><span class="line"><span class="comment">// you should use "|" to combine flags.</span></span><br><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="keyword">pde_t</span> entry_pgdir[NPDENTRIES] = &#123;</span><br><span class="line">    <span class="comment">// Map VA's [0, 4MB) to PA's [0, 4MB)</span></span><br><span class="line">    [<span class="number">0</span>]</span><br><span class="line">        = ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line">    <span class="comment">// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)</span></span><br><span class="line">    [KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">        = ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry 0 of the page table maps to physical page 0, entry 1 to</span></span><br><span class="line"><span class="comment">// physical page 1, etc.</span></span><br><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="keyword">pte_t</span> entry_pgtable[NPTENTRIES] = &#123;</span><br><span class="line">    <span class="number">0x000000</span> | PTE_P | PTE_W,</span><br><span class="line">    <span class="number">0x001000</span> | PTE_P | PTE_W,</span><br><span class="line">    <span class="number">0x002000</span> | PTE_P | PTE_W,</span><br><span class="line">    <span class="number">0x003000</span> | PTE_P | PTE_W,</span><br><span class="line">    <span class="number">0x004000</span> | PTE_P | PTE_W,</span><br><span class="line">    <span class="number">0x005000</span> | PTE_P | PTE_W,</span><br></pre></td></tr></table></figure>
<p>这个文件将<code>4MB</code>大小的物理空间<code>[0,4MB]</code>映射至<code>[KERNBASE, KERNBASE+4MB]</code>，启动阶段完全够用了，4MB就是一个页表能容纳的容量。后续的虚拟空间到物理空间的映射我们会在内核代码中完成。这部分内存是内核可写的。映射完成后，页目录的第0项与第<code>KERNBASE &gt;&gt; PDXSHIFT</code>项均指向页表<code>entry_pgtable</code>。从这里我们可以看到，页目录每一项指向的页表为4MB，而页目录共1024项，总可映射内存为4GB</p>
<h4 id="练习7：实模式和保护模式下的内存"><a href="#练习7：实模式和保护模式下的内存" class="headerlink" title="练习7：实模式和保护模式下的内存"></a>练习7：实模式和保护模式下的内存</h4><p>进入内核然后停留在<code>mov %eax, %cr0</code>这条语句处，验证此时<code>0x00100000</code>和<code>0xf0100000</code>两个内存位置处的内存，然后<code>si</code>执行<code>mov %eax, %cr0</code>，再次验证这两个位置的内存，有什么现象？</p>
<p><code>mov %eax, %cr0</code>的作用是开启地址的映射，将高位地址映射至低位地址上，所以没有执行这句语句前，<code>0xf0100000</code>处的内存是不存在的，故显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xf0100000 &lt;_start-268435468&gt;:	Cannot access memory at address 0xf0100000</span><br></pre></td></tr></table></figure>
<p>而<code>0x00100000</code>处则存储了内核的代码。当执行<code>mov %eax, %cr0</code>后，开启了地址映射，会发现<code>0xf0100000</code>被映射至了<code>0x00100000</code>处，两者存放的内容相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/10 0xf0100000</span><br><span class="line">   0xf0100000 &lt;_start-268435468&gt;:	add    0x1bad(%eax),%dh</span><br><span class="line">   0xf0100006 &lt;_start-268435462&gt;:	add    %al,(%eax)</span><br><span class="line">   0xf0100008 &lt;_start-268435460&gt;:	decb   0x52(%edi)</span><br><span class="line">   0xf010000b &lt;_start-268435457&gt;:	in     $0x66,%al</span><br><span class="line"></span><br><span class="line">gdb) x/10 0x00100000</span><br><span class="line">   0x100000:	add    0x1bad(%eax),%dh</span><br><span class="line">   0x100006:	add    %al,(%eax)</span><br><span class="line">   0x100008:	decb   0x52(%edi)</span><br><span class="line">   0x10000b:	in     $0x66,%al</span><br></pre></td></tr></table></figure>
<h4 id="控制台格式化输出"><a href="#控制台格式化输出" class="headerlink" title="控制台格式化输出"></a>控制台格式化输出</h4><p>阅读<a href="/downloads/printf.c">kern/printf.c</a>、<a href="/downloads/printfmt.c">lib/printfmt.c</a>以及<a href="/downloads/console.c">kern/console.c</a>三个文件，弄清三者之间的关系。我们先针对控制台程序进行整理，对代码的详细分析参考下面的链接</p>
<ul>
<li><a href="/2024/10/13/计算机/操作系统/控制台/" title="xv6控制台程序详解">xv6控制台程序详解</a>
</li>
</ul>
<p>而printfmt是带有格式的输出，printf是printfmt的封装，底层调用的是console中的cputchar，最后留给上层的系统调用为cprintf，所以三个文件的关系如下：</p>
<pre class="mermaid">graph BT
    node1["console"]
    node2["printfmt"]
    node3["printf"]

    node1-->node2
    node2-->node3</pre>

<p>这也解释了为何printfmt被放在了lib中，因为它是作为库被调用的，而不是直接给用户的系统调用。其中输出八进制的代码被省略了，补充完成后如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">    num = getuint(&amp;ap, lflag);</span><br><span class="line">    base = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure>
<p>然后在monitor.c里加一句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cprintf(&quot;%u decimal is %o octal!\n&quot;, num,num);       // num is 6828</span><br></pre></td></tr></table></figure>
<p>然后执行make grade即可，显示printf: OK，说明代码没有问题。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">running JOS: (<span class="number">0.7</span>s) </span><br><span class="line">  printf: OK</span><br></pre></td></tr></table></figure>
<p>回答下面的问题：</p>
<blockquote>
<p> 解释printf.c和console.c之间的关系，console.c开放了哪些函数，这些函数是如何被printf.c使用的？</p>
</blockquote>
<p>观察console.c，可以看到下列函数之前没有加static，即为开放函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void  serial_intr(void)  // 串口中断</span><br><span class="line">void  kbd_intr(void)     // 键盘中断</span><br><span class="line">int   cons_getc(void)    // 控制台读取字符</span><br><span class="line">void  cons_init(void)    // 控制台初始化</span><br><span class="line">void  cputchar(int c)    // 写入字符</span><br><span class="line">int   getchar(void)      // 获取一个字节</span><br><span class="line">int   iscons(int fdnum)  //</span><br></pre></td></tr></table></figure>
<p>而在pringf中，使用到的函数为<code>cputchar</code>，其函数及内部调用的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">cputchar(int c)</span><br><span class="line">&#123;</span><br><span class="line">    cons_putc(c);            // 说明外部文件可以通过调用全局函数，而全局函数再调用局部函数的方式调用局部函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output a character to the console</span><br><span class="line">static void</span><br><span class="line">cons_putc(int c)</span><br><span class="line">&#123;</span><br><span class="line">    serial_putc(c);</span><br><span class="line">    lpt_putc(c);</span><br><span class="line">    cga_putc(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">serial_putc(int c)          // 从串口输出</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i = 0;</span><br><span class="line">         !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; 12800;</span><br><span class="line">         i++)</span><br><span class="line">        delay();</span><br><span class="line"></span><br><span class="line">    outb(COM1 + COM_TX, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释下面的console.c中的代码片段</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// crt_pos uint16_t 光标位置</span></span><br><span class="line"><span class="comment">// #define CRT_ROWS    25                                                          </span></span><br><span class="line"><span class="comment">// #define CRT_COLS    80    </span></span><br><span class="line"><span class="comment">// #define CRT_SIZE    (CRT_ROWS * CRT_COLS)  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;  <span class="comment">//超出屏幕范围</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));  <span class="comment">// 将buf中的内容进行移动，从而产生滚动屏幕的效果</span></span><br><span class="line">    <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)   <span class="comment">//将最后一行用空格进行填充</span></span><br><span class="line">        crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">    crt_pos -= CRT_COLS;      <span class="comment">// 将光标退回至行首</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码出现在<code>cga_putc</code>中，我们先要明确其中变量、宏定义以及魔数的作用。详细注释见上方代码，总之其功能就是在CGA设备写满了内容后，将内容上滚，并产生新行，在qemu仿真中，终端的窗口大小就是25*80。</p>
<blockquote>
<p>单步调试下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">&gt; cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>在调用cprintf()的过程中，fmt指向哪里？ap指向哪里？</p>
</li>
<li><p>列出每一次对<code>cons_putc</code>,<code>va_arg</code>以及<code>vcprintf</code>的调用，对于<code>cons_putc</code>，列出所有的参数；对于<code>va_arg</code>，列出调用前后ap指针指向的内容，对于<code>vcprintf</code>，列出两个参数的值。</p>
</li>
</ul>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="练习8：栈初始化"><a href="#练习8：栈初始化" class="headerlink" title="练习8：栈初始化"></a>练习8：栈初始化</h4><blockquote>
<p>阅读内核代码，指出栈是在哪里初始化的？位于哪个内存？如何预留栈空间？栈指针指向哪里？</p>
</blockquote>
<p>在<code>entry.S</code>中，栈初始化语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl $(stack + KSTACKSIZE), %esp</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.comm stack, KSTACKSIZE     # 4096</span><br></pre></td></tr></table></figure>
<p>栈大小为KSTACKSIZE，位于data段中，预留的方式是通过<code>.comm</code>命令对栈空间进行分配，esp指针指向 stack + KSTACKSIZE处。</p>
<h4 id="练习9：test-backtrace函数"><a href="#练习9：test-backtrace函数" class="headerlink" title="练习9：test_backtrace函数"></a>练习9：test_backtrace函数</h4><blockquote>
<p>找到test_backtrace函数，然后设置断点，观察每次调用这个函数时会发生什么</p>
</blockquote>
<p>使用nm命令在kernel中找到test_backtrace，其位置为0xf0100040，在此处设置一个断点，然后执行至此处，可以发现这个函数是一个递归函数，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">test_backtrace(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    cprintf(<span class="string">"entering test_backtrace %d\n"</span>, x);</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span>) </span><br><span class="line">        test_backtrace(x<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mon_backtrace(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"leaving test_backtrace %d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次递归调用，在函数栈上增加一层，例如调用test_backtrace(5)并使用gdb调试得到结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  test_backtrace (x=4) at kern/init.c:13</span><br><span class="line">#1  0xf0100076 in test_backtrace (x=5) at kern/init.c:16</span><br><span class="line">#2  0xf01000f4 in i386_init () at kern/init.c:39</span><br><span class="line">#3  0xf010003e in relocated () at kern/entry.S:80</span><br></pre></td></tr></table></figure>
<p>每次调用后会有以下几个push语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push %ebp  # 保存栈底</span><br><span class="line">push %esi  # 源操作数偏移量（是printf中内容的偏移量吗）</span><br><span class="line">push %ebx  # 保存ebx寄存器，eax、ecx和edx由硬件进行保存</span><br><span class="line">push %eip  # 保存返回指令</span><br></pre></td></tr></table></figure>
<p>为了更细致地分析函数调用栈的行为，我们进一步使用gdb进行分析，首先我们分析栈指针%ebp的情况：</p>
<h5 id="栈指针-ebp的情况"><a href="#栈指针-ebp的情况" class="headerlink" title="栈指针%ebp的情况"></a>栈指针%ebp的情况</h5><p>在我们进入到test_backtrace函数前，即在<code>enter.S</code>中，我们能够看到这样一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Clear the frame pointer register (EBP)                                                                     # so that once we get into debugging C code,                                                                 # stack backtraces will be terminated properly.                                                             </span><br><span class="line">movl    $0x0,%ebp                       # nuke frame pointer  </span><br><span class="line"></span><br><span class="line"># Set the stack pointer</span><br><span class="line">movl    $(bootstacktop), %esp           # bootstacktop为f0100000</span><br><span class="line"></span><br><span class="line">call    i386_init</span><br></pre></td></tr></table></figure>
<p>将栈基底设置为0x0，然后将栈顶指针设置为bootstacktop，然后下面一句开始调用i386_init函数，将eip压栈，则f010effc保存着返回地址eip的值，为<code>0xf010003e</code>，进入函数后，首先要进行栈分配，保存前一栈帧的栈底，即<code>push %ebp</code>，故<code>0xf010eff8</code>保存的内容为<code>0x00000000</code>，即最开始栈的栈底，然后执行<code>mov %esp, %ebp</code>，所以从这里我们得到一个关键信息：<strong>ebp保存着前一个调用栈的栈底ebp’</strong>，用数学语言描述如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\textrm{ebp}_n&=\&\textrm{(ebp)}_{n-1}\\
\textrm{ebp}_0&=v_0
\end{aligned}</script><p>即第$n$个ebp的值为第$n-1$个栈的基地址，而初始的$\%ebp_0$即为第一个站的栈底。所以我们的backtrace结束条件可以写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(get_ebp() == 0x0)</span><br></pre></td></tr></table></figure>
<h5 id="eip的情况"><a href="#eip的情况" class="headerlink" title="%eip的情况"></a>%eip的情况</h5><p>现在我们来分析另一个重要的寄存器eip的情况，因为函数返回后要返回到恰当的位置继续执行，所以eip的值也要被妥善保存。由于我们在使用<code>call</code>命令时先将eip进行了push，所以实际上eip先于ebp被保存，在栈中的保存位置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xf010effc:  0xf010003e (value of ret eip)    //栈是向下增长的</span><br><span class="line">0xf010eff8:  0x00000000 (value of ret ebp)</span><br></pre></td></tr></table></figure>
<h5 id="输入参数的情况"><a href="#输入参数的情况" class="headerlink" title="输入参数的情况"></a>输入参数的情况</h5><p>在调用函数之前，还有一个非常关键的步骤就是给函数提供输入参数，而在实际调试过程中，我们可以发现函数调用时顺序如下：</p>
<ol>
<li><p>先<code>push</code>参数，从后往前（如果只有一个参数，也可能直接<code>mov $value, %esp</code>，这个看具体的实现过程）</p>
</li>
<li><p>再调用<code>call</code>，将返回位置所在的<code>eip</code>压栈</p>
</li>
<li>调用<code>call</code>后，第一条语句就是<code>push %ebp</code>，将前一个函数的栈底进行保存</li>
</ol>
<p>至此，我们可以画出一个函数<code>void func(arg1, arg2, ... , argn)</code>调用过程的栈模型如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/20201231600.svg" width = "250" alt="图片名称" align=center /></p>
<p>在实际调试过程中，backtrace的模型确实如此。</p>
<h4 id="练习10：实施一个mon-backtrace函数"><a href="#练习10：实施一个mon-backtrace函数" class="headerlink" title="练习10：实施一个mon_backtrace函数"></a>练习10：实施一个mon_backtrace函数</h4><p>在了解了上面的函数调用过程后，我们来实施一个backtrace函数，这个函数能够根据函数的调用深度，打印调用栈中的一些关键信息，包括：当前函数的栈底、当前函数的返回地址以及当前函数的参数，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>这个函数位于kern/monitor.c中，写完后记得将其和命令挂钩，这样用户就能通过这个命令查看函数调用栈的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __attribute__((optimize(<span class="string">"O0"</span>)))</span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)                      </span><br><span class="line">&#123;                                                                               </span><br><span class="line">    cprintf(<span class="string">"Stack backtrace:\n"</span>);                                              </span><br><span class="line">                                                                                 </span><br><span class="line">    <span class="comment">// Your code here.                                                          </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *ebp = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)read_ebp();   <span class="comment">//get the frame base of backtrace</span></span><br><span class="line">    <span class="keyword">while</span>(*ebp != <span class="number">0x0</span>)&#123;                                                         </span><br><span class="line">        cprintf(<span class="string">"ebp %x  eip %x  args %08x %08x %08x %08x %08x\n"</span>, *ebp, ebp[<span class="number">1</span>], ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line">        ebp =(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (*ebp);                                           </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数需要注意以下几点：</p>
<ul>
<li>因为保存的都是32位地址，所以我们采用了unsigned int*类型定义了一个ebp指针</li>
<li>read_ebp()得到的是ebp寄存器中的内容，即被调用函数的栈基址，我们需要对其进行解引用操作，*ebp为调用者的栈基址</li>
<li>使用ebp[1]表示*(ebp+1)，注意地址的加法和数的加法是不一样的</li>
<li>ebp[2]-ebp[6]分别表示五个变量</li>
<li>_<em>attribute_</em>((optimize(“O0”)))表示关闭优化，因为编译器是有可能先执行read_ebp()函数，再调用mon_backtrace，但是在我这里不可能，因为在read_ebp之前调用了cprintf，所以不会出错，当然保险起见还是加上禁止优化（虽然这么写可能不太规范，还是应该在函数一开始就定义变量）</li>
</ul>
<p>这个函数目前还是比较简陋的，它只能打印出内存中的内容，不能打印返回函数所在的文件、行数；同时打印的参数个数也是固定的，为5个，因此我们需要对其进行一些修改，使它能够打印更加丰富的信息。</p>
<h4 id="练习11：改进的mon-backtrace"><a href="#练习11：改进的mon-backtrace" class="headerlink" title="练习11：改进的mon_backtrace"></a>练习11：改进的mon_backtrace</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>我们现在要将mon_backtrace进行改进，使其可以输出更多的信息，包括函数所在文件、行数等。</p>
<h5 id="探究符号表及其载入"><a href="#探究符号表及其载入" class="headerlink" title="探究符号表及其载入"></a>探究符号表及其载入</h5><p>这里提供了一个<code>debuginfo_eip()</code>，可以根据<code>eip</code>找到对应的符号表，eip的debuginfo定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Debug information about a particular instruction pointer                     </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> &#123;</span>                                                                                                                                                                                            </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eip_file;       <span class="comment">// Source code filename for EIP                 </span></span><br><span class="line">    <span class="keyword">int</span> eip_line;           <span class="comment">// Source code linenumber for EIP                                               </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eip_fn_name;    <span class="comment">// Name of function containing EIP              </span></span><br><span class="line">                                <span class="comment">//  - Note: not null terminated!                            </span></span><br><span class="line">    <span class="keyword">int</span> eip_fn_namelen;     <span class="comment">// Length of function name                          </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> eip_fn_addr;      <span class="comment">// Address of start of function                 </span></span><br><span class="line">    <span class="keyword">int</span> eip_fn_narg;        <span class="comment">// Number of function arguments                     </span></span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>                                                                             </span><br><span class="line">debuginfo_eip(<span class="keyword">uintptr_t</span> addr, struct Eipdebuginfo *info)</span><br></pre></td></tr></table></figure>
<p><code>debuginfo_eip</code>比较长，总之就是把给定<code>addr</code>处的指令进行解析，然后填充到<code>info</code>，成功返回0，否则返回负数。阅读<code>debuginfo_eip</code>后，回答下面的问题：</p>
<blockquote>
<p>在debuginfo<em>eip函数中用到了\</em>_STAB__*（_<em>STAB_BEGIN\</em>_等，表示符号表保存的位置等信息），这个东西是哪里来的？</p>
</blockquote>
<p>为了解决这个问题，我们需要做如下几件事：</p>
<ul>
<li>阅读<code>kern/kernel.ld</code>，找到_STAB_*（说明符号表是在链接阶段产生的），这里需要对link script的基本写法有一些了解。</li>
</ul>
<p>在<code>kern/kernel.ld</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.stab : &#123;</span><br><span class="line">    PROVIDE(__STAB_BEGIN__=.)</span><br><span class="line">    *(.stab);</span><br><span class="line">    PROVIDE(__STAB_END__=.)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行<code>objdump -h obj/kern/kernel</code>，结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sections:</span><br><span class="line">...</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">2 .stab           00003f19  f010239c  0010239c  0000339c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从中可以看到<code>.stab</code>的分配情况。</p>
<ul>
<li>运行<code>objdump -G obj/kern/kernel</code>，结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of .stab section:</span><br><span class="line"></span><br><span class="line">Symnum n_type n_othr n_desc n_value  n_strx String</span><br><span class="line">...     # 以下为init.c中的符号表所在位置</span><br><span class="line">23     SO     0      2      f0100040 268    kern/init.c     # SO  为源文件</span><br><span class="line">24     OPT    0      0      00000000 49     gcc2_compiled.</span><br><span class="line">25     FUN    0      0      f0100040 280    i386_init:F(0,1)=(0,1)</span><br><span class="line">26     LSYM   0      0      00000000 303    void:t(0,1)</span><br><span class="line">27     SLINE  0      15     00000000 0      </span><br><span class="line">28     SLINE  0      21     00000012 0      </span><br><span class="line">29     SLINE  0      21     00000020 0      </span><br><span class="line">30     SLINE  0      25     00000029 0      </span><br><span class="line">31     SLINE  0      30     0000002e 0      </span><br><span class="line">32     SLINE  0      34     00000036 0      </span><br><span class="line">33     FUN    0      0      f0100085 315    _panic:F(0,1)</span><br><span class="line">34     PSYM   0      0      00000008 329    file:p(0,2)=*(0,3)=r(0,3);0;127;</span><br><span class="line">35     PSYM   0      0      0000000c 362    line:p(0,4)=r(0,4);-2147483648;2147483647;</span><br><span class="line">36     PSYM   0      0      00000010 405    fmt:p(0,2)</span><br><span class="line">37     LSYM   0      0      00000000 416    char:t(0,3)</span><br><span class="line">38     LSYM   0      0      00000000 428    int:t(0,4)</span><br><span class="line">39     SLINE  0      50     00000000 0      </span><br><span class="line">40     SLINE  0      53     00000010 0      </span><br><span class="line">41     SLINE  0      69     00000019 0      </span><br><span class="line">42     SLINE  0      55     00000028 0      </span><br><span class="line">43     SLINE  0      58     00000031 0      </span><br><span class="line">44     SLINE  0      60     00000033 0      </span><br><span class="line">45     SLINE  0      61     00000036 0      </span><br><span class="line">46     SLINE  0      62     0000004b 0      </span><br><span class="line">47     SLINE  0      63     00000057 0      </span><br><span class="line">48     FUN    0      0      f01000ef 439    _warn:F(0,1)</span><br><span class="line">49     PSYM   0      0      00000008 452    file:p(0,2)</span><br><span class="line">50     PSYM   0      0      0000000c 464    line:p(0,4)</span><br><span class="line">51     PSYM   0      0      00000010 405    fmt:p(0,2)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>结果很长，总之这里记录的是stab段中的内容，给出了符号和对应的地址。</p>
<ul>
<li>运行下列命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c</span></span><br></pre></td></tr></table></figure>
<p>然后查看<code>init.S</code>，可以看到一段非常冗长的代码：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐代码段</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    .file	&quot;init.c&quot;</span><br><span class="line">    .stabs	&quot;kern/init.c&quot;,100,0,2,.Ltext0    # .stabs string, type, other, desc, value</span><br><span class="line">    .text</span><br><span class="line">.Ltext0:</span><br><span class="line">    .stabs	&quot;gcc2_compiled.&quot;,60,0,0,0</span><br><span class="line">    .section	.rodata.str1.1,&quot;aMS&quot;,@progbits,1</span><br><span class="line">.LC0:</span><br><span class="line">    .string	&quot;entering test_backtrace %d\n&quot;</span><br><span class="line">.LC1:</span><br><span class="line">    .string	&quot;leaving test_backtrace %d\n&quot;</span><br><span class="line">    .text</span><br><span class="line">    .p2align 4</span><br><span class="line">    .stabs	&quot;test_backtrace:F(0,1)=(0,1)&quot;,36,0,0,test_backtrace</span><br><span class="line">    .stabs	&quot;void:t(0,1)&quot;,128,0,0,0</span><br><span class="line">    .stabs	&quot;x:P(0,2)=r(0,2);-2147483648;2147483647;&quot;,64,0,0,6</span><br><span class="line">    .stabs	&quot;int:t(0,2)&quot;,128,0,0,0</span><br><span class="line">    .globl	test_backtrace</span><br><span class="line">    .type	test_backtrace, @function</span><br><span class="line">test_backtrace:</span><br><span class="line">    .stabn	68,0,13,.LM0-.LFBB1</span><br><span class="line">.LM0:</span><br><span class="line">.LFBB1:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq	%r15</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 15, -16</span><br><span class="line">    .stabn	68,0,14,.LM1-.LFBB1</span><br><span class="line">.LM1:</span><br><span class="line">    movl	%edi, %esi</span><br><span class="line">    xorl	%eax, %eax</span><br><span class="line">    .stabn	68,0,13,.LM2-.LFBB1</span><br><span class="line">.LM2:</span><br><span class="line">    pushq	%r14</span><br><span class="line">    .cfi_def_cfa_offset 24</span><br><span class="line">    .cfi_offset 14, -24</span><br><span class="line">    pushq	%r13</span><br><span class="line">    .cfi_def_cfa_offset 32</span><br><span class="line">    .cfi_offset 13, -32</span><br><span class="line">    pushq	%r12</span><br><span class="line">    .cfi_def_cfa_offset 40</span><br><span class="line">    .cfi_offset 12, -40</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    .cfi_def_cfa_offset 48</span><br><span class="line">    .cfi_offset 6, -48</span><br><span class="line">    .stabn	68,0,13,.LM3-.LFBB1</span><br></pre></td></tr></table></figure>

</div></div>
<p>结合这段代码中的<code>.stab*</code>段以及上面的<code>objdump -G obj/kern/kernel</code>的输出结果，我们可以看到<code>init.s</code>中的<code>.stab</code>段已经被分配了具体的内存，同理其他的段和指令也会被分配相应的内存。也就是说我们的符号表被载入到了内存当中。</p>
<ul>
<li>看看bootloader工作时会不会将符号表载入内存中</li>
</ul>
<p>这里没搞明白，还有以下几个问题：</p>
<ol>
<li>符号表是何时载入的？</li>
<li>载入到了哪里</li>
</ol>
<p>还需要对符号表进行更深入的了解。总之这里我们知道，kernel加载过程中符号表也被载入，根据符号表，我们能够解析出<code>eip</code>保存的指令所在文件、行号、参数等相关信息。现在我们来对<code>mon_backtrace</code>进行改进。</p>
<h5 id="改进mon-backtrace"><a href="#改进mon-backtrace" class="headerlink" title="改进mon_backtrace"></a>改进mon_backtrace</h5><p>首先，我们需要改进<code>kern/kdebug.c</code>中的<code>debuginfo_eip</code>函数，添加行号搜索功能，根据提示添加如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Search within [lline, rline] for the line number stab.</span></span><br><span class="line"><span class="comment">// If found, set info-&gt;eip_line to the right line number.</span></span><br><span class="line"><span class="comment">// If not found, return -1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//	There's a particular stabs type used for line numbers.</span></span><br><span class="line"><span class="comment">//	Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span></span><br><span class="line"><span class="comment">//	which one.</span></span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline)&#123;</span><br><span class="line">    info-&gt;eip_line = rline;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>mon_backtrace</code>，调用<code>debuginfo_eip</code>并按照格式输出相关信息。修改后的<code>mon_backtrace</code>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)                      </span><br><span class="line">&#123;                                                                               </span><br><span class="line">    cprintf(<span class="string">"Stack backtrace:\n"</span>);                                              </span><br><span class="line">                                                                                 </span><br><span class="line">    <span class="comment">// Your code here.                                                          </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *ebp = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)read_ebp();   <span class="comment">//get the frame base of backtrace</span></span><br><span class="line">    <span class="keyword">while</span>(*ebp != <span class="number">0x0</span>)&#123;                                                         </span><br><span class="line">        cprintf(<span class="string">"ebp %x  eip %x  args %08x %08x %08x %08x %08x\n"</span>, *ebp, ebp[<span class="number">1</span>], ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line">        debuginfo_eip(ebp[<span class="number">1</span>], &amp;info);</span><br><span class="line">        cprintf(<span class="string">"%s:%d: %.*s+%u\n"</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, ebp[<span class="number">1</span>]-info.eip_fn_addr); </span><br><span class="line">        <span class="comment">//由于info.eip_fn_name并不是以0结尾，所以我们需要输出指定长度的函数名info.eip_fn_namelen</span></span><br><span class="line">        ebp =(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (*ebp);                 </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，Lab1的内容就全部完成了。</p>
<h2 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h2><h3 id="Selection-of-Operating-System-Papers"><a href="#Selection-of-Operating-System-Papers" class="headerlink" title="Selection of Operating System Papers"></a>Selection of Operating System Papers</h3><p>Available on <a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">the 6.828 schedule</a>.</p>
<h3 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h3><ul>
<li><a href="https://www.youtube.com/watch?v=tc4ROCJYbm0">Youtube Unix intro</a></li>
<li><a href="http://citeseer.ist.psu.edu/10962.html">The UNIX Time-Sharing System</a>, <a href="http://cm.bell-labs.com/who/dmr/">Dennis M. Ritchie</a> and <a href="http://cm.bell-labs.com/who/ken/">Ken L.Thompson</a>,. Bell System Technical Journal 57, number 6, part 2 (July-August 1978) pages 1905-1930. <a href="https://pdos.csail.mit.edu/6.828/2018/readings/ritchie78unix.pdf">(local copy)</a> You read this paper in 6.033.</li>
<li><a href="http://www.read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf">The Evolution of the Unix Time-sharing System</a>, Dennis M. Ritchie, 1979.</li>
<li><em>The C programming language (second edition)</em> by Kernighan and Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8, 1998.</li>
</ul>
<h3 id="x86-Emulation"><a href="#x86-Emulation" class="headerlink" title="x86 Emulation"></a>x86 Emulation</h3><ul>
<li><p>QEMU</p>
<p>- A fast and popular x86 platform and CPU emulator.</p>
<ul>
<li><a href="http://wiki.qemu.org/Qemu-doc.html">User manual</a></li>
</ul>
</li>
<li><p>Bochs</p>
<p>- A more mature, but quirkier and much slower x86 emulator. Bochs is generally a more faithful emulator of real hardware than QEMU.</p>
<ul>
<li><a href="http://bochs.sourceforge.net/doc/docbook/user/index.html">User manual</a></li>
<li><a href="http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html">Debugger reference</a></li>
</ul>
</li>
</ul>
<h3 id="x86-Assembly-Language"><a href="#x86-Assembly-Language" class="headerlink" title="x86 Assembly Language"></a>x86 Assembly Language</h3><ul>
<li><p><em><a href="http://www.drpaulcarter.com/pcasm/">PC Assembly Language</a></em>, Paul A. Carter, November 2003. <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">(local copy)</a></p>
</li>
<li><p><em><a href="http://www.logix.cz/michal/doc/i386/">Intel 80386 Programmer’s Reference Manual</a></em>, 1987 (HTML). <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386.pdf">(local copy - PDF)</a> <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">(local copy - HTML)</a><br>Much shorter than the full current Intel Architecture manuals below, but describes all processor features used in 6.828.</p>
</li>
<li><p>Intel 64 and IA-32 Intel Architecture Software Developer’s Manuals</p>
<p>, Intel, 2007. Local copies:</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-1.pdf">Volume I: Basic Architecture</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-2A.pdf">Volume 2A: Instruction Set Reference, A-M</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-2B.pdf">Volume 2B: Instruction Set Reference, N-Z</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">Volume 3A: System Programming Guide, Part 1</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3B.pdf">Volume 3B: System Programming Guide, Part 2</a></li>
</ul>
</li>
<li><p>Multiprocessor references:</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf">MP specification</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/ioapic.pdf">IO APIC</a></li>
</ul>
</li>
<li><p><a href="https://developer.amd.com/resources/developer-guides-manuals/">AMD64 Architecture Programmer’s Manual</a>.<br>Covers both the “classic” 32-bit x86 architecture and the new 64-bit extensions supported by the latest AMD and Intel processors.</p>
</li>
<li><p>Writing inline assembly language with GCC:</p>
<ul>
<li><a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan’s Guide to Inline Assembly</a>, Brennan “Mr. Wacko” Underwood</li>
<li><a href="http://www.ibm.com/developerworks/linux/library/l-ia.html">Inline assembly for x86 in Linux</a>, Bharata B. Rao, IBM</li>
<li><a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC-Inline-Assembly-HOWTO</a>, Sandeep.S</li>
</ul>
</li>
<li><p>Loading x86 executables in the ELF format:</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf">Tool Interface Standard (TIS) Executable and Linking Format (ELF)</a>.<br>The definitive standard for the ELF format.</li>
<li><a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Wikipedia page</a> has a short description.</li>
</ul>
</li>
</ul>
<h3 id="PC-Hardware-Programming"><a href="#PC-Hardware-Programming" class="headerlink" title="PC Hardware Programming"></a>PC Hardware Programming</h3><ul>
<li><p>General PC architecture information</p>
<ul>
<li><a href="http://web.archive.org/web/20040603021346/http://members.iweb.net.au/~pstorr/pcbook/">Phil Storrs PC Hardware book</a>, Phil Storrs, December 1998.</li>
<li><a href="http://bochs.sourceforge.net/techdata.html">Bochs technical hardware specifications directory</a>.</li>
</ul>
</li>
<li><p>General BIOS and PC bootstrap</p>
<ul>
<li><a href="http://www.htl-steyr.ac.at/~morg/pcinfo/hardware/interrupts/inte1at0.htm">BIOS Services and Software Interrupts</a>, Roger Morgan, 1997.</li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf">“El Torito” Bootable CD-ROM Format Specification</a>, Phoenix/IBM, January 1995.</li>
</ul>
</li>
<li><p>VGA display -</p>
<p>kern/console.c</p>
<ul>
<li><a href="http://web.archive.org/web/20080302090304/http://www.vesa.org/public/VBE/vbe3.pdf">VESA BIOS Extension (VBE) 3.0</a>, <a href="http://www.vesa.org/">Video Electronics Standards Association</a>, September 1998. <a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/vbe3.pdf">(local copy)</a></li>
<li>VGADOC, Finn Thøgersen, 2000. <a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/vgadoc/">(local copy - text)</a> <a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/vgadoc4b.zip">(local copy - ZIP)</a></li>
<li><a href="http://www.osdever.net/FreeVGA/home.htm">Free VGA Project</a>, J.D. Neal, 1998.</li>
</ul>
</li>
<li><p>Keyboard and Mouse -</p>
<p>kern/console.c</p>
<ul>
<li><a href="http://www.computer-engineering.org/index.html">Adam Chapweske’s resources</a>.</li>
</ul>
</li>
<li><p>8253/8254 Programmable Interval Timer (PIT) -</p>
<p>inc/timerreg.h</p>
<ul>
<li><a href="http://www.intel.com/design/archives/periphrl/docs/23124406.htm">82C54 CHMOS Programmable Interval Timer</a>, Intel, October 1994. <a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/82C54.pdf">(local copy)</a></li>
<li><a href="http://www.decisioncards.com/io/tutorials/8254_tut.html">Data Solutions 8253/8254 Tutorial</a>, Data Solutions.</li>
</ul>
</li>
<li><p>8259/8259A Programmable Interrupt Controller (PIC) -</p>
<p>kern/picirq.*</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8259A.pdf">8259A Programmable Interrupt Controller</a>, Intel, December 1988.</li>
</ul>
</li>
<li><p>Real-Time Clock (RTC) -</p>
<p>kern/kclock.*</p>
<ul>
<li><p>Phil Storrs PC Hardware book</p>
<p>, Phil Storrs, December 1998. In particular:</p>
<ul>
<li><a href="http://web.archive.org/web/20040603021346/http://members.iweb.net.au/~pstorr/pcbook/book5/cmos.htm">Understanding the CMOS</a></li>
<li><a href="http://web.archive.org/web/20040603021346/http://members.iweb.net.au/~pstorr/pcbook/book5/cmoslist.htm">A list of what is in the CMOS</a></li>
</ul>
</li>
<li><p><a href="http://bochs.sourceforge.net/techspec/CMOS-reference.txt">CMOS Memory Map</a>, Padgett Peterson, May 1996.</p>
</li>
<li><p><a href="http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/DATASHEET/CD00001009.pdf">M48T86 PC Real-Time Clock</a>, ST Microelectronics, April 2004. <a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/M48T86.pdf">(local copy)</a></p>
</li>
</ul>
</li>
<li><p>16550 UART Serial Port -</p>
<p>kern/console.c</p>
<ul>
<li><a href="http://www.national.com/pf/PC/PC16550D.html">PC16550D Universal Asynchronous Receiver/Transmitter with FIFOs</a>, National Semiconductor, 1995.</li>
<li><a href="http://byterunner.com/16550.html">Technical Data on 16550</a>, Byterunner Technologies.</li>
<li><a href="http://www.beyondlogic.org/serial/serial.htm">Interfacing the Serial / RS232 Port</a>, Craig Peacock, August 2001.</li>
</ul>
</li>
<li><p>IEEE 1284 Parallel Port -</p>
<p>kern/console.c</p>
<ul>
<li><a href="http://www.lvr.com/parport.htm">Parallel Port Central</a>, Jan Axelson.</li>
<li><a href="http://www.fapo.com/porthist.htm">Parallel Port Background</a>, Warp Nine Engineering.</li>
<li><a href="http://zone.ni.com/devzone/cda/tut/p/id/3466">IEEE 1284 - Updating the PC Parallel Port</a>, National Instruments.</li>
<li><a href="http://www.beyondlogic.org/spp/parallel.htm">Interfacing the Standard Parallel Port</a>, Craig Peacock, August 2001.</li>
</ul>
</li>
<li><p>IDE hard drive controller -</p>
<p>fs/ide.c</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/ATA-d1410r3a.pdf">AT Attachment with Packet Interface - 6 (working draft)</a>, ANSI, December 2001.</li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/IDE-BusMaster.pdf">Programming Interface for Bus Master IDE Controller</a>, Brad Hosler, Intel, May 1994.</li>
<li><a href="http://suif.stanford.edu/~csapuntz/ide.html">The Guide to ATA/ATAPI documentation</a>, Constantine Sapuntzakis, January 2002.</li>
</ul>
</li>
<li><p>Sound cards (not supported in 6.828 kernel, but you’re welcome to do it as a challenge problem!)</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/SoundBlaster.pdf">Sound Blaster Series Hardware Programming Guide</a>, Creative Technology, 1996.</li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8237A.pdf">8237A High Performance Programmable DMA Controller</a>, Intel, September 1993.</li>
<li><a href="http://homepages.cae.wisc.edu/~brodskye/sb16doc/sb16doc.html">Sound Blaster 16 Programming Document</a>, Ethan Brodsky, June 1997.</li>
<li><a href="http://www.inversereality.org/tutorials/sound programming/soundprogramming.html">Sound Programming</a>, Inverse Reality.</li>
</ul>
</li>
<li><p>E100 Network Interface Card</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8255X_OpenSDM.pdf">Intel 8255x 10/100 Mbps Ethernet Controller Family Open Source Software Developer Manual</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/82559ER_datasheet.pdf">82559ER Fast Ethernet PCI Controller Datasheet</a></li>
</ul>
</li>
<li><p>E1000 Network Interface Card</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8254x_GBe_SDM.pdf">PCI/PCI-X Family of Gigabit Ethernet Controllers Software Developerâ€™s Manual</a></li>
</ul>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://www.bilibili.com/video/av15896196/">MIT6828课程视频链接</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">Lab1介绍</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">6828课程表</a><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">6828课程材料</a><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><a href="https://www.win.tue.nl/~aeb/linux/kbd/scancodes-11.html">8086端口说明</a><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><a href="https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_appendix_a20.html">关于 A20的详细介绍</a><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><a href="https://wiki.osdev.org/I/O_Ports#Looking_for_a_list_of_ports">x86端口映射表</a>
[^ 8]:<a href="https://111qqz.github.io/2019/01/mit-6-828-lab-1/">111qqz做的实验</a>
[^ 9]:<a href="https://www.glamenv-septzen.net/en/view/6">0x7c00这个魔数的含义</a><a href="#fnref:7" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6828-Lab4-抢占式多线程</title>
    <url>/2024/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B/MIT6828-Lab4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>剪不断，理还乱</p>
</blockquote>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>In this lab you will implement preemptive multitasking among multiple simultaneously active user-mode environments.</p>
<p>In part A you will add multiprocessor support to JOS, implement round-robin scheduling, and add basic environment management system calls (calls that create and destroy environments, and allocate/map memory).</p>
<p>In part B, you will implement a Unix-like <code>fork()</code>, which allows a user-mode environment to create copies of itself.</p>
<p>Finally, in part C you will add support for inter-process communication (IPC), allowing different user-mode environments to communicate and synchronize with each other explicitly. You will also add support for hardware clock interrupts and preemption.</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">athena% cd ~/<span class="number">6.828</span>/lab</span><br><span class="line">athena% add git</span><br><span class="line">athena% git pull</span><br><span class="line">Already up-to-date.</span><br><span class="line">athena% git checkout -b lab4 origin/lab4</span><br><span class="line">Branch lab4 <span class="built_in">set</span> up to track remote branch refs/remotes/origin/lab4.</span><br><span class="line">Switched to a <span class="keyword">new</span> branch <span class="string">"lab4"</span></span><br><span class="line">athena% git merge lab3</span><br><span class="line">Merge made by recursive.</span><br><span class="line">...</span><br><span class="line">athena%</span><br></pre></td></tr></table></figure>
<p>首先，合并lab3，然后切换至lab4，在lab4中，你需要参考及阅读的源码如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>文件</th>
<th>功能</th>
<th>进度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inc/</code></td>
<td><code>env.h</code></td>
<td>Public definitions for user-mode environments</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code></td>
<td>Public definitions for trap handling</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>Public definitions for system calls from user environments to the kernel</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>lib.h</code></td>
<td>Public definitions for the user-mode support library</td>
<td></td>
</tr>
<tr>
<td><code>kern/</code></td>
<td><code>env.h</code></td>
<td>Kernel-private definitions for user-mode environments</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>env.c</code></td>
<td>Kernel code implementing user-mode environments</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code></td>
<td>Kernel-private trap handling definitions</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>trap.c</code></td>
<td>Trap handling code</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>trapentry.S</code></td>
<td>Assembly-language trap handler entry-points</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>Kernel-private definitions for system call handling</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>System call implementation code</td>
<td></td>
</tr>
<tr>
<td><code>lib/</code></td>
<td><code>Makefrag</code></td>
<td>Makefile fragment to build user-mode library, <code>obj/lib/libjos.a</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>entry.S</code></td>
<td>Assembly-language entry-point for user environments</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>libmain.c</code></td>
<td>User-mode library setup code called from <code>entry.S</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>User-mode system call stub functions</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>console.c</code></td>
<td>User-mode implementations of <code>putchar</code> and <code>getchar</code>, providing console I/O</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>exit.c</code></td>
<td>User-mode implementation of <code>exit</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>panic.c</code></td>
<td>User-mode implementation of <code>panic</code></td>
<td></td>
</tr>
<tr>
<td><code>user/</code></td>
<td><code>*</code></td>
<td>Various test programs to check kernel lab 3 code</td>
</tr>
</tbody>
</table>
</div>

</div></div>
<h3 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h3><p>本练习有三个部分，每个部分耗时一周。你需要完成所有的任务和至少一个挑战。</p>
<h2 id="第一部分：多处理器支持及协作多任务"><a href="#第一部分：多处理器支持及协作多任务" class="headerlink" title="第一部分：多处理器支持及协作多任务"></a>第一部分：多处理器支持及协作多任务</h2><p>在本实验第一章，你需要在多处理器系统上扩展JOS，并实现一些新的系统调用使用户程序创建新的用户环境。你需要实现合作的round-robin调度算法，从而使内核实现任务切换。在Part C，你需要实现抢占式调度，从而使内核重新获得CPU控制权。</p>
<h3 id="多处理器支持"><a href="#多处理器支持" class="headerlink" title="多处理器支持"></a>多处理器支持</h3><p>We are going to make JOS support “symmetric multiprocessing” (SMP), a multiprocessor model in which all CPUs have equivalent access to system resources such as memory and I/O buses. While all CPUs are functionally identical in SMP, during the boot process they can be classified into two types: the bootstrap processor (BSP) is responsible for initializing the system and for booting the operating system; and the application processors (APs) are activated by the BSP only after the operating system is up and running. Which processor is the BSP is determined by the hardware and the BIOS. Up to this point, all your existing JOS code has been running on the BSP. （BSP负责启动系统）</p>
<p>In an SMP system, each CPU has an accompanying local APIC (局部可编程终端控制) unit. The LAPIC units are responsible for delivering interrupts throughout the system. The LAPIC also provides its connected CPU with a unique identifier. In this lab, we make use of the following basic functionality of the LAPIC unit (in <code>kern/lapic.c</code>):</p>
<ul>
<li>Reading the LAPIC identifier (APIC ID) to tell which CPU our code is currently running on (see <code>cpunum()</code>).</li>
<li>Sending the <code>STARTUP</code> interprocessor interrupt (IPI) from the BSP to the APs to bring up other CPUs (see <code>lapic_startap()</code>).</li>
<li>In part C, we program LAPIC’s built-in timer to trigger clock interrupts to support preemptive multitasking (see <code>apic_init()</code>).</li>
</ul>
<p>一个处理器通过内存映射IO（MMIO）来访问其LAPIC。在MMIO中，a portion of <em>physical</em> memory is hardwired to the registers of some I/O devices, so the same load/store instructions typically used to access memory can be used to access device registers. You’ve already seen one IO hole at physical address <code>0xA0000</code> (we use this to write to the VGA display buffer). The LAPIC lives in a hole starting at physical address <code>0xFE000000</code> (32MB short of 4GB), so it’s too high for us to access using our usual direct map at KERNBASE. The JOS virtual memory map leaves a 4MB gap at <code>MMIOBASE</code> so we have a place to map devices like this. Since later labs introduce more MMIO regions, you’ll write a simple function to allocate space from this region and map device memory to it.</p>
<div class="note default">
            <p><strong>练习1</strong>：在<code>kern/pmap.c</code>中编写<code>mmio_map_region</code>。为了搞明白这个是如何工作的，看一下<code>kern/lapic.c</code>中<code>lapic_init</code>的一开始部分。你需要完成下一个练习，才能令<code>mmio_map_region</code>正常工作。</p>
          </div>
<p><strong>函数原型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数功能</strong></p>
<p>这个函数保留了一段空间，用于MMIO区域，这段区域位于<code>MMIOBASE + size</code>，被映射至<code>[pa, pa+size)</code>，程序不难，照着注释就能写完。</p>
<p><strong>函数实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line">    <span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line">    <span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line">    <span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    size = (<span class="keyword">size_t</span>) ROUNDUP((<span class="keyword">uint32_t</span>)(size), PGSIZE);    <span class="comment">// Round size up to a multiple of PGSIZE</span></span><br><span class="line">    <span class="comment">// Handle if this reservation would overflow MMIOLIM</span></span><br><span class="line">    <span class="keyword">if</span>(base + size &gt;= MMIOBASE) panic(<span class="string">"The reservation of MMIO region is overflowed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reserve size bytes of virtual memory starting at base and</span></span><br><span class="line">    <span class="comment">// map physical pages [pa,pa+size) to virtual addresses</span></span><br><span class="line">    <span class="comment">// [base,base+size).  Since this is device memory and not</span></span><br><span class="line">    <span class="comment">// regular DRAM, you'll have to tell the CPU that it isn't</span></span><br><span class="line">    <span class="comment">// safe to cache access to this memory. </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// PTE_PCD: Cache disable</span></span><br><span class="line">    <span class="comment">// PTE_PWT: write through</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Should I write PTE_P?</span></span><br><span class="line">    boot_map_region(kern_pgdir, base, size, pa, (PTE_P | PTE_W | PTE_PCD | PTE_PWT));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p><strong>调试</strong></p>
<p>上面的函数无法通过<code>check_kern_pgdir</code>，注意这里的<code>base</code>用的是<code>static</code>，根据其中的注释，我们每次调用<code>mmio_map_region</code>，都需要更新<code>base</code>，因此我们在函数中使用一个<code>old_base</code>记录更新前的值，然后令<code>base = base + size</code>。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> old_base = base;</span><br><span class="line">base = base + size;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span>*)old_base</span><br></pre></td></tr></table></figure>
<h4 id="应用处理器启动"><a href="#应用处理器启动" class="headerlink" title="应用处理器启动"></a>应用处理器启动</h4><p>在启动APs之前，BSP将会收集多处理器系统的信息，例如CPU总数，APIC号以及LAPIC的多路IO地址。 <code>kern/mpconfig.c</code>中的 <code>mp_init()</code>函数通过读取位于内存BIOS区域的多处理器配置表获取这些信息。</p>
<p><code>boot_aps()</code> 函数 (位于<code>kern/init.c</code>) 驱动了应用处理器的启动过程。APs于实模式下启动，和bootloader由<code>boot/boot.S</code>的启动过程类似，因此<code>boot_aps()</code>(位于<code>kern/mpentry.S</code>)将AP的入口（entry）代码复制到了可以在实模式下寻址的一段内存空间中。不同于bootloader，我们对于AP执行代码的位置有了一定控制；我们将入口代码复制到了 <code>0x7000</code> (<code>MPENTRY_PADDR</code>)处。</p>
<p>在此之后，<code>boot_aps()</code> 将依次激活应用处理器，通过向对应处理器的LAPIC单元发送<code>STARTUP</code>IPIs，以及一个初始化的 <code>CS:IP</code> 地址，应用处理器将会在这个地址执行入口代码 (<code>MPENTRY_PADDR</code>). <code>kern/mpentry.S</code> 中的入口代码和<code>boot/boot.S</code>中的很类似。经过一些简单的启动过程后，这个代码将会令AP进入保护模式，从而使能页映射，并调用 <code>mp_main()</code>进行配置(also in <code>kern/init.c</code>)。 在唤醒下一个AP前，<code>boot_aps()</code> 等待AP发送一个<code>CPU_STARTED</code>标志。这个标志位于结构体<code>struct CpuInfo</code>的<code>cpu_status</code>字段。</p>
<div class="note default">
            <p><strong>练习 2.</strong> Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code> to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p>
          </div>
<p><strong>阅读<code>boot_aps</code>、<code>mp_main</code>以及<code>mpentry.S</code></strong></p>
<p><code>boot_aps</code>的源代码如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_aps(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mpentry_start[], mpentry_end[];   <span class="comment">// 这两个地址位于`mpentry.S`中</span></span><br><span class="line">    <span class="keyword">void</span> *code;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write entry code to unused memory at MPENTRY_PADDR</span></span><br><span class="line">    code = KADDR(MPENTRY_PADDR);</span><br><span class="line">    memmove(code, mpentry_start, mpentry_end - mpentry_start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boot each AP one at a time</span></span><br><span class="line">    <span class="keyword">for</span> (c = cpus; c &lt; cpus + ncpu; c++) &#123;</span><br><span class="line">        <span class="comment">// 下面这句不是太理解，是说当前CPU已经启动么？</span></span><br><span class="line">        <span class="keyword">if</span> (c == cpus + cpunum())  <span class="comment">// We've started already.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell mpentry.S what stack to use </span></span><br><span class="line">        mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;</span><br><span class="line">        <span class="comment">// Start the CPU at mpentry_start</span></span><br><span class="line">        lapic_startap(c-&gt;cpu_id, PADDR(code));</span><br><span class="line">        <span class="comment">// Wait for the CPU to finish some basic setup in mp_main()</span></span><br><span class="line">        <span class="keyword">while</span>(c-&gt;cpu_status != CPU_STARTED)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p><code>boot_aps</code>的基本过程为首先拷贝入口代码，然后遍历每个CPU，如果CPU已经启动了（cpunum返回当前CPU），那么跳过，否则分配栈（大小为32768），然后启动AP并等待配置完成。</p>
<p><code>mp_main</code>的源码如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Setup code for APs</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">mp_main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We are in high EIP now, safe to switch to kern_pgdir </span></span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">    cprintf(<span class="string">"SMP: CPU %d starting\n"</span>, cpunum());</span><br><span class="line"></span><br><span class="line">    lapic_init();           <span class="comment">// 初始化local apic</span></span><br><span class="line">    env_init_percpu();      <span class="comment">// 初始化每个CPU的进程</span></span><br><span class="line">    trap_init_percpu();     <span class="comment">// 初始化每个CPU的trap</span></span><br><span class="line">    xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="comment">// tell boot_aps() we're up</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line">    <span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line">    <span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Your code here:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this after you finish Exercise 6</span></span><br><span class="line">    <span class="keyword">for</span> (;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p><code>mp_main</code>主要做了一些初始化工作，具体内容我们会在后面进行讲解。至于<code>mpentry.S</code>，其基本功能就是初始化一些寄存器，然后调用<code>mp_main</code>，所以AP的初始化过程可以总结为：<code>boot_aps</code>将<code>mpentry.S</code>拷贝到给定内存空间中，然后<code>mpentry.S</code>调用<code>mp_main</code>进行CPU初始化工作。</p>
<p><strong>将<code>MPENTRY_PADDR</code>（0x7000）对应的物理页从内存freelist中剔除</strong></p>
<p>我们之间以链表的形式将内存中空闲页面进行了串联，现在需要将0x7000对应的物理页剔除，只要找到0x7000对应的页在pages的数组中所在下标，并调整链表节点连接关系即可，比较简单，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LAB 4:</span></span><br><span class="line"><span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR</span></span><br><span class="line"><span class="comment">// as in use</span></span><br><span class="line">i = MPENTRY_PADDR/PGSIZE;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">pages[i+<span class="number">1</span>].pp_link = &amp;pages[i<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="单个CPU的状态及初始化"><a href="#单个CPU的状态及初始化" class="headerlink" title="单个CPU的状态及初始化"></a>单个CPU的状态及初始化</h4><p>编写多处理器OS时，最重要的一个就是分辨每个CPU的状态（私有）以及系统共享全局状态。 <code>kern/cpu.h</code>定义了最常用的CPU状态，包括 <code>struct CpuInfo</code>，包含了每个CPU中的状态变量. <code>cpunum()</code>总是返回调用它的CPU的序号，因此可以被用来作为CPU数组<code>cpus</code>的索引。同样的， 宏<code>thiscpu</code> 也记录了当前CPU的 <code>struct CpuInfo</code>.</p>
<p>这里列举了你应当了解的每个CPU的状态：</p>
<ul>
<li><p><strong>Per-CPU kernel stack</strong>（每个CPU的内核栈）<br>每个CPU可能同时陷入内核态，我们需要为每个处理器设置单独的内核栈，确保他们之间不会相互打扰。The array <code>percpu_kstacks[NCPU][KSTKSIZE]</code> reserves space for NCPU’s worth of kernel stacks.（独立的内核栈确保互不打扰）</p>
<p>In Lab 2, you mapped the physical memory that <code>bootstack</code> refers to as the BSP’s kernel stack just below <code>KSTACKTOP</code>. Similarly, in this lab, you will map each CPU’s kernel stack into this region with guard pages acting as a buffer between them. CPU 0’s stack will still grow down from <code>KSTACKTOP</code>; CPU 1’s stack will start <code>KSTKGAP</code> bytes below the bottom of CPU 0’s stack, and so on. <code>inc/memlayout.h</code> shows the mapping layout.</p>
</li>
<li><p><strong>Per-CPU TSS and TSS descriptor</strong>（每个CPU的TSS和TSSD）<br>A per-CPU task state segment (TSS) is also needed in order to specify where each CPU’s kernel stack lives. The TSS for CPU <em>i</em> is stored in <code>cpus[i].cpu_ts</code>, and the corresponding TSS descriptor is defined in the GDT entry <code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>. The global <code>ts</code> variable defined in <code>kern/trap.c</code> will no longer be useful.</p>
</li>
<li><p><strong>Per-CPU current environment pointer</strong>（每个CPU的当前环境指针）<br>Since each CPU can run different user process simultaneously, we redefined the symbol <code>curenv</code> to refer to <code>cpus[cpunum()].cpu_env</code> (or <code>thiscpu-&gt;cpu_env</code>), which points to the environment <em>currently</em> executing on the <em>current</em> CPU (the CPU on which the code is running).</p>
</li>
<li><p><strong>Per-CPU system registers</strong>（每个CPU的系统寄存器）<br>All registers, including system registers, are private to a CPU. Therefore, instructions that initialize these registers, such as <code>lcr3()</code>, <code>ltr()</code>, <code>lgdt()</code>, <code>lidt()</code>, etc., must be executed once on each CPU. Functions <code>env_init_percpu()</code> and <code>trap_init_percpu()</code> are defined for this purpose.</p>
</li>
<li><p>In addition to this, if you have added any extra per-CPU state or performed any additional CPU-specific initialization (by say, setting new bits in the CPU registers) in your solutions to challenge problems in earlier labs, be sure to replicate them on each CPU here!</p>
</li>
</ul>
<div class="note default">
            <p><strong>Exercise 3.</strong> Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p>
          </div>
<p><strong>函数功能</strong></p>
<p>为每个CPU分配栈空间，栈空间分为两部分，一部分为栈区，大小为<code>KSTKSIZE</code>，另一部分为缓冲区，大小为<code>KSTKGAP</code>，缓冲区的作用是判断栈溢出，如果进入缓冲区，说明溢出，要触发异常，栈示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/kstacktop.svg" width = "250" alt="图片名称" align=center /></p>
<p><strong>函数实现</strong></p>
<p>根据函数功能，我们需要将栈地址与对应的物理地址进行映射，每个栈的栈顶为<code>kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP)</code>，栈底为<code>kstacktop_i-KSTKSIZE</code>，大小为<code>KSTKSIZE</code>。不难写出映射代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// For CPU i, use the physical memory that 'percpu_kstacks[i]' refers</span></span><br><span class="line">    <span class="comment">// to as its kernel stack. CPU i's kernel stack grows down from virtual</span></span><br><span class="line">    <span class="comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span></span><br><span class="line">    <span class="comment">// divided into two pieces, just like the single stack you set up in</span></span><br><span class="line">    <span class="comment">// mem_init:</span></span><br><span class="line">    <span class="comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span></span><br><span class="line">    <span class="comment">//          -- backed by physical memory</span></span><br><span class="line">    <span class="comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span></span><br><span class="line">    <span class="comment">//          -- not backed; so if the kernel overflows its stack,</span></span><br><span class="line">    <span class="comment">//             it will fault rather than overwrite another CPU's stack.</span></span><br><span class="line">    <span class="comment">//             Known as a "guard page".</span></span><br><span class="line">    <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i)&#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span><br><span class="line">        boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), (PTE_W | PTE_P));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成后，代码应当能够通过<code>check_kern_pgdir</code></p>
<div class="note default">
            <p><strong>Exercise 4.</strong> The code in <code>trap_init_percpu()</code> (<code>kern/trap.c</code>) initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3, but is incorrect when running on other CPUs. Change the code so that it can work on all CPUs. (Note: your new code should not use the global <code>ts</code> variable any more.)</p>
          </div>
<p><strong>TSS和TSS descriptor</strong></p>
<p>为了解决这个问题，我们首先要搞清楚Task Segment Selector（TSS）和TSS descriptor，关于这些内容请参考<a href="/2024/10/13/计算机/操作系统/进程/" title="关于进程的讲解">关于进程的讲解</a>。练习四要求我们修改<code>trap_init_percpu</code>，从而初始化TSS和TSSD。</p>
<p><strong>原始版本的trap_init_percpu</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ts.ts_esp0 = KSTACKTOP;</span><br><span class="line">    ts.ts_ss0 = GD_KD;</span><br><span class="line">    ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">    gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;ts),</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>].sd_s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ltr(GD_TSS0);</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码配置了CPU0（Boot CPU）的TSS和TSSD，但是并不通用，我们要将其修改，令其可以自适应地配置每个CPU的TSS和TSSD。</p>
<p><strong>修改内容</strong></p>
<p>根据注释，我们需要修改的内容如下：</p>
<ul>
<li>首先使用<code>thiscpu-&gt;cpu_ts</code>即当前CPU的TSS段代替<code>ts</code></li>
<li>将TSS段中的esp0指向当前CPU内核栈栈顶（栈顶计算过程参考练习3）</li>
<li>修改当前CPU的TSSD，即<code>gdt[(GD_TSS0 &gt;&gt; 3) + cpunum()]</code></li>
<li>修改当前CPU的TSS selector</li>
</ul>
<p>前三个任务根据注释很好完成，主要注意下当前CPU的TSS selector。根据注释，selector的低三位都是0，实际上第四位表示具体的CPU，因此每个CPU的TSS selector可以表示为：<code>GD_TSS0  + (cpunum() &lt;&lt; 3)</code>。</p>
<p><strong>改进后的trap_init_percpu</strong></p>
<p>根据上面的分析及注释，可以写出改进的<code>trap_init_percpu</code>如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize and load TSS, TSS descriptor and IDT for all CPUs</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// - Calculate current CPU's kern stack top (esp0), thiscpu points to the current CPU's </span></span><br><span class="line">    <span class="comment">// struct CpuInfo, and cpunum() returns current CPU's id</span></span><br><span class="line">    <span class="comment">// - Use "thiscpu-&gt;cpu_ts" as the TSS for the current CPU,</span></span><br><span class="line">    <span class="comment">// rather than the global "ts" variable;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cur_cpu_kstacktop = KSTACKTOP - cpunum() * (KSTKSIZE + KSTKGAP);  </span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_esp0 = cur_cpu_kstacktop;</span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span></span><br><span class="line">    <span class="comment">//     from doing IO (0 is not the correct value!)</span></span><br><span class="line">    thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Setup a TSS so that we get the right stack when we trap to the kernel.</span></span><br><span class="line">    <span class="comment">// Initialize the TSS slot of the gdt. USE gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i's TSS descriptor;</span></span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()].sd_s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ltr sets a 'busy' flag in the TSS selector, so if you</span></span><br><span class="line">    <span class="comment">// accidentally load the same TSS on more than one CPU, you'll</span></span><br><span class="line">    <span class="comment">// get a triple fault.  If you set up an individual CPU's TSS</span></span><br><span class="line">    <span class="comment">// wrong, you may not get a fault until you try to return from</span></span><br><span class="line">    <span class="comment">// user space on that CPU.</span></span><br><span class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">    ltr(GD_TSS0  + (cpunum() &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the IDT</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p>完成上述内容后，以4核CPU在QEMU中启动JOS（<code>make qemu CPUS=4</code>），可以得到如下输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Physical memory: 66556K available, base = 640K, extended = 65532K</span><br><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br><span class="line">check_kern_pgdir() succeeded!</span><br><span class="line">check_page_installed_pgdir() succeeded!</span><br><span class="line">SMP: CPU 0 found 4 CPU(s)</span><br><span class="line">enabled interrupts: 1 2</span><br><span class="line">SMP: CPU 1 starting</span><br><span class="line">SMP: CPU 2 starting</span><br><span class="line">SMP: CPU 3 starting</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">EAX=00000000 EBX=00000000 ECX=ef804000 EDX=f022a094</span><br><span class="line">... <span class="comment">#中间省略一堆寄存器的信息</span></span><br><span class="line">EFER=0000000000000000</span><br><span class="line">Triple fault.  Halting <span class="keyword">for</span> inspection via QEMU monitor.</span><br></pre></td></tr></table></figure>
<p>可以看到CPU都启动了，但新启动的进程遇到了一个Triple fault，原因见上一个实验。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>我们现在的代码将在<code>mp_main()</code>初始化AP后陷入死循环。为了让AP能够继续运行，我们首先要解决多CPU同时运行内核代码时的竞态条件。最简单的解决方式是使用一个大的全局内核锁，当有进程进入内核态后，需要对内核进行上锁；从内核态返回用户态时，需要解锁。在这个模型中，用户态进程可以在任意CPU上并发执行，但是只有一个进程能够运行于内核态，任何一个其他的想要进入内核态的进程必须等待。</p>
<p><code>kern/spinlock.h</code> declares the big kernel lock, namely <code>kernel_lock</code>. It also provides <code>lock_kernel()</code> and <code>unlock_kernel()</code>, shortcuts to acquire and release the lock. You should apply the big kernel lock at four locations:</p>
<ul>
<li>In <code>i386_init()</code>, acquire the lock before the BSP wakes up the other CPUs. 避免其他CPU执行内核代码。</li>
<li>In <code>mp_main()</code>, acquire the lock after initializing the AP, and then call <code>sched_yield()</code> to start running environments on this AP. 在该CPU上执行用户态进程</li>
<li>In <code>trap()</code>, acquire the lock when trapped from user mode. To determine whether a trap happened in user mode or in kernel mode, check the low bits of the <code>tf_cs</code>. 从用户态进入内核态，占有内核锁。</li>
<li>In <code>env_run()</code>, release the lock <em>right before</em> switching to user mode. Do not do that too early or too late, otherwise you will experience races or deadlocks. 从内核态进入用户态，释放内核锁</li>
</ul>
<p>从上面的过程中可以看出，我们有三处位置进行上锁，一处位置进行解锁。实际上，我们在所有可能发生内核态到用户态以及用户态到内核态转变的过程中，都对内核锁进行了操作。</p>
<div class="note default">
            <p><strong>Exercise 5.</strong> Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p>
          </div>
<p><strong>在指定位置为内核上锁/解锁</strong></p>
<p>根据上面的提示，我们需要在特定位置上对内核锁进行加锁与解锁的操作。代码并不难，就不赘述了。目前我们尚无法验证上锁是否正确，但是随着后面练习的推进，我们会验证锁的正确性</p>
<div class="note default">
            <p><strong>问题</strong>：使用一个大的内核锁保证了在一个时刻只能有一个CPU运行内核代码。为何我们还需要对每个CPU单独设置内核栈？Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</p>
          </div>
<p>在由用户态执行系统调用进入内核态，到<code>trap()</code>对内核进行加锁保护这一段时间内，内核实际上是未经保护的，此时<code>_alltrap</code>会将一些关键寄存器的值压栈并保存，因此会对内核栈进行修改。可能会发生错误，所以必须要多个内核栈。</p>
<div class="note danger">
            <p><strong>Challenge!</strong> </p><p>粗颗粒锁简单易用，但是限制了内核态的所有并发，效率较低。现代操作系统使用细颗粒锁来保护共享态中的不同的部分。细颗粒锁提高了并发性能，但是更困难，同时也更容易出错。请尝试设计合理的细颗粒锁，实现对于内核更加精细的控制。</p><p>提示：你可以考虑针对如下的共享部分设计细颗粒锁，并实现内核的访问控制：</p><ul><li>The page allocator.</li><li>The console driver.</li><li>The scheduler.</li><li>The inter-process communication (IPC) state that you will implement in the part C.</li></ul>
          </div>
<p><strong>定义细颗粒锁以及加锁/解锁函数</strong></p>
<p>根据上面的提示，我们首先要针对共享部分，定义新的细颗粒锁。</p>
<h3 id="Round-Robin-调度（轮转调度）"><a href="#Round-Robin-调度（轮转调度）" class="headerlink" title="Round-Robin 调度（轮转调度）"></a>Round-Robin 调度（轮转调度）</h3><p>下一个任务是实施轮转调度，令内核轮转调度多个进程，调度过程如下：</p>
<ul>
<li>函数<code>sched_yield()</code> （在新的<code>kern/sched.c</code>中）选择一个新的要运行的进程。该函数在进程队列<code>envs[]</code>中环形顺序搜索， 搜索位置开始于前一个运行的进程之后（如果没有前一时刻的运行进程，那么就从进程队列起始位置搜索），并选择第一个状态为 <code>ENV_RUNNABLE</code> (see <code>inc/env.h</code>)的进程，并调用<code>env_run()</code>执行该进程</li>
<li><code>sched_yield()</code> 永远不应于同一时刻在两个CPU上运行同一个进程。根据进程状态<code>ENV_RUNNING</code>，我们可以判定当前进程是否在某个CPU（或当前CPU）上运行.</li>
<li>我们定义了一个新系统调用<code>sys_yield()</code>，用户可以通过该调用来调用内核<code>sched_yield()</code>函数，从而主动将CPU让给另一个进程。</li>
</ul>
<div class="note default">
            <p><strong>Exercise 6.</strong> Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.</p><p>在<code>mp_main</code>中调用<code>sched_yield()</code>，修改<code>kern/init.c</code> 并创建三个以上的进程，这些进程都运行程序 <code>user/yield.c</code>。现在，运行<code>make qemu CPUS=2</code>，你应当能看到多个进程交互运行，每个执行了五次，然后退出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Hello, I am environment 00001000.</span><br><span class="line">Hello, I am environment 00001001.</span><br><span class="line">Hello, I am environment 00001002.</span><br><span class="line">Back in environment 00001000, iteration 0.</span><br><span class="line">Back in environment 00001001, iteration 0.</span><br><span class="line">Back in environment 00001002, iteration 0.</span><br><span class="line">Back in environment 00001000, iteration 1.</span><br><span class="line">Back in environment 00001001, iteration 1.</span><br><span class="line">Back in environment 00001002, iteration 1.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>After the <code>yield</code> programs exit, there will be no runnable environment in the system, the scheduler should invoke the JOS kernel monitor. If any of this does not happen, then fix your code before proceeding.</p>
          </div>
<p><strong>框架编写</strong></p>
<p>任务6主要是实现轮询调度，然后在合适的地方调用该函数，找到下一个调度的进程。我们先完成框架的编写，在<code>mp_main</code>中调用<code>sched_yield()</code>，改进后的<code>mp_main</code>为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Setup code for APs</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">mp_main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We are in high EIP now, safe to switch to kern_pgdir </span></span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">    cprintf(<span class="string">"SMP: CPU %d starting\n"</span>, cpunum());</span><br><span class="line"></span><br><span class="line">    lapic_init();           <span class="comment">// 初始化local apic</span></span><br><span class="line">    env_init_percpu();      <span class="comment">// 初始化每个CPU的进程</span></span><br><span class="line">    trap_init_percpu();     <span class="comment">// 初始化每个CPU的trap</span></span><br><span class="line">    xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="comment">// tell boot_aps() we're up</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line">    <span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line">    <span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line">    lock_kernel();</span><br><span class="line">    sched_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>kern/syscall.c</code>，在<code>syscall()</code>中添加对<code>sys_yield</code>的响应。</p>
<p><strong>轮询算法实现</strong></p>
<p>为了实现轮询算法，我们需要解决如下问题：</p>
<ul>
<li>数组遍历：算法要求我们从当前进程之后开始，对可调度的进程进行搜索，因此我们需要从<code>envs</code>中间某个位置开始，对其进行遍历。简介的写法可以写为：<code>envs[(next_envid + i) % NENV]</code></li>
<li>找不到合适的<code>envs</code>：<ul>
<li>如果当前CPU的进程仍然在运行，可以选择当前进程继续执行</li>
<li>如果当前CPU上的进程也结束了，也找不到合适的进程，那么就挂起CPU</li>
</ul>
</li>
</ul>
<p>我们能够写出轮询算法如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search through 'envs' for an ENV_RUNNABLE environment in</span></span><br><span class="line">    <span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line">    <span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line">    <span class="keyword">int</span> next_envid = curenv ? ENVX(curenv-&gt;env_id) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NENV; i++) &#123;</span><br><span class="line">        idle = &amp;envs[(next_envid + i) % NENV];</span><br><span class="line">        <span class="keyword">if</span> (idle-&gt;env_status == ENV_RUNNABLE)&#123;   </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Do we need to modify the id of the env?</span></span><br><span class="line">            env_run(idle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line">    <span class="comment">// running on this CPU is still ENV_RUNNING, it's okay to</span></span><br><span class="line">    <span class="comment">// choose that environment.</span></span><br><span class="line">    <span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">        env_run(curenv);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Never choose an environment that's currently running on</span></span><br><span class="line">    <span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line">    <span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line">    <span class="comment">// below to halt the cpu. </span></span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<div class="note default">
            <p><strong>Q uestion</strong></p><ol><li>在<code>env_run()</code>中，你调用了<code>lcr3()</code>实现页目录的切换，而在这条语句之后，代码都使用了变量<code>e</code>。在将进程页目录载入<code>cr3</code>寄存器后，地址映射发生了变化，为何还能通过<code>e</code>的虚拟地址找到<code>e</code>所在的物理地址呢</li><li>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</li></ol>
          </div>
<ul>
<li>第一个问题：如果JOS能够正确运行，那说明<code>e</code>的虚拟地址实际上是没有变化的，也就是在内核页目录和用户页目录中，<code>e</code>的映射是相同的。实际也确实如此，因为用户页目录本身就从内核页目录中复制过来，只有一部分发生了变动，而<code>e</code>所在的区域<code>envs</code>并未发生改变，在每个进程页目录中都相同，所以映射依然有效。</li>
<li>第二个问题：旧的进程的寄存器需要保存，因为要保存现场，确保下一次调度时，能够从上一次暂停的地方继续执行。这个发生的地方在<code>_alltrap</code>中，即从用户态转向内核态后。</li>
</ul>
<div class="note danger">
            <p><strong>Challenge!</strong> 为内核添加一个不那么普通的（trivial）调度策略，例如固定优先级策略, such as a fixed-priority scheduler that allows each environment to be assigned a priority and ensures that higher-priority environments are always chosen in preference to lower-priority environments. If you’re feeling really adventurous, try implementing a Unix-style adjustable-priority scheduler or even a lottery or stride scheduler. (Look up “lottery scheduling” and “stride scheduling” in Google.)</p><p>Write a test program or two that verifies that your scheduling algorithm is working correctly (i.e., the right environments get run in the right order). It may be easier to write these test programs once you have implemented <code>fork()</code> and IPC in parts B and C of this lab.</p>
          </div>
<p>暂时未解决，先了解一下静态优先级调度（花半天时间看看）</p>
<div class="note danger">
            <p><strong>Challenge!</strong> The JOS kernel currently does not allow applications to use the x86 processor’s x87 floating-point unit (FPU), MMX instructions, or Streaming SIMD Extensions (SSE). Extend the <code>Env</code> structure to provide a save area for the processor’s floating point state, and extend the context switching code to save and restore this state properly when switching from one environment to another. The <code>FXSAVE</code> and <code>FXRSTOR</code> instructions may be useful, but note that these are not in the old i386 user’s manual because they were introduced in more recent processors. Write a user-level test program that does something cool with floating-point.</p>
          </div>
<p>未解决</p>
<h3 id="用于进程创建的系统调用"><a href="#用于进程创建的系统调用" class="headerlink" title="用于进程创建的系统调用"></a>用于进程创建的系统调用</h3><p>目前JOS只能运行内核初始化时设置的进程，你需要编写对应的系统调用，使得用户进程能够创建并开始其他的用户进程。</p>
<p>Unix provides the <code>fork()</code> system call as its process creation primitive. Unix <code>fork()</code> copies the entire address space of calling process (the parent) to create a new process (the child). The only differences between the two observable from user space are their process IDs and parent process IDs (as returned by <code>getpid</code> and <code>getppid</code>). 在父进程中，<code>fork()</code>返回子进程ID，而在子进程中 <code>fork()</code>返回<code>0</code>。默认地，每个进程拥有其私有的地址空间，并对对方不可见。</p>
<p>你需要提供一组用于创建新用户进程的系统调用。利用这些系统调用，你能够在用户态执行<code>fork</code>，新的系统调用如下：</p>
<ul>
<li><p><code>sys_exofork</code>:</p>
<p>这个系统调用创建了一个几乎空白状态的进程：用户地址空间尚未被映射，同时这个进程也不能运行。新的进程和父进程拥有相同的寄存器状态。在父进程中，<code>sys_exofork</code>返回新创建进程的<code>envid_t</code>（如果进程分配错误，返回负错误码）。在子进程中，返回0（由于子进程被标注为不能运行态，因此<code>sys_exofork</code>不会真的返回子进程，直到父进程使用<code>sys_env_set_status</code>显式修改子进程状态为runnable）</p>
</li>
<li><p><code>sys_env_set_status</code>:</p>
<p>将特定进程的状态设置为<code>ENV_RUNNABLE</code>或<code>ENV_NOT_RUNNABLE</code>。当一个新进程地址空间和寄存器状态被初始化后，这个系统调用用来将新进程标记为可运行的。</p>
</li>
<li><p><code>sys_page_alloc</code>:</p>
<p>分配一个页的物理内存，并将其映射到给定进程地址空间的虚拟地址上。</p>
</li>
<li><p><code>sys_page_map</code>:</p>
<p>将一个进程的地址空间映射关系拷贝到另一个进程，新旧进程的虚拟地址将指向相同的物理内存（共享内存）。</p>
</li>
<li><p><code>sys_page_unmap</code>:</p>
<p>解除给定进程的一个给定虚拟地址的映射关系。</p>
</li>
</ul>
<p>对于上面所有的接收一个进程ID的系统调用，JOS使用0表示当前进程。这个转换由函数<code>envid2env()</code>（in <code>kern/env.c</code>）实现。</p>
<p>We have provided a very primitive implementation of a Unix-like <code>fork()</code> in the test program <code>user/dumbfork.c</code>. This test program uses the above system calls to create and run a child environment with a copy of its own address space. The two environments then switch back and forth using <code>sys_yield</code> as in the previous exercise. The parent exits after 10 iterations, whereas the child exits after 20.</p>
<div class="note default">
            <p><strong>Exercise 7.</strong> 实现上述系统调用，并确保<code>syscall</code>调用他们。你需要使用<code>kern/pmap.c</code> 和 <code>kern/env.c</code>中的几个函数，特别是<code>envid2env()</code>. For now, whenever you call <code>envid2env()</code>, pass 1 in the <code>checkperm</code> parameter. Be sure you check for any invalid system call arguments, returning <code>-E_INVAL</code> in that case. Test your JOS kernel with <code>user/dumbfork</code> and make sure it works before proceeding.</p>
          </div>
<p>代码中已经给出了系统调用函数的框架，我们只需要在<code>kern/syscall.c</code>中实现对应的系统调用即可。</p>
<h4 id="sys-exofork实现"><a href="#sys-exofork实现" class="headerlink" title="sys_exofork实现"></a><code>sys_exofork</code>实现</h4><p><strong>函数设计</strong></p>
<p>在该函数中，我们主要需要完成下面两个任务：</p>
<ul>
<li>使用<code>env_alloc</code>创建一个新的进程</li>
<li>对新的进程进行初始化，主要是对<code>tf</code>进行拷贝，同时将<code>tf_regs</code>的<code>reg_eax</code>字段设置为0，保证系统调用返回值为0</li>
</ul>
<p><strong>调试</strong></p>
<p>在一开始对于函数的功能没有理解，创建了进程后，直接调用<code>env_run</code>运行了进程，这样做的后果是进程A调用<code>sys_exofork</code>后，创建了新的进程B，随即立刻开始运行进程B，即由A进入系统调用，但是返回却是返回了进程B，这样显然是有问题的。正确的做法是将新进程的状态设为<code>ENV_NOT_RUNNABLE</code>，并在后面的某个位置中将其修改为<code>ENV_RUNNABLE</code>，令其可以被<code>sched_yield</code>调度。</p>
<p><strong>函数实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a new environment.</span></span><br><span class="line"><span class="comment">// Returns envid of new environment, </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">    r = env_alloc(&amp;e, curenv-&gt;env_id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return &lt; 0 on error.  Errors are:</span></span><br><span class="line">    <span class="comment">//	-E_NO_FREE_ENV if no free environment is available.</span></span><br><span class="line">    <span class="comment">//	-E_NO_MEM on memory exhaustion.</span></span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    e-&gt;env_tf = curenv-&gt;env_tf;          <span class="comment">// 将父进程的寄存器值拷贝给子进程</span></span><br><span class="line">    e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;       <span class="comment">// 保存子进程系统调用后的返回值。</span></span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    <span class="keyword">int</span> pid = e-&gt;env_id;</span><br><span class="line">    <span class="comment">// It should be left as env_alloc created it, except that</span></span><br><span class="line">    <span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></span><br><span class="line">    <span class="comment">// from the current environment -- but tweaked so sys_exofork</span></span><br><span class="line">    <span class="comment">// will appear to return 0.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p><strong>函数解释</strong></p>
<p>这个函数里比较难的一点是，子进程和父进程会返回不同的参数，这一点是依靠修改子进程栈帧寄存器<code>eax</code>的值实现的。父进程会返回子进程的id</p>
<h4 id="剩余几个系统调用的实现"><a href="#剩余几个系统调用的实现" class="headerlink" title="剩余几个系统调用的实现"></a>剩余几个系统调用的实现</h4><p>剩下的几个系统调用都不难，主要是对输入参数有效性进行了一些判断，这里直接给出源码。</p>
<p><strong>函数实现</strong></p>
<p><code>sys_env_set_status</code>的实现如下：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set envid's env_status to status, which must be ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// or ENV_NOT_RUNNABLE.</span></span><br><span class="line"><span class="comment">// Return 0 for success and &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if status is not a valid status for an environment.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Hint: Use the 'envid2env' function from kern/env.c to translate an</span></span><br><span class="line">    <span class="comment">// envid to a struct Env.</span></span><br><span class="line">    <span class="comment">// You should set envid2env's third argument to 1, which will</span></span><br><span class="line">    <span class="comment">// check whether the current environment has permission to set</span></span><br><span class="line">    <span class="comment">// envid's status.</span></span><br><span class="line">    <span class="keyword">if</span>(status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE)&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    r = envid2env(envid, &amp;e, <span class="number">1</span>);    <span class="comment">// get env from envid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    e-&gt;env_status = status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns 0 on success.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p><code>sys_page_alloc</code>实现如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></span><br><span class="line"><span class="comment">// 'perm' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// The page's contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there's no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//		or to allocate any necessary page tables.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">    <span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">    <span class="comment">//   parameters for correctness.</span></span><br><span class="line">    <span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">    <span class="comment">//   allocated!</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    r = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">"sys_page_alloc: wrong envid %d!\n"</span>, envid);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">uint32_t</span>)va &gt;= UTOP || (<span class="keyword">uint32_t</span>)va != ROUNDUP((<span class="keyword">uint32_t</span>)va, PGSIZE))&#123;</span><br><span class="line">        cprintf(<span class="string">"sys_page_alloc: wrong virtual address!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(perm &amp; (PTE_U | PTE_P )) )&#123;</span><br><span class="line">        cprintf(<span class="string">"sys_page_alloc: wrong perm!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> = <span class="title">page_alloc</span>(1);</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = page_insert(e-&gt;env_pgdir, pp, va, perm);</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        page_free(pp);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p><code>sys_page_map</code>实现如下:</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></span><br><span class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change one of them.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//		or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL is srcva is not mapped in srcenvid's address space.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there's no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">         <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">    <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">    <span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">    <span class="comment">//   parameters for correctness.</span></span><br><span class="line">    <span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">    <span class="comment">//   check the current permissions on the page.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srce</span>, *<span class="title">dste</span>;</span></span><br><span class="line">    envid2env(srcenvid, &amp;srce, <span class="number">1</span>);</span><br><span class="line">    envid2env(dstenvid, &amp;dste, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!srce || !dste)&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">uint32_t</span>)srcva &gt;= UTOP || (<span class="keyword">uint32_t</span>)srcva != ROUNDUP((<span class="keyword">uint32_t</span>)srcva, PGSIZE) ||\</span><br><span class="line">       (<span class="keyword">uint32_t</span>)dstva &gt;= UTOP || (<span class="keyword">uint32_t</span>)dstva != ROUNDUP((<span class="keyword">uint32_t</span>)dstva, PGSIZE))&#123;</span><br><span class="line">        cprintf(<span class="string">"sys_page_map: wrong virtual address!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pte_t</span> *pte_store; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> = <span class="title">page_lookup</span>(<span class="title">srce</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, &amp;<span class="title">pte_store</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">"sys_page_map: srcva not mapped!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (perm &amp; PTE_W) &amp;&amp; !(*pte_store &amp; PTE_W ))&#123;</span><br><span class="line">        cprintf(<span class="string">"sys_page_map: srcva is read only, but perm want write!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(perm &amp; (PTE_U | PTE_P )) )&#123;</span><br><span class="line">        cprintf(<span class="string">"sys_page_map: wrong perm!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(page_insert(dste-&gt;env_pgdir, pp, dstva, perm) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">"sys_page_map: no memory!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p><code>sys_page_unmap</code>实现如下:</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unmap the page of memory at 'va' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(envid2env(envid, &amp;e, <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">uint32_t</span>)va &gt;= UTOP || (<span class="keyword">uint32_t</span>)va != ROUNDUP((<span class="keyword">uint32_t</span>)va, PGSIZE))&#123;</span><br><span class="line">        cprintf(<span class="string">"sys_page_map: wrong virtual address!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line">    page_remove(e-&gt;env_pgdir, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<div class="note danger">
            <p><strong>Challenge!</strong> Add the additional system calls necessary to <em>read</em> all of the vital state of an existing environment as well as set it up. Then implement a user mode program that forks off a child environment, runs it for a while (e.g., a few iterations of <code>sys_yield()</code>), then takes a complete snapshot or <em>checkpoint</em> of the child environment, runs the child for a while longer, and finally restores the child environment to the state it was in at the checkpoint and continues it from there. Thus, you are effectively “replaying” the execution of the child environment from an intermediate state. Make the child environment perform some interaction with the user using <code>sys_cgetc()</code> or <code>readline()</code> so that the user can view and mutate its internal state, and verify that with your checkpoint/restart you can give the child environment a case of selective amnesia, making it “forget” everything that happened beyond a certain point.</p>
          </div>
<p>现在你完成了Part A，运行<code>make grade</code>并确保通过Part A的所有测试用例。If you are trying to figure out why a particular test case is failing, run ./grade-lab4 -v, which will show you the output of the kernel builds and QEMU runs for each test, until a test fails. When a test fails, the script will stop, and then you can inspect <code>jos.out</code> to see what the kernel actually printed.</p>
<h2 id="第二部分：写复制"><a href="#第二部分：写复制" class="headerlink" title="第二部分：写复制"></a>第二部分：写复制</h2><p>Unix提供了<code>fork()</code>系统调用作为主要的进程创建手段。<code>fork()</code>系统调用将调用进程的地址空间拷贝至新的子进程中。xv6 Unix的<code>fork()</code>将父进程的页全部拷贝到了子进程中，这个做法和<code>dumbfork()</code>所采用的基本一致。The copying of the parent’s address space into the child is the most expensive part of the <code>fork()</code> operation (拷贝是开销最大的部分).</p>
<p>However, a call to <code>fork()</code> is frequently followed almost immediately by a call to <code>exec()</code> in the child process, which replaces the child’s memory with a new program. This is what the the shell typically does, for example. In this case, the time spent copying the parent’s address space is largely wasted, because the child process will use very little of its memory before calling <code>exec()</code>.</p>
<p>更新版本的Unix允许父子进程共享内存映射，直到某个进程修改了进程地址空间。这项技术叫做写时复制。为了实现该功能，在<code>fork</code>中，内核会拷贝地址空间映射关系而非内存中的具体内容，同时将共享的内存页标注为只读。当某个进程试图在共享页写入内存，那么将会触发一个页错误。此时内核将会为触发页错误的进程分配一个新的、私有的、可写的副本。因此，直到内存页中的内容被实际写入时，该页才会被拷贝。This optimization makes a <code>fork()</code> followed by an <code>exec()</code> in the child much cheaper: the child will probably only need to copy one page (the current page of its stack) before it calls <code>exec()</code>.</p>
<p>在下面的实验部分，你将实施一个像Unix的写时复制<code>fork()</code>作为用户态的一个库函数。Implementing <code>fork()</code> and copy-on-write support in user space has the benefit that the kernel remains much simpler and thus more likely to be correct. It also lets individual user-mode programs define their own semantics for <code>fork()</code>. A program that wants a slightly different implementation (for example, the expensive always-copy version like <code>dumbfork()</code>, or one in which the parent and child actually share memory afterward) can easily provide its own.</p>
<h3 id="用户态页错误处理"><a href="#用户态页错误处理" class="headerlink" title="用户态页错误处理"></a>用户态页错误处理</h3><p>一个用户态的写时拷贝函数 <code>fork()</code>需要知道写保护页的页错误。写时拷贝是处理用户态页错误的一种手段。</p>
<p>It’s common to set up an address space so that page faults indicate when some action needs to take place. For example, most Unix kernels initially map only a single page in a new process’s stack region, and allocate and map additional stack pages later “on demand” as the process’s stack consumption increases and causes page faults on stack addresses that are not yet mapped. A typical Unix kernel must keep track of what action to take when a page fault occurs in each region of a process’s space. For example, a fault in the stack region will typically allocate and map new page of physical memory. A fault in the program’s BSS region will typically allocate a new page, fill it with zeroes, and map it. In systems with demand-paged executables, a fault in the text region will read the corresponding page of the binary off of disk and then map it.</p>
<p>This is a lot of information for the kernel to keep track of. Instead of taking the traditional Unix approach, you will decide what to do about each page fault in user space, where bugs are less damaging. This design has the added benefit of allowing programs great flexibility in defining their memory regions; you’ll use user-level page fault handling later for mapping and accessing files on a disk-based file system.</p>
<h4 id="设置Page-Fault-Handler"><a href="#设置Page-Fault-Handler" class="headerlink" title="设置Page Fault Handler"></a>设置Page Fault Handler</h4><p>为了处理页错误，一个用户进程需要在JOS内核中注册一个<code>page_fault_handler</code>。用户进程通过<code>sys_env_set_pgfault_upcall</code>设置页错误处理入口。我们需要在<code>Env</code>中添加一个新的成员<code>env_pgfault_upcall</code>来记录该信息。</p>
<div class="note default">
            <p>Exercise 8. Implement the <code>sys_env_set_pgfault_upcall</code> system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a “dangerous” system call.</p>
          </div>
<p><strong>函数实现</strong></p>
<p>这个函数也不难，就是将进程的<code>page_fault_handler</code>设置为给定的函数入口：</p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// 'func'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(envid2env(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    e-&gt;env_pgfault_upcall = func;    <span class="comment">// Set page fault entrypoint for e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="用户进程的普通与异常栈"><a href="#用户进程的普通与异常栈" class="headerlink" title="用户进程的普通与异常栈"></a>用户进程的普通与异常栈</h4><p>在正常的执行过程中，一个用户进程运行在常规的用户栈上：其<code>ESP</code>寄存器指向<code>USTACKTOP</code>，栈的范围是<code>[USTACKTOP-PGSIZE, USTACKTOP-1]</code>。当用户态发生了页错误后，内核将会令用户进程在一个不同的栈上运行对应的用户态page fault handler，这个栈叫用户异常栈(<em>user exception</em> stack)。我们将令JOS内核代替(on behalf of)用户进程执行自动栈切换，这个过程与发生用户态到内核态的切换时，x86代替JOS实现用户栈到内核栈的切换非常类似。</p>
<p>用户异常栈的大小也是一个页，栈顶地址为<code>UXSTACKTOP</code>，范围是<code>[UXSTACKTOP-PGSIZE, UXSTACKTOP-1]</code>。当运行在这个栈时，用户态的page fault handler能够使用JOS的常规系统调用，映射新的栈或调整映射，从而修复触发页错误的问题。随后用户态的page fault handler通过汇编指令<code>stub</code>返回到常规栈中继续运行。</p>
<p>每个想要支持用户态页错误处理的进程，都需要利用<code>sys_page_alloc()</code>为异常栈分配空间。</p>
<h4 id="触发用户态Page-Fault-Handler"><a href="#触发用户态Page-Fault-Handler" class="headerlink" title="触发用户态Page Fault Handler"></a>触发用户态Page Fault Handler</h4><p>现在，你需要修改<code>kern/trap.c</code>的代码，处理来自用户态的页错误。我们将处在页错误的用户态的状态成为陷入时间 (<em>trap-time</em>)态。</p>
<p>如果没有page fault handler被注册，那么内核将销毁用户进程。否则内核将在异常栈上设置一个栈帧，其格式如<code>struct UTrapframe</code>所示（在 <code>inc/trap.h</code>中）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure>
<p>随后，内核将安排用户进程在异常栈上以该栈帧恢复执行，运行的代码为page fault handler；你需要弄清楚这个是如何实现的，<code>fault_va</code>即造成页错误的虚拟地址。</p>
<p>如果在异常发生时，用户已经位于异常栈上了，此时page fault handler本身发生了错误（嵌套异常）。在这种情况下，你需要在异常栈栈顶 <code>tf-&gt;tf_esp</code> 下方开启新的异常栈，而不是在<code>UXSTACKTOP</code>下，你需要先压入一个空的32-bit的word，然后再压入一个<code>struct UTrapframe</code>。为了验证<code>tf-&gt;tf_esp</code>是否已经在用户异常栈上，你需要检测该指针是否位于<code>UXSTACKTOP-PGSIZE</code>和<code>UXSTACKTOP-1</code>之间。</p>
<div class="note default">
            <p>Exercise 9. Implement the code in <code>page_fault_handler</code> in <code>kern/trap.c</code> required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. (What happens if the user environment runs out of space on the exception stack?)</p>
          </div> 
<p><strong>函数功能</strong></p>
<p><code>page_fault_handler</code>的主要功能是在进入内核后，由内核调整<code>trapframe</code>，从而令当前进程在异常栈上执行<code>page_fault_handler</code>函数。</p>
<p><strong>函数设计</strong></p>
<p>首先，我们要判断<code>page_fault_handler</code>是否注册，如果没注册，直接销毁进程。然后，根据当前栈指针调整其位置，为utf分配空间，并对分配的空间进行检查。随后，我们设置<code>utf</code>的内容，主要就是对<code>tf</code>的关键内容进行保存。最后，我们调整<code>tf</code>中的<code>esp</code>与<code>eip</code>，并运行进程，使其在异常栈上运行给定的函数。</p>
<p><strong>函数实现</strong></p>
<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * page_fault (interrupt 14) handler, Handles the page fault</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     This handler function is invoked by the interrupt 14 to </span></span><br><span class="line"><span class="comment"> *     deal with page fault in both the kernel mode and user mode</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * INPUT: - tf trapframe of current env</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * OUTPUT: void</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * WARNINGS: none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * HISTORY: </span></span><br><span class="line"><span class="comment"> *     - 2021-7-2 created by Shiqi Duan (sqduan@mail.ustc.edu.cn) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read processor's CR2 register to find the faulting address</span></span><br><span class="line">    fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line">    <span class="keyword">if</span>(tf-&gt;tf_cs == GD_KT)&#123;</span><br><span class="line">        panic(<span class="string">"Kernel mode page faults\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We've already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">    <span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the env_pgfault_upcall function ptr isn't registered, simply</span></span><br><span class="line">    <span class="comment">// destory the environment that caused the fault.</span></span><br><span class="line">    <span class="keyword">if</span>(!curenv-&gt;env_pgfault_upcall)&#123;</span><br><span class="line">        cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">            curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        env_destroy(curenv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> utf_size = <span class="keyword">sizeof</span>(struct UTrapframe);</span><br><span class="line">    <span class="comment">// Set up a page fault stack frame on the user exception stack </span></span><br><span class="line">    <span class="comment">// which range is [UXSTACKTOP-PGSIZE, UXSTACKTOP). Remember to </span></span><br><span class="line">    <span class="comment">// check the validation of the memory.</span></span><br><span class="line">    <span class="keyword">if</span>( tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP )&#123;</span><br><span class="line">        <span class="comment">// Current stack is already the exception stack, create a UTrapframe </span></span><br><span class="line">        <span class="comment">// under current esp. Remember to first push a empty 32-bit word.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// It is convenient for our code which returns from a page fault</span></span><br><span class="line">        <span class="comment">// (lib/pfentry.S) to have one word of scratch space at the top of the</span></span><br><span class="line">        <span class="comment">// trap-time stack; it allows us to more easily restore the eip/esp. In</span></span><br><span class="line">        <span class="comment">// the non-recursive case, we don't have to worry about this because</span></span><br><span class="line">        <span class="comment">// the top of the regular user stack is free.  In the recursive case,</span></span><br><span class="line">        <span class="comment">// this means we have to leave an extra word between the current top of</span></span><br><span class="line">        <span class="comment">// the exception stack and the new stack frame because the exception</span></span><br><span class="line">        <span class="comment">// stack _is_ the trap-time stack.</span></span><br><span class="line">        utf = (struct UTrapframe*)( tf-&gt;tf_esp - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) - utf_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// Current stack is in user normal stack, create a UTrapframe </span></span><br><span class="line">        <span class="comment">// under UXSTACKTOP.</span></span><br><span class="line">        utf = (struct UTrapframe*)(UXSTACKTOP - utf_size);</span><br><span class="line">    &#125;</span><br><span class="line">    user_mem_check(curenv, (<span class="keyword">void</span>*)utf, utf_size, (PTE_P | PTE_U | PTE_W) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we set the content of the utf, the utf here is actually </span></span><br><span class="line">    <span class="comment">// saving the tf, since we need to switch the context.</span></span><br><span class="line">    <span class="comment">// When return from the upcall, we will restore the context to the original tf</span></span><br><span class="line">    utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">    utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">    utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">    utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">    utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">    utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace tf's eip with the upcall, and the stack is now the ustack</span></span><br><span class="line">    tf-&gt;tf_esp = (<span class="keyword">uintptr_t</span>)utf;</span><br><span class="line">    tf-&gt;tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the env, when return from kernel to user, it will use the utf as</span></span><br><span class="line">    <span class="comment">// its tf, and run the env_pgfault_upcall.</span></span><br><span class="line">    env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p>根据这段代码，我们能够画出处理页错误过程中，内核栈、用户常规栈与用户异常栈的结构及关系如下所示：</p>
<p><img src="https://raw.githubusercontent.com/sqduan/hexoimg/master/utrapandtrap.svg" width = "680" alt="图片名称" align=center /></p>
<p>从该图中可以看出，嵌套处理utf实际上就是函数的递归调用，这一点要特别明确，因为后面的练习10要用到。</p>
<h4 id="用户态页错误入口"><a href="#用户态页错误入口" class="headerlink" title="用户态页错误入口"></a>用户态页错误入口</h4><p>下面，你需要实现一段汇编程序，这段程序将调用C编写的page fault handler，并在原先产生页错误的语句上继续执行。这个汇编代码将由内核使用<code>sys_env_set_pgfault_upcall()</code>进行注册。</p>
<div class="note default">
            <p>Exercise 10. Implement the <code>_pgfault_upcall</code> routine in <code>lib/pfentry.S</code>. The interesting part is returning to the original point in the user code that caused the page fault. You’ll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP.    </p>
          </div> 
<p><strong>思路分析</strong></p>
<p>练习十可能是本实验乃至整个课程实验中最难的一个，如果要做好练习十，你需要掌握的知识包括</p>
<ul>
<li>汇编代码中<code>call</code>与<code>ret</code>的原理，主要是这两个语句在调用时栈的变化</li>
<li>内核栈、用户栈及用户异常栈的布局</li>
<li>对于内存的精细操作</li>
</ul>
<p>我反正是没搞定，看了别人的代码琢磨了半天琢磨明白了，还是太菜了。</p>
<p><strong>设计</strong></p>
<p>根据程序的注释，我们可以总结出这段程序的流程图如下：首先这个函数要调用<code>_pgfault_handler</code>。处理完页错误后，再将异常栈帧弹出即可。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h5><div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Page fault upcall entrypoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is where we ask the kernel to redirect us to whenever we cause</span></span><br><span class="line"><span class="comment">// a page fault in user space (see the call to sys_set_pgfault_handler</span></span><br><span class="line"><span class="comment">// in pgfault.c).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When a page fault actually occurs, the kernel switches our ESP to</span></span><br><span class="line"><span class="comment">// point to the user exception stack if we're not already on the user</span></span><br><span class="line"><span class="comment">// exception stack, and then it pushes a UTrapframe onto our user</span></span><br><span class="line"><span class="comment">// exception stack:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	trap-time esp</span></span><br><span class="line"><span class="comment">//	trap-time eflags</span></span><br><span class="line"><span class="comment">//	trap-time eip</span></span><br><span class="line"><span class="comment">//	utf_regs.reg_eax</span></span><br><span class="line"><span class="comment">//	...</span></span><br><span class="line"><span class="comment">//	utf_regs.reg_esi</span></span><br><span class="line"><span class="comment">//	utf_regs.reg_edi</span></span><br><span class="line"><span class="comment">//	utf_err (error code)</span></span><br><span class="line"><span class="comment">//	utf_fault_va            &lt;-- %esp</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If this is a recursive fault, the kernel will reserve for us a</span></span><br><span class="line"><span class="comment">// blank word above the trap-time esp for scratch work when we unwind</span></span><br><span class="line"><span class="comment">// the recursive call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We then have call up to the appropriate page fault handler in C</span></span><br><span class="line"><span class="comment">// code, pointed to by the global variable '_pgfault_handler'.</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    <span class="comment">// Call the C page fault handler.</span></span><br><span class="line">    pushl %esp			<span class="comment">// function argument: pointer to UTF</span></span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $<span class="number">4</span>, %esp			<span class="comment">// pop function argument</span></span><br><span class="line">                            <span class="comment">// After this instruction, %esp will</span></span><br><span class="line">                            <span class="comment">// points to the last utf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now the C page fault handler has returned and you must return</span></span><br><span class="line">    <span class="comment">// to the trap time state.</span></span><br><span class="line">    <span class="comment">// Push trap-time %eip onto the trap-time stack.</span></span><br><span class="line">    <span class="comment">// Restore tf from utf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Explanation:</span></span><br><span class="line">    <span class="comment">//   We must prepare the trap-time stack for our eventual return to</span></span><br><span class="line">    <span class="comment">//   re-execute the instruction that faulted.</span></span><br><span class="line">    <span class="comment">//   Unfortunately, we can't return directly from the exception stack:</span></span><br><span class="line">    <span class="comment">//   We can't call 'jmp', since that requires that we load the address</span></span><br><span class="line">    <span class="comment">//   into a register, and all registers must have their trap-time</span></span><br><span class="line">    <span class="comment">//   values after the return.</span></span><br><span class="line">    <span class="comment">//   We can't call 'ret' from the exception stack either, since if we</span></span><br><span class="line">    <span class="comment">//   did, %esp would have the wrong value.</span></span><br><span class="line">    <span class="comment">//   So instead, we push the trap-time %eip onto the *trap-time* stack!</span></span><br><span class="line">    <span class="comment">//   Below we'll switch to that stack and call 'ret', which will</span></span><br><span class="line">    <span class="comment">//   restore %eip to its pre-fault value.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   In the case of a recursive fault on the exception stack,</span></span><br><span class="line">    <span class="comment">//   note that the word we're pushing now will fit in the</span></span><br><span class="line">    <span class="comment">//   blank word that the kernel reserved for us.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Throughout the remaining code, think carefully about what</span></span><br><span class="line">    <span class="comment">// registers are available for intermediate calculations.  You</span></span><br><span class="line">    <span class="comment">// may find that you have to rearrange your code in non-obvious</span></span><br><span class="line">    <span class="comment">// ways as registers become unavailable as scratch space.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">    movl <span class="number">40</span>(%esp), %ebx</span><br><span class="line">    movl %esp, %eax</span><br><span class="line">    movl <span class="number">48</span>(%esp), %esp</span><br><span class="line">    pushl %ebx</span><br><span class="line"></span><br><span class="line">    movl %eax, %esp</span><br><span class="line">    subl $<span class="number">4</span>, <span class="number">48</span>(%esp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore the trap-time registers.  After you do this, you</span></span><br><span class="line">    <span class="comment">// can no longer modify any general-purpose registers.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    addl $<span class="number">8</span>, %esp</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore eflags from the stack.  After you do this, you can</span></span><br><span class="line">    <span class="comment">// no longer use arithmetic operations or anything else that</span></span><br><span class="line">    <span class="comment">// modifies eflags.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    addl $<span class="number">4</span>, %esp</span><br><span class="line">    popfl</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch back to the adjusted trap-time stack.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    popl %esp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return to re-execute the instruction that faulted.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

</div></div>
<p>最后，你需要完成C用户库的用户层页错误处理机制，即练习11。</p>
<div class="note default">
            <p>Exercise 11. Finish <code>set_pgfault_handler()</code> in <code>lib/pgfault.c</code>.</p>
          </div> 
<p><strong>函数功能</strong></p>
<p>这个函数的功能是设置<code>pgfault_handler</code>，这个函数会注册用户指定的页错误处理函数，并通知内核在发生页错误时，调用汇编编写的页错误回调函数<code>_pgfault_upcall</code>。</p>
<p><strong>函数设计</strong></p>
<blockquote>
<p>:warning:注意，用户态与内核进行交互需要使用系统调用！</p>
</blockquote>
<p><strong>函数实现</strong></p>
<p>根据函数功能和函数相关的注释提示，我们能够写出函数的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the page fault handler function.</span></span><br><span class="line"><span class="comment">// If there isn't one yet, _pgfault_handler will be 0.</span></span><br><span class="line"><span class="comment">// The first time we register a handler, we need to</span></span><br><span class="line"><span class="comment">// allocate an exception stack (one page of memory with its top</span></span><br><span class="line"><span class="comment">// at UXSTACKTOP), and tell the kernel to call the assembly-language</span></span><br><span class="line"><span class="comment">// _pgfault_upcall routine when a page fault occurs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First time through!</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="comment">// Allocate an exception stack 	</span></span><br><span class="line">        sys_page_alloc(thisenv-&gt;env_id, (<span class="keyword">void</span>*)UXSTACKTOP-PGSIZE, PTE_U | PTE_P | PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">    _pgfault_handler = handler;</span><br><span class="line">    sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用了两个系统调用，一个用于分配页空间作为异常栈，一个用于设置<code>pgfault_upcall</code>，注意完成之后，需要注册系统调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">        r = sys_cgetc();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> SYS_env_set_pgfault_upcall:</span><br><span class="line">        r = sys_env_set_pgfault_upcall((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span>*)a2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h4><p>Run <code>user/faultread</code> (make run-faultread). You should see:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">[00001000] user fault va 00000000 ip 0080003a</span><br><span class="line">TRAP frame ...</span><br><span class="line">[00001000] free env 00001000</span><br></pre></td></tr></table></figure>
<p>上面这段代码试图读取0x0这个地址的内容，所以出错了，由于没有注册页错误处理函数，所以打印user fault va 00000000 ip 0080003a。Run <code>user/faultdie</code>. You should see:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">i faulted at va deadbeef, err 6</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br></pre></td></tr></table></figure>
<p>上面这段代码试图写<code>0xdeadbeef</code>这个地址，所以出错</p>
<p>Run <code>user/faultalloc</code>. You should see:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">fault deadbeef</span><br><span class="line">this string was faulted in at deadbeef</span><br><span class="line">fault cafebffe          </span><br><span class="line">fault cafec000        // 这个是为什么呢？</span><br><span class="line">this string was faulted in at cafebffe</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br></pre></td></tr></table></figure>
<p>If you see only the first “this string” line, it means you are not handling recursive page faults properly.</p>
<p>Run <code>user/faultallocbad</code>. You should see:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">[00001000] user_mem_check assertion failure for va deadbeef</span><br><span class="line">[00001000] free env 00001000</span><br></pre></td></tr></table></figure>
<p>Make sure you understand why <code>user/faultalloc</code> and <code>user/faultallocbad</code> behave differently. <code>faultallocbad</code>试图向<code>deadbeef</code>写入，而<code>faultalloc</code>只是试图读取。</p>
<div class="note danger">
            <p><strong>Challenge!</strong> 扩展你的内核，令其不仅能处理页错误，任何在用户空间产生的处理器异常，都能重定向至一个用户态的异常处理函数。编写用户态测试程序来测试用户态异常处理函数对于不同异常的处理，例如除零错误、通用保护错误以及非法操作(illegal opcode)等。.</p>
          </div> 
<h3 id="实施写入时复制的Fork"><a href="#实施写入时复制的Fork" class="headerlink" title="实施写入时复制的Fork"></a>实施写入时复制的Fork</h3><p>现在，你有了在用户空间实施写入时复制<code>fork</code>的全部内核特性。我们在<code>lib/fork.c</code>为你提供了<code>fork</code>的骨架。和<code>dumbfork()</code>类似， <code>fork()</code>应当创建一个新进程，然后扫描父进程的整个地址空间，并在子进程中建立对应的页映射。关键不同在于，<code>dumbfork()</code> 拷贝了所有的<em>页</em>，而 <code>fork()</code> 将只复制页映射关系。当有一个进程试图写入一个页时，<code>fork()</code>才会拷贝这个页。</p>
<p><code>fork()</code>的基本控制流如下：</p>
<ul>
<li><p>父进程利用<code>set_pgfault_handler()</code>将<code>pgfault()</code>设置为C语言层面的fault handler。</p>
</li>
<li><p>父进程调用<code>sys_exofork()</code>创建一个子进程。</p>
</li>
<li><p>对于每一个在地址空间中低于UTOP的可写的或者copy-on-write的页，父进程调用<code>duppage</code>，这个函数将把每一个可写的页以copy-on-write的形式映射到子进程的地址空间中，同时，将自己的可写页重新映射为copy-on-write。[ 注意此处的顺序，先将子进程设置为COW，再设置父进程，这个非常重要。为什么呢？请思考一种顺序改变后可能造成的错误]<code>duppage</code>设置了父进程与子进程的PTE，使得页不可写，同时在”avail”字段包含了<code>PTE_COW</code>，来区分传统的只读页和copy-on-write页。</p>
<p>与普通用户空间不同，异常栈不是这样映射的，你需要为子进程分配一个新页作为异常栈。由于页错误处理函数将执行实际拷贝操作，同时页错误处理函数运行在异常栈上，因此异常栈不能被设置为copy-on-write。况且也没有进程会复制异常栈。</p>
<p><code>fork()</code>同样需要处理存在（PTE_P）但是不是可写的或者COW的页。</p>
</li>
<li><p>父进程为子进程设置用户页错误处理入口。</p>
</li>
<li>子进程现在准备运行，父进程将其设置为可运行态。</li>
</ul>
<p>当有进程写一个它尚未写入的copy-on-write页时，它将会产生一个页错误。这里是用户页错误处理函数的控制流程：</p>
<ol>
<li>内核产生一个页错误The kernel propagates the page fault to <code>_pgfault_upcall</code>，这个函数调用<code>fork()</code>的 <code>pgfault()</code>handler。</li>
<li><code>pgfault()</code> 检查错误是否为一个写操作(check for <code>FEC_WR</code> in the error code)，同时，写入页的PTE标记为<code>PTE_COW</code>。如果不是，触发panic。</li>
<li><code>pgfault()</code> allocates a new page mapped at a temporary location and copies the contents of the faulting page into it. Then the fault handler maps the new page at the appropriate address with read/write permissions, in place of the old read-only mapping.</li>
</ol>
<p>The user-level <code>lib/fork.c</code> code must consult the environment’s page tables for several of the operations above (e.g., that the PTE for a page is marked <code>PTE_COW</code>). The kernel maps the environment’s page tables at <code>UVPT</code> exactly for this purpose. It uses a <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab4/uvpt.html">clever mapping trick</a> to make it to make it easy to lookup PTEs for user code. <code>lib/entry.S</code> sets up <code>uvpt</code> and <code>uvpd</code> so that you can easily lookup page-table information in <code>lib/fork.c</code>.</p>
<div class="note default">
            <p>Exercise 12. Implement <code>fork</code>, <code>duppage</code> and <code>pgfault</code> in <code>lib/fork.c</code>.</p>
          </div> 
<p><strong>设计</strong></p>
<p>fork的完整流程如下：</p>
<p><strong>伪代码</strong></p>
<p>fork的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function Fork</span><br><span class="line">    Set pgfault handler</span><br><span class="line">    Exo Fork</span><br><span class="line">EndFunction</span><br></pre></td></tr></table></figure>
<p>利用<code>forktree</code>测试你的程序 。这个程序应当产生如下信息， It should produce the following messages, with interspersed ‘new env’, ‘free env’, and ‘exiting gracefully’ messages. The messages may not appear in this order, and the environment IDs may be different.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000: I am &apos;&apos;</span><br><span class="line">1001: I am &apos;0&apos;</span><br><span class="line">2000: I am &apos;00&apos;</span><br><span class="line">2001: I am &apos;000&apos;</span><br><span class="line">1002: I am &apos;1&apos;</span><br><span class="line">3000: I am &apos;11&apos;</span><br><span class="line">3001: I am &apos;10&apos;</span><br><span class="line">4000: I am &apos;100&apos;</span><br><span class="line">1003: I am &apos;01&apos;</span><br><span class="line">5000: I am &apos;010&apos;</span><br><span class="line">4001: I am &apos;011&apos;</span><br><span class="line">2002: I am &apos;110&apos;</span><br><span class="line">1004: I am &apos;001&apos;</span><br><span class="line">1005: I am &apos;111&apos;</span><br><span class="line">1006: I am &apos;101&apos;</span><br></pre></td></tr></table></figure>
<div class="note danger">
            <p><strong>Challenge!</strong> Implement a shared-memory <code>fork()</code> called <code>sfork()</code>. This version should have the parent and child <em>share</em> all their memory pages (so writes in one environment appear in the other) except for pages in the stack area, which should be treated in the usual copy-on-write manner. Modify <code>user/forktree.c</code> to use <code>sfork()</code> instead of regular <code>fork()</code>. Also, once you have finished implementing IPC in part C, use your <code>sfork()</code> to run <code>user/pingpongs</code>. You will have to find a new way to provide the functionality of the global <code>thisenv</code> pointer.</p>
          </div> 
<div class="note danger">
            <p><strong>Challenge!</strong> Your implementation of <code>fork</code> makes a huge number of system calls. On the x86, switching into the kernel using interrupts has non-trivial cost. Augment the system call interface so that it is possible to send a batch of system calls at once. Then change <code>fork</code> to use this interface.</p><p>你的新fork比原先的有多快？</p><p>You can answer this (roughly) by using analytical arguments to estimate how much of an improvement batching system calls will make to the performance of your <code>fork</code>: How expensive is an <code>int 0x30</code> instruction? How many times do you execute <code>int 0x30</code> in your <code>fork</code>? Is accessing the <code>TSS</code> stack switch also expensive? And so on…</p><p>Alternatively, you can boot your kernel on real hardware and <em>really</em> benchmark your code. See the <code>RDTSC</code> (read time-stamp counter) instruction, defined in the IA32 manual, which counts the number of clock cycles that have elapsed since the last processor reset. QEMU doesn’t emulate this instruction faithfully (it can either count the number of virtual instructions executed or use the host TSC, neither of which reflects the number of cycles a real CPU would require).</p>
          </div> 
<p>第二部分到此结束，确保你通过了第二部分所有测试。As usual, you can hand in your submission with make handin.</p>
<h2 id="第三部分：抢占式多任务与进程间通信"><a href="#第三部分：抢占式多任务与进程间通信" class="headerlink" title="第三部分：抢占式多任务与进程间通信"></a>第三部分：抢占式多任务与进程间通信</h2><p>在第三部分，你将修改内核，使其支持抢占式进程，并允许进程间相互通信。</p>
<h3 id="定时中断与抢占"><a href="#定时中断与抢占" class="headerlink" title="定时中断与抢占"></a>定时中断与抢占</h3><p>运行<code>user/spin</code>测试程序。这个测试程序将fork一个子进程，这个进程一旦获取CPU控制权，将会陷入无限制的循环当中。父进程和内核都无法再获取CPU。这样显然不是一个用户进程的理想情况，因为任意一个用户进程都可以通过陷入死循环劫持CPU导致整个系统僵死。为了允许内核抢占一个正在运行的进程，强制性重新占据CPU，我们需要允许JOS内核支持来自时钟的外部硬件中断。</p>
<h4 id="中断规律"><a href="#中断规律" class="headerlink" title="中断规律"></a>中断规律</h4><p>外部中断（设备中断）被称为IRQs。此处一共有16个可能的IRQs，序号为0-15。IRQ序号与中断向量表入口的映射不是固定的。 <code>picirq.c</code>中的<code>pic_init</code>将IRQs 0-15映射至IDT入口<code>IRQ_OFFSET</code>至<code>IRQ_OFFSET+15</code>（32-47）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">outb(IO_PIC1+1, IRQ_OFFSET);          // 0-7</span><br><span class="line">outb(IO_PIC2+1, IRQ_OFFSET + 8);      // 8-15</span><br></pre></td></tr></table></figure>
<p>在<code>inc/trap.h</code>中， <code>IRQ_OFFSET</code>被定义为十进制32。因此IDT入口32-47与IRQs 0-15相关联。例如，时钟中断为IRQ 0。因此， IDT[IRQ_OFFSET+0] (即IDT[32]) 包含了内核对时钟中断处理程序的地址。<code>IRQ_OFFSET</code>的选择需要注意硬件中断不能覆盖处理器提供的异常入口。</p>
<p>相比xv6，我们在JOS中做了关键简化。在内核态，外部设备中断总是被关闭的（在用户态则打开）。外部中断由<code>%eflags</code>寄存器的<code>FL_IF</code>标志位进行控制。<code>FL_IF = 1</code>时开中断。由于这个标志位可以通过若干种方式修改，由于我们的简化，我们只需要在进入和离开用户态时对其进行保存和恢复即可。</p>
<p>你需要保证<code>FL_IF</code>标志位在用户态进程运行时被设置，当一个中断来临时，这个中断将会被传递至处理器，并被你的中断处理程序处理。否则，中断被掩盖（masked）或者忽略直到中断被重新使能。我们在bootloader的第一条语句中关闭了中断，同时没有再重新使能它。</p>
<div class="note default">
            <p>Exercise 13. 修改 <code>kern/trapentry.S</code>和<code>kern/trap.c</code>在IDT中初始化证确的入口，同时为中断0-15提供正确的入口。然后修改<code>kern/env.c</code>中<code>env_alloc()</code>的代码，确保用户态进程总是运行在中断使能的状态下。</p><p>同样，取消<code>sched_halt()</code>中<code>sti</code>指令的注释，使得空闲的CPU不再掩盖中断。由于我在lab3中使用了自动生成中断入口函数的脚本vectors.py，因此此处我需要修改vectors.py</p>
          </div> 
<p><strong>修改vectors.py</strong></p>
<p>首先修改vectors.py，32号到47号向量不需要压入错误码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl vector32</span><br><span class="line">.type vector32,@function</span><br><span class="line">.align 2</span><br><span class="line">vector32:</span><br><span class="line">    pushl $32</span><br><span class="line">    jmp _alltraps</span><br></pre></td></tr></table></figure>
<p>然后在trap_init.c中为中断设置入口函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set gate for irq</span></span><br><span class="line"><span class="keyword">for</span>(i = IRQ_OFFSET; i &lt;= IRQ_OFFSET + <span class="number">15</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// SETGATE(idt[i], is_trap, selector, function, dpl)</span></span><br><span class="line">    SETGATE(idt[i], <span class="number">0</span>, GD_KT, vectors[i], <span class="number">0</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改env_alloc代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure>
<p>当激活一个硬件中断时，处理器将不会压入一个错误码。You might want to re-read section 9.2 of the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">80386 Reference Manual</a>, or section 5.8 of the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">IA-32 Intel Architecture Software Developer’s Manual, Volume 3</a>, at this time.</p>
<p>当做完这个练习后，如果你运行内核if you run your kernel with any test program that runs for a non-trivial length of time (e.g., <code>spin</code>), you should see the kernel print trap frames for hardware interrupts. While interrupts are now enabled in the processor, JOS isn’t yet handling them, so you should see it misattribute each interrupt to the currently running user environment and destroy it. Eventually it should run out of environments to destroy and drop into the monitor.</p>
<h4 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h4><p>In the <code>user/spin</code> program, after the child environment was first run, it just spun in a loop, and the kernel never got control back. We need to program the hardware to generate clock interrupts periodically, which will force control back to the kernel where we can switch control to a different user environment.</p>
<p>The calls to <code>lapic_init</code> and <code>pic_init</code> (from <code>i386_init</code> in <code>init.c</code>), which we have written for you, set up the clock and the interrupt controller to generate interrupts. You now need to write the code to handle these interrupts.</p>
<p>Exercise 14. Modify the kernel’s <code>trap_dispatch()</code> function so that it calls <code>sched_yield()</code> to find and run a different environment whenever a clock interrupt takes place.</p>
<p>You should now be able to get the <code>user/spin</code> test to work: the parent environment should fork off the child, <code>sys_yield()</code> to it a couple times but in each case regain control of the CPU after one time slice, and finally kill the child environment and terminate gracefully.</p>
<p>This is a great time to do some <em>regression testing</em>. Make sure that you haven’t broken any earlier part of that lab that used to work (e.g. <code>forktree</code>) by enabling interrupts. Also, try running with multiple CPUs using make CPUS=2 <em>target</em>. You should also be able to pass <code>stresssched</code> now. Run make grade to see for sure. You should now get a total score of 65/80 points on this lab.</p>
<h3 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h3><p>(Technically in JOS this is “inter-environment communication” or “IEC”, but everyone else calls it IPC, so we’ll use the standard term.)</p>
<p>We’ve been focusing on the isolation aspects of the operating system, the ways it provides the illusion that each program has a machine all to itself. Another important service of an operating system is to allow programs to communicate with each other when they want to. It can be quite powerful to let programs interact with other programs. The Unix pipe model is the canonical example.</p>
<p>There are many models for interprocess communication. Even today there are still debates about which models are best. We won’t get into that debate. Instead, we’ll implement a simple IPC mechanism and then try it out.</p>
<h4 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h4><p>You will implement a few additional JOS kernel system calls that collectively provide a simple interprocess communication mechanism. You will implement two system calls, <code>sys_ipc_recv</code> and <code>sys_ipc_try_send</code>. Then you will implement two library wrappers <code>ipc_recv</code> and <code>ipc_send</code>.</p>
<p>The “messages” that user environments can send to each other using JOS’s IPC mechanism consist of two components: a single 32-bit value, and optionally a single page mapping. Allowing environments to pass page mappings in messages provides an efficient way to transfer more data than will fit into a single 32-bit integer, and also allows environments to set up shared memory arrangements easily.</p>
<h4 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h4><p>To receive a message, an environment calls <code>sys_ipc_recv</code>. This system call de-schedules the current environment and does not run it again until a message has been received. When an environment is waiting to receive a message, <em>any</em> other environment can send it a message - not just a particular environment, and not just environments that have a parent/child arrangement with the receiving environment. In other words, the permission checking that you implemented in Part A will not apply to IPC, because the IPC system calls are carefully designed so as to be “safe”: an environment cannot cause another environment to malfunction simply by sending it messages (unless the target environment is also buggy).</p>
<p>To try to send a value, an environment calls <code>sys_ipc_try_send</code> with both the receiver’s environment id and the value to be sent. If the named environment is actually receiving (it has called <code>sys_ipc_recv</code> and not gotten a value yet), then the send delivers the message and returns 0. Otherwise the send returns <code>-E_IPC_NOT_RECV</code> to indicate that the target environment is not currently expecting to receive a value.</p>
<p>A library function <code>ipc_recv</code> in user space will take care of calling <code>sys_ipc_recv</code> and then looking up the information about the received values in the current environment’s <code>struct Env</code>.</p>
<p>Similarly, a library function <code>ipc_send</code> will take care of repeatedly calling <code>sys_ipc_try_send</code> until the send succeeds.</p>
<h4 id="Transferring-Pages"><a href="#Transferring-Pages" class="headerlink" title="Transferring Pages"></a>Transferring Pages</h4><p>When an environment calls <code>sys_ipc_recv</code> with a valid <code>dstva</code> parameter (below <code>UTOP</code>), the environment is stating that it is willing to receive a page mapping. If the sender sends a page, then that page should be mapped at <code>dstva</code> in the receiver’s address space. If the receiver already had a page mapped at <code>dstva</code>, then that previous page is unmapped.</p>
<p>When an environment calls <code>sys_ipc_try_send</code> with a valid <code>srcva</code> (below <code>UTOP</code>), it means the sender wants to send the page currently mapped at <code>srcva</code> to the receiver, with permissions <code>perm</code>. After a successful IPC, the sender keeps its original mapping for the page at <code>srcva</code> in its address space, but the receiver also obtains a mapping for this same physical page at the <code>dstva</code> originally specified by the receiver, in the receiver’s address space. As a result this page becomes shared between the sender and receiver.</p>
<p>If either the sender or the receiver does not indicate that a page should be transferred, then no page is transferred. After any IPC the kernel sets the new field <code>env_ipc_perm</code> in the receiver’s <code>Env</code> structure to the permissions of the page received, or zero if no page was received.</p>
<h4 id="Implementing-IPC"><a href="#Implementing-IPC" class="headerlink" title="Implementing IPC"></a>Implementing IPC</h4><p>Exercise 15. Implement <code>sys_ipc_recv</code> and <code>sys_ipc_try_send</code> in <code>kern/syscall.c</code>. Read the comments on both before implementing them, since they have to work together. When you call <code>envid2env</code> in these routines, you should set the <code>checkperm</code> flag to 0, meaning that any environment is allowed to send IPC messages to any other environment, and the kernel does no special permission checking other than verifying that the target envid is valid.</p>
<p>Then implement the <code>ipc_recv</code> and <code>ipc_send</code> functions in <code>lib/ipc.c</code>.</p>
<p>Use the <code>user/pingpong</code> and <code>user/primes</code> functions to test your IPC mechanism. <code>user/primes</code> will generate for each prime number a new environment until JOS runs out of environments. You might find it interesting to read <code>user/primes.c</code> to see all the forking and IPC going on behind the scenes.</p>
<p>Challenge! Why does <code>ipc_send</code> have to loop? Change the system call interface so it doesn’t have to. Make sure you can handle multiple environments trying to send to one environment at the same time.</p>
<p>Challenge! The prime sieve is only one neat use of message passing between a large number of concurrent programs. Read C. A. R. Hoare, ``Communicating Sequential Processes,’’ <em>Communications of the ACM</em> 21(8) (August 1978), 666-667, and implement the matrix multiplication example.</p>
<p>Challenge! One of the most impressive examples of the power of message passing is Doug McIlroy’s power series calculator, described in <a href="https://swtch.com/~rsc/thread/squint.pdf">M. Douglas McIlroy, ``Squinting at Power Series,’’ <em>Software—Practice and Experience</em>, 20(7) (July 1990), 661-683</a>. Implement his power series calculator and compute the power series for <em>sin</em>(<em>x</em>+<em>x</em>^3).</p>
<p>Challenge! Make JOS’s IPC mechanism more efficient by applying some of the techniques from Liedtke’s paper, <a href="http://dl.acm.org/citation.cfm?id=168633">Improving IPC by Kernel Design</a>, or any other tricks you may think of. Feel free to modify the kernel’s system call API for this purpose, as long as your code is backwards compatible with what our grading scripts expect.</p>
<p><strong>This ends part C.</strong> Make sure you pass all of the make grade tests and don’t forget to write up your answers to the questions and a description of your challenge exercise solution in <code>answers-lab4.txt</code>.</p>
<p>Before handing in, use git status and git diff to examine your changes and don’t forget to git add answers-lab4.txt. When you’re ready, commit your changes with git commit -am ‘my solutions to lab 4’, then make handin and follow the directions.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id="footnotes"><hr><div id="footnotelist"><ol><li id="fn:1"><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">xv6 book</a><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab4/">Lab4</a><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><a href="https://blog.csdn.net/bysui/article/details/51567733">MIT6.828 Lab4 Part A: 答案</a><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>课程</category>
      </categories>
  </entry>
</search>
